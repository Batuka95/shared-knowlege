#RequireAdmin
#Region
#AutoIt3Wrapper_Icon=ico.ico
#AutoIt3Wrapper_Outfile=eve.exe
#AutoIt3Wrapper_Compression=4
#AutoIt3Wrapper_Res_Comment=echo bot
#AutoIt3Wrapper_Res_Description=echo bot
#AutoIt3Wrapper_Res_Fileversion=1.0.1.16
#AutoIt3Wrapper_Run_After=del currentversion.txt
#AutoIt3Wrapper_Run_After=del eve.zip
#AutoIt3Wrapper_Run_After=del /f /s /q screenshot
#AutoIt3Wrapper_Run_After=del /f /s /q logs
#AutoIt3Wrapper_Run_After=echo %fileversion% >> "currentversion.txt"
#AutoIt3Wrapper_Run_After=WinRAR a eve.zip -r img Tesseract-OCR Curl OpenCV\DLLs\ eve.exe screenshot adb starter.exe IRL32\ IRL64\ 7z\ logs\
#AutoIt3Wrapper_Run_After=mkdir versions\%fileversion%-%date%\
#AutoIt3Wrapper_Run_After=copy eve.zip versions\%fileversion%-%date%\
#AutoIt3Wrapper_Run_After=copy *.au3 versions\%fileversion%-%date%\
#Au3Stripper_Parameters=/mo
#EndRegion
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_ABORTRETRYIGNORE = 2
Global Const $MB_YESNOCANCEL = 3
Global Const $MB_YESNO = 4
Global Const $MB_RETRYCANCEL = 5
Global Const $MB_CANCELTRYCONTINUE = 6
Global Const $MB_HELP = 16384
Global Const $MB_ICONNONE = 0
Global Const $MB_ICONSTOP = 16
Global Const $MB_ICONERROR = 16
Global Const $MB_ICONHAND = 16
Global Const $MB_ICONQUESTION = 32
Global Const $MB_ICONEXCLAMATION = 48
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_ICONASTERISK = 64
Global Const $MB_USERICON = 128
Global Const $MB_DEFBUTTON1 = 0
Global Const $MB_DEFBUTTON2 = 256
Global Const $MB_DEFBUTTON3 = 512
Global Const $MB_DEFBUTTON4 = 768
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TASKMODAL = 8192
Global Const $MB_DEFAULT_DESKTOP_ONLY = 131072
Global Const $MB_RIGHT = 524288
Global Const $MB_RTLREADING = 1048576
Global Const $MB_SETFOREGROUND = 65536
Global Const $MB_TOPMOST = 262144
Global Const $MB_SERVICE_NOTIFICATION = 2097152
Global Const $MB_RIGHTJUSTIFIED = $MB_RIGHT
Global Const $IDTIMEOUT = + 4294967295
Global Const $IDOK = 1
Global Const $IDCANCEL = 2
Global Const $IDABORT = 3
Global Const $IDRETRY = 4
Global Const $IDIGNORE = 5
Global Const $IDYES = 6
Global Const $IDNO = 7
Global Const $IDCLOSE = 8
Global Const $IDHELP = 9
Global Const $IDTRYAGAIN = 10
Global Const $IDCONTINUE = 11
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYFULLMATCH = 2
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_REGEXPARRAYGLOBALFULLMATCH = 4
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $SB_ANSI = 1
Global Const $SB_UTF16LE = 2
Global Const $SB_UTF16BE = 3
Global Const $SB_UTF8 = 4
Global Const $SE_UTF16 = 0
Global Const $SE_ANSI = 1
Global Const $SE_UTF8 = 2
Global Const $STR_UTF16 = 0
Global Const $STR_UCS2 = 1
#Region Global Variables and Constants
Global Const $FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
Global Const $FORMAT_MESSAGE_IGNORE_INSERTS = 512
Global Const $FORMAT_MESSAGE_FROM_STRING = 1024
Global Const $FORMAT_MESSAGE_FROM_HMODULE = 2048
Global Const $FORMAT_MESSAGE_FROM_SYSTEM = 4096
Global Const $FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192
#EndRegion Global Variables and Constants
Func _WINAPI_BEEP ( $IFREQ = 500 , $IDURATION = 1000 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "Beep" , "dword" , $IFREQ , "dword" , $IDURATION )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FORMATMESSAGE ( $IFLAGS , $PSOURCE , $IMESSAGEID , $ILANGUAGEID , ByRef $PBUFFER , $ISIZE , $VARGUMENTS )
	Local $SBUFFERTYPE = "struct*"
	If IsString ( $PBUFFER ) Then $SBUFFERTYPE = "wstr"
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "FormatMessageW" , "dword" , $IFLAGS , "struct*" , $PSOURCE , "dword" , $IMESSAGEID , "dword" , $ILANGUAGEID , $SBUFFERTYPE , $PBUFFER , "dword" , $ISIZE , "ptr" , $VARGUMENTS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	If $SBUFFERTYPE = "wstr" Then $PBUFFER = $ACALL [ 5 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETERRORMESSAGE ( $ICODE , $ILANGUAGE = 0 , Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "FormatMessageW" , "dword" , BitOR ( $FORMAT_MESSAGE_FROM_SYSTEM , $FORMAT_MESSAGE_IGNORE_INSERTS ) , "ptr" , 0 , "dword" , $ICODE , "dword" , $ILANGUAGE , "wstr" , "" , "dword" , 4096 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , StringRegExpReplace ( $ACALL [ 5 ] , "[" & @LF & "," & @CR & "]*\Z" , "" ) )
EndFunc
Func _WINAPI_GETLASTERROR ( Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetLastError" )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_GETLASTERRORMESSAGE ( Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
	Local $TBUFFERPTR = DllStructCreate ( "ptr" )
	Local $NCOUNT = _WINAPI_FORMATMESSAGE ( BitOR ( $FORMAT_MESSAGE_ALLOCATE_BUFFER , $FORMAT_MESSAGE_FROM_SYSTEM , $FORMAT_MESSAGE_IGNORE_INSERTS ) , 0 , $ILASTERROR , 0 , $TBUFFERPTR , 0 , 0 )
	If @error Then Return SetError ( - @error , @extended , "" )
	Local $STEXT = ""
	Local $PBUFFER = DllStructGetData ( $TBUFFERPTR , 1 )
	If $PBUFFER Then
		If $NCOUNT > 0 Then
			Local $TBUFFER = DllStructCreate ( "wchar[" & ( $NCOUNT + 1 ) & "]" , $PBUFFER )
			$STEXT = DllStructGetData ( $TBUFFER , 1 )
			If StringRight ( $STEXT , 2 ) = @CRLF Then $STEXT = StringTrimRight ( $STEXT , 2 )
		EndIf
		DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $PBUFFER )
	EndIf
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , $STEXT )
EndFunc
Func _WINAPI_MESSAGEBEEP ( $ITYPE = 1 )
	Local $ISOUND
	Switch $ITYPE
	Case 1
		$ISOUND = 0
	Case 2
		$ISOUND = 16
	Case 3
		$ISOUND = 32
	Case 4
		$ISOUND = 48
	Case 5
		$ISOUND = 64
Case Else
		$ISOUND = + 4294967295
	EndSwitch
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "MessageBeep" , "uint" , $ISOUND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MSGBOX ( $IFLAGS , $STITLE , $STEXT )
	BlockInput ( 0 )
	MsgBox ( $IFLAGS , $STITLE , $STEXT & "      " )
EndFunc
Func _WINAPI_SETLASTERROR ( $IERRORCODE , Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	DllCall ( "kernel32.dll" , "none" , "SetLastError" , "dword" , $IERRORCODE )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , Null )
EndFunc
Func _WINAPI_SHOWERROR ( $STEXT , $BEXIT = True )
	BlockInput ( 0 )
	MsgBox ( $MB_SYSTEMMODAL , "Error" , $STEXT & "      " )
	If $BEXIT Then Exit
EndFunc
Func _WINAPI_SHOWLASTERROR ( $STEXT = "" , $BABORT = False , $ILANGUAGE = 0 , Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $SERROR
	Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
	While 1
		$SERROR = _WINAPI_GETERRORMESSAGE ( $ILASTERROR , $ILANGUAGE )
		If @error And $ILANGUAGE Then
			$ILANGUAGE = 0
		Else
			ExitLoop
		EndIf
	WEnd
	If StringStripWS ( $STEXT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
		$STEXT &= @CRLF & @CRLF
	Else
		$STEXT = ""
	EndIf
	_WINAPI_MSGBOX ( BitOR ( 262144 , BitShift ( 16 , + 4294967294 * ( Not $ILASTERROR ) ) ) , $ILASTERROR , $STEXT & $SERROR )
	If $ILASTERROR Then
		_WINAPI_SETLASTERROR ( $ILASTERROR )
		If $BABORT Then
			Exit $ILASTERROR
		EndIf
	EndIf
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , 1 )
EndFunc
Func _WINAPI_SHOWMSG ( $STEXT )
	_WINAPI_MSGBOX ( $MB_SYSTEMMODAL , "Information" , $STEXT )
EndFunc
Func __COMERRORFORMATING ( ByRef $OCOMERROR , $SPREFIX = @TAB )
	Local Const $STR_STRIPTRAILING = 2
	Local $SERROR = "COM Error encountered in " & @ScriptName & " (" & $OCOMERROR .Scriptline & ") :" & @CRLF & $SPREFIX & "Number        " & @TAB & "= 0x" & Hex ( $OCOMERROR .Number , 8 ) & " (" & $OCOMERROR .Number & ")" & @CRLF & $SPREFIX & "WinDescription" & @TAB & "= " & StringStripWS ( $OCOMERROR .WinDescription , $STR_STRIPTRAILING ) & @CRLF & $SPREFIX & "Description   " & @TAB & "= " & StringStripWS ( $OCOMERROR .Description , $STR_STRIPTRAILING ) & @CRLF & $SPREFIX & "Source        " & @TAB & "= " & $OCOMERROR .Source & @CRLF & $SPREFIX & "HelpFile      " & @TAB & "= " & $OCOMERROR .HelpFile & @CRLF & $SPREFIX & "HelpContext   " & @TAB & "= " & $OCOMERROR .HelpContext & @CRLF & $SPREFIX & "LastDllError  " & @TAB & "= " & $OCOMERROR .LastDllError & @CRLF & $SPREFIX & "Retcode       " & @TAB & "= 0x" & Hex ( $OCOMERROR .retcode )
	Return $SERROR
EndFunc
Global Const $BS_GROUPBOX = 7
Global Const $BS_BOTTOM = 2048
Global Const $BS_CENTER = 768
Global Const $BS_DEFPUSHBUTTON = 1
Global Const $BS_LEFT = 256
Global Const $BS_MULTILINE = 8192
Global Const $BS_PUSHBOX = 10
Global Const $BS_PUSHLIKE = 4096
Global Const $BS_RIGHT = 512
Global Const $BS_RIGHTBUTTON = 32
Global Const $BS_TOP = 1024
Global Const $BS_VCENTER = 3072
Global Const $BS_FLAT = 32768
Global Const $BS_ICON = 64
Global Const $BS_BITMAP = 128
Global Const $BS_NOTIFY = 16384
Global Const $BS_SPLITBUTTON = 12
Global Const $BS_DEFSPLITBUTTON = 13
Global Const $BS_COMMANDLINK = 14
Global Const $BS_DEFCOMMANDLINK = 15
Global Const $BCSIF_GLYPH = 1
Global Const $BCSIF_IMAGE = 2
Global Const $BCSIF_STYLE = 4
Global Const $BCSIF_SIZE = 8
Global Const $BCSS_NOSPLIT = 1
Global Const $BCSS_STRETCH = 2
Global Const $BCSS_ALIGNLEFT = 4
Global Const $BCSS_IMAGE = 8
Global Const $BUTTON_IMAGELIST_ALIGN_LEFT = 0
Global Const $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
Global Const $BUTTON_IMAGELIST_ALIGN_TOP = 2
Global Const $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
Global Const $BUTTON_IMAGELIST_ALIGN_CENTER = 4
Global Const $BS_3STATE = 5
Global Const $BS_AUTO3STATE = 6
Global Const $BS_AUTOCHECKBOX = 3
Global Const $BS_CHECKBOX = 2
Global Const $BS_RADIOBUTTON = 4
Global Const $BS_AUTORADIOBUTTON = 9
Global Const $BS_OWNERDRAW = 11
Global Const $GUI_SS_DEFAULT_BUTTON = 0
Global Const $GUI_SS_DEFAULT_CHECKBOX = 0
Global Const $GUI_SS_DEFAULT_GROUP = 0
Global Const $GUI_SS_DEFAULT_RADIO = 0
Global Const $BCM_FIRST = 5632
Global Const $BCM_GETIDEALSIZE = ( $BCM_FIRST + 1 )
Global Const $BCM_GETIMAGELIST = ( $BCM_FIRST + 3 )
Global Const $BCM_GETNOTE = ( $BCM_FIRST + 10 )
Global Const $BCM_GETNOTELENGTH = ( $BCM_FIRST + 11 )
Global Const $BCM_GETSPLITINFO = ( $BCM_FIRST + 8 )
Global Const $BCM_GETTEXTMARGIN = ( $BCM_FIRST + 5 )
Global Const $BCM_SETDROPDOWNSTATE = ( $BCM_FIRST + 6 )
Global Const $BCM_SETIMAGELIST = ( $BCM_FIRST + 2 )
Global Const $BCM_SETNOTE = ( $BCM_FIRST + 9 )
Global Const $BCM_SETSHIELD = ( $BCM_FIRST + 12 )
Global Const $BCM_SETSPLITINFO = ( $BCM_FIRST + 7 )
Global Const $BCM_SETTEXTMARGIN = ( $BCM_FIRST + 4 )
Global Const $BM_CLICK = 245
Global Const $BM_GETCHECK = 240
Global Const $BM_GETIMAGE = 246
Global Const $BM_GETSTATE = 242
Global Const $BM_SETCHECK = 241
Global Const $BM_SETDONTCLICK = 248
Global Const $BM_SETIMAGE = 247
Global Const $BM_SETSTATE = 243
Global Const $BM_SETSTYLE = 244
Global Const $BCN_FIRST = + 4294966046
Global Const $BCN_DROPDOWN = ( $BCN_FIRST + 2 )
Global Const $BCN_HOTITEMCHANGE = ( $BCN_FIRST + 1 )
Global Const $BN_CLICKED = 0
Global Const $BN_PAINT = 1
Global Const $BN_HILITE = 2
Global Const $BN_UNHILITE = 3
Global Const $BN_DISABLE = 4
Global Const $BN_DOUBLECLICKED = 5
Global Const $BN_SETFOCUS = 6
Global Const $BN_KILLFOCUS = 7
Global Const $BN_PUSHED = $BN_HILITE
Global Const $BN_UNPUSHED = $BN_UNHILITE
Global Const $BN_DBLCLK = $BN_DOUBLECLICKED
Global Const $BST_CHECKED = 1
Global Const $BST_INDETERMINATE = 2
Global Const $BST_UNCHECKED = 0
Global Const $BST_FOCUS = 8
Global Const $BST_PUSHED = 4
Global Const $BST_DONTCLICK = 128
Global Const $CB_ERR = + 4294967295
Global Const $CB_ERRATTRIBUTE = + 4294967293
Global Const $CB_ERRREQUIRED = + 4294967292
Global Const $CB_ERRSPACE = + 4294967294
Global Const $CB_OKAY = 0
Global Const $STATE_SYSTEM_INVISIBLE = 32768
Global Const $STATE_SYSTEM_PRESSED = 8
Global Const $CBS_AUTOHSCROLL = 64
Global Const $CBS_DISABLENOSCROLL = 2048
Global Const $CBS_DROPDOWN = 2
Global Const $CBS_DROPDOWNLIST = 3
Global Const $CBS_HASSTRINGS = 512
Global Const $CBS_LOWERCASE = 16384
Global Const $CBS_NOINTEGRALHEIGHT = 1024
Global Const $CBS_OEMCONVERT = 128
Global Const $CBS_OWNERDRAWFIXED = 16
Global Const $CBS_OWNERDRAWVARIABLE = 32
Global Const $CBS_SIMPLE = 1
Global Const $CBS_SORT = 256
Global Const $CBS_UPPERCASE = 8192
Global Const $CBM_FIRST = 5888
Global Const $CB_ADDSTRING = 323
Global Const $CB_DELETESTRING = 324
Global Const $CB_DIR = 325
Global Const $CB_FINDSTRING = 332
Global Const $CB_FINDSTRINGEXACT = 344
Global Const $CB_GETCOMBOBOXINFO = 356
Global Const $CB_GETCOUNT = 326
Global Const $CB_GETCUEBANNER = ( $CBM_FIRST + 4 )
Global Const $CB_GETCURSEL = 327
Global Const $CB_GETDROPPEDCONTROLRECT = 338
Global Const $CB_GETDROPPEDSTATE = 343
Global Const $CB_GETDROPPEDWIDTH = 351
Global Const $CB_GETEDITSEL = 320
Global Const $CB_GETEXTENDEDUI = 342
Global Const $CB_GETHORIZONTALEXTENT = 349
Global Const $CB_GETITEMDATA = 336
Global Const $CB_GETITEMHEIGHT = 340
Global Const $CB_GETLBTEXT = 328
Global Const $CB_GETLBTEXTLEN = 329
Global Const $CB_GETLOCALE = 346
Global Const $CB_GETMINVISIBLE = 5890
Global Const $CB_GETTOPINDEX = 347
Global Const $CB_INITSTORAGE = 353
Global Const $CB_LIMITTEXT = 321
Global Const $CB_RESETCONTENT = 331
Global Const $CB_INSERTSTRING = 330
Global Const $CB_SELECTSTRING = 333
Global Const $CB_SETCUEBANNER = ( $CBM_FIRST + 3 )
Global Const $CB_SETCURSEL = 334
Global Const $CB_SETDROPPEDWIDTH = 352
Global Const $CB_SETEDITSEL = 322
Global Const $CB_SETEXTENDEDUI = 341
Global Const $CB_SETHORIZONTALEXTENT = 350
Global Const $CB_SETITEMDATA = 337
Global Const $CB_SETITEMHEIGHT = 339
Global Const $CB_SETLOCALE = 345
Global Const $CB_SETMINVISIBLE = 5889
Global Const $CB_SETTOPINDEX = 348
Global Const $CB_SHOWDROPDOWN = 335
Global Const $CBN_CLOSEUP = 8
Global Const $CBN_DBLCLK = 2
Global Const $CBN_DROPDOWN = 7
Global Const $CBN_EDITCHANGE = 5
Global Const $CBN_EDITUPDATE = 6
Global Const $CBN_ERRSPACE = ( + 4294967295 )
Global Const $CBN_KILLFOCUS = 4
Global Const $CBN_SELCHANGE = 1
Global Const $CBN_SELENDCANCEL = 10
Global Const $CBN_SELENDOK = 9
Global Const $CBN_SETFOCUS = 3
Global Const $CBES_EX_CASESENSITIVE = 16
Global Const $CBES_EX_NOEDITIMAGE = 1
Global Const $CBES_EX_NOEDITIMAGEINDENT = 2
Global Const $CBES_EX_NOSIZELIMIT = 8
Global Const $__COMBOBOXCONSTANT_WM_USER = 1024
Global Const $CBEM_DELETEITEM = $CB_DELETESTRING
Global Const $CBEM_GETCOMBOCONTROL = ( $__COMBOBOXCONSTANT_WM_USER + 6 )
Global Const $CBEM_GETEDITCONTROL = ( $__COMBOBOXCONSTANT_WM_USER + 7 )
Global Const $CBEM_GETEXSTYLE = ( $__COMBOBOXCONSTANT_WM_USER + 9 )
Global Const $CBEM_GETEXTENDEDSTYLE = ( $__COMBOBOXCONSTANT_WM_USER + 9 )
Global Const $CBEM_GETIMAGELIST = ( $__COMBOBOXCONSTANT_WM_USER + 3 )
Global Const $CBEM_GETITEMA = ( $__COMBOBOXCONSTANT_WM_USER + 4 )
Global Const $CBEM_GETITEMW = ( $__COMBOBOXCONSTANT_WM_USER + 13 )
Global Const $CBEM_GETUNICODEFORMAT = 8192 + 6
Global Const $CBEM_HASEDITCHANGED = ( $__COMBOBOXCONSTANT_WM_USER + 10 )
Global Const $CBEM_INSERTITEMA = ( $__COMBOBOXCONSTANT_WM_USER + 1 )
Global Const $CBEM_INSERTITEMW = ( $__COMBOBOXCONSTANT_WM_USER + 11 )
Global Const $CBEM_SETEXSTYLE = ( $__COMBOBOXCONSTANT_WM_USER + 8 )
Global Const $CBEM_SETEXTENDEDSTYLE = ( $__COMBOBOXCONSTANT_WM_USER + 14 )
Global Const $CBEM_SETIMAGELIST = ( $__COMBOBOXCONSTANT_WM_USER + 2 )
Global Const $CBEM_SETITEMA = ( $__COMBOBOXCONSTANT_WM_USER + 5 )
Global Const $CBEM_SETITEMW = ( $__COMBOBOXCONSTANT_WM_USER + 12 )
Global Const $CBEM_SETUNICODEFORMAT = 8192 + 5
Global Const $CBEM_SETWINDOWTHEME = 8192 + 11
Global Const $CBEN_FIRST = ( + 4294966496 )
Global Const $CBEN_LAST = ( + 4294966466 )
Global Const $CBEN_BEGINEDIT = ( $CBEN_FIRST + 4294967292 )
Global Const $CBEN_DELETEITEM = ( $CBEN_FIRST + 4294967294 )
Global Const $CBEN_DRAGBEGINA = ( $CBEN_FIRST + 4294967288 )
Global Const $CBEN_DRAGBEGINW = ( $CBEN_FIRST + 4294967287 )
Global Const $CBEN_ENDEDITA = ( $CBEN_FIRST + 4294967291 )
Global Const $CBEN_ENDEDITW = ( $CBEN_FIRST + 4294967290 )
Global Const $CBEN_GETDISPINFO = ( $CBEN_FIRST + 0 )
Global Const $CBEN_GETDISPINFOA = ( $CBEN_FIRST + 0 )
Global Const $CBEN_GETDISPINFOW = ( $CBEN_FIRST + 4294967289 )
Global Const $CBEN_INSERTITEM = ( $CBEN_FIRST + 4294967295 )
Global Const $CBEIF_DI_SETITEM = 268435456
Global Const $CBEIF_IMAGE = 2
Global Const $CBEIF_INDENT = 16
Global Const $CBEIF_LPARAM = 32
Global Const $CBEIF_OVERLAY = 8
Global Const $CBEIF_SELECTEDIMAGE = 4
Global Const $CBEIF_TEXT = 1
Global Const $GUI_SS_DEFAULT_COMBO = 2097218
Global Const $GUI_EVENT_SINGLE = 0
Global Const $GUI_EVENT_ARRAY = 1
Global Const $GUI_EVENT_NONE = 0
Global Const $GUI_EVENT_CLOSE = + 4294967293
Global Const $GUI_EVENT_MINIMIZE = + 4294967292
Global Const $GUI_EVENT_RESTORE = + 4294967291
Global Const $GUI_EVENT_MAXIMIZE = + 4294967290
Global Const $GUI_EVENT_PRIMARYDOWN = + 4294967289
Global Const $GUI_EVENT_PRIMARYUP = + 4294967288
Global Const $GUI_EVENT_SECONDARYDOWN = + 4294967287
Global Const $GUI_EVENT_SECONDARYUP = + 4294967286
Global Const $GUI_EVENT_MOUSEMOVE = + 4294967285
Global Const $GUI_EVENT_RESIZED = + 4294967284
Global Const $GUI_EVENT_DROPPED = + 4294967283
Global Const $GUI_RUNDEFMSG = "GUI_RUNDEFMSG"
Global Const $GUI_AVISTOP = 0
Global Const $GUI_AVISTART = 1
Global Const $GUI_AVICLOSE = 2
Global Const $GUI_CHECKED = 1
Global Const $GUI_INDETERMINATE = 2
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_DROPACCEPTED = 8
Global Const $GUI_NODROPACCEPTED = 4096
Global Const $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_NOFOCUS = 8192
Global Const $GUI_DEFBUTTON = 512
Global Const $GUI_EXPAND = 1024
Global Const $GUI_ONTOP = 2048
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTITALIC = 2
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_FONTSTRIKE = 8
Global Const $GUI_DOCKAUTO = 1
Global Const $GUI_DOCKLEFT = 2
Global Const $GUI_DOCKRIGHT = 4
Global Const $GUI_DOCKHCENTER = 8
Global Const $GUI_DOCKTOP = 32
Global Const $GUI_DOCKBOTTOM = 64
Global Const $GUI_DOCKVCENTER = 128
Global Const $GUI_DOCKWIDTH = 256
Global Const $GUI_DOCKHEIGHT = 512
Global Const $GUI_DOCKSIZE = 768
Global Const $GUI_DOCKMENUBAR = 544
Global Const $GUI_DOCKSTATEBAR = 576
Global Const $GUI_DOCKALL = 802
Global Const $GUI_DOCKBORDERS = 102
Global Const $GUI_GR_CLOSE = 1
Global Const $GUI_GR_LINE = 2
Global Const $GUI_GR_BEZIER = 4
Global Const $GUI_GR_MOVE = 6
Global Const $GUI_GR_COLOR = 8
Global Const $GUI_GR_RECT = 10
Global Const $GUI_GR_ELLIPSE = 12
Global Const $GUI_GR_PIE = 14
Global Const $GUI_GR_DOT = 16
Global Const $GUI_GR_PIXEL = 18
Global Const $GUI_GR_HINT = 20
Global Const $GUI_GR_REFRESH = 22
Global Const $GUI_GR_PENSIZE = 24
Global Const $GUI_GR_NOBKCOLOR = + 4294967294
Global Const $GUI_BKCOLOR_DEFAULT = + 4294967295
Global Const $GUI_BKCOLOR_TRANSPARENT = + 4294967294
Global Const $GUI_BKCOLOR_LV_ALTERNATE = 4261412864
Global Const $GUI_READ_DEFAULT = 0
Global Const $GUI_READ_EXTENDED = 1
Global Const $GUI_CURSOR_NOOVERRIDE = 0
Global Const $GUI_CURSOR_OVERRIDE = 1
Global Const $GUI_WS_EX_PARENTDRAG = 1048576
Global Const $LVGS_NORMAL = 0
Global Const $LVGS_COLLAPSED = 1
Global Const $LVGS_HIDDEN = 2
Global Const $LVGS_NOHEADER = 4
Global Const $LVGS_COLLAPSIBLE = 8
Global Const $LVGS_FOCUSED = 16
Global Const $LVGS_SELECTED = 32
Global Const $LVGS_SUBSETED = 64
Global Const $LVGS_SUBSETLINKFOCUSED = 128
Global Const $LVGGR_GROUP = 0
Global Const $LVGGR_HEADER = 1
Global Const $LVGGR_LABEL = 2
Global Const $LVGGR_SUBSETLINK = 3
Global Const $LV_ERR = + 4294967295
Global Const $LVBKIF_SOURCE_NONE = 0
Global Const $LVBKIF_SOURCE_HBITMAP = 1
Global Const $LVBKIF_SOURCE_URL = 2
Global Const $LVBKIF_SOURCE_MASK = 3
Global Const $LVBKIF_STYLE_NORMAL = 0
Global Const $LVBKIF_STYLE_TILE = 16
Global Const $LVBKIF_STYLE_MASK = 16
Global Const $LVBKIF_FLAG_TILEOFFSET = 256
Global Const $LVBKIF_TYPE_WATERMARK = 268435456
Global Const $LV_VIEW_DETAILS = 1
Global Const $LV_VIEW_ICON = 0
Global Const $LV_VIEW_LIST = 3
Global Const $LV_VIEW_SMALLICON = 2
Global Const $LV_VIEW_TILE = 4
Global Const $LVA_ALIGNLEFT = 1
Global Const $LVA_ALIGNTOP = 2
Global Const $LVA_DEFAULT = 0
Global Const $LVA_SNAPTOGRID = 5
Global Const $LVCDI_ITEM = 0
Global Const $LVCDI_GROUP = 1
Global Const $LVCF_ALLDATA = 63
Global Const $LVCF_FMT = 1
Global Const $LVCF_IMAGE = 16
Global Const $LVCFMT_JUSTIFYMASK = 3
Global Const $LVCF_TEXT = 4
Global Const $LVCF_WIDTH = 2
Global Const $LVCFMT_BITMAP_ON_RIGHT = 4096
Global Const $LVCFMT_CENTER = 2
Global Const $LVCFMT_COL_HAS_IMAGES = 32768
Global Const $LVCFMT_IMAGE = 2048
Global Const $LVCFMT_LEFT = 0
Global Const $LVCFMT_RIGHT = 1
Global Const $LVCFMT_LINE_BREAK = 1048576
Global Const $LVCFMT_FILL = 2097152
Global Const $LVCFMT_WRAP = 4194304
Global Const $LVCFMT_NO_TITLE = 8388608
Global Const $LVCFMT_TILE_PLACEMENTMASK = BitOR ( $LVCFMT_LINE_BREAK , $LVCFMT_FILL )
Global Const $LVFI_NEARESTXY = 64
Global Const $LVFI_PARAM = 1
Global Const $LVFI_PARTIAL = 8
Global Const $LVFI_STRING = 2
Global Const $LVFI_SUBSTRING = 4
Global Const $LVFI_WRAP = 32
Global Const $LVGA_FOOTER_LEFT = 8
Global Const $LVGA_FOOTER_CENTER = 16
Global Const $LVGA_FOOTER_RIGHT = 32
Global Const $LVGA_HEADER_LEFT = 1
Global Const $LVGA_HEADER_CENTER = 2
Global Const $LVGA_HEADER_RIGHT = 4
Global Const $LVGF_ALIGN = 8
Global Const $LVGF_DESCRIPTIONTOP = 1024
Global Const $LVGF_DESCRIPTIONBOTTOM = 2048
Global Const $LVGF_EXTENDEDIMAGE = 8192
Global Const $LVGF_FOOTER = 2
Global Const $LVGF_GROUPID = 16
Global Const $LVGF_HEADER = 1
Global Const $LVGF_ITEMS = 16384
Global Const $LVGF_NONE = 0
Global Const $LVGF_STATE = 4
Global Const $LVGF_SUBSET = 32768
Global Const $LVGF_SUBSETITEMS = 65536
Global Const $LVGF_SUBTITLE = 256
Global Const $LVGF_TASK = 512
Global Const $LVGF_TITLEIMAGE = 4096
Global Const $LVHT_ABOVE = 8
Global Const $LVHT_BELOW = 16
Global Const $LVHT_NOWHERE = 1
Global Const $LVHT_ONITEMICON = 2
Global Const $LVHT_ONITEMLABEL = 4
Global Const $LVHT_ONITEMSTATEICON = 8
Global Const $LVHT_TOLEFT = 64
Global Const $LVHT_TORIGHT = 32
Global Const $LVHT_ONITEM = BitOR ( $LVHT_ONITEMICON , $LVHT_ONITEMLABEL , $LVHT_ONITEMSTATEICON )
Global Const $LVHT_EX_GROUP_HEADER = 268435456
Global Const $LVHT_EX_GROUP_FOOTER = 536870912
Global Const $LVHT_EX_GROUP_COLLAPSE = 1073741824
Global Const $LVHT_EX_GROUP_BACKGROUND = 2147483648
Global Const $LVHT_EX_GROUP_STATEICON = 16777216
Global Const $LVHT_EX_GROUP_SUBSETLINK = 33554432
Global Const $LVHT_EX_GROUP = BitOR ( $LVHT_EX_GROUP_BACKGROUND , $LVHT_EX_GROUP_COLLAPSE , $LVHT_EX_GROUP_FOOTER , $LVHT_EX_GROUP_HEADER , $LVHT_EX_GROUP_STATEICON , $LVHT_EX_GROUP_SUBSETLINK )
Global Const $LVHT_EX_ONCONTENTS = 67108864
Global Const $LVHT_EX_FOOTER = 134217728
Global Const $LVIF_COLFMT = 65536
Global Const $LVIF_COLUMNS = 512
Global Const $LVIF_GROUPID = 256
Global Const $LVIF_IMAGE = 2
Global Const $LVIF_INDENT = 16
Global Const $LVIF_NORECOMPUTE = 2048
Global Const $LVIF_PARAM = 4
Global Const $LVIF_STATE = 8
Global Const $LVIF_TEXT = 1
Global Const $LVIM_AFTER = 1
Global Const $LVIR_BOUNDS = 0
Global Const $LVIR_ICON = 1
Global Const $LVIR_LABEL = 2
Global Const $LVIR_SELECTBOUNDS = 3
Global Const $LVIS_CUT = 4
Global Const $LVIS_DROPHILITED = 8
Global Const $LVIS_FOCUSED = 1
Global Const $LVIS_OVERLAYMASK = 3840
Global Const $LVIS_SELECTED = 2
Global Const $LVIS_STATEIMAGEMASK = 61440
Global Const $LVS_ALIGNLEFT = 2048
Global Const $LVS_ALIGNMASK = 3072
Global Const $LVS_ALIGNTOP = 0
Global Const $LVS_AUTOARRANGE = 256
Global Const $LVS_DEFAULT = 13
Global Const $LVS_EDITLABELS = 512
Global Const $LVS_ICON = 0
Global Const $LVS_LIST = 3
Global Const $LVS_NOCOLUMNHEADER = 16384
Global Const $LVS_NOLABELWRAP = 128
Global Const $LVS_NOSCROLL = 8192
Global Const $LVS_NOSORTHEADER = 32768
Global Const $LVS_OWNERDATA = 4096
Global Const $LVS_OWNERDRAWFIXED = 1024
Global Const $LVS_REPORT = 1
Global Const $LVS_SHAREIMAGELISTS = 64
Global Const $LVS_SHOWSELALWAYS = 8
Global Const $LVS_SINGLESEL = 4
Global Const $LVS_SMALLICON = 2
Global Const $LVS_SORTASCENDING = 16
Global Const $LVS_SORTDESCENDING = 32
Global Const $LVS_TYPEMASK = 3
Global Const $LVS_TYPESTYLEMASK = 64512
Global Const $LVS_EX_AUTOAUTOARRANGE = 16777216
Global Const $LVS_EX_AUTOCHECKSELECT = 134217728
Global Const $LVS_EX_AUTOSIZECOLUMNS = 268435456
Global Const $LVS_EX_BORDERSELECT = 32768
Global Const $LVS_EX_CHECKBOXES = 4
Global Const $LVS_EX_COLUMNOVERFLOW = 2147483648
Global Const $LVS_EX_COLUMNSNAPPOINTS = 1073741824
Global Const $LVS_EX_DOUBLEBUFFER = 65536
Global Const $LVS_EX_FLATSB = 256
Global Const $LVS_EX_FULLROWSELECT = 32
Global Const $LVS_EX_GRIDLINES = 1
Global Const $LVS_EX_HEADERDRAGDROP = 16
Global Const $LVS_EX_HEADERINALLVIEWS = 33554432
Global Const $LVS_EX_HIDELABELS = 131072
Global Const $LVS_EX_INFOTIP = 1024
Global Const $LVS_EX_JUSTIFYCOLUMNS = 2097152
Global Const $LVS_EX_LABELTIP = 16384
Global Const $LVS_EX_MULTIWORKAREAS = 8192
Global Const $LVS_EX_ONECLICKACTIVATE = 64
Global Const $LVS_EX_REGIONAL = 512
Global Const $LVS_EX_SIMPLESELECT = 1048576
Global Const $LVS_EX_SNAPTOGRID = 524288
Global Const $LVS_EX_SUBITEMIMAGES = 2
Global Const $LVS_EX_TRACKSELECT = 8
Global Const $LVS_EX_TRANSPARENTBKGND = 4194304
Global Const $LVS_EX_TRANSPARENTSHADOWTEXT = 8388608
Global Const $LVS_EX_TWOCLICKACTIVATE = 128
Global Const $LVS_EX_UNDERLINECOLD = 4096
Global Const $LVS_EX_UNDERLINEHOT = 2048
Global Const $GUI_SS_DEFAULT_LISTVIEW = BitOR ( $LVS_SHOWSELALWAYS , $LVS_SINGLESEL )
Global Const $LVM_FIRST = 4096
Global Const $LVM_APPROXIMATEVIEWRECT = ( $LVM_FIRST + 64 )
Global Const $LVM_ARRANGE = ( $LVM_FIRST + 22 )
Global Const $LVM_CANCELEDITLABEL = ( $LVM_FIRST + 179 )
Global Const $LVM_CREATEDRAGIMAGE = ( $LVM_FIRST + 33 )
Global Const $LVM_DELETEALLITEMS = ( $LVM_FIRST + 9 )
Global Const $LVM_DELETECOLUMN = ( $LVM_FIRST + 28 )
Global Const $LVM_DELETEITEM = ( $LVM_FIRST + 8 )
Global Const $LVM_EDITLABELA = ( $LVM_FIRST + 23 )
Global Const $LVM_EDITLABELW = ( $LVM_FIRST + 118 )
Global Const $LVM_EDITLABEL = $LVM_EDITLABELA
Global Const $LVM_ENABLEGROUPVIEW = ( $LVM_FIRST + 157 )
Global Const $LVM_ENSUREVISIBLE = ( $LVM_FIRST + 19 )
Global Const $LVM_FINDITEM = ( $LVM_FIRST + 13 )
Global Const $LVM_GETBKCOLOR = ( $LVM_FIRST + 0 )
Global Const $LVM_GETBKIMAGEA = ( $LVM_FIRST + 69 )
Global Const $LVM_GETBKIMAGEW = ( $LVM_FIRST + 139 )
Global Const $LVM_GETCALLBACKMASK = ( $LVM_FIRST + 10 )
Global Const $LVM_GETCOLUMNA = ( $LVM_FIRST + 25 )
Global Const $LVM_GETCOLUMNW = ( $LVM_FIRST + 95 )
Global Const $LVM_GETCOLUMNORDERARRAY = ( $LVM_FIRST + 59 )
Global Const $LVM_GETCOLUMNWIDTH = ( $LVM_FIRST + 29 )
Global Const $LVM_GETCOUNTPERPAGE = ( $LVM_FIRST + 40 )
Global Const $LVM_GETEDITCONTROL = ( $LVM_FIRST + 24 )
Global Const $LVM_GETEMPTYTEXT = ( $LVM_FIRST + 204 )
Global Const $LVM_GETEXTENDEDLISTVIEWSTYLE = ( $LVM_FIRST + 55 )
Global Const $LVM_GETFOCUSEDGROUP = ( $LVM_FIRST + 93 )
Global Const $LVM_GETFOOTERINFO = ( $LVM_FIRST + 206 )
Global Const $LVM_GETFOOTERITEM = ( $LVM_FIRST + 208 )
Global Const $LVM_GETFOOTERITEMRECT = ( $LVM_FIRST + 207 )
Global Const $LVM_GETFOOTERRECT = ( $LVM_FIRST + 205 )
Global Const $LVM_GETGROUPCOUNT = ( $LVM_FIRST + 152 )
Global Const $LVM_GETGROUPINFO = ( $LVM_FIRST + 149 )
Global Const $LVM_GETGROUPINFOBYINDEX = ( $LVM_FIRST + 153 )
Global Const $LVM_GETGROUPMETRICS = ( $LVM_FIRST + 156 )
Global Const $LVM_GETGROUPRECT = ( $LVM_FIRST + 98 )
Global Const $LVM_GETGROUPSTATE = ( $LVM_FIRST + 92 )
Global Const $LVM_GETHEADER = ( $LVM_FIRST + 31 )
Global Const $LVM_GETHOTCURSOR = ( $LVM_FIRST + 63 )
Global Const $LVM_GETHOTITEM = ( $LVM_FIRST + 61 )
Global Const $LVM_GETHOVERTIME = ( $LVM_FIRST + 72 )
Global Const $LVM_GETIMAGELIST = ( $LVM_FIRST + 2 )
Global Const $LVM_GETINSERTMARK = ( $LVM_FIRST + 167 )
Global Const $LVM_GETINSERTMARKCOLOR = ( $LVM_FIRST + 171 )
Global Const $LVM_GETINSERTMARKRECT = ( $LVM_FIRST + 169 )
Global Const $LVM_GETISEARCHSTRINGA = ( $LVM_FIRST + 52 )
Global Const $LVM_GETISEARCHSTRINGW = ( $LVM_FIRST + 117 )
Global Const $LVM_GETITEMA = ( $LVM_FIRST + 5 )
Global Const $LVM_GETITEMW = ( $LVM_FIRST + 75 )
Global Const $LVM_GETITEMCOUNT = ( $LVM_FIRST + 4 )
Global Const $LVM_GETITEMINDEXRECT = ( $LVM_FIRST + 209 )
Global Const $LVM_GETITEMPOSITION = ( $LVM_FIRST + 16 )
Global Const $LVM_GETITEMRECT = ( $LVM_FIRST + 14 )
Global Const $LVM_GETITEMSPACING = ( $LVM_FIRST + 51 )
Global Const $LVM_GETITEMSTATE = ( $LVM_FIRST + 44 )
Global Const $LVM_GETITEMTEXTA = ( $LVM_FIRST + 45 )
Global Const $LVM_GETITEMTEXTW = ( $LVM_FIRST + 115 )
Global Const $LVM_GETNEXTITEM = ( $LVM_FIRST + 12 )
Global Const $LVM_GETNEXTITEMINDEX = ( $LVM_FIRST + 211 )
Global Const $LVM_GETNUMBEROFWORKAREAS = ( $LVM_FIRST + 73 )
Global Const $LVM_GETORIGIN = ( $LVM_FIRST + 41 )
Global Const $LVM_GETOUTLINECOLOR = ( $LVM_FIRST + 176 )
Global Const $LVM_GETSELECTEDCOLUMN = ( $LVM_FIRST + 174 )
Global Const $LVM_GETSELECTEDCOUNT = ( $LVM_FIRST + 50 )
Global Const $LVM_GETSELECTIONMARK = ( $LVM_FIRST + 66 )
Global Const $LVM_GETSTRINGWIDTHA = ( $LVM_FIRST + 17 )
Global Const $LVM_GETSTRINGWIDTHW = ( $LVM_FIRST + 87 )
Global Const $LVM_GETSUBITEMRECT = ( $LVM_FIRST + 56 )
Global Const $LVM_GETTEXTBKCOLOR = ( $LVM_FIRST + 37 )
Global Const $LVM_GETTEXTCOLOR = ( $LVM_FIRST + 35 )
Global Const $LVM_GETTILEINFO = ( $LVM_FIRST + 165 )
Global Const $LVM_GETTILEVIEWINFO = ( $LVM_FIRST + 163 )
Global Const $LVM_GETTOOLTIPS = ( $LVM_FIRST + 78 )
Global Const $LVM_GETTOPINDEX = ( $LVM_FIRST + 39 )
Global Const $LVM_GETUNICODEFORMAT = 8192 + 6
Global Const $LVM_GETVIEW = ( $LVM_FIRST + 143 )
Global Const $LVM_GETVIEWRECT = ( $LVM_FIRST + 34 )
Global Const $LVM_GETWORKAREAS = ( $LVM_FIRST + 70 )
Global Const $LVM_HASGROUP = ( $LVM_FIRST + 161 )
Global Const $LVM_HITTEST = ( $LVM_FIRST + 18 )
Global Const $LVM_INSERTCOLUMNA = ( $LVM_FIRST + 27 )
Global Const $LVM_INSERTCOLUMNW = ( $LVM_FIRST + 97 )
Global Const $LVM_INSERTGROUP = ( $LVM_FIRST + 145 )
Global Const $LVM_INSERTGROUPSORTED = ( $LVM_FIRST + 159 )
Global Const $LVM_INSERTITEMA = ( $LVM_FIRST + 7 )
Global Const $LVM_INSERTITEMW = ( $LVM_FIRST + 77 )
Global Const $LVM_INSERTMARKHITTEST = ( $LVM_FIRST + 168 )
Global Const $LVM_ISGROUPVIEWENABLED = ( $LVM_FIRST + 175 )
Global Const $LVM_ISITEMVISIBLE = ( $LVM_FIRST + 182 )
Global Const $LVM_MAPIDTOINDEX = ( $LVM_FIRST + 181 )
Global Const $LVM_MAPINDEXTOID = ( $LVM_FIRST + 180 )
Global Const $LVM_MOVEGROUP = ( $LVM_FIRST + 151 )
Global Const $LVM_REDRAWITEMS = ( $LVM_FIRST + 21 )
Global Const $LVM_REMOVEALLGROUPS = ( $LVM_FIRST + 160 )
Global Const $LVM_REMOVEGROUP = ( $LVM_FIRST + 150 )
Global Const $LVM_SCROLL = ( $LVM_FIRST + 20 )
Global Const $LVM_SETBKCOLOR = ( $LVM_FIRST + 1 )
Global Const $LVM_SETBKIMAGEA = ( $LVM_FIRST + 68 )
Global Const $LVM_SETBKIMAGEW = ( $LVM_FIRST + 138 )
Global Const $LVM_SETCALLBACKMASK = ( $LVM_FIRST + 11 )
Global Const $LVM_SETCOLUMNA = ( $LVM_FIRST + 26 )
Global Const $LVM_SETCOLUMNW = ( $LVM_FIRST + 96 )
Global Const $LVM_SETCOLUMNORDERARRAY = ( $LVM_FIRST + 58 )
Global Const $LVM_SETCOLUMNWIDTH = ( $LVM_FIRST + 30 )
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE = ( $LVM_FIRST + 54 )
Global Const $LVM_SETGROUPINFO = ( $LVM_FIRST + 147 )
Global Const $LVM_SETGROUPMETRICS = ( $LVM_FIRST + 155 )
Global Const $LVM_SETHOTCURSOR = ( $LVM_FIRST + 62 )
Global Const $LVM_SETHOTITEM = ( $LVM_FIRST + 60 )
Global Const $LVM_SETHOVERTIME = ( $LVM_FIRST + 71 )
Global Const $LVM_SETICONSPACING = ( $LVM_FIRST + 53 )
Global Const $LVM_SETIMAGELIST = ( $LVM_FIRST + 3 )
Global Const $LVM_SETINFOTIP = ( $LVM_FIRST + 173 )
Global Const $LVM_SETINSERTMARK = ( $LVM_FIRST + 166 )
Global Const $LVM_SETINSERTMARKCOLOR = ( $LVM_FIRST + 170 )
Global Const $LVM_SETITEMA = ( $LVM_FIRST + 6 )
Global Const $LVM_SETITEMW = ( $LVM_FIRST + 76 )
Global Const $LVM_SETITEMCOUNT = ( $LVM_FIRST + 47 )
Global Const $LVM_SETITEMINDEXSTATE = ( $LVM_FIRST + 210 )
Global Const $LVM_SETITEMPOSITION = ( $LVM_FIRST + 15 )
Global Const $LVM_SETITEMPOSITION32 = ( $LVM_FIRST + 49 )
Global Const $LVM_SETITEMSTATE = ( $LVM_FIRST + 43 )
Global Const $LVM_SETITEMTEXTA = ( $LVM_FIRST + 46 )
Global Const $LVM_SETITEMTEXTW = ( $LVM_FIRST + 116 )
Global Const $LVM_SETOUTLINECOLOR = ( $LVM_FIRST + 177 )
Global Const $LVM_SETSELECTEDCOLUMN = ( $LVM_FIRST + 140 )
Global Const $LVM_SETSELECTIONMARK = ( $LVM_FIRST + 67 )
Global Const $LVM_SETTEXTBKCOLOR = ( $LVM_FIRST + 38 )
Global Const $LVM_SETTEXTCOLOR = ( $LVM_FIRST + 36 )
Global Const $LVM_SETTILEINFO = ( $LVM_FIRST + 164 )
Global Const $LVM_SETTILEVIEWINFO = ( $LVM_FIRST + 162 )
Global Const $LVM_SETTILEWIDTH = ( $LVM_FIRST + 141 )
Global Const $LVM_SETTOOLTIPS = ( $LVM_FIRST + 74 )
Global Const $LVM_SETUNICODEFORMAT = 8192 + 5
Global Const $LVM_SETVIEW = ( $LVM_FIRST + 142 )
Global Const $LVM_SETWORKAREAS = ( $LVM_FIRST + 65 )
Global Const $LVM_SORTGROUPS = ( $LVM_FIRST + 158 )
Global Const $LVM_SORTITEMS = ( $LVM_FIRST + 48 )
Global Const $LVM_SORTITEMSEX = ( $LVM_FIRST + 81 )
Global Const $LVM_SUBITEMHITTEST = ( $LVM_FIRST + 57 )
Global Const $LVM_UPDATE = ( $LVM_FIRST + 42 )
Global Const $LVN_FIRST = + 4294967196
Global Const $LVN_LAST = + 4294967097
Global Const $LVN_BEGINDRAG = ( $LVN_FIRST + 4294967287 )
Global Const $LVN_BEGINLABELEDITA = ( $LVN_FIRST + 4294967291 )
Global Const $LVN_BEGINLABELEDITW = ( $LVN_FIRST + 4294967221 )
Global Const $LVN_BEGINRDRAG = ( $LVN_FIRST + 4294967285 )
Global Const $LVN_BEGINSCROLL = ( $LVN_FIRST + 4294967216 )
Global Const $LVN_COLUMNCLICK = ( $LVN_FIRST + 4294967288 )
Global Const $LVN_COLUMNDROPDOWN = ( $LVN_FIRST + 4294967232 )
Global Const $LVN_COLUMNOVERFLOWCLICK = ( $LVN_FIRST + 4294967230 )
Global Const $LVN_DELETEALLITEMS = ( $LVN_FIRST + 4294967292 )
Global Const $LVN_DELETEITEM = ( $LVN_FIRST + 4294967293 )
Global Const $LVN_ENDLABELEDITA = ( $LVN_FIRST + 4294967290 )
Global Const $LVN_ENDLABELEDITW = ( $LVN_FIRST + 4294967220 )
Global Const $LVN_ENDSCROLL = ( $LVN_FIRST + 4294967215 )
Global Const $LVN_GETDISPINFOA = ( $LVN_FIRST + 4294967246 )
Global Const $LVN_GETDISPINFOW = ( $LVN_FIRST + 4294967219 )
Global Const $LVN_GETDISPINFO = $LVN_GETDISPINFOA
Global Const $LVN_GETEMPTYMARKUP = ( $LVN_FIRST + 4294967209 )
Global Const $LVN_GETINFOTIPA = ( $LVN_FIRST + 4294967239 )
Global Const $LVN_GETINFOTIPW = ( $LVN_FIRST + 4294967238 )
Global Const $LVN_HOTTRACK = ( $LVN_FIRST + 4294967275 )
Global Const $LVN_INCREMENTALSEARCHA = ( $LVN_FIRST + 4294967234 )
Global Const $LVN_INCREMENTALSEARCHW = ( $LVN_FIRST + 4294967233 )
Global Const $LVN_INSERTITEM = ( $LVN_FIRST + 4294967294 )
Global Const $LVN_ITEMACTIVATE = ( $LVN_FIRST + 4294967282 )
Global Const $LVN_ITEMCHANGED = ( $LVN_FIRST + 4294967295 )
Global Const $LVN_ITEMCHANGING = ( $LVN_FIRST + 0 )
Global Const $LVN_KEYDOWN = ( $LVN_FIRST + 4294967241 )
Global Const $LVN_LINKCLICK = ( $LVN_FIRST + 4294967212 )
Global Const $LVN_MARQUEEBEGIN = ( $LVN_FIRST + 4294967240 )
Global Const $LVN_ODCACHEHINT = ( $LVN_FIRST + 4294967283 )
Global Const $LVN_ODFINDITEMA = ( $LVN_FIRST + 4294967244 )
Global Const $LVN_ODFINDITEMW = ( $LVN_FIRST + 4294967217 )
Global Const $LVN_ODFINDITEM = $LVN_ODFINDITEMA
Global Const $LVN_ODSTATECHANGED = ( $LVN_FIRST + 4294967281 )
Global Const $LVN_SETDISPINFOA = ( $LVN_FIRST + 4294967245 )
Global Const $LVN_SETDISPINFOW = ( $LVN_FIRST + 4294967218 )
Global Const $LVNI_ABOVE = 256
Global Const $LVNI_BELOW = 512
Global Const $LVNI_TOLEFT = 1024
Global Const $LVNI_TORIGHT = 2048
Global Const $LVNI_ALL = 0
Global Const $LVNI_CUT = 4
Global Const $LVNI_DROPHILITED = 8
Global Const $LVNI_FOCUSED = 1
Global Const $LVNI_SELECTED = 2
Global Const $LVSCW_AUTOSIZE = + 4294967295
Global Const $LVSCW_AUTOSIZE_USEHEADER = + 4294967294
Global Const $LVSICF_NOINVALIDATEALL = 1
Global Const $LVSICF_NOSCROLL = 2
Global Const $LVSIL_NORMAL = 0
Global Const $LVSIL_SMALL = 1
Global Const $LVSIL_STATE = 2
Global Const $LVFN_DIR_LEFT = 0
Global Const $LVFN_DIR_RIGHT = 1
Global Const $LVFN_DIR_UP = 2
Global Const $LVFN_DIR_DOWN = 3
Global Const $LVFN_DIR_START = 4
Global Const $LVFN_DIR_MEND = 5
Global Const $LVFN_DIR_PRIOR = 6
Global Const $LVFN_DIR_NEXT = 7
Global Const $SS_LEFT = 0
Global Const $SS_CENTER = 1
Global Const $SS_RIGHT = 2
Global Const $SS_ICON = 3
Global Const $SS_BLACKRECT = 4
Global Const $SS_GRAYRECT = 5
Global Const $SS_WHITERECT = 6
Global Const $SS_BLACKFRAME = 7
Global Const $SS_GRAYFRAME = 8
Global Const $SS_WHITEFRAME = 9
Global Const $SS_SIMPLE = 11
Global Const $SS_LEFTNOWORDWRAP = 12
Global Const $SS_BITMAP = 14
Global Const $SS_ENHMETAFILE = 15
Global Const $SS_ETCHEDHORZ = 16
Global Const $SS_ETCHEDVERT = 17
Global Const $SS_ETCHEDFRAME = 18
Global Const $SS_REALSIZECONTROL = 64
Global Const $SS_NOPREFIX = 128
Global Const $SS_NOTIFY = 256
Global Const $SS_CENTERIMAGE = 512
Global Const $SS_RIGHTJUST = 1024
Global Const $SS_SUNKEN = 4096
Global Const $GUI_SS_DEFAULT_LABEL = 0
Global Const $GUI_SS_DEFAULT_GRAPHIC = 0
Global Const $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
Global Const $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
Global Const $STM_SETICON = 368
Global Const $STM_GETICON = 369
Global Const $STM_SETIMAGE = 370
Global Const $STM_GETIMAGE = 371
Global Const $WC_ANIMATE = "SysAnimate32"
Global Const $WC_BUTTON = "Button"
Global Const $WC_COMBOBOX = "ComboBox"
Global Const $WC_COMBOBOXEX = "ComboBoxEx32"
Global Const $WC_DATETIMEPICK = "SysDateTimePick32"
Global Const $WC_EDIT = "Edit"
Global Const $WC_HEADER = "SysHeader32"
Global Const $WC_HOTKEY = "msctls_hotkey32"
Global Const $WC_IPADDRESS = "SysIPAddress32"
Global Const $WC_LINK = "SysLink"
Global Const $WC_LISTBOX = "ListBox"
Global Const $WC_LISTVIEW = "SysListView32"
Global Const $WC_MONTHCAL = "SysMonthCal32"
Global Const $WC_NATIVEFONTCTL = "NativeFontCtl"
Global Const $WC_PAGESCROLLER = "SysPager"
Global Const $WC_PROGRESS = "msctls_progress32"
Global Const $WC_REBAR = "ReBarWindow32"
Global Const $WC_SCROLLBAR = "ScrollBar"
Global Const $WC_STATIC = "Static"
Global Const $WC_STATUSBAR = "msctls_statusbar32"
Global Const $WC_TABCONTROL = "SysTabControl32"
Global Const $WC_TOOLBAR = "ToolbarWindow32"
Global Const $WC_TOOLTIPS = "tooltips_class32"
Global Const $WC_TRACKBAR = "msctls_trackbar32"
Global Const $WC_TREEVIEW = "SysTreeView32"
Global Const $WC_UPDOWN = "msctls_updown32"
Global Const $WS_OVERLAPPED = 0
Global Const $WS_TILED = $WS_OVERLAPPED
Global Const $WS_MAXIMIZEBOX = 65536
Global Const $WS_MINIMIZEBOX = 131072
Global Const $WS_TABSTOP = 65536
Global Const $WS_GROUP = 131072
Global Const $WS_SIZEBOX = 262144
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 524288
Global Const $WS_HSCROLL = 1048576
Global Const $WS_VSCROLL = 2097152
Global Const $WS_DLGFRAME = 4194304
Global Const $WS_BORDER = 8388608
Global Const $WS_CAPTION = 12582912
Global Const $WS_OVERLAPPEDWINDOW = BitOR ( $WS_CAPTION , $WS_MAXIMIZEBOX , $WS_MINIMIZEBOX , $WS_OVERLAPPED , $WS_SYSMENU , $WS_THICKFRAME )
Global Const $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
Global Const $WS_MAXIMIZE = 16777216
Global Const $WS_CLIPCHILDREN = 33554432
Global Const $WS_CLIPSIBLINGS = 67108864
Global Const $WS_DISABLED = 134217728
Global Const $WS_VISIBLE = 268435456
Global Const $WS_MINIMIZE = 536870912
Global Const $WS_ICONIC = $WS_MINIMIZE
Global Const $WS_CHILD = 1073741824
Global Const $WS_CHILDWINDOW = $WS_CHILD
Global Const $WS_POPUP = 2147483648
Global Const $WS_POPUPWINDOW = 2156396544
Global Const $DS_3DLOOK = 4
Global Const $DS_ABSALIGN = 1
Global Const $DS_CENTER = 2048
Global Const $DS_CENTERMOUSE = 4096
Global Const $DS_CONTEXTHELP = 8192
Global Const $DS_CONTROL = 1024
Global Const $DS_FIXEDSYS = 8
Global Const $DS_LOCALEDIT = 32
Global Const $DS_MODALFRAME = 128
Global Const $DS_NOFAILCREATE = 16
Global Const $DS_NOIDLEMSG = 256
Global Const $DS_SETFONT = 64
Global Const $DS_SETFOREGROUND = 512
Global Const $DS_SHELLFONT = BitOR ( $DS_FIXEDSYS , $DS_SETFONT )
Global Const $DS_SYSMODAL = 2
Global Const $WS_EX_ACCEPTFILES = 16
Global Const $WS_EX_APPWINDOW = 262144
Global Const $WS_EX_COMPOSITED = 33554432
Global Const $WS_EX_CONTROLPARENT = 65536
Global Const $WS_EX_CLIENTEDGE = 512
Global Const $WS_EX_CONTEXTHELP = 1024
Global Const $WS_EX_DLGMODALFRAME = 1
Global Const $WS_EX_LAYERED = 524288
Global Const $WS_EX_LAYOUTRTL = 4194304
Global Const $WS_EX_LEFT = 0
Global Const $WS_EX_LEFTSCROLLBAR = 16384
Global Const $WS_EX_LTRREADING = 0
Global Const $WS_EX_MDICHILD = 64
Global Const $WS_EX_NOACTIVATE = 134217728
Global Const $WS_EX_NOINHERITLAYOUT = 1048576
Global Const $WS_EX_NOPARENTNOTIFY = 4
Global Const $WS_EX_NOREDIRECTIONBITMAP = 2097152
Global Const $WS_EX_RIGHT = 4096
Global Const $WS_EX_RIGHTSCROLLBAR = 0
Global Const $WS_EX_RTLREADING = 8192
Global Const $WS_EX_STATICEDGE = 131072
Global Const $WS_EX_TOOLWINDOW = 128
Global Const $WS_EX_TOPMOST = 8
Global Const $WS_EX_TRANSPARENT = 32
Global Const $WS_EX_WINDOWEDGE = 256
Global Const $WS_EX_OVERLAPPEDWINDOW = BitOR ( $WS_EX_CLIENTEDGE , $WS_EX_WINDOWEDGE )
Global Const $WS_EX_PALETTEWINDOW = BitOR ( $WS_EX_TOOLWINDOW , $WS_EX_TOPMOST , $WS_EX_WINDOWEDGE )
Global Const $WM_NULL = 0
Global Const $WM_CREATE = 1
Global Const $WM_DESTROY = 2
Global Const $WM_MOVE = 3
Global Const $WM_SIZEWAIT = 4
Global Const $WM_SIZE = 5
Global Const $WM_ACTIVATE = 6
Global Const $WM_SETFOCUS = 7
Global Const $WM_KILLFOCUS = 8
Global Const $WM_SETVISIBLE = 9
Global Const $WM_ENABLE = 10
Global Const $WM_SETREDRAW = 11
Global Const $WM_SETTEXT = 12
Global Const $WM_GETTEXT = 13
Global Const $WM_GETTEXTLENGTH = 14
Global Const $WM_PAINT = 15
Global Const $WM_CLOSE = 16
Global Const $WM_QUERYENDSESSION = 17
Global Const $WM_QUIT = 18
Global Const $WM_ERASEBKGND = 20
Global Const $WM_QUERYOPEN = 19
Global Const $WM_SYSCOLORCHANGE = 21
Global Const $WM_ENDSESSION = 22
Global Const $WM_SYSTEMERROR = 23
Global Const $WM_SHOWWINDOW = 24
Global Const $WM_CTLCOLOR = 25
Global Const $WM_SETTINGCHANGE = 26
Global Const $WM_WININICHANGE = 26
Global Const $WM_DEVMODECHANGE = 27
Global Const $WM_ACTIVATEAPP = 28
Global Const $WM_FONTCHANGE = 29
Global Const $WM_TIMECHANGE = 30
Global Const $WM_CANCELMODE = 31
Global Const $WM_SETCURSOR = 32
Global Const $WM_MOUSEACTIVATE = 33
Global Const $WM_CHILDACTIVATE = 34
Global Const $WM_QUEUESYNC = 35
Global Const $WM_GETMINMAXINFO = 36
Global Const $WM_LOGOFF = 37
Global Const $WM_PAINTICON = 38
Global Const $WM_ICONERASEBKGND = 39
Global Const $WM_NEXTDLGCTL = 40
Global Const $WM_ALTTABACTIVE = 41
Global Const $WM_SPOOLERSTATUS = 42
Global Const $WM_DRAWITEM = 43
Global Const $WM_MEASUREITEM = 44
Global Const $WM_DELETEITEM = 45
Global Const $WM_VKEYTOITEM = 46
Global Const $WM_CHARTOITEM = 47
Global Const $WM_SETFONT = 48
Global Const $WM_GETFONT = 49
Global Const $WM_SETHOTKEY = 50
Global Const $WM_GETHOTKEY = 51
Global Const $WM_FILESYSCHANGE = 52
Global Const $WM_ISACTIVEICON = 53
Global Const $WM_QUERYPARKICON = 54
Global Const $WM_QUERYDRAGICON = 55
Global Const $WM_WINHELP = 56
Global Const $WM_COMPAREITEM = 57
Global Const $WM_FULLSCREEN = 58
Global Const $WM_CLIENTSHUTDOWN = 59
Global Const $WM_DDEMLEVENT = 60
Global Const $WM_GETOBJECT = 61
Global Const $WM_CALCSCROLL = 63
Global Const $WM_TESTING = 64
Global Const $WM_COMPACTING = 65
Global Const $WM_OTHERWINDOWCREATED = 66
Global Const $WM_OTHERWINDOWDESTROYED = 67
Global Const $WM_COMMNOTIFY = 68
Global Const $WM_MEDIASTATUSCHANGE = 69
Global Const $WM_WINDOWPOSCHANGING = 70
Global Const $WM_WINDOWPOSCHANGED = 71
Global Const $WM_POWER = 72
Global Const $WM_COPYGLOBALDATA = 73
Global Const $WM_COPYDATA = 74
Global Const $WM_CANCELJOURNAL = 75
Global Const $WM_LOGONNOTIFY = 76
Global Const $WM_KEYF1 = 77
Global Const $WM_NOTIFY = 78
Global Const $WM_ACCESS_WINDOW = 79
Global Const $WM_INPUTLANGCHANGEREQUEST = 80
Global Const $WM_INPUTLANGCHANGE = 81
Global Const $WM_TCARD = 82
Global Const $WM_HELP = 83
Global Const $WM_USERCHANGED = 84
Global Const $WM_NOTIFYFORMAT = 85
Global Const $WM_QM_ACTIVATE = 96
Global Const $WM_HOOK_DO_CALLBACK = 97
Global Const $WM_SYSCOPYDATA = 98
Global Const $WM_FINALDESTROY = 112
Global Const $WM_MEASUREITEM_CLIENTDATA = 113
Global Const $WM_CONTEXTMENU = 123
Global Const $WM_STYLECHANGING = 124
Global Const $WM_STYLECHANGED = 125
Global Const $WM_DISPLAYCHANGE = 126
Global Const $WM_GETICON = 127
Global Const $WM_SETICON = 128
Global Const $WM_NCCREATE = 129
Global Const $WM_NCDESTROY = 130
Global Const $WM_NCCALCSIZE = 131
Global Const $WM_NCHITTEST = 132
Global Const $WM_NCPAINT = 133
Global Const $WM_NCACTIVATE = 134
Global Const $WM_GETDLGCODE = 135
Global Const $WM_SYNCPAINT = 136
Global Const $WM_SYNCTASK = 137
Global Const $WM_KLUDGEMINRECT = 139
Global Const $WM_LPKDRAWSWITCHWND = 140
Global Const $WM_UAHDESTROYWINDOW = 144
Global Const $WM_UAHDRAWMENU = 145
Global Const $WM_UAHDRAWMENUITEM = 146
Global Const $WM_UAHINITMENU = 147
Global Const $WM_UAHMEASUREMENUITEM = 148
Global Const $WM_UAHNCPAINTMENUPOPUP = 149
Global Const $WM_NCMOUSEMOVE = 160
Global Const $WM_NCLBUTTONDOWN = 161
Global Const $WM_NCLBUTTONUP = 162
Global Const $WM_NCLBUTTONDBLCLK = 163
Global Const $WM_NCRBUTTONDOWN = 164
Global Const $WM_NCRBUTTONUP = 165
Global Const $WM_NCRBUTTONDBLCLK = 166
Global Const $WM_NCMBUTTONDOWN = 167
Global Const $WM_NCMBUTTONUP = 168
Global Const $WM_NCMBUTTONDBLCLK = 169
Global Const $WM_NCXBUTTONDOWN = 171
Global Const $WM_NCXBUTTONUP = 172
Global Const $WM_NCXBUTTONDBLCLK = 173
Global Const $WM_NCUAHDRAWCAPTION = 174
Global Const $WM_NCUAHDRAWFRAME = 175
Global Const $WM_INPUT_DEVICE_CHANGE = 254
Global Const $WM_INPUT = 255
Global Const $WM_KEYDOWN = 256
Global Const $WM_KEYFIRST = 256
Global Const $WM_KEYUP = 257
Global Const $WM_CHAR = 258
Global Const $WM_DEADCHAR = 259
Global Const $WM_SYSKEYDOWN = 260
Global Const $WM_SYSKEYUP = 261
Global Const $WM_SYSCHAR = 262
Global Const $WM_SYSDEADCHAR = 263
Global Const $WM_YOMICHAR = 264
Global Const $WM_KEYLAST = 265
Global Const $WM_UNICHAR = 265
Global Const $WM_CONVERTREQUEST = 266
Global Const $WM_CONVERTRESULT = 267
Global Const $WM_IM_INFO = 268
Global Const $WM_IME_STARTCOMPOSITION = 269
Global Const $WM_IME_ENDCOMPOSITION = 270
Global Const $WM_IME_COMPOSITION = 271
Global Const $WM_IME_KEYLAST = 271
Global Const $WM_INITDIALOG = 272
Global Const $WM_COMMAND = 273
Global Const $WM_SYSCOMMAND = 274
Global Const $WM_TIMER = 275
Global Const $WM_HSCROLL = 276
Global Const $WM_VSCROLL = 277
Global Const $WM_INITMENU = 278
Global Const $WM_INITMENUPOPUP = 279
Global Const $WM_SYSTIMER = 280
Global Const $WM_GESTURE = 281
Global Const $WM_GESTURENOTIFY = 282
Global Const $WM_GESTUREINPUT = 283
Global Const $WM_GESTURENOTIFIED = 284
Global Const $WM_MENUSELECT = 287
Global Const $WM_MENUCHAR = 288
Global Const $WM_ENTERIDLE = 289
Global Const $WM_MENURBUTTONUP = 290
Global Const $WM_MENUDRAG = 291
Global Const $WM_MENUGETOBJECT = 292
Global Const $WM_UNINITMENUPOPUP = 293
Global Const $WM_MENUCOMMAND = 294
Global Const $WM_CHANGEUISTATE = 295
Global Const $WM_UPDATEUISTATE = 296
Global Const $WM_QUERYUISTATE = 297
Global Const $WM_LBTRACKPOINT = 305
Global Const $WM_CTLCOLORMSGBOX = 306
Global Const $WM_CTLCOLOREDIT = 307
Global Const $WM_CTLCOLORLISTBOX = 308
Global Const $WM_CTLCOLORBTN = 309
Global Const $WM_CTLCOLORDLG = 310
Global Const $WM_CTLCOLORSCROLLBAR = 311
Global Const $WM_CTLCOLORSTATIC = 312
Global Const $MN_GETHMENU = 481
Global Const $WM_PARENTNOTIFY = 528
Global Const $WM_ENTERMENULOOP = 529
Global Const $WM_EXITMENULOOP = 530
Global Const $WM_NEXTMENU = 531
Global Const $WM_SIZING = 532
Global Const $WM_CAPTURECHANGED = 533
Global Const $WM_MOVING = 534
Global Const $WM_POWERBROADCAST = 536
Global Const $WM_DEVICECHANGE = 537
Global Const $WM_MDICREATE = 544
Global Const $WM_MDIDESTROY = 545
Global Const $WM_MDIACTIVATE = 546
Global Const $WM_MDIRESTORE = 547
Global Const $WM_MDINEXT = 548
Global Const $WM_MDIMAXIMIZE = 549
Global Const $WM_MDITILE = 550
Global Const $WM_MDICASCADE = 551
Global Const $WM_MDIICONARRANGE = 552
Global Const $WM_MDIGETACTIVE = 553
Global Const $WM_DROPOBJECT = 554
Global Const $WM_QUERYDROPOBJECT = 555
Global Const $WM_BEGINDRAG = 556
Global Const $WM_DRAGLOOP = 557
Global Const $WM_DRAGSELECT = 558
Global Const $WM_DRAGMOVE = 559
Global Const $WM_MDISETMENU = 560
Global Const $WM_ENTERSIZEMOVE = 561
Global Const $WM_EXITSIZEMOVE = 562
Global Const $WM_DROPFILES = 563
Global Const $WM_MDIREFRESHMENU = 564
Global Const $WM_TOUCH = 576
Global Const $WM_IME_SETCONTEXT = 641
Global Const $WM_IME_NOTIFY = 642
Global Const $WM_IME_CONTROL = 643
Global Const $WM_IME_COMPOSITIONFULL = 644
Global Const $WM_IME_SELECT = 645
Global Const $WM_IME_CHAR = 646
Global Const $WM_IME_SYSTEM = 647
Global Const $WM_IME_REQUEST = 648
Global Const $WM_IME_KEYDOWN = 656
Global Const $WM_IME_KEYUP = 657
Global Const $WM_NCMOUSEHOVER = 672
Global Const $WM_MOUSEHOVER = 673
Global Const $WM_NCMOUSELEAVE = 674
Global Const $WM_MOUSELEAVE = 675
Global Const $WM_WTSSESSION_CHANGE = 689
Global Const $WM_TABLET_FIRST = 704
Global Const $WM_TABLET_LAST = 735
Global Const $WM_CUT = 768
Global Const $WM_COPY = 769
Global Const $WM_PASTE = 770
Global Const $WM_CLEAR = 771
Global Const $WM_UNDO = 772
Global Const $WM_PALETTEISCHANGING = 784
Global Const $WM_HOTKEY = 786
Global Const $WM_PALETTECHANGED = 785
Global Const $WM_SYSMENU = 787
Global Const $WM_HOOKMSG = 788
Global Const $WM_EXITPROCESS = 789
Global Const $WM_WAKETHREAD = 790
Global Const $WM_PRINT = 791
Global Const $WM_PRINTCLIENT = 792
Global Const $WM_APPCOMMAND = 793
Global Const $WM_QUERYNEWPALETTE = 783
Global Const $WM_THEMECHANGED = 794
Global Const $WM_UAHINIT = 795
Global Const $WM_DESKTOPNOTIFY = 796
Global Const $WM_CLIPBOARDUPDATE = 797
Global Const $WM_DWMCOMPOSITIONCHANGED = 798
Global Const $WM_DWMNCRENDERINGCHANGED = 799
Global Const $WM_DWMCOLORIZATIONCOLORCHANGED = 800
Global Const $WM_DWMWINDOWMAXIMIZEDCHANGE = 801
Global Const $WM_DWMEXILEFRAME = 802
Global Const $WM_DWMSENDICONICTHUMBNAIL = 803
Global Const $WM_MAGNIFICATION_STARTED = 804
Global Const $WM_MAGNIFICATION_ENDED = 805
Global Const $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 806
Global Const $WM_DWMTHUMBNAILSIZECHANGED = 807
Global Const $WM_MAGNIFICATION_OUTPUT = 808
Global Const $WM_MEASURECONTROL = 816
Global Const $WM_GETACTIONTEXT = 817
Global Const $WM_FORWARDKEYDOWN = 819
Global Const $WM_FORWARDKEYUP = 820
Global Const $WM_GETTITLEBARINFOEX = 831
Global Const $WM_NOTIFYWOW = 832
Global Const $WM_HANDHELDFIRST = 856
Global Const $WM_HANDHELDLAST = 863
Global Const $WM_AFXFIRST = 864
Global Const $WM_AFXLAST = 895
Global Const $WM_PENWINFIRST = 896
Global Const $WM_PENWINLAST = 911
Global Const $WM_DDE_INITIATE = 992
Global Const $WM_DDE_TERMINATE = 993
Global Const $WM_DDE_ADVISE = 994
Global Const $WM_DDE_UNADVISE = 995
Global Const $WM_DDE_ACK = 996
Global Const $WM_DDE_DATA = 997
Global Const $WM_DDE_REQUEST = 998
Global Const $WM_DDE_POKE = 999
Global Const $WM_DDE_EXECUTE = 1000
Global Const $WM_DBNOTIFICATION = 1021
Global Const $WM_NETCONNECT = 1022
Global Const $WM_HIBERNATE = 1023
Global Const $WM_USER = 1024
Global Const $WM_APP = 32768
Global Const $NM_FIRST = 0
Global Const $NM_OUTOFMEMORY = $NM_FIRST + 4294967295
Global Const $NM_CLICK = $NM_FIRST + 4294967294
Global Const $NM_DBLCLK = $NM_FIRST + 4294967293
Global Const $NM_RETURN = $NM_FIRST + 4294967292
Global Const $NM_RCLICK = $NM_FIRST + 4294967291
Global Const $NM_RDBLCLK = $NM_FIRST + 4294967290
Global Const $NM_SETFOCUS = $NM_FIRST + 4294967289
Global Const $NM_KILLFOCUS = $NM_FIRST + 4294967288
Global Const $NM_CUSTOMDRAW = $NM_FIRST + 4294967284
Global Const $NM_HOVER = $NM_FIRST + 4294967283
Global Const $NM_NCHITTEST = $NM_FIRST + 4294967282
Global Const $NM_KEYDOWN = $NM_FIRST + 4294967281
Global Const $NM_RELEASEDCAPTURE = $NM_FIRST + 4294967280
Global Const $NM_SETCURSOR = $NM_FIRST + 4294967279
Global Const $NM_CHAR = $NM_FIRST + 4294967278
Global Const $NM_TOOLTIPSCREATED = $NM_FIRST + 4294967277
Global Const $NM_LDOWN = $NM_FIRST + 4294967276
Global Const $NM_RDOWN = $NM_FIRST + 4294967275
Global Const $NM_THEMECHANGED = $NM_FIRST + 4294967274
Global Const $WM_MOUSEFIRST = 512
Global Const $WM_MOUSEMOVE = 512
Global Const $WM_LBUTTONDOWN = 513
Global Const $WM_LBUTTONUP = 514
Global Const $WM_LBUTTONDBLCLK = 515
Global Const $WM_RBUTTONDOWN = 516
Global Const $WM_RBUTTONUP = 517
Global Const $WM_RBUTTONDBLCLK = 518
Global Const $WM_MBUTTONDOWN = 519
Global Const $WM_MBUTTONUP = 520
Global Const $WM_MBUTTONDBLCLK = 521
Global Const $WM_MOUSEWHEEL = 522
Global Const $WM_XBUTTONDOWN = 523
Global Const $WM_XBUTTONUP = 524
Global Const $WM_XBUTTONDBLCLK = 525
Global Const $WM_MOUSEHWHEEL = 526
Global Const $PS_SOLID = 0
Global Const $PS_DASH = 1
Global Const $PS_DOT = 2
Global Const $PS_DASHDOT = 3
Global Const $PS_DASHDOTDOT = 4
Global Const $PS_NULL = 5
Global Const $PS_INSIDEFRAME = 6
Global Const $PS_USERSTYLE = 7
Global Const $PS_ALTERNATE = 8
Global Const $PS_ENDCAP_ROUND = 0
Global Const $PS_ENDCAP_SQUARE = 256
Global Const $PS_ENDCAP_FLAT = 512
Global Const $PS_JOIN_BEVEL = 4096
Global Const $PS_JOIN_MITER = 8192
Global Const $PS_JOIN_ROUND = 0
Global Const $PS_GEOMETRIC = 65536
Global Const $PS_COSMETIC = 0
Global Const $LWA_ALPHA = 2
Global Const $LWA_COLORKEY = 1
Global Const $RGN_AND = 1
Global Const $RGN_OR = 2
Global Const $RGN_XOR = 3
Global Const $RGN_DIFF = 4
Global Const $RGN_COPY = 5
Global Const $ERRORREGION = 0
Global Const $NULLREGION = 1
Global Const $SIMPLEREGION = 2
Global Const $COMPLEXREGION = 3
Global Const $TRANSPARENT = 1
Global Const $OPAQUE = 2
Global Const $CCM_FIRST = 8192
Global Const $CCM_GETUNICODEFORMAT = ( $CCM_FIRST + 6 )
Global Const $CCM_SETUNICODEFORMAT = ( $CCM_FIRST + 5 )
Global Const $CCM_SETBKCOLOR = $CCM_FIRST + 1
Global Const $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
Global Const $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
Global Const $CCM_GETDROPTARGET = $CCM_FIRST + 4
Global Const $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
Global Const $GA_PARENT = 1
Global Const $GA_ROOT = 2
Global Const $GA_ROOTOWNER = 3
Global Const $SM_CXSCREEN = 0
Global Const $SM_CYSCREEN = 1
Global Const $SM_CXVSCROLL = 2
Global Const $SM_CYHSCROLL = 3
Global Const $SM_CYCAPTION = 4
Global Const $SM_CXBORDER = 5
Global Const $SM_CYBORDER = 6
Global Const $SM_CXFIXEDFRAME = 7
Global Const $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
Global Const $SM_CYFIXEDFRAME = 8
Global Const $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
Global Const $SM_CYVTHUMB = 9
Global Const $SM_CXHTHUMB = 10
Global Const $SM_CXICON = 11
Global Const $SM_CYICON = 12
Global Const $SM_CXCURSOR = 13
Global Const $SM_CYCURSOR = 14
Global Const $SM_CYMENU = 15
Global Const $SM_CXFULLSCREEN = 16
Global Const $SM_CYFULLSCREEN = 17
Global Const $SM_CYKANJIWINDOW = 18
Global Const $SM_MOUSEPRESENT = 19
Global Const $SM_CYVSCROLL = 20
Global Const $SM_CXHSCROLL = 21
Global Const $SM_DEBUG = 22
Global Const $SM_SWAPBUTTON = 23
Global Const $SM_RESERVED1 = 24
Global Const $SM_RESERVED2 = 25
Global Const $SM_RESERVED3 = 26
Global Const $SM_RESERVED4 = 27
Global Const $SM_CXMIN = 28
Global Const $SM_CYMIN = 29
Global Const $SM_CXSIZE = 30
Global Const $SM_CYSIZE = 31
Global Const $SM_CXSIZEFRAME = 32
Global Const $SM_CXFRAME = $SM_CXSIZEFRAME
Global Const $SM_CYSIZEFRAME = 33
Global Const $SM_CYFRAME = $SM_CYSIZEFRAME
Global Const $SM_CXMINTRACK = 34
Global Const $SM_CYMINTRACK = 35
Global Const $SM_CXDOUBLECLK = 36
Global Const $SM_CYDOUBLECLK = 37
Global Const $SM_CXICONSPACING = 38
Global Const $SM_CYICONSPACING = 39
Global Const $SM_MENUDROPALIGNMENT = 40
Global Const $SM_PENWINDOWS = 41
Global Const $SM_DBCSENABLED = 42
Global Const $SM_CMOUSEBUTTONS = 43
Global Const $SM_SECURE = 44
Global Const $SM_CXEDGE = 45
Global Const $SM_CYEDGE = 46
Global Const $SM_CXMINSPACING = 47
Global Const $SM_CYMINSPACING = 48
Global Const $SM_CXSMICON = 49
Global Const $SM_CYSMICON = 50
Global Const $SM_CYSMCAPTION = 51
Global Const $SM_CXSMSIZE = 52
Global Const $SM_CYSMSIZE = 53
Global Const $SM_CXMENUSIZE = 54
Global Const $SM_CYMENUSIZE = 55
Global Const $SM_ARRANGE = 56
Global Const $SM_CXMINIMIZED = 57
Global Const $SM_CYMINIMIZED = 58
Global Const $SM_CXMAXTRACK = 59
Global Const $SM_CYMAXTRACK = 60
Global Const $SM_CXMAXIMIZED = 61
Global Const $SM_CYMAXIMIZED = 62
Global Const $SM_NETWORK = 63
Global Const $SM_CLEANBOOT = 67
Global Const $SM_CXDRAG = 68
Global Const $SM_CYDRAG = 69
Global Const $SM_SHOWSOUNDS = 70
Global Const $SM_CXMENUCHECK = 71
Global Const $SM_CYMENUCHECK = 72
Global Const $SM_SLOWMACHINE = 73
Global Const $SM_MIDEASTENABLED = 74
Global Const $SM_MOUSEWHEELPRESENT = 75
Global Const $SM_XVIRTUALSCREEN = 76
Global Const $SM_YVIRTUALSCREEN = 77
Global Const $SM_CXVIRTUALSCREEN = 78
Global Const $SM_CYVIRTUALSCREEN = 79
Global Const $SM_CMONITORS = 80
Global Const $SM_SAMEDISPLAYFORMAT = 81
Global Const $SM_IMMENABLED = 82
Global Const $SM_CXFOCUSBORDER = 83
Global Const $SM_CYFOCUSBORDER = 84
Global Const $SM_TABLETPC = 86
Global Const $SM_MEDIACENTER = 87
Global Const $SM_STARTER = 88
Global Const $SM_SERVERR2 = 89
Global Const $SM_CMETRICS = 90
Global Const $SM_REMOTESESSION = 4096
Global Const $SM_SHUTTINGDOWN = 8192
Global Const $SM_REMOTECONTROL = 8193
Global Const $SM_CARETBLINKINGENABLED = 8194
Global Const $BLACKNESS = 66
Global Const $CAPTUREBLT = 1073741824
Global Const $DSTINVERT = 5570569
Global Const $MERGECOPY = 12583114
Global Const $MERGEPAINT = 12255782
Global Const $NOMIRRORBITMAP = 2147483648
Global Const $NOTSRCCOPY = 3342344
Global Const $NOTSRCERASE = 1114278
Global Const $PATCOPY = 15728673
Global Const $PATINVERT = 5898313
Global Const $PATPAINT = 16452105
Global Const $SRCAND = 8913094
Global Const $SRCCOPY = 13369376
Global Const $SRCERASE = 4457256
Global Const $SRCINVERT = 6684742
Global Const $SRCPAINT = 15597702
Global Const $WHITENESS = 16711778
Global Const $DT_BOTTOM = 8
Global Const $DT_CALCRECT = 1024
Global Const $DT_CENTER = 1
Global Const $DT_EDITCONTROL = 8192
Global Const $DT_END_ELLIPSIS = 32768
Global Const $DT_EXPANDTABS = 64
Global Const $DT_EXTERNALLEADING = 512
Global Const $DT_HIDEPREFIX = 1048576
Global Const $DT_INTERNAL = 4096
Global Const $DT_LEFT = 0
Global Const $DT_MODIFYSTRING = 65536
Global Const $DT_NOCLIP = 256
Global Const $DT_NOFULLWIDTHCHARBREAK = 524288
Global Const $DT_NOPREFIX = 2048
Global Const $DT_PATH_ELLIPSIS = 16384
Global Const $DT_PREFIXONLY = 2097152
Global Const $DT_RIGHT = 2
Global Const $DT_RTLREADING = 131072
Global Const $DT_SINGLELINE = 32
Global Const $DT_TABSTOP = 128
Global Const $DT_TOP = 0
Global Const $DT_VCENTER = 4
Global Const $DT_WORDBREAK = 16
Global Const $DT_WORD_ELLIPSIS = 262144
Global Const $RDW_ERASE = 4
Global Const $RDW_FRAME = 1024
Global Const $RDW_INTERNALPAINT = 2
Global Const $RDW_INVALIDATE = 1
Global Const $RDW_NOERASE = 32
Global Const $RDW_NOFRAME = 2048
Global Const $RDW_NOINTERNALPAINT = 16
Global Const $RDW_VALIDATE = 8
Global Const $RDW_ERASENOW = 512
Global Const $RDW_UPDATENOW = 256
Global Const $RDW_ALLCHILDREN = 128
Global Const $RDW_NOCHILDREN = 64
Global Const $WM_RENDERFORMAT = 773
Global Const $WM_RENDERALLFORMATS = 774
Global Const $WM_DESTROYCLIPBOARD = 775
Global Const $WM_DRAWCLIPBOARD = 776
Global Const $WM_PAINTCLIPBOARD = 777
Global Const $WM_VSCROLLCLIPBOARD = 778
Global Const $WM_SIZECLIPBOARD = 779
Global Const $WM_ASKCBFORMATNAME = 780
Global Const $WM_CHANGECBCHAIN = 781
Global Const $WM_HSCROLLCLIPBOARD = 782
Global Const $HTERROR = + 4294967294
Global Const $HTTRANSPARENT = + 4294967295
Global Const $HTNOWHERE = 0
Global Const $HTCLIENT = 1
Global Const $HTCAPTION = 2
Global Const $HTSYSMENU = 3
Global Const $HTGROWBOX = 4
Global Const $HTSIZE = $HTGROWBOX
Global Const $HTMENU = 5
Global Const $HTHSCROLL = 6
Global Const $HTVSCROLL = 7
Global Const $HTMINBUTTON = 8
Global Const $HTMAXBUTTON = 9
Global Const $HTLEFT = 10
Global Const $HTRIGHT = 11
Global Const $HTTOP = 12
Global Const $HTTOPLEFT = 13
Global Const $HTTOPRIGHT = 14
Global Const $HTBOTTOM = 15
Global Const $HTBOTTOMLEFT = 16
Global Const $HTBOTTOMRIGHT = 17
Global Const $HTBORDER = 18
Global Const $HTREDUCE = $HTMINBUTTON
Global Const $HTZOOM = $HTMAXBUTTON
Global Const $HTSIZEFIRST = $HTLEFT
Global Const $HTSIZELAST = $HTBOTTOMRIGHT
Global Const $HTOBJECT = 19
Global Const $HTCLOSE = 20
Global Const $HTHELP = 21
Global Const $COLOR_SCROLLBAR = 0
Global Const $COLOR_BACKGROUND = 1
Global Const $COLOR_ACTIVECAPTION = 2
Global Const $COLOR_INACTIVECAPTION = 3
Global Const $COLOR_MENU = 4
Global Const $COLOR_WINDOW = 5
Global Const $COLOR_WINDOWFRAME = 6
Global Const $COLOR_MENUTEXT = 7
Global Const $COLOR_WINDOWTEXT = 8
Global Const $COLOR_CAPTIONTEXT = 9
Global Const $COLOR_ACTIVEBORDER = 10
Global Const $COLOR_INACTIVEBORDER = 11
Global Const $COLOR_APPWORKSPACE = 12
Global Const $COLOR_HIGHLIGHT = 13
Global Const $COLOR_HIGHLIGHTTEXT = 14
Global Const $COLOR_BTNFACE = 15
Global Const $COLOR_BTNSHADOW = 16
Global Const $COLOR_GRAYTEXT = 17
Global Const $COLOR_BTNTEXT = 18
Global Const $COLOR_INACTIVECAPTIONTEXT = 19
Global Const $COLOR_BTNHIGHLIGHT = 20
Global Const $COLOR_3DDKSHADOW = 21
Global Const $COLOR_3DLIGHT = 22
Global Const $COLOR_INFOTEXT = 23
Global Const $COLOR_INFOBK = 24
Global Const $COLOR_HOTLIGHT = 26
Global Const $COLOR_GRADIENTACTIVECAPTION = 27
Global Const $COLOR_GRADIENTINACTIVECAPTION = 28
Global Const $COLOR_MENUHILIGHT = 29
Global Const $COLOR_MENUBAR = 30
Global Const $COLOR_DESKTOP = 1
Global Const $COLOR_3DFACE = 15
Global Const $COLOR_3DSHADOW = 16
Global Const $COLOR_3DHIGHLIGHT = 20
Global Const $COLOR_3DHILIGHT = 20
Global Const $COLOR_BTNHILIGHT = 20
Global Const $HINST_COMMCTRL = + 4294967295
Global Const $IDB_STD_SMALL_COLOR = 0
Global Const $IDB_STD_LARGE_COLOR = 1
Global Const $IDB_VIEW_SMALL_COLOR = 4
Global Const $IDB_VIEW_LARGE_COLOR = 5
Global Const $IDB_HIST_SMALL_COLOR = 8
Global Const $IDB_HIST_LARGE_COLOR = 9
Global Const $STARTF_FORCEOFFFEEDBACK = 128
Global Const $STARTF_FORCEONFEEDBACK = 64
Global Const $STARTF_PREVENTPINNING = 8192
Global Const $STARTF_RUNFULLSCREEN = 32
Global Const $STARTF_TITLEISAPPID = 4096
Global Const $STARTF_TITLEISLINKNAME = 2048
Global Const $STARTF_USECOUNTCHARS = 8
Global Const $STARTF_USEFILLATTRIBUTE = 16
Global Const $STARTF_USEHOTKEY = 512
Global Const $STARTF_USEPOSITION = 4
Global Const $STARTF_USESHOWWINDOW = 1
Global Const $STARTF_USESIZE = 2
Global Const $STARTF_USESTDHANDLES = 256
Global Const $CDDS_PREPAINT = 1
Global Const $CDDS_POSTPAINT = 2
Global Const $CDDS_PREERASE = 3
Global Const $CDDS_POSTERASE = 4
Global Const $CDDS_ITEM = 65536
Global Const $CDDS_ITEMPREPAINT = 65537
Global Const $CDDS_ITEMPOSTPAINT = 65538
Global Const $CDDS_ITEMPREERASE = 65539
Global Const $CDDS_ITEMPOSTERASE = 65540
Global Const $CDDS_SUBITEM = 131072
Global Const $CDIS_SELECTED = 1
Global Const $CDIS_GRAYED = 2
Global Const $CDIS_DISABLED = 4
Global Const $CDIS_CHECKED = 8
Global Const $CDIS_FOCUS = 16
Global Const $CDIS_DEFAULT = 32
Global Const $CDIS_HOT = 64
Global Const $CDIS_MARKED = 128
Global Const $CDIS_INDETERMINATE = 256
Global Const $CDIS_SHOWKEYBOARDCUES = 512
Global Const $CDIS_NEARHOT = 1024
Global Const $CDIS_OTHERSIDEHOT = 2048
Global Const $CDIS_DROPHILITED = 4096
Global Const $CDRF_DODEFAULT = 0
Global Const $CDRF_NEWFONT = 2
Global Const $CDRF_SKIPDEFAULT = 4
Global Const $CDRF_NOTIFYPOSTPAINT = 16
Global Const $CDRF_NOTIFYITEMDRAW = 32
Global Const $CDRF_NOTIFYSUBITEMDRAW = 32
Global Const $CDRF_NOTIFYPOSTERASE = 64
Global Const $CDRF_DOERASE = 8
Global Const $CDRF_SKIPPOSTPAINT = 256
Global Const $GUI_SS_DEFAULT_GUI = BitOR ( $WS_MINIMIZEBOX , $WS_CAPTION , $WS_POPUP , $WS_SYSMENU )
Global Const $DDL_ARCHIVE = 32
Global Const $DDL_DIRECTORY = 16
Global Const $DDL_DRIVES = 16384
Global Const $DDL_EXCLUSIVE = 32768
Global Const $DDL_HIDDEN = 2
Global Const $DDL_READONLY = 1
Global Const $DDL_READWRITE = 0
Global Const $DDL_SYSTEM = 4
Func _SENDMESSAGE ( $HWND , $IMSG , $WPARAM = 0 , $LPARAM = 0 , $IRETURN = 0 , $WPARAMTYPE = "wparam" , $LPARAMTYPE = "lparam" , $SRETURNTYPE = "lresult" )
	Local $ACALL = DllCall ( "user32.dll" , $SRETURNTYPE , "SendMessageW" , "hwnd" , $HWND , "uint" , $IMSG , $WPARAMTYPE , $WPARAM , $LPARAMTYPE , $LPARAM )
	If @error Then Return SetError ( @error , @extended , "" )
	If $IRETURN >= 0 And $IRETURN <= 4 Then Return $ACALL [ $IRETURN ]
	Return $ACALL
EndFunc
Func _SENDMESSAGEA ( $HWND , $IMSG , $WPARAM = 0 , $LPARAM = 0 , $IRETURN = 0 , $WPARAMTYPE = "wparam" , $LPARAMTYPE = "lparam" , $SRETURNTYPE = "lresult" )
	Local $ACALL = DllCall ( "user32.dll" , $SRETURNTYPE , "SendMessageA" , "hwnd" , $HWND , "uint" , $IMSG , $WPARAMTYPE , $WPARAM , $LPARAMTYPE , $LPARAM )
	If @error Then Return SetError ( @error , @extended , "" )
	If $IRETURN >= 0 And $IRETURN <= 4 Then Return $ACALL [ $IRETURN ]
	Return $ACALL
EndFunc
Global Const $TAGPOINT = "struct;long X;long Y;endstruct"
Global Const $TAGRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $TAGSIZE = "struct;long X;long Y;endstruct"
Global Const $TAGMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $TAGFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $TAGSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $TAGTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $TAGNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $TAGCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $TAGNMCBEDRAGBEGIN = $TAGNMHDR & ";int ItemID;wchar szText[260]"
Global Const $TAGNMCBEENDEDIT = $TAGNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $TAGNMCOMBOBOXEX = $TAGNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $TAGDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $TAGNMDATETIMECHANGE = $TAGNMHDR & ";dword Flag;" & $TAGSYSTEMTIME
Global Const $TAGNMDATETIMEFORMAT = $TAGNMHDR & ";ptr Format;" & $TAGSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
Global Const $TAGNMDATETIMEFORMATQUERY = $TAGNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $TAGNMDATETIMEKEYDOWN = $TAGNMHDR & ";int VirtKey;ptr Format;" & $TAGSYSTEMTIME
Global Const $TAGNMDATETIMESTRING = $TAGNMHDR & ";ptr UserString;" & $TAGSYSTEMTIME & ";dword Flags"
Global Const $TAGEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $TAGGDIP_EFFECTPARAMS_BLUR = "float Radius; bool ExpandEdge"
Global Const $TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST = "int BrightnessLevel; int ContrastLevel"
Global Const $TAGGDIP_EFFECTPARAMS_COLORBALANCE = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $TAGGDIP_EFFECTPARAMS_COLORCURVE = "int Adjustment; int Channel; int AdjustValue"
Global Const $TAGGDIP_EFFECTPARAMS_COLORLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $TAGGDIP_EFFECTPARAMS_LEVELS = "int Highlight; int Midtone; int Shadow"
Global Const $TAGGDIP_EFFECTPARAMS_REDEYECORRECTION = "uint NumberOfAreas; ptr Areas"
Global Const $TAGGDIP_EFFECTPARAMS_SHARPEN = "float Radius; float Amount"
Global Const $TAGGDIP_EFFECTPARAMS_TINT = "int Hue; int Amount"
Global Const $TAGGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $TAGGDIPCOLORMATRIX = "float m[25]"
Global Const $TAGGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $TAGGDIPENCODERPARAMS = "uint Count;" & $TAGGDIPENCODERPARAM
Global Const $TAGGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $TAGGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $TAGGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
Global Const $TAGGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $TAGGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
Global Const $TAGHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $TAGNMHDDISPINFO = $TAGNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $TAGNMHDFILTERBTNCLICK = $TAGNMHDR & ";int Item;" & $TAGRECT
Global Const $TAGNMHEADER = $TAGNMHDR & ";int Item;int Button;ptr pItem"
Global Const $TAGGETIPADDRESS = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $TAGNMIPADDRESS = $TAGNMHDR & ";int Field;int Value"
Global Const $TAGLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $TAGPOINT & ";uint Direction;endstruct"
Global Const $TAGLVHITTESTINFO = $TAGPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $TAGNMLISTVIEW = $TAGNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $TAGNMLVCUSTOMDRAW = "struct;" & $TAGNMHDR & ";dword dwDrawStage;handle hdc;" & $TAGRECT & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $TAGNMLVDISPINFO = $TAGNMHDR & ";" & $TAGLVITEM
Global Const $TAGNMLVFINDITEM = $TAGNMHDR & ";int Start;" & $TAGLVFINDINFO
Global Const $TAGNMLVGETINFOTIP = $TAGNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $TAGNMITEMACTIVATE = $TAGNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $TAGPOINT & ";lparam lParam;uint KeyFlags"
Global Const $TAGNMLVKEYDOWN = $TAGNMHDR & ";align 2;word VKey;uint Flags"
Global Const $TAGNMLVSCROLL = $TAGNMHDR & ";int DX;int DY"
Global Const $TAGMCHITTESTINFO = "uint Size;" & $TAGPOINT & ";uint Hit;" & $TAGSYSTEMTIME & ";" & $TAGRECT & ";int iOffset;int iRow;int iCol"
Global Const $TAGMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
Global Const $TAGMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $TAGMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
Global Const $TAGNMDAYSTATE = $TAGNMHDR & ";" & $TAGSYSTEMTIME & ";int DayState;ptr pDayState"
Global Const $TAGNMSELCHANGE = $TAGNMHDR & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $TAGNMOBJECTNOTIFY = $TAGNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $TAGNMTCKEYDOWN = $TAGNMHDR & ";align 2;word VKey;uint Flags"
Global Const $TAGTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
Global Const $TAGTVITEMEX = "struct;" & $TAGTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $TAGNMTREEVIEW = $TAGNMHDR & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
Global Const $TAGNMTVCUSTOMDRAW = "struct;" & $TAGNMHDR & ";dword DrawStage;handle HDC;" & $TAGRECT & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
Global Const $TAGNMTVDISPINFO = $TAGNMHDR & ";" & $TAGTVITEM
Global Const $TAGNMTVGETINFOTIP = $TAGNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $TAGNMTVITEMCHANGE = $TAGNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $TAGTVHITTESTINFO = $TAGPOINT & ";uint Flags;handle Item"
Global Const $TAGNMTVKEYDOWN = $TAGNMHDR & ";align 2;word VKey;uint Flags"
Global Const $TAGNMMOUSE = $TAGNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $TAGPOINT & ";lparam HitInfo"
Global Const $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $TAGIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $TAGRECT
Global Const $TAGMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $TAGMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $TAGREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ( ( @OSVersion = "WIN_XP" ) ? "" : ";" & $TAGRECT & ";uint uChevronState" )
Global Const $TAGNMREBARAUTOBREAK = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $TAGNMRBAUTOSIZE = $TAGNMHDR & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $TAGNMREBAR = $TAGNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $TAGNMREBARCHEVRON = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;" & $TAGRECT & ";lparam lParamNM"
Global Const $TAGNMREBARCHILDSIZE = $TAGNMHDR & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $TAGCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $TAGNMTOOLBAR = $TAGNMHDR & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $TAGRECT
Global Const $TAGNMTBHOTITEM = $TAGNMHDR & ";int idOld;int idNew;dword dwFlags"
Global Const $TAGTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $TAGTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $TAGNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $TAGOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $TAGOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $TAGBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $TAGBITMAPINFO = $TAGBITMAPINFOHEADER & ";dword biRGBQuad[1]"
Global Const $TAGBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $TAGGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $TAGWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $TAGWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $TAGSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $TAGSCROLLBARINFO = "dword cbSize;" & $TAGRECT & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $TAGLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $TAGKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $TAGPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $TAGSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $TAGSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $TAGWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $TAGTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $OPT_COORDSRELATIVE = 0
Global Const $OPT_COORDSABSOLUTE = 1
Global Const $OPT_COORDSCLIENT = 2
Global Const $OPT_ERRORSILENT = 0
Global Const $OPT_ERRORFATAL = 1
Global Const $OPT_CAPSNOSTORE = 0
Global Const $OPT_CAPSSTORE = 1
Global Const $OPT_MATCHSTART = 1
Global Const $OPT_MATCHANY = 2
Global Const $OPT_MATCHEXACT = 3
Global Const $OPT_MATCHADVANCED = 4
Global Const $CCS_TOP = 1
Global Const $CCS_NOMOVEY = 2
Global Const $CCS_BOTTOM = 3
Global Const $CCS_NORESIZE = 4
Global Const $CCS_NOPARENTALIGN = 8
Global Const $CCS_NOHILITE = 16
Global Const $CCS_ADJUSTABLE = 32
Global Const $CCS_NODIVIDER = 64
Global Const $CCS_VERT = 128
Global Const $CCS_LEFT = 129
Global Const $CCS_NOMOVEX = 130
Global Const $CCS_RIGHT = 131
Global Const $DT_DRIVETYPE = 1
Global Const $DT_SSDSTATUS = 2
Global Const $DT_BUSTYPE = 3
Global Const $PROXY_IE = 0
Global Const $PROXY_NONE = 1
Global Const $PROXY_SPECIFIED = 2
Global Const $OBJID_WINDOW = 0
Global Const $OBJID_TITLEBAR = 4294967294
Global Const $OBJID_SIZEGRIP = 4294967289
Global Const $OBJID_CARET = 4294967288
Global Const $OBJID_CURSOR = 4294967287
Global Const $OBJID_ALERT = 4294967286
Global Const $OBJID_SOUND = 4294967285
Global Const $DLG_CENTERONTOP = 0
Global Const $DLG_NOTITLE = 1
Global Const $DLG_NOTONTOP = 2
Global Const $DLG_TEXTLEFT = 4
Global Const $DLG_TEXTRIGHT = 8
Global Const $DLG_MOVEABLE = 16
Global Const $DLG_TEXTVCENTER = 32
Global Const $MCID_UNKNOWN = + 4294967295
Global Const $MCID_HAND = 0
Global Const $MCID_APPSTARTING = 1
Global Const $MCID_ARROW = 2
Global Const $MCID_CROSS = 3
Global Const $MCID_HELP = 4
Global Const $MCID_IBEAM = 5
Global Const $MCID_ICON = 6
Global Const $MCID_NO = 7
Global Const $MCID_SIZE = 8
Global Const $MCID_SIZEALL = 9
Global Const $MCID_SIZENESW = 10
Global Const $MCID_SIZENS = 11
Global Const $MCID_SIZENWSE = 12
Global Const $MCID_SIZEWE = 13
Global Const $MCID_UPARROW = 14
Global Const $MCID_WAIT = 15
Global Const $MCID_NONE = 16
Global Const $SD_LOGOFF = 0
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_POWERDOWN = 8
Global Const $SD_FORCEHUNG = 16
Global Const $SD_STANDBY = 32
Global Const $SD_HIBERNATE = 64
Global Const $STDIN_CHILD = 1
Global Const $STDOUT_CHILD = 2
Global Const $STDERR_CHILD = 4
Global Const $STDERR_MERGED = 8
Global Const $STDIO_INHERIT_PARENT = 16
Global Const $RUN_CREATE_NEW_CONSOLE = 65536
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $MOUSEEVENTF_ABSOLUTE = 32768
Global Const $MOUSEEVENTF_MOVE = 1
Global Const $MOUSEEVENTF_LEFTDOWN = 2
Global Const $MOUSEEVENTF_LEFTUP = 4
Global Const $MOUSEEVENTF_RIGHTDOWN = 8
Global Const $MOUSEEVENTF_RIGHTUP = 16
Global Const $MOUSEEVENTF_MIDDLEDOWN = 32
Global Const $MOUSEEVENTF_MIDDLEUP = 64
Global Const $MOUSEEVENTF_WHEEL = 2048
Global Const $MOUSEEVENTF_XDOWN = 128
Global Const $MOUSEEVENTF_XUP = 256
Global Const $REG_NONE = 0
Global Const $REG_SZ = 1
Global Const $REG_EXPAND_SZ = 2
Global Const $REG_BINARY = 3
Global Const $REG_DWORD = 4
Global Const $REG_DWORD_LITTLE_ENDIAN = 4
Global Const $REG_DWORD_BIG_ENDIAN = 5
Global Const $REG_LINK = 6
Global Const $REG_MULTI_SZ = 7
Global Const $REG_RESOURCE_LIST = 8
Global Const $REG_FULL_RESOURCE_DESCRIPTOR = 9
Global Const $REG_RESOURCE_REQUIREMENTS_LIST = 10
Global Const $REG_QWORD = 11
Global Const $REG_QWORD_LITTLE_ENDIAN = 11
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = + 4294967294
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = + 4294967295
Global Const $SWP_NOSIZE = 1
Global Const $SWP_NOMOVE = 2
Global Const $SWP_NOZORDER = 4
Global Const $SWP_NOREDRAW = 8
Global Const $SWP_NOACTIVATE = 16
Global Const $SWP_FRAMECHANGED = 32
Global Const $SWP_DRAWFRAME = 32
Global Const $SWP_SHOWWINDOW = 64
Global Const $SWP_HIDEWINDOW = 128
Global Const $SWP_NOCOPYBITS = 256
Global Const $SWP_NOOWNERZORDER = 512
Global Const $SWP_NOREPOSITION = 512
Global Const $SWP_NOSENDCHANGING = 1024
Global Const $SWP_DEFERERASE = 8192
Global Const $SWP_ASYNCWINDOWPOS = 16384
Global Const $KEYWORD_DEFAULT = 1
Global Const $KEYWORD_NULL = 2
Global Const $DECLARED_LOCAL = + 4294967295
Global Const $DECLARED_UNKNOWN = 0
Global Const $DECLARED_GLOBAL = 1
Global Const $ASSIGN_CREATE = 0
Global Const $ASSIGN_FORCELOCAL = 1
Global Const $ASSIGN_FORCEGLOBAL = 2
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $BI_ENABLE = 0
Global Const $BI_DISABLE = 1
Global Const $BREAK_ENABLE = 1
Global Const $BREAK_DISABLE = 0
Global Const $CDTRAY_OPEN = "open"
Global Const $CDTRAY_CLOSED = "closed"
Global Const $SEND_DEFAULT = 0
Global Const $SEND_RAW = 1
Global Const $DIR_DEFAULT = 0
Global Const $DIR_EXTENDED = 1
Global Const $DIR_NORECURSE = 2
Global Const $DIR_REMOVE = 1
Global Const $DT_ALL = "ALL"
Global Const $DT_CDROM = "CDROM"
Global Const $DT_REMOVABLE = "REMOVABLE"
Global Const $DT_FIXED = "FIXED"
Global Const $DT_NETWORK = "NETWORK"
Global Const $DT_RAMDISK = "RAMDISK"
Global Const $DT_UNKNOWN = "UNKNOWN"
Global Const $DT_UNDEFINED = 1
Global Const $DT_FAT = "FAT"
Global Const $DT_FAT32 = "FAT32"
Global Const $DT_EXFAT = "exFAT"
Global Const $DT_NTFS = "NTFS"
Global Const $DT_NWFS = "NWFS"
Global Const $DT_CDFS = "CDFS"
Global Const $DT_UDF = "UDF"
Global Const $DMA_DEFAULT = 0
Global Const $DMA_PERSISTENT = 1
Global Const $DMA_AUTHENTICATION = 8
Global Const $DS_UNKNOWN = "UNKNOWN"
Global Const $DS_READY = "READY"
Global Const $DS_NOTREADY = "NOTREADY"
Global Const $DS_INVALID = "INVALID"
Global Const $MOUSE_CLICK_LEFT = "left"
Global Const $MOUSE_CLICK_RIGHT = "right"
Global Const $MOUSE_CLICK_MIDDLE = "middle"
Global Const $MOUSE_CLICK_MAIN = "main"
Global Const $MOUSE_CLICK_MENU = "menu"
Global Const $MOUSE_CLICK_PRIMARY = "primary"
Global Const $MOUSE_CLICK_SECONDARY = "secondary"
Global Const $MOUSE_WHEEL_UP = "up"
Global Const $MOUSE_WHEEL_DOWN = "down"
Global Const $NUMBER_AUTO = 0
Global Const $NUMBER_32BIT = 1
Global Const $NUMBER_64BIT = 2
Global Const $NUMBER_DOUBLE = 3
Global Const $OBJ_NAME = 1
Global Const $OBJ_STRING = 2
Global Const $OBJ_PROGID = 3
Global Const $OBJ_FILE = 4
Global Const $OBJ_MODULE = 5
Global Const $OBJ_CLSID = 6
Global Const $OBJ_IID = 7
Global Const $EXITCLOSE_NORMAL = 0
Global Const $EXITCLOSE_BYEXIT = 1
Global Const $EXITCLOSE_BYCLICK = 2
Global Const $EXITCLOSE_BYLOGOFF = 3
Global Const $EXITCLOSE_BYSHUTDOWN = 4
Global Const $PROCESS_STATS_MEMORY = 0
Global Const $PROCESS_STATS_IO = 1
Global Const $PROCESS_LOW = 0
Global Const $PROCESS_BELOWNORMAL = 1
Global Const $PROCESS_NORMAL = 2
Global Const $PROCESS_ABOVENORMAL = 3
Global Const $PROCESS_HIGH = 4
Global Const $PROCESS_REALTIME = 5
Global Const $RUN_LOGON_NOPROFILE = 0
Global Const $RUN_LOGON_PROFILE = 1
Global Const $RUN_LOGON_NETWORK = 2
Global Const $RUN_LOGON_INHERIT = 4
Global Const $SOUND_NOWAIT = 0
Global Const $SOUND_WAIT = 1
Global Const $SHEX_OPEN = "open"
Global Const $SHEX_EDIT = "edit"
Global Const $SHEX_PRINT = "print"
Global Const $SHEX_PROPERTIES = "properties"
Global Const $TCP_DATA_DEFAULT = 0
Global Const $TCP_DATA_BINARY = 1
Global Const $UDP_OPEN_DEFAULT = 0
Global Const $UDP_OPEN_BROADCAST = 1
Global Const $UDP_DATA_DEFAULT = 0
Global Const $UDP_DATA_BINARY = 1
Global Const $UDP_DATA_ARRAY = 2
Global Const $TIP_NOICON = 0
Global Const $TIP_INFOICON = 1
Global Const $TIP_WARNINGICON = 2
Global Const $TIP_ERRORICON = 3
Global Const $TIP_BALLOON = 1
Global Const $TIP_CENTER = 2
Global Const $TIP_FORCEVISIBLE = 4
Global Const $WINDOWS_NOONTOP = 0
Global Const $WINDOWS_ONTOP = 1
Global Const $WIN_STATE_EXISTS = 1
Global Const $WIN_STATE_VISIBLE = 2
Global Const $WIN_STATE_ENABLED = 4
Global Const $WIN_STATE_ACTIVE = 8
Global Const $WIN_STATE_MINIMIZED = 16
Global Const $WIN_STATE_MAXIMIZED = 32
Global Const $_UDF_GLOBALIDS_OFFSET = 2
Global Const $_UDF_GLOBALID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GLOBALID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 65536
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 268435456
Global Const $__UDFGUICONSTANT_WS_CHILD = 1073741824
Global $__G_AUDF_GLOBALIDS_USED [ $_UDF_GLOBALID_MAX_WIN ] [ $_UDF_GLOBALID_MAX_IDS + $_UDF_GLOBALIDS_OFFSET + 1 ]
Func __UDF_GETNEXTGLOBALID ( $HWND )
	Local $NCTRLID , $IUSEDINDEX = + 4294967295 , $BALLUSED = True
	If Not WinExists ( $HWND ) Then Return SetError ( + 4294967295 , + 4294967295 , 0 )
	For $IINDEX = 0 To $_UDF_GLOBALID_MAX_WIN + 4294967295
		If $__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 0 ] <> 0 Then
			If Not WinExists ( $__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 0 ] ) Then
				For $X = 0 To UBound ( $__G_AUDF_GLOBALIDS_USED , $UBOUND_COLUMNS ) + 4294967295
					$__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ $X ] = 0
				Next
				$__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 1 ] = $_UDF_STARTID
				$BALLUSED = False
			EndIf
		EndIf
	Next
	For $IINDEX = 0 To $_UDF_GLOBALID_MAX_WIN + 4294967295
		If $__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 0 ] = $HWND Then
			$IUSEDINDEX = $IINDEX
			ExitLoop
		EndIf
	Next
	If $IUSEDINDEX = + 4294967295 Then
		For $IINDEX = 0 To $_UDF_GLOBALID_MAX_WIN + 4294967295
			If $__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 0 ] = 0 Then
				$__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 0 ] = $HWND
				$__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 1 ] = $_UDF_STARTID
				$BALLUSED = False
				$IUSEDINDEX = $IINDEX
				ExitLoop
			EndIf
		Next
	EndIf
	If $IUSEDINDEX = + 4294967295 And $BALLUSED Then Return SetError ( 16 , 0 , 0 )
	If $__G_AUDF_GLOBALIDS_USED [ $IUSEDINDEX ] [ 1 ] = $_UDF_STARTID + $_UDF_GLOBALID_MAX_IDS Then
		For $IIDINDEX = $_UDF_GLOBALIDS_OFFSET To UBound ( $__G_AUDF_GLOBALIDS_USED , $UBOUND_COLUMNS ) + 4294967295
			If $__G_AUDF_GLOBALIDS_USED [ $IUSEDINDEX ] [ $IIDINDEX ] = 0 Then
				$NCTRLID = ( $IIDINDEX - $_UDF_GLOBALIDS_OFFSET ) + 10000
				$__G_AUDF_GLOBALIDS_USED [ $IUSEDINDEX ] [ $IIDINDEX ] = $NCTRLID
				Return $NCTRLID
			EndIf
		Next
		Return SetError ( + 4294967295 , $_UDF_GLOBALID_MAX_IDS , 0 )
	EndIf
	$NCTRLID = $__G_AUDF_GLOBALIDS_USED [ $IUSEDINDEX ] [ 1 ]
	$__G_AUDF_GLOBALIDS_USED [ $IUSEDINDEX ] [ 1 ] += 1
	$__G_AUDF_GLOBALIDS_USED [ $IUSEDINDEX ] [ ( $NCTRLID + 4294957296 ) + $_UDF_GLOBALIDS_OFFSET ] = $NCTRLID
	Return $NCTRLID
EndFunc
Func __UDF_FREEGLOBALID ( $HWND , $IGLOBALID )
	If $IGLOBALID - $_UDF_STARTID < 0 Or $IGLOBALID - $_UDF_STARTID > $_UDF_GLOBALID_MAX_IDS Then Return SetError ( + 4294967295 , 0 , False )
	For $IINDEX = 0 To $_UDF_GLOBALID_MAX_WIN + 4294967295
		If $__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ 0 ] = $HWND Then
			For $X = $_UDF_GLOBALIDS_OFFSET To UBound ( $__G_AUDF_GLOBALIDS_USED , $UBOUND_COLUMNS ) + 4294967295
				If $__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ $X ] = $IGLOBALID Then
					$__G_AUDF_GLOBALIDS_USED [ $IINDEX ] [ $X ] = 0
					Return True
				EndIf
			Next
			Return SetError ( + 4294967293 , 0 , False )
		EndIf
	Next
	Return SetError ( + 4294967294 , 0 , False )
EndFunc
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_ACCESSED = 2
Global Const $FT_ARRAY = 0
Global Const $FT_STRING = 1
Global Const $FT_MSEC = 2
Global Const $FT_UTC = 4
Global Const $FSF_CREATEBUTTON = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FSF_EDITCONTROL = 4
Global Const $FT_NONRECURSIVE = 0
Global Const $FT_RECURSIVE = 1
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UNICODE = 32
Global Const $FO_UTF16_LE = 32
Global Const $FO_UTF16_BE = 64
Global Const $FO_UTF8 = 128
Global Const $FO_UTF8_NOBOM = 256
Global Const $FO_ANSI = 512
Global Const $FO_UTF16_LE_NOBOM = 1024
Global Const $FO_UTF16_BE_NOBOM = 2048
Global Const $FO_UTF8_FULL = 16384
Global Const $FO_FULLFILE_DETECT = 16384
Global Const $EOF = + 4294967295
Global Const $FD_FILEMUSTEXIST = 1
Global Const $FD_PATHMUSTEXIST = 2
Global Const $FD_MULTISELECT = 4
Global Const $FD_PROMPTCREATENEW = 8
Global Const $FD_PROMPTOVERWRITE = 16
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $INVALID_SET_FILE_POINTER = + 4294967295
Global Const $FILE_BEGIN = 0
Global Const $FILE_CURRENT = 1
Global Const $FILE_END = 2
Global Const $FILE_ATTRIBUTE_READONLY = 1
Global Const $FILE_ATTRIBUTE_HIDDEN = 2
Global Const $FILE_ATTRIBUTE_SYSTEM = 4
Global Const $FILE_ATTRIBUTE_DIRECTORY = 16
Global Const $FILE_ATTRIBUTE_ARCHIVE = 32
Global Const $FILE_ATTRIBUTE_DEVICE = 64
Global Const $FILE_ATTRIBUTE_NORMAL = 128
Global Const $FILE_ATTRIBUTE_TEMPORARY = 256
Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 512
Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 1024
Global Const $FILE_ATTRIBUTE_COMPRESSED = 2048
Global Const $FILE_ATTRIBUTE_OFFLINE = 4096
Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192
Global Const $FILE_ATTRIBUTE_ENCRYPTED = 16384
Global Const $FILE_SHARE_READ = 1
Global Const $FILE_SHARE_WRITE = 2
Global Const $FILE_SHARE_DELETE = 4
Global Const $FILE_SHARE_READWRITE = BitOR ( $FILE_SHARE_READ , $FILE_SHARE_WRITE )
Global Const $FILE_SHARE_ANY = BitOR ( $FILE_SHARE_READ , $FILE_SHARE_WRITE , $FILE_SHARE_DELETE )
Global Const $GENERIC_ALL = 268435456
Global Const $GENERIC_EXECUTE = 536870912
Global Const $GENERIC_WRITE = 1073741824
Global Const $GENERIC_READ = 2147483648
Global Const $GENERIC_READWRITE = BitOR ( $GENERIC_READ , $GENERIC_WRITE )
Global Const $FILE_ENCODING_UTF16LE = 32
Global Const $FE_ENTIRE_UTF8 = 1
Global Const $FE_PARTIALFIRST_UTF8 = 2
Global Const $FN_FULLPATH = 0
Global Const $FN_RELATIVEPATH = 1
Global Const $FV_COMMENTS = "Comments"
Global Const $FV_COMPANYNAME = "CompanyName"
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FV_FILEVERSION = "FileVersion"
Global Const $FV_INTERNALNAME = "InternalName"
Global Const $FV_LEGALCOPYRIGHT = "LegalCopyright"
Global Const $FV_LEGALTRADEMARKS = "LegalTrademarks"
Global Const $FV_ORIGINALFILENAME = "OriginalFilename"
Global Const $FV_PRODUCTNAME = "ProductName"
Global Const $FV_PRODUCTVERSION = "ProductVersion"
Global Const $FV_PRIVATEBUILD = "PrivateBuild"
Global Const $FV_SPECIALBUILD = "SpecialBuild"
Global Const $FRTA_NOCOUNT = 0
Global Const $FRTA_COUNT = 1
Global Const $FRTA_INTARRAYS = 2
Global Const $FRTA_ENTIRESPLIT = 4
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_FOLDERS = 2
Global Const $FLTAR_NOHIDDEN = 4
Global Const $FLTAR_NOSYSTEM = 8
Global Const $FLTAR_NOLINK = 16
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_FASTSORT = 2
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $FLTAR_FULLPATH = 2
Global Const $PATH_ORIGINAL = 0
Global Const $PATH_DRIVE = 1
Global Const $PATH_DIRECTORY = 2
Global Const $PATH_FILENAME = 3
Global Const $PATH_EXTENSION = 4
#Region Global Variables and Constants
Global $__G_VENUM , $__G_VEXT = 0
Global $__G_IRGBMODE = 1
Global Const $TAGOSVERSIONINFO = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
Global Const $IMAGE_BITMAP = 0
Global Const $IMAGE_ICON = 1
Global Const $IMAGE_CURSOR = 2
Global Const $IMAGE_ENHMETAFILE = 3
Global Const $LR_DEFAULTCOLOR = 0
Global Const $LR_MONOCHROME = 1
Global Const $LR_COLOR = 2
Global Const $LR_COPYRETURNORG = 4
Global Const $LR_COPYDELETEORG = 8
Global Const $LR_LOADFROMFILE = 16
Global Const $LR_LOADTRANSPARENT = 32
Global Const $LR_DEFAULTSIZE = 64
Global Const $LR_VGACOLOR = 128
Global Const $LR_LOADMAP3DCOLORS = 4096
Global Const $LR_CREATEDIBSECTION = 8192
Global Const $LR_COPYFROMRESOURCE = 16384
Global Const $LR_SHARED = 32768
Global Const $__TAGCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CREATEFILE ( $SFILENAME , $ICREATION , $IACCESS = 4 , $ISHARE = 0 , $IATTRIBUTES = 0 , $TSECURITY = 0 )
	Local $IDA = 0 , $ISM = 0 , $ICD = 0 , $IFA = 0
	If BitAND ( $IACCESS , 1 ) <> 0 Then $IDA = BitOR ( $IDA , $GENERIC_EXECUTE )
	If BitAND ( $IACCESS , 2 ) <> 0 Then $IDA = BitOR ( $IDA , $GENERIC_READ )
	If BitAND ( $IACCESS , 4 ) <> 0 Then $IDA = BitOR ( $IDA , $GENERIC_WRITE )
	If BitAND ( $ISHARE , 1 ) <> 0 Then $ISM = BitOR ( $ISM , $FILE_SHARE_DELETE )
	If BitAND ( $ISHARE , 2 ) <> 0 Then $ISM = BitOR ( $ISM , $FILE_SHARE_READ )
	If BitAND ( $ISHARE , 4 ) <> 0 Then $ISM = BitOR ( $ISM , $FILE_SHARE_WRITE )
	Switch $ICREATION
	Case 0
		$ICD = $CREATE_NEW
	Case 1
		$ICD = $CREATE_ALWAYS
	Case 2
		$ICD = $OPEN_EXISTING
	Case 3
		$ICD = $OPEN_ALWAYS
	Case 4
		$ICD = $TRUNCATE_EXISTING
	EndSwitch
	If BitAND ( $IATTRIBUTES , 1 ) <> 0 Then $IFA = BitOR ( $IFA , $FILE_ATTRIBUTE_ARCHIVE )
	If BitAND ( $IATTRIBUTES , 2 ) <> 0 Then $IFA = BitOR ( $IFA , $FILE_ATTRIBUTE_HIDDEN )
	If BitAND ( $IATTRIBUTES , 4 ) <> 0 Then $IFA = BitOR ( $IFA , $FILE_ATTRIBUTE_READONLY )
	If BitAND ( $IATTRIBUTES , 8 ) <> 0 Then $IFA = BitOR ( $IFA , $FILE_ATTRIBUTE_SYSTEM )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $SFILENAME , "dword" , $IDA , "dword" , $ISM , "struct*" , $TSECURITY , "dword" , $ICD , "dword" , $IFA , "ptr" , 0 )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FREELIBRARY ( $HMODULE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FreeLibrary" , "handle" , $HMODULE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCURSORINFO ( )
	Local $TCURSOR = DllStructCreate ( $__TAGCURSORINFO )
	Local $ICURSOR = DllStructGetSize ( $TCURSOR )
	DllStructSetData ( $TCURSOR , "Size" , $ICURSOR )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetCursorInfo" , "struct*" , $TCURSOR )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ACURSOR [ 5 ]
	$ACURSOR [ 0 ] = True
	$ACURSOR [ 1 ] = DllStructGetData ( $TCURSOR , "Flags" ) <> 0
	$ACURSOR [ 2 ] = DllStructGetData ( $TCURSOR , "hCursor" )
	$ACURSOR [ 3 ] = DllStructGetData ( $TCURSOR , "X" )
	$ACURSOR [ 4 ] = DllStructGetData ( $TCURSOR , "Y" )
	Return $ACURSOR
EndFunc
Func _WINAPI_GETDLGCTRLID ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetDlgCtrlID" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETMODULEHANDLE ( $SMODULENAME )
	If $SMODULENAME = "" Then $SMODULENAME = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GetModuleHandleW" , "wstr" , $SMODULENAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSTRING ( $PSTRING , $BUNICODE = True )
	Local $ILENGTH = _WINAPI_STRLEN ( $PSTRING , $BUNICODE )
	If @error Or Not $ILENGTH Then Return SetError ( @error + 10 , @extended , "" )
	Local $TSTRING = DllStructCreate ( ( $BUNICODE ? "wchar" : "char" ) & "[" & ( $ILENGTH + 1 ) & "]" , $PSTRING )
	If @error Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ILENGTH , DllStructGetData ( $TSTRING , 1 ) )
EndFunc
Func _WINAPI_GETVERSION ( )
	Local $TOSVI = DllStructCreate ( $TAGOSVERSIONINFO )
	DllStructSetData ( $TOSVI , 1 , DllStructGetSize ( $TOSVI ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetVersionExW" , "struct*" , $TOSVI )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return Number ( DllStructGetData ( $TOSVI , 2 ) & "." & DllStructGetData ( $TOSVI , 3 ) , $NUMBER_DOUBLE )
EndFunc
Func _WINAPI_ISWOW64PROCESS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( _WINAPI_GETVERSION ( ) < 6.0 ? 1024 : 4096 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsWow64Process" , "handle" , $HPROCESS [ 0 ] , "bool*" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HPROCESS [ 0 ] ) Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_LOADIMAGE ( $HINSTANCE , $SIMAGE , $ITYPE , $IXDESIRED , $IYDESIRED , $ILOAD )
	Local $ACALL , $SIMAGETYPE = "int"
	If IsString ( $SIMAGE ) Then $SIMAGETYPE = "wstr"
	$ACALL = DllCall ( "user32.dll" , "handle" , "LoadImageW" , "handle" , $HINSTANCE , $SIMAGETYPE , $SIMAGE , "uint" , $ITYPE , "int" , $IXDESIRED , "int" , $IYDESIRED , "uint" , $ILOAD )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADLIBRARY ( $SFILENAME )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "LoadLibraryW" , "wstr" , $SFILENAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISDIRECTORY ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsDirectoryW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_READFILE ( $HFILE , $PBUFFER , $ITOREAD , ByRef $IREAD , $TOVERLAPPED = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "struct*" , $PBUFFER , "dword" , $ITOREAD , "dword*" , 0 , "struct*" , $TOVERLAPPED )
	If @error Then Return SetError ( @error , @extended , False )
	$IREAD = $ACALL [ 4 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRLEN ( $PSTRING , $BUNICODE = True )
	Local $W = ""
	If $BUNICODE Then $W = "W"
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "lstrlen" & $W , "struct*" , $PSTRING )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SWITCHCOLOR ( $ICOLOR )
	If $ICOLOR = + 4294967295 Then Return $ICOLOR
	Return BitOR ( BitAND ( $ICOLOR , 65280 ) , BitShift ( BitAND ( $ICOLOR , 255 ) , + 4294967280 ) , BitShift ( BitAND ( $ICOLOR , 16711680 ) , 16 ) )
EndFunc
Func _WINAPI_WRITEFILE ( $HFILE , $PBUFFER , $ITOWRITE , ByRef $IWRITTEN , $TOVERLAPPED = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "WriteFile" , "handle" , $HFILE , "struct*" , $PBUFFER , "dword" , $ITOWRITE , "dword*" , 0 , "struct*" , $TOVERLAPPED )
	If @error Then Return SetError ( @error , @extended , False )
	$IWRITTEN = $ACALL [ 4 ]
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __CHECKERRORARRAYBOUNDS ( Const ByRef $ADATA , ByRef $ISTART , ByRef $IEND , $NDIM = 1 , $IDIM = $UBOUND_DIMENSIONS )
	If Not IsArray ( $ADATA ) Then Return SetError ( 1 , 0 , 1 )
	If UBound ( $ADATA , $IDIM ) <> $NDIM Then Return SetError ( 2 , 0 , 1 )
	If $ISTART < 0 Then $ISTART = 0
	Local $IUBOUND = UBound ( $ADATA ) + 4294967295
	If $IEND < 1 Or $IEND > $IUBOUND Then $IEND = $IUBOUND
	If $ISTART > $IEND Then Return SetError ( 4 , 0 , 1 )
	Return 0
EndFunc
Func __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE , $BLASTERROR = False , $ICURERR = @error , $ICUREXT = @extended )
	If Not $ICURERR And Not $ACALL [ 0 ] Then $ICURERR = 10
	Local $ALASTERROR = DllCall ( "kernel32.dll" , "dword" , "GetLastError" )
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HFILE )
	If $ICURERR Then DllCall ( "kernel32.dll" , "none" , "SetLastError" , "dword" , $ALASTERROR [ 0 ] )
	If $BLASTERROR Then $ICUREXT = $ALASTERROR [ 0 ]
	Return SetError ( $ICURERR , $ICUREXT , $ICURERR )
EndFunc
Func __DLL ( $SPATH , $BPIN = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetModuleHandleExW" , "dword" , ( $BPIN ? 1 : 2 ) , "wstr" , $SPATH , "ptr*" , 0 )
	If Not $ACALL [ 3 ] Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "LoadLibraryW" , "wstr" , $SPATH )
		If @error Or Not $ACALL [ 0 ] Then Return 0
	EndIf
	Return 1
EndFunc
Func __ENUMWINDOWSPROC ( $HWND , $BVISIBLE )
	Local $ACALL
	If $BVISIBLE Then
		$ACALL = DllCall ( "user32.dll" , "bool" , "IsWindowVisible" , "hwnd" , $HWND )
		If Not $ACALL [ 0 ] Then
			Return 1
		EndIf
	EndIf
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = $HWND
	$ACALL = DllCall ( "user32.dll" , "int" , "GetClassNameW" , "hwnd" , $HWND , "wstr" , "" , "int" , 4096 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] = $ACALL [ 2 ]
	Return 1
EndFunc
Func __FATALEXIT ( $ICODE , $STEXT = "" )
	If $STEXT Then MsgBox ( $MB_SYSTEMMODAL , "AutoIt" , $STEXT )
	DllCall ( "kernel32.dll" , "none" , "FatalExit" , "int" , $ICODE )
EndFunc
Func __INC ( ByRef $ADATA , $IINCREMENT = 100 )
	Select
	Case UBound ( $ADATA , $UBOUND_COLUMNS )
		If $IINCREMENT < 0 Then
			ReDim $ADATA [ $ADATA [ 0 ] [ 0 ] + 1 ] [ UBound ( $ADATA , $UBOUND_COLUMNS ) ]
		Else
			$ADATA [ 0 ] [ 0 ] += 1
			If $ADATA [ 0 ] [ 0 ] > UBound ( $ADATA ) + 4294967295 Then
				ReDim $ADATA [ $ADATA [ 0 ] [ 0 ] + $IINCREMENT ] [ UBound ( $ADATA , $UBOUND_COLUMNS ) ]
			EndIf
		EndIf
	Case UBound ( $ADATA , $UBOUND_ROWS )
		If $IINCREMENT < 0 Then
			ReDim $ADATA [ $ADATA [ 0 ] + 1 ]
		Else
			$ADATA [ 0 ] += 1
			If $ADATA [ 0 ] > UBound ( $ADATA ) + 4294967295 Then
				ReDim $ADATA [ $ADATA [ 0 ] + $IINCREMENT ]
			EndIf
		EndIf
Case Else
		Return 0
	EndSelect
	Return 1
EndFunc
Func __RGB ( $ICOLOR )
	If $__G_IRGBMODE Then
		$ICOLOR = _WINAPI_SWITCHCOLOR ( $ICOLOR )
	EndIf
	Return $ICOLOR
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CHARTOOEM ( $SSTR )
	Local $ACALL , $SRETSTR = "" , $NLEN = StringLen ( $SSTR ) + 1 , $ISTART = 1
	While $ISTART < $NLEN
		$ACALL = DllCall ( "user32.dll" , "bool" , "CharToOemW" , "wstr" , StringMid ( $SSTR , $ISTART , 65536 ) , "wstr" , "" )
		If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
		$ISTART += 65536
		$SRETSTR &= $ACALL [ 2 ]
	WEnd
	Return $SRETSTR
EndFunc
Func _WINAPI_CLIENTTOSCREEN ( $HWND , ByRef $TPOINT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ClientToScreen" , "hwnd" , $HWND , "struct*" , $TPOINT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_DWORDTOFLOAT ( $IVALUE )
	Local $TDWORD = DllStructCreate ( "dword" )
	Local $TFLOAT = DllStructCreate ( "float" , DllStructGetPtr ( $TDWORD ) )
	DllStructSetData ( $TDWORD , 1 , $IVALUE )
	Return DllStructGetData ( $TFLOAT , 1 )
EndFunc
Func _WINAPI_DWORDTOINT ( $IVALUE )
	Local $TDATA = DllStructCreate ( "int" )
	DllStructSetData ( $TDATA , 1 , $IVALUE )
	Return DllStructGetData ( $TDATA , 1 )
EndFunc
Func _WINAPI_FLOATTODWORD ( $IVALUE )
	Local $TFLOAT = DllStructCreate ( "float" )
	Local $TDWORD = DllStructCreate ( "dword" , DllStructGetPtr ( $TFLOAT ) )
	DllStructSetData ( $TFLOAT , 1 , $IVALUE )
	Return DllStructGetData ( $TDWORD , 1 )
EndFunc
Func _WINAPI_FLOATTOINT ( $NFLOAT )
	Local $TFLOAT = DllStructCreate ( "float" )
	Local $TINT = DllStructCreate ( "int" , DllStructGetPtr ( $TFLOAT ) )
	DllStructSetData ( $TFLOAT , 1 , $NFLOAT )
	Return DllStructGetData ( $TINT , 1 )
EndFunc
Func _WINAPI_GETXYFROMPOINT ( ByRef $TPOINT , ByRef $IX , ByRef $IY )
	$IX = DllStructGetData ( $TPOINT , "X" )
	$IY = DllStructGetData ( $TPOINT , "Y" )
EndFunc
Func _WINAPI_GUIDFROMSTRING ( $SGUID )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	If Not _WINAPI_GUIDFROMSTRINGEX ( $SGUID , $TGUID ) Then Return SetError ( @error , @extended , 0 )
	Return $TGUID
EndFunc
Func _WINAPI_GUIDFROMSTRINGEX ( $SGUID , $TGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _WINAPI_HASHDATA ( $PMEMORY , $ISIZE , $ILENGTH = 32 )
	If ( $ILENGTH <= 0 ) Or ( $ILENGTH > 256 ) Then Return SetError ( 11 , 0 , 0 )
	Local $TDATA = DllStructCreate ( "byte[" & $ILENGTH & "]" )
	Local $ACALL = DllCall ( "shlwapi.dll" , "uint" , "HashData" , "struct*" , $PMEMORY , "dword" , $ISIZE , "struct*" , $TDATA , "dword" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return DllStructGetData ( $TDATA , 1 )
EndFunc
Func _WINAPI_HASHSTRING ( $SSTRING , $BCASESENSITIVE = True , $ILENGTH = 32 )
	Local $ILENGTHS = StringLen ( $SSTRING )
	If Not $ILENGTHS Or ( $ILENGTH > 256 ) Then Return SetError ( 12 , 0 , 0 )
	Local $TSTRING = DllStructCreate ( "wchar[" & ( $ILENGTHS + 1 ) & "]" )
	If Not $BCASESENSITIVE Then
		$SSTRING = StringLower ( $SSTRING )
	EndIf
	DllStructSetData ( $TSTRING , 1 , $SSTRING )
	Local $SHASH = _WINAPI_HASHDATA ( $TSTRING , 2 * $ILENGTHS , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SHASH
EndFunc
Func _WINAPI_HIBYTE ( $IVALUE )
	Return BitAND ( BitShift ( $IVALUE , 8 ) , 255 )
EndFunc
Func _WINAPI_HIDWORD ( $IVALUE )
	Local $TINT64 = DllStructCreate ( "int64" )
	Local $TQWORD = DllStructCreate ( "dword;dword" , DllStructGetPtr ( $TINT64 ) )
	DllStructSetData ( $TINT64 , 1 , $IVALUE )
	Return DllStructGetData ( $TQWORD , 2 )
EndFunc
Func _WINAPI_HIWORD ( $ILONG )
	Return BitShift ( $ILONG , 16 )
EndFunc
Func _WINAPI_INTTODWORD ( $IVALUE )
	Local $TDATA = DllStructCreate ( "dword" )
	DllStructSetData ( $TDATA , 1 , $IVALUE )
	Return DllStructGetData ( $TDATA , 1 )
EndFunc
Func _WINAPI_INTTOFLOAT ( $IINT )
	Local $TINT = DllStructCreate ( "int" )
	Local $TFLOAT = DllStructCreate ( "float" , DllStructGetPtr ( $TINT ) )
	DllStructSetData ( $TINT , 1 , $IINT )
	Return DllStructGetData ( $TFLOAT , 1 )
EndFunc
Func _WINAPI_LOBYTE ( $IVALUE )
	Return BitAND ( $IVALUE , 255 )
EndFunc
Func _WINAPI_LODWORD ( $IVALUE )
	Local $TINT64 = DllStructCreate ( "int64" )
	Local $TQWORD = DllStructCreate ( "dword;dword" , DllStructGetPtr ( $TINT64 ) )
	DllStructSetData ( $TINT64 , 1 , $IVALUE )
	Return DllStructGetData ( $TQWORD , 1 )
EndFunc
Func _WINAPI_LOWORD ( $ILONG )
	Return BitAND ( $ILONG , 65535 )
EndFunc
Func _WINAPI_LONGMID ( $IVALUE , $ISTART , $ICOUNT )
	Return BitAND ( BitShift ( $IVALUE , $ISTART ) , BitOR ( BitShift ( BitShift ( 2147483647 , 32 - ( $ICOUNT + 1 ) ) , 1 ) , BitShift ( 1 , - ( $ICOUNT + 4294967295 ) ) ) )
EndFunc
Func _WINAPI_MAKELANGID ( $ILNGIDPRIMARY , $ILNGIDSUB )
	Return BitOR ( BitShift ( $ILNGIDSUB , + 4294967286 ) , $ILNGIDPRIMARY )
EndFunc
Func _WINAPI_MAKELCID ( $ILNGID , $ISORTID )
	Return BitOR ( BitShift ( $ISORTID , + 4294967280 ) , $ILNGID )
EndFunc
Func _WINAPI_MAKELONG ( $ILO , $IHI )
	Return BitOR ( BitShift ( $IHI , + 4294967280 ) , BitAND ( $ILO , 65535 ) )
EndFunc
Func _WINAPI_MAKEQWORD ( $ILODWORD , $IHIDWORD )
	Local $TINT64 = DllStructCreate ( "uint64" )
	Local $TDWORDS = DllStructCreate ( "dword;dword" , DllStructGetPtr ( $TINT64 ) )
	DllStructSetData ( $TDWORDS , 1 , $ILODWORD )
	DllStructSetData ( $TDWORDS , 2 , $IHIDWORD )
	Return DllStructGetData ( $TINT64 , 1 )
EndFunc
Func _WINAPI_MAKEWORD ( $ILO , $IHI )
	Local $TWORD = DllStructCreate ( "ushort" )
	Local $TBYTE = DllStructCreate ( "byte;byte" , DllStructGetPtr ( $TWORD ) )
	DllStructSetData ( $TBYTE , 1 , $IHI )
	DllStructSetData ( $TBYTE , 2 , $ILO )
	Return DllStructGetData ( $TWORD , 1 )
EndFunc
Func _WINAPI_MULTIBYTETOWIDECHAR ( $VTEXT , $ICODEPAGE = 0 , $IFLAGS = 0 , $BRETSTRING = False )
	Local $STEXTTYPE = ""
	If IsString ( $VTEXT ) Then $STEXTTYPE = "str"
	If ( IsDllStruct ( $VTEXT ) Or IsPtr ( $VTEXT ) ) Then $STEXTTYPE = "struct*"
	If $STEXTTYPE = "" Then Return SetError ( 1 , 0 , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "MultiByteToWideChar" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , $STEXTTYPE , $VTEXT , "int" , + 4294967295 , "ptr" , 0 , "int" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $IOUT = $ACALL [ 0 ]
	Local $TOUT = DllStructCreate ( "wchar[" & $IOUT & "]" )
	$ACALL = DllCall ( "kernel32.dll" , "int" , "MultiByteToWideChar" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , $STEXTTYPE , $VTEXT , "int" , + 4294967295 , "struct*" , $TOUT , "int" , $IOUT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	If $BRETSTRING Then Return DllStructGetData ( $TOUT , 1 )
	Return $TOUT
EndFunc
Func _WINAPI_MULTIBYTETOWIDECHAREX ( $STEXT , $PTEXT , $ICODEPAGE = 0 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "MultiByteToWideChar" , "uint" , $ICODEPAGE , "dword" , $IFLAGS , "STR" , $STEXT , "int" , + 4294967295 , "struct*" , $PTEXT , "int" , ( StringLen ( $STEXT ) + 1 ) * 2 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OEMTOCHAR ( $SSTR )
	Local $ACALL , $SRETSTR = "" , $NLEN = StringLen ( $SSTR ) + 1 , $ISTART = 1
	While $ISTART < $NLEN
		$ACALL = DllCall ( "user32.dll" , "bool" , "OemToCharA" , "str" , StringMid ( $SSTR , $ISTART , 65536 ) , "str" , "" )
		If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
		$SRETSTR &= $ACALL [ 2 ]
		$ISTART += 65536
	WEnd
	Return $SRETSTR
EndFunc
Func _WINAPI_POINTFROMRECT ( ByRef $TRECT , $BCENTER = True )
	Local $IX1 = DllStructGetData ( $TRECT , "Left" )
	Local $IY1 = DllStructGetData ( $TRECT , "Top" )
	Local $IX2 = DllStructGetData ( $TRECT , "Right" )
	Local $IY2 = DllStructGetData ( $TRECT , "Bottom" )
	If $BCENTER Then
		$IX1 = $IX1 + ( ( $IX2 - $IX1 ) / 2 )
		$IY1 = $IY1 + ( ( $IY2 - $IY1 ) / 2 )
	EndIf
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	DllStructSetData ( $TPOINT , "X" , $IX1 )
	DllStructSetData ( $TPOINT , "Y" , $IY1 )
	Return $TPOINT
EndFunc
Func _WINAPI_PRIMARYLANGID ( $ILNGID )
	Return BitAND ( $ILNGID , 1023 )
EndFunc
Func _WINAPI_SCREENTOCLIENT ( $HWND , ByRef $TPOINT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ScreenToClient" , "hwnd" , $HWND , "struct*" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHORTTOWORD ( $IVALUE )
	Return BitAND ( $IVALUE , 65535 )
EndFunc
Func _WINAPI_STRFORMATBYTESIZE ( $ISIZE )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "StrFormatByteSizeW" , "int64" , $ISIZE , "wstr" , "" , "uint" , 1024 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_STRFORMATBYTESIZEEX ( $ISIZE )
	Local $ASYMBOL = DllCall ( "kernel32.dll" , "int" , "GetLocaleInfoW" , "dword" , 1024 , "dword" , 15 , "wstr" , "" , "int" , 2048 )
	If @error Then Return SetError ( @error + 10 , @extended , "" )
	Local $SSIZE = _WINAPI_STRFORMATBYTESIZE ( 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	Return StringReplace ( $SSIZE , "0" , StringRegExpReplace ( Number ( $ISIZE ) , "(?<=\d)(?=(\d{3})+\z)" , $ASYMBOL [ 3 ] ) )
EndFunc
Func _WINAPI_STRFORMATKBSIZE ( $ISIZE )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "StrFormatKBSizeW" , "int64" , $ISIZE , "wstr" , "" , "uint" , 1024 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_STRFROMTIMEINTERVAL ( $ITIME , $IDIGITS = 7 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "int" , "StrFromTimeIntervalW" , "wstr" , "" , "uint" , 1024 , "dword" , $ITIME , "int" , $IDIGITS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return StringStripWS ( $ACALL [ 1 ] , $STR_STRIPLEADING + $STR_STRIPTRAILING )
EndFunc
Func _WINAPI_STRINGFROMGUID ( $TGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "int" , "StringFromGUID2" , "struct*" , $TGUID , "wstr" , "" , "int" , 40 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 2 ] )
EndFunc
Func _WINAPI_SUBLANGID ( $ILNGID )
	Return BitShift ( $ILNGID , 10 )
EndFunc
Func _WINAPI_SWAPDWORD ( $IVALUE )
	Local $TSTRUCT1 = DllStructCreate ( "dword;dword" )
	Local $TSTRUCT2 = DllStructCreate ( "byte[4];byte[4]" , DllStructGetPtr ( $TSTRUCT1 ) )
	DllStructSetData ( $TSTRUCT1 , 1 , $IVALUE )
	For $I = 1 To 4
		DllStructSetData ( $TSTRUCT2 , 2 , DllStructGetData ( $TSTRUCT2 , 1 , 5 - $I ) , $I )
	Next
	Return DllStructGetData ( $TSTRUCT1 , 2 )
EndFunc
Func _WINAPI_SWAPQWORD ( $IVALUE )
	Local $TSTRUCT1 = DllStructCreate ( "int64;int64" )
	Local $TSTRUCT2 = DllStructCreate ( "byte[8];byte[8]" , DllStructGetPtr ( $TSTRUCT1 ) )
	DllStructSetData ( $TSTRUCT1 , 1 , $IVALUE )
	For $I = 1 To 8
		DllStructSetData ( $TSTRUCT2 , 2 , DllStructGetData ( $TSTRUCT2 , 1 , 9 - $I ) , $I )
	Next
	Return DllStructGetData ( $TSTRUCT1 , 2 )
EndFunc
Func _WINAPI_SWAPWORD ( $IVALUE )
	Local $TSTRUCT1 = DllStructCreate ( "word;word" )
	Local $TSTRUCT2 = DllStructCreate ( "byte[2];byte[2]" , DllStructGetPtr ( $TSTRUCT1 ) )
	DllStructSetData ( $TSTRUCT1 , 1 , $IVALUE )
	For $I = 1 To 2
		DllStructSetData ( $TSTRUCT2 , 2 , DllStructGetData ( $TSTRUCT2 , 1 , 3 - $I ) , $I )
	Next
	Return DllStructGetData ( $TSTRUCT1 , 2 )
EndFunc
Func _WINAPI_WIDECHARTOMULTIBYTE ( $VUNICODE , $ICODEPAGE = 0 , $BRETNOSTRUCT = True , $BRETBINARY = False )
	Local $SUNICODETYPE = "wstr"
	If Not IsString ( $VUNICODE ) Then $SUNICODETYPE = "struct*"
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "WideCharToMultiByte" , "uint" , $ICODEPAGE , "dword" , 0 , $SUNICODETYPE , $VUNICODE , "int" , + 4294967295 , "ptr" , 0 , "int" , 0 , "ptr" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	Local $TMULTIBYTE = DllStructCreate ( ( ( $BRETBINARY ) ? ( "byte" ) : ( "char" ) ) & "[" & $ACALL [ 0 ] & "]" )
	$ACALL = DllCall ( "kernel32.dll" , "int" , "WideCharToMultiByte" , "uint" , $ICODEPAGE , "dword" , 0 , $SUNICODETYPE , $VUNICODE , "int" , + 4294967295 , "struct*" , $TMULTIBYTE , "int" , $ACALL [ 0 ] , "ptr" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	If $BRETNOSTRUCT Then Return DllStructGetData ( $TMULTIBYTE , 1 )
	Return $TMULTIBYTE
EndFunc
Func _WINAPI_WORDTOSHORT ( $IVALUE )
	If BitAND ( $IVALUE , 32768 ) Then
		Return BitOR ( $IVALUE , 4294934528 )
	EndIf
	Return BitAND ( $IVALUE , 32767 )
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global Const $DUPLICATE_CLOSE_SOURCE = 1
Global Const $DUPLICATE_SAME_ACCESS = 2
Global Const $OBJ_BITMAP = 7
Global Const $OBJ_BRUSH = 2
Global Const $OBJ_COLORSPACE = 14
Global Const $OBJ_DC = 3
Global Const $OBJ_ENHMETADC = 12
Global Const $OBJ_ENHMETAFILE = 13
Global Const $OBJ_EXTPEN = 11
Global Const $OBJ_FONT = 6
Global Const $OBJ_MEMDC = 10
Global Const $OBJ_METADC = 4
Global Const $OBJ_METAFILE = 9
Global Const $OBJ_PAL = 5
Global Const $OBJ_PEN = 1
Global Const $OBJ_REGION = 8
Global Const $NULL_BRUSH = 5
Global Const $NULL_PEN = 8
Global Const $BLACK_BRUSH = 4
Global Const $DKGRAY_BRUSH = 3
Global Const $DC_BRUSH = 18
Global Const $GRAY_BRUSH = 2
Global Const $HOLLOW_BRUSH = $NULL_BRUSH
Global Const $LTGRAY_BRUSH = 1
Global Const $WHITE_BRUSH = 0
Global Const $BLACK_PEN = 7
Global Const $DC_PEN = 19
Global Const $WHITE_PEN = 6
Global Const $ANSI_FIXED_FONT = 11
Global Const $ANSI_VAR_FONT = 12
Global Const $DEVICE_DEFAULT_FONT = 14
Global Const $DEFAULT_GUI_FONT = 17
Global Const $OEM_FIXED_FONT = 10
Global Const $SYSTEM_FONT = 13
Global Const $SYSTEM_FIXED_FONT = 16
Global Const $DEFAULT_PALETTE = 15
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CLOSEHANDLE ( $HOBJECT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HOBJECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DELETEOBJECT ( $HOBJECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "DeleteObject" , "handle" , $HOBJECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DUPLICATEHANDLE ( $HSOURCEPROCESSHANDLE , $HSOURCEHANDLE , $HTARGETPROCESSHANDLE , $IDESIREDACCESS , $IINHERITHANDLE , $IOPTIONS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DuplicateHandle" , "handle" , $HSOURCEPROCESSHANDLE , "handle" , $HSOURCEHANDLE , "handle" , $HTARGETPROCESSHANDLE , "handle*" , 0 , "dword" , $IDESIREDACCESS , "bool" , $IINHERITHANDLE , "dword" , $IOPTIONS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _WINAPI_GETCURRENTOBJECT ( $HDC , $ITYPE )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "GetCurrentObject" , "handle" , $HDC , "uint" , $ITYPE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCURRENTPROCESS ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GetCurrentProcess" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETOBJECT ( $HOBJECT , $ISIZE , $POBJECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetObjectW" , "handle" , $HOBJECT , "int" , $ISIZE , "struct*" , $POBJECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETOBJECTINFOBYHANDLE ( $HOBJECT )
	Local $TAGPUBLIC_OBJECT_BASIC_INFORMATION = "ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]"
	Local $TPOBI = DllStructCreate ( $TAGPUBLIC_OBJECT_BASIC_INFORMATION )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryObject" , "handle" , $HOBJECT , "uint" , 0 , "struct*" , $TPOBI , "ulong" , DllStructGetSize ( $TPOBI ) , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 4 ]
	For $I = 0 To 3
		$ARET [ $I ] = DllStructGetData ( $TPOBI , $I + 1 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETOBJECTNAMEBYHANDLE ( $HOBJECT )
	Local $TAGUNICODE_STRING = "struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct"
	Local $TAGPUBLIC_OBJECT_TYPE_INFORMATION = "struct;" & $TAGUNICODE_STRING & ";ulong Reserved[22];endstruct"
	Local $TPOTI = DllStructCreate ( $TAGPUBLIC_OBJECT_TYPE_INFORMATION & ";byte[32]" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryObject" , "handle" , $HOBJECT , "uint" , 2 , "struct*" , $TPOTI , "ulong" , DllStructGetSize ( $TPOTI ) , "ulong*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Local $PDATA = DllStructGetData ( $TPOTI , 3 )
	If Not $PDATA Then Return SetError ( 11 , 0 , "" )
	Return _WINAPI_GETSTRING ( $PDATA )
EndFunc
Func _WINAPI_GETOBJECTTYPE ( $HOBJECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "GetObjectType" , "handle" , $HOBJECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSTDHANDLE ( $ISTDHANDLE )
	If $ISTDHANDLE < 0 Or $ISTDHANDLE > 2 Then Return SetError ( 2 , 0 , + 4294967295 )
	Local Const $AHANDLE [ 3 ] = [ + 4294967286 , + 4294967285 , + 4294967284 ]
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GetStdHandle" , "dword" , $AHANDLE [ $ISTDHANDLE ] )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSTOCKOBJECT ( $IOBJECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "GetStockObject" , "int" , $IOBJECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SELECTOBJECT ( $HDC , $HGDIOBJ )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDC , "handle" , $HGDIOBJ )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETHANDLEINFORMATION ( $HOBJECT , $IMASK , $IFLAGS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetHandleInformation" , "handle" , $HOBJECT , "dword" , $IMASK , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global $__G_AINPROCESS_WINAPI [ 64 ] [ 2 ] = [ [ 0 , 0 ] ]
Global $__G_AWINLIST_WINAPI [ 64 ] [ 2 ] = [ [ 0 , 0 ] ]
Global Const $GW_HWNDFIRST = 0
Global Const $GW_HWNDLAST = 1
Global Const $GW_HWNDNEXT = 2
Global Const $GW_HWNDPREV = 3
Global Const $GW_OWNER = 4
Global Const $GW_CHILD = 5
Global Const $GW_ENABLEDPOPUP = 6
Global Const $GWL_WNDPROC = 4294967292
Global Const $GWL_HINSTANCE = 4294967290
Global Const $GWL_HWNDPARENT = 4294967288
Global Const $GWL_ID = 4294967284
Global Const $GWL_STYLE = 4294967280
Global Const $GWL_EXSTYLE = 4294967276
Global Const $GWL_USERDATA = 4294967275
Global Const $__WINAPICONSTANT_WM_SETFONT = 48
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CREATEWINDOWEX ( $IEXSTYLE , $SCLASS , $SNAME , $ISTYLE , $IX , $IY , $IWIDTH , $IHEIGHT , $HPARENT , $HMENU = 0 , $HINSTANCE = 0 , $PPARAM = 0 )
	If $HINSTANCE = 0 Then $HINSTANCE = _WINAPI_GETMODULEHANDLE ( "" )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "CreateWindowExW" , "dword" , $IEXSTYLE , "wstr" , $SCLASS , "wstr" , $SNAME , "dword" , $ISTYLE , "int" , $IX , "int" , $IY , "int" , $IWIDTH , "int" , $IHEIGHT , "hwnd" , $HPARENT , "handle" , $HMENU , "handle" , $HINSTANCE , "struct*" , $PPARAM )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCLIENTRECT ( $HWND )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetClientRect" , "hwnd" , $HWND , "struct*" , $TRECT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETDESKTOPWINDOW ( )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetDesktopWindow" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DESTROYWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DestroyWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENABLEWINDOW ( $HWND , $BENABLE = True )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnableWindow" , "hwnd" , $HWND , "bool" , $BENABLE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENUMWINDOWS ( $BVISIBLE = True , $HWND = Default )
	__WINAPI_ENUMWINDOWSINIT ( )
	If $HWND = Default Then $HWND = _WINAPI_GETDESKTOPWINDOW ( )
	__WINAPI_ENUMWINDOWSCHILD ( $HWND , $BVISIBLE )
	Return $__G_AWINLIST_WINAPI
EndFunc
Func _WINAPI_ENUMWINDOWSPOPUP ( )
	__WINAPI_ENUMWINDOWSINIT ( )
	Local $HWND = _WINAPI_GETWINDOW ( _WINAPI_GETDESKTOPWINDOW ( ) , $GW_CHILD )
	Local $SCLASS
	While $HWND <> 0
		If _WINAPI_ISWINDOWVISIBLE ( $HWND ) Then
			$SCLASS = _WINAPI_GETCLASSNAME ( $HWND )
			If $SCLASS = "#32768" Then
				__WINAPI_ENUMWINDOWSADD ( $HWND )
			ElseIf $SCLASS = "ToolbarWindow32" Then
				__WINAPI_ENUMWINDOWSADD ( $HWND )
			ElseIf $SCLASS = "ToolTips_Class32" Then
				__WINAPI_ENUMWINDOWSADD ( $HWND )
			ElseIf $SCLASS = "BaseBar" Then
				__WINAPI_ENUMWINDOWSCHILD ( $HWND )
			EndIf
		EndIf
		$HWND = _WINAPI_GETWINDOW ( $HWND , $GW_HWNDNEXT )
	WEnd
	Return $__G_AWINLIST_WINAPI
EndFunc
Func _WINAPI_ENUMWINDOWSTOP ( )
	__WINAPI_ENUMWINDOWSINIT ( )
	Local $HWND = _WINAPI_GETWINDOW ( _WINAPI_GETDESKTOPWINDOW ( ) , $GW_CHILD )
	While $HWND <> 0
		If _WINAPI_ISWINDOWVISIBLE ( $HWND ) Then __WINAPI_ENUMWINDOWSADD ( $HWND )
		$HWND = _WINAPI_GETWINDOW ( $HWND , $GW_HWNDNEXT )
	WEnd
	Return $__G_AWINLIST_WINAPI
EndFunc
Func _WINAPI_GETCLASSNAME ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetClassNameW" , "hwnd" , $HWND , "wstr" , "" , "int" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 2 ] )
EndFunc
Func _WINAPI_GETFOCUS ( )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetFocus" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPARENT ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetParent" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSYSCOLOR ( $IINDEX )
	Local $ACALL = DllCall ( "user32.dll" , "INT" , "GetSysColor" , "int" , $IINDEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSYSTEMMETRICS ( $IINDEX )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetSystemMetrics" , "int" , $IINDEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOW ( $HWND , $ICMD )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetWindow" , "hwnd" , $HWND , "uint" , $ICMD )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOWHEIGHT ( $HWND )
	Local $TRECT = _WINAPI_GETWINDOWRECT ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TRECT , "Bottom" ) - DllStructGetData ( $TRECT , "Top" )
EndFunc
Func _WINAPI_GETWINDOWLONG ( $HWND , $IINDEX )
	Local $SFUNCNAME = "GetWindowLongW"
	If @AutoItX64 Then $SFUNCNAME = "GetWindowLongPtrW"
	Local $ACALL = DllCall ( "user32.dll" , "long_ptr" , $SFUNCNAME , "hwnd" , $HWND , "int" , $IINDEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOWRECT ( $HWND )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetWindowRect" , "hwnd" , $HWND , "struct*" , $TRECT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETWINDOWTEXT ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetWindowTextW" , "hwnd" , $HWND , "wstr" , "" , "int" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 2 ] )
EndFunc
Func _WINAPI_GETWINDOWTHREADPROCESSID ( $HWND , ByRef $IPID )
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "GetWindowThreadProcessId" , "hwnd" , $HWND , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	$IPID = $ACALL [ 2 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOWWIDTH ( $HWND )
	Local $TRECT = _WINAPI_GETWINDOWRECT ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TRECT , "Right" ) - DllStructGetData ( $TRECT , "Left" )
EndFunc
Func _WINAPI_INPROCESS ( $HWND , ByRef $HLASTWND )
	If $HWND = $HLASTWND Then Return True
	For $II = $__G_AINPROCESS_WINAPI [ 0 ] [ 0 ] To 1 Step + 4294967295
		If $HWND = $__G_AINPROCESS_WINAPI [ $II ] [ 0 ] Then
			If $__G_AINPROCESS_WINAPI [ $II ] [ 1 ] Then
				$HLASTWND = $HWND
				Return True
			Else
				Return False
			EndIf
		EndIf
	Next
	Local $IPID
	_WINAPI_GETWINDOWTHREADPROCESSID ( $HWND , $IPID )
	Local $ICOUNT = $__G_AINPROCESS_WINAPI [ 0 ] [ 0 ] + 1
	If $ICOUNT >= 64 Then $ICOUNT = 1
	$__G_AINPROCESS_WINAPI [ 0 ] [ 0 ] = $ICOUNT
	$__G_AINPROCESS_WINAPI [ $ICOUNT ] [ 0 ] = $HWND
	$__G_AINPROCESS_WINAPI [ $ICOUNT ] [ 1 ] = ( $IPID = @AutoItPID )
	Return $__G_AINPROCESS_WINAPI [ $ICOUNT ] [ 1 ]
EndFunc
Func _WINAPI_INVALIDATERECT ( $HWND , $TRECT = 0 , $BERASE = True )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "InvalidateRect" , "hwnd" , $HWND , "struct*" , $TRECT , "bool" , $BERASE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISCLASSNAME ( $HWND , $SCLASSNAME )
	Local $SSEPARATOR = Opt ( "GUIDataSeparatorChar" )
	Local $ACLASSNAME = StringSplit ( $SCLASSNAME , $SSEPARATOR )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $SCLASSCHECK = _WINAPI_GETCLASSNAME ( $HWND )
	For $X = 1 To UBound ( $ACLASSNAME ) + 4294967295
		If StringUpper ( StringMid ( $SCLASSCHECK , 1 , StringLen ( $ACLASSNAME [ $X ] ) ) ) = StringUpper ( $ACLASSNAME [ $X ] ) Then Return True
	Next
	Return False
EndFunc
Func _WINAPI_ISWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISWINDOWVISIBLE ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsWindowVisible" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MOVEWINDOW ( $HWND , $IX , $IY , $IWIDTH , $IHEIGHT , $BREPAINT = True )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "MoveWindow" , "hwnd" , $HWND , "int" , $IX , "int" , $IY , "int" , $IWIDTH , "int" , $IHEIGHT , "bool" , $BREPAINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFOCUS ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "SetFocus" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFONT ( $HWND , $HFONT , $BREDRAW = True )
	_SENDMESSAGE ( $HWND , $__WINAPICONSTANT_WM_SETFONT , $HFONT , $BREDRAW , 0 , "hwnd" )
EndFunc
Func _WINAPI_SETPARENT ( $HWNDCHILD , $HWNDPARENT )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "SetParent" , "hwnd" , $HWNDCHILD , "hwnd" , $HWNDPARENT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWPOS ( $HWND , $HAFTER , $IX , $IY , $ICX , $ICY , $IFLAGS )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetWindowPos" , "hwnd" , $HWND , "hwnd" , $HAFTER , "int" , $IX , "int" , $IY , "int" , $ICX , "int" , $ICY , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWTEXT ( $HWND , $STEXT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetWindowTextW" , "hwnd" , $HWND , "wstr" , $STEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHOWWINDOW ( $HWND , $ICMDSHOW = 5 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ShowWindow" , "hwnd" , $HWND , "int" , $ICMDSHOW )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UPDATEWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UpdateWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __WINAPI_ENUMWINDOWSADD ( $HWND , $SCLASS = "" )
	If $SCLASS = "" Then $SCLASS = _WINAPI_GETCLASSNAME ( $HWND )
	$__G_AWINLIST_WINAPI [ 0 ] [ 0 ] += 1
	Local $ICOUNT = $__G_AWINLIST_WINAPI [ 0 ] [ 0 ]
	If $ICOUNT >= $__G_AWINLIST_WINAPI [ 0 ] [ 1 ] Then
		ReDim $__G_AWINLIST_WINAPI [ $ICOUNT + 64 ] [ 2 ]
		$__G_AWINLIST_WINAPI [ 0 ] [ 1 ] += 64
	EndIf
	$__G_AWINLIST_WINAPI [ $ICOUNT ] [ 0 ] = $HWND
	$__G_AWINLIST_WINAPI [ $ICOUNT ] [ 1 ] = $SCLASS
EndFunc
Func __WINAPI_ENUMWINDOWSCHILD ( $HWND , $BVISIBLE = True )
	$HWND = _WINAPI_GETWINDOW ( $HWND , $GW_CHILD )
	While $HWND <> 0
		If ( Not $BVISIBLE ) Or _WINAPI_ISWINDOWVISIBLE ( $HWND ) Then
			__WINAPI_ENUMWINDOWSADD ( $HWND )
			__WINAPI_ENUMWINDOWSCHILD ( $HWND , $BVISIBLE )
		EndIf
		$HWND = _WINAPI_GETWINDOW ( $HWND , $GW_HWNDNEXT )
	WEnd
EndFunc
Func __WINAPI_ENUMWINDOWSINIT ( )
	ReDim $__G_AWINLIST_WINAPI [ 64 ] [ 2 ]
	$__G_AWINLIST_WINAPI [ 0 ] [ 0 ] = 0
	$__G_AWINLIST_WINAPI [ 0 ] [ 1 ] = 64
EndFunc
#EndRegion Internal Functions
Global $__G_HCBLASTWND
Global Const $__COMBOBOXCONSTANT_CLASSNAME = "ComboBox"
Global Const $__COMBOBOXCONSTANT_EM_GETLINE = 196
Global Const $__COMBOBOXCONSTANT_EM_LINEINDEX = 187
Global Const $__COMBOBOXCONSTANT_EM_LINELENGTH = 193
Global Const $__COMBOBOXCONSTANT_EM_REPLACESEL = 194
Global Const $__COMBOBOXCONSTANT_WM_SETREDRAW = 11
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $TAGCOMBOBOXINFO = "dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" & "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList"
Func _GUICTRLCOMBOBOX_ADDDIR ( $HWND , $SFILEPATH , $IATTRIBUTES = 0 , $BBRACKETS = True )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	If BitAND ( $IATTRIBUTES , $DDL_DRIVES ) = $DDL_DRIVES And Not $BBRACKETS Then
		Local $STEXT
		Local $HGUI_NO_BRACKETS = GUICreate ( "no brackets" )
		Local $IDCOMBO_NO_BRACKETS = GUICtrlCreateCombo ( "" , 240 , 40 , 120 , 120 )
		Local $IRET = GUICtrlSendMsg ( $IDCOMBO_NO_BRACKETS , $CB_DIR , $IATTRIBUTES , $SFILEPATH )
		For $I = 0 To _GUICTRLCOMBOBOX_GETCOUNT ( $IDCOMBO_NO_BRACKETS ) + 4294967295
			_GUICTRLCOMBOBOX_GETLBTEXT ( $IDCOMBO_NO_BRACKETS , $I , $STEXT )
			$STEXT = StringReplace ( StringReplace ( StringReplace ( $STEXT , "[" , "" ) , "]" , ":" ) , "-" , "" )
			_GUICTRLCOMBOBOX_INSERTSTRING ( $HWND , $STEXT )
		Next
		GUIDelete ( $HGUI_NO_BRACKETS )
		Return $IRET
	Else
		Return _SENDMESSAGE ( $HWND , $CB_DIR , $IATTRIBUTES , $SFILEPATH , 0 , "wparam" , "wstr" )
	EndIf
EndFunc
Func _GUICTRLCOMBOBOX_ADDSTRING ( $HWND , $STEXT )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_ADDSTRING , 0 , $STEXT , 0 , "wparam" , "wstr" )
EndFunc
Func _GUICTRLCOMBOBOX_AUTOCOMPLETE ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	If Not __GUICTRLCOMBOBOX_ISPRESSED ( "08" ) And Not __GUICTRLCOMBOBOX_ISPRESSED ( "2E" ) Then
		Local $SEDITTEXT = _GUICTRLCOMBOBOX_GETEDITTEXT ( $HWND )
		If StringLen ( $SEDITTEXT ) Then
			Local $SINPUTTEXT
			Local $IRET = _GUICTRLCOMBOBOX_FINDSTRING ( $HWND , $SEDITTEXT )
			If ( $IRET <> $CB_ERR ) Then
				_GUICTRLCOMBOBOX_GETLBTEXT ( $HWND , $IRET , $SINPUTTEXT )
				_GUICTRLCOMBOBOX_SETEDITTEXT ( $HWND , $SINPUTTEXT )
				_GUICTRLCOMBOBOX_SETEDITSEL ( $HWND , StringLen ( $SEDITTEXT ) , StringLen ( $SINPUTTEXT ) )
			EndIf
		EndIf
	EndIf
EndFunc
Func _GUICTRLCOMBOBOX_BEGINUPDATE ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $__COMBOBOXCONSTANT_WM_SETREDRAW , False ) = 0
EndFunc
Func _GUICTRLCOMBOBOX_CREATE ( $HWND , $STEXT , $IX , $IY , $IWIDTH = 100 , $IHEIGHT = 120 , $ISTYLE = 2097218 , $IEXSTYLE = 0 )
	If Not IsHWnd ( $HWND ) Then Return SetError ( 1 , 0 , 0 )
	If Not IsString ( $STEXT ) Then Return SetError ( 2 , 0 , 0 )
	Local $ATEXT , $SDELIMITER = Opt ( "GUIDataSeparatorChar" )
	If $IWIDTH = + 4294967295 Then $IWIDTH = 100
	If $IHEIGHT = + 4294967295 Then $IHEIGHT = 120
	Local Const $WS_VSCROLL = 2097152
	If $ISTYLE = + 4294967295 Then $ISTYLE = BitOR ( $WS_VSCROLL , $CBS_AUTOHSCROLL , $CBS_DROPDOWN )
	If $IEXSTYLE = + 4294967295 Then $IEXSTYLE = 0
	$ISTYLE = BitOR ( $ISTYLE , $__UDFGUICONSTANT_WS_CHILD , $__UDFGUICONSTANT_WS_TABSTOP , $__UDFGUICONSTANT_WS_VISIBLE )
	Local $NCTRLID = __UDF_GETNEXTGLOBALID ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $HCOMBO = _WINAPI_CREATEWINDOWEX ( $IEXSTYLE , $__COMBOBOXCONSTANT_CLASSNAME , "" , $ISTYLE , $IX , $IY , $IWIDTH , $IHEIGHT , $HWND , $NCTRLID )
	_WINAPI_SETFONT ( $HCOMBO , _WINAPI_GETSTOCKOBJECT ( $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT ) )
	If StringLen ( $STEXT ) Then
		$ATEXT = StringSplit ( $STEXT , $SDELIMITER )
		For $X = 1 To $ATEXT [ 0 ]
			_GUICTRLCOMBOBOX_ADDSTRING ( $HCOMBO , $ATEXT [ $X ] )
		Next
	EndIf
	Return $HCOMBO
EndFunc
Func _GUICTRLCOMBOBOX_DELETESTRING ( $HWND , $IINDEX )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_DELETESTRING , $IINDEX )
EndFunc
Func _GUICTRLCOMBOBOX_DESTROY ( ByRef $HWND )
	If Not _WINAPI_ISCLASSNAME ( $HWND , $__COMBOBOXCONSTANT_CLASSNAME ) Then Return SetError ( 2 , 2 , False )
	Local $IDESTROYED = 0
	If IsHWnd ( $HWND ) Then
		If _WINAPI_INPROCESS ( $HWND , $__G_HCBLASTWND ) Then
			Local $NCTRLID = _WINAPI_GETDLGCTRLID ( $HWND )
			Local $HPARENT = _WINAPI_GETPARENT ( $HWND )
			$IDESTROYED = _WINAPI_DESTROYWINDOW ( $HWND )
			Local $IRET = __UDF_FREEGLOBALID ( $HPARENT , $NCTRLID )
			If Not $IRET Then
			EndIf
		Else
			Return SetError ( 1 , 1 , False )
		EndIf
	Else
		$IDESTROYED = GUICtrlDelete ( $HWND )
	EndIf
	If $IDESTROYED Then $HWND = 0
	Return $IDESTROYED <> 0
EndFunc
Func _GUICTRLCOMBOBOX_ENDUPDATE ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $__COMBOBOXCONSTANT_WM_SETREDRAW , True ) = 0
EndFunc
Func _GUICTRLCOMBOBOX_FINDSTRING ( $HWND , $STEXT , $IINDEX = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_FINDSTRING , $IINDEX , $STEXT , 0 , "int" , "wstr" )
EndFunc
Func _GUICTRLCOMBOBOX_FINDSTRINGEXACT ( $HWND , $STEXT , $IINDEX = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_FINDSTRINGEXACT , $IINDEX , $STEXT , 0 , "wparam" , "wstr" )
EndFunc
Func _GUICTRLCOMBOBOX_GETCOMBOBOXINFO ( $HWND , ByRef $TINFO )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	$TINFO = DllStructCreate ( $TAGCOMBOBOXINFO )
	Local $IINFO = DllStructGetSize ( $TINFO )
	DllStructSetData ( $TINFO , "Size" , $IINFO )
	Return _SENDMESSAGE ( $HWND , $CB_GETCOMBOBOXINFO , 0 , $TINFO , 0 , "wparam" , "struct*" ) <> 0
EndFunc
Func _GUICTRLCOMBOBOX_GETCOUNT ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETCOUNT )
EndFunc
Func _GUICTRLCOMBOBOX_GETCUEBANNER ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TTEXT = DllStructCreate ( "wchar[4096]" )
	If _SENDMESSAGE ( $HWND , $CB_GETCUEBANNER , $TTEXT , 4096 , 0 , "struct*" ) <> 1 Then Return SetError ( + 4294967295 , 0 , "" )
	Return DllStructGetData ( $TTEXT , 1 )
EndFunc
Func _GUICTRLCOMBOBOX_GETCURSEL ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETCURSEL )
EndFunc
Func _GUICTRLCOMBOBOX_GETDROPPEDCONTROLRECT ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $ARECT [ 4 ]
	Local $TRECT = _GUICTRLCOMBOBOX_GETDROPPEDCONTROLRECTEX ( $HWND )
	$ARECT [ 0 ] = DllStructGetData ( $TRECT , "Left" )
	$ARECT [ 1 ] = DllStructGetData ( $TRECT , "Top" )
	$ARECT [ 2 ] = DllStructGetData ( $TRECT , "Right" )
	$ARECT [ 3 ] = DllStructGetData ( $TRECT , "Bottom" )
	Return $ARECT
EndFunc
Func _GUICTRLCOMBOBOX_GETDROPPEDCONTROLRECTEX ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	_SENDMESSAGE ( $HWND , $CB_GETDROPPEDCONTROLRECT , 0 , $TRECT , 0 , "wparam" , "struct*" )
	Return $TRECT
EndFunc
Func _GUICTRLCOMBOBOX_GETDROPPEDSTATE ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETDROPPEDSTATE ) <> 0
EndFunc
Func _GUICTRLCOMBOBOX_GETDROPPEDWIDTH ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETDROPPEDWIDTH )
EndFunc
Func _GUICTRLCOMBOBOX_GETEDITSEL ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TSTART = DllStructCreate ( "dword Start" )
	Local $TEND = DllStructCreate ( "dword End" )
	Local $IRET = _SENDMESSAGE ( $HWND , $CB_GETEDITSEL , $TSTART , $TEND , 0 , "struct*" , "struct*" )
	If $IRET = 0 Then Return SetError ( $CB_ERR , $CB_ERR , $CB_ERR )
	Local $ASEL [ 2 ]
	$ASEL [ 0 ] = DllStructGetData ( $TSTART , "Start" )
	$ASEL [ 1 ] = DllStructGetData ( $TEND , "End" )
	Return $ASEL
EndFunc
Func _GUICTRLCOMBOBOX_GETEDITTEXT ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TINFO
	If _GUICTRLCOMBOBOX_GETCOMBOBOXINFO ( $HWND , $TINFO ) Then
		Local $HEDIT = DllStructGetData ( $TINFO , "hEdit" )
		Local $ILINE = 0
		Local $IINDEX = _SENDMESSAGE ( $HEDIT , $__COMBOBOXCONSTANT_EM_LINEINDEX , $ILINE )
		Local $ILENGTH = _SENDMESSAGE ( $HEDIT , $__COMBOBOXCONSTANT_EM_LINELENGTH , $IINDEX )
		If $ILENGTH = 0 Then Return ""
		Local $TBUFFER = DllStructCreate ( "short Len;wchar Text[" & $ILENGTH & "]" )
		DllStructSetData ( $TBUFFER , "Len" , $ILENGTH )
		Local $IRET = _SENDMESSAGE ( $HEDIT , $__COMBOBOXCONSTANT_EM_GETLINE , $ILINE , $TBUFFER , 0 , "wparam" , "struct*" )
		If $IRET = 0 Then Return SetError ( + 4294967295 , + 4294967295 , "" )
		Local $TTEXT = DllStructCreate ( "wchar Text[" & $ILENGTH & "]" , DllStructGetPtr ( $TBUFFER ) )
		Return DllStructGetData ( $TTEXT , "Text" )
	Else
		Return SetError ( + 4294967295 , + 4294967295 , "" )
	EndIf
EndFunc
Func _GUICTRLCOMBOBOX_GETEXTENDEDUI ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETEXTENDEDUI ) <> 0
EndFunc
Func _GUICTRLCOMBOBOX_GETHORIZONTALEXTENT ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETHORIZONTALEXTENT )
EndFunc
Func _GUICTRLCOMBOBOX_GETITEMHEIGHT ( $HWND , $IINDEX = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETITEMHEIGHT , $IINDEX )
EndFunc
Func _GUICTRLCOMBOBOX_GETLBTEXT ( $HWND , $IINDEX , ByRef $STEXT )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $ILEN = _GUICTRLCOMBOBOX_GETLBTEXTLEN ( $HWND , $IINDEX )
	Local $TBUFFER = DllStructCreate ( "wchar Text[" & $ILEN + 1 & "]" )
	Local $IRET = _SENDMESSAGE ( $HWND , $CB_GETLBTEXT , $IINDEX , $TBUFFER , 0 , "wparam" , "struct*" )
	If ( $IRET == $CB_ERR ) Then Return SetError ( $CB_ERR , $CB_ERR , $CB_ERR )
	$STEXT = DllStructGetData ( $TBUFFER , "Text" )
	Return $IRET
EndFunc
Func _GUICTRLCOMBOBOX_GETLBTEXTLEN ( $HWND , $IINDEX )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETLBTEXTLEN , $IINDEX )
EndFunc
Func _GUICTRLCOMBOBOX_GETLIST ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $SDELIMITER = Opt ( "GUIDataSeparatorChar" )
	Local $SRESULT = "" , $SITEM
	For $I = 0 To _GUICTRLCOMBOBOX_GETCOUNT ( $HWND ) + 4294967295
		_GUICTRLCOMBOBOX_GETLBTEXT ( $HWND , $I , $SITEM )
		$SRESULT &= $SITEM & $SDELIMITER
	Next
	Return StringTrimRight ( $SRESULT , StringLen ( $SDELIMITER ) )
EndFunc
Func _GUICTRLCOMBOBOX_GETLISTARRAY ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $SDELIMITER = Opt ( "GUIDataSeparatorChar" )
	Return StringSplit ( _GUICTRLCOMBOBOX_GETLIST ( $HWND ) , $SDELIMITER )
EndFunc
Func _GUICTRLCOMBOBOX_GETLOCALE ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETLOCALE )
EndFunc
Func _GUICTRLCOMBOBOX_GETLOCALECOUNTRY ( $HWND )
	Return _WINAPI_HIWORD ( _GUICTRLCOMBOBOX_GETLOCALE ( $HWND ) )
EndFunc
Func _GUICTRLCOMBOBOX_GETLOCALELANG ( $HWND )
	Return _WINAPI_LOWORD ( _GUICTRLCOMBOBOX_GETLOCALE ( $HWND ) )
EndFunc
Func _GUICTRLCOMBOBOX_GETLOCALEPRIMLANG ( $HWND )
	Return _WINAPI_PRIMARYLANGID ( _GUICTRLCOMBOBOX_GETLOCALELANG ( $HWND ) )
EndFunc
Func _GUICTRLCOMBOBOX_GETLOCALESUBLANG ( $HWND )
	Return _WINAPI_SUBLANGID ( _GUICTRLCOMBOBOX_GETLOCALELANG ( $HWND ) )
EndFunc
Func _GUICTRLCOMBOBOX_GETMINVISIBLE ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETMINVISIBLE )
EndFunc
Func _GUICTRLCOMBOBOX_GETTOPINDEX ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_GETTOPINDEX )
EndFunc
Func _GUICTRLCOMBOBOX_INITSTORAGE ( $HWND , $INUM , $IBYTES )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_INITSTORAGE , $INUM , $IBYTES )
EndFunc
Func _GUICTRLCOMBOBOX_INSERTSTRING ( $HWND , $STEXT , $IINDEX = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_INSERTSTRING , $IINDEX , $STEXT , 0 , "wparam" , "wstr" )
EndFunc
Func _GUICTRLCOMBOBOX_LIMITTEXT ( $HWND , $ILIMIT = 0 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	_SENDMESSAGE ( $HWND , $CB_LIMITTEXT , $ILIMIT )
EndFunc
Func _GUICTRLCOMBOBOX_REPLACEEDITSEL ( $HWND , $STEXT )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TINFO
	If _GUICTRLCOMBOBOX_GETCOMBOBOXINFO ( $HWND , $TINFO ) Then
		Local $HEDIT = DllStructGetData ( $TINFO , "hEdit" )
		_SENDMESSAGE ( $HEDIT , $__COMBOBOXCONSTANT_EM_REPLACESEL , True , $STEXT , 0 , "wparam" , "wstr" )
	EndIf
EndFunc
Func _GUICTRLCOMBOBOX_RESETCONTENT ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	_SENDMESSAGE ( $HWND , $CB_RESETCONTENT )
EndFunc
Func _GUICTRLCOMBOBOX_SELECTSTRING ( $HWND , $STEXT , $IINDEX = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SELECTSTRING , $IINDEX , $STEXT , 0 , "wparam" , "wstr" )
EndFunc
Func _GUICTRLCOMBOBOX_SETCUEBANNER ( $HWND , $STEXT )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TTEXT = _WINAPI_MULTIBYTETOWIDECHAR ( $STEXT )
	Return _SENDMESSAGE ( $HWND , $CB_SETCUEBANNER , 0 , $TTEXT , 0 , "wparam" , "struct*" ) = 1
EndFunc
Func _GUICTRLCOMBOBOX_SETCURSEL ( $HWND , $IINDEX = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETCURSEL , $IINDEX )
EndFunc
Func _GUICTRLCOMBOBOX_SETDROPPEDWIDTH ( $HWND , $IWIDTH )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETDROPPEDWIDTH , $IWIDTH )
EndFunc
Func _GUICTRLCOMBOBOX_SETEDITSEL ( $HWND , $ISTART , $ISTOP )
	If Not HWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETEDITSEL , 0 , _WINAPI_MAKELONG ( $ISTART , $ISTOP ) ) <> + 4294967295
EndFunc
Func _GUICTRLCOMBOBOX_SETEDITTEXT ( $HWND , $STEXT )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	_GUICTRLCOMBOBOX_SETEDITSEL ( $HWND , 0 , + 4294967295 )
	_GUICTRLCOMBOBOX_REPLACEEDITSEL ( $HWND , $STEXT )
EndFunc
Func _GUICTRLCOMBOBOX_SETEXTENDEDUI ( $HWND , $BEXTENDED = False )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETEXTENDEDUI , $BEXTENDED ) = 0
EndFunc
Func _GUICTRLCOMBOBOX_SETHORIZONTALEXTENT ( $HWND , $IWIDTH )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	_SENDMESSAGE ( $HWND , $CB_SETHORIZONTALEXTENT , $IWIDTH )
EndFunc
Func _GUICTRLCOMBOBOX_SETITEMHEIGHT ( $HWND , $IHEIGHT , $ICOMPONENT = + 4294967295 )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETITEMHEIGHT , $ICOMPONENT , $IHEIGHT )
EndFunc
Func _GUICTRLCOMBOBOX_SETLOCALE ( $HWND , $ILOCAL )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETLOCALE , $ILOCAL )
EndFunc
Func _GUICTRLCOMBOBOX_SETMINVISIBLE ( $HWND , $IMINIMUM )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETMINVISIBLE , $IMINIMUM ) <> 0
EndFunc
Func _GUICTRLCOMBOBOX_SETTOPINDEX ( $HWND , $IINDEX )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _SENDMESSAGE ( $HWND , $CB_SETTOPINDEX , $IINDEX ) = 0
EndFunc
Func _GUICTRLCOMBOBOX_SHOWDROPDOWN ( $HWND , $BSHOW = False )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	_SENDMESSAGE ( $HWND , $CB_SHOWDROPDOWN , $BSHOW )
EndFunc
Func __GUICTRLCOMBOBOX_ISPRESSED ( $SHEXKEY , $VDLL = "user32.dll" )
	Local $A_R = DllCall ( $VDLL , "short" , "GetAsyncKeyState" , "int" , "0x" & $SHEXKEY )
	If @error Then Return SetError ( @error , @extended , False )
	Return BitAND ( $A_R [ 0 ] , 32768 ) <> 0
EndFunc
#AutoIt3Wrapper_Au3Check_Parameters=-q -d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6 -w 7
Global $__G_OHTTP_ERRORHANDLER = ObjEvent ( "AutoIt.Error" , __HTTP_ONERROR )
Func __HTTP_ONERROR ( ByRef $OMYERROR )
	Local $HEXNUMBER = Hex ( $OMYERROR .number , 8 )
	ConsoleWrite ( "We intercepted a COM Error !" & @LF & "Number is: " & $HEXNUMBER & @LF & "Windescription is: " & $OMYERROR .windescription )
	Return SetError ( 5 , $HEXNUMBER , 0 )
EndFunc
Func _HTTP_GET ( $URL )
	Local $OHTTP = ObjCreate ( "winhttp.winhttprequest.5.1" )
	Local $RES = $OHTTP .Open ( "GET" , $URL , False )
	If @error Then Return SetError ( 1 , 0 , 0 )
	#forceref $res
	$OHTTP .Send ( )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local $SRECEIVED = $OHTTP .ResponseText
	Local $ISTATUS = $OHTTP .Status
	If $ISTATUS = 200 Then Return $SRECEIVED
	Return SetError ( 3 , $ISTATUS , $SRECEIVED )
EndFunc
Func _HTTP_POST ( $URL , $POSTDATA = "" )
	Local $OHTTP = ObjCreate ( "winhttp.winhttprequest.5.1" )
	$OHTTP .Open ( "POST" , $URL , False )
	If @error Then Return SetError ( 1 , 0 , 0 )
	$OHTTP .SetRequestHeader ( "Content-Type" , "application/x-www-form-urlencoded" )
	$OHTTP .Send ( $POSTDATA )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local $SRECEIVED = $OHTTP .ResponseText
	Local $ISTATUS = $OHTTP .Status
	If $ISTATUS = 200 Then Return $SRECEIVED
	Return SetError ( 3 , $ISTATUS , $SRECEIVED )
EndFunc
Func _HTTP_UPLOAD ( $STRUPLOADURL , $STRFILEPATH , $STRFILEFIELD , $STRDATAPAIRS = "" , $STRFILENAME = Default )
	If $STRFILENAME = Default Then $STRFILENAME = StringMid ( $STRFILEPATH , StringInStr ( $STRFILEPATH , "\" , 0 , + 4294967295 ) + 1 )
	Local $MULTIPART_BOUNDARY = "----WebKitFormBoundary"
	Local $ASPACE [ 3 ]
	For $I = 1 To 16
		$ASPACE [ 0 ] = Chr ( Random ( 65 , 90 , 1 ) )
		$ASPACE [ 1 ] = Chr ( Random ( 97 , 122 , 1 ) )
		$ASPACE [ 2 ] = Chr ( Random ( 48 , 57 , 1 ) )
		$MULTIPART_BOUNDARY &= $ASPACE [ Random ( 0 , 2 , 1 ) ]
	Next
	If Not FileExists ( $STRFILEPATH ) Then Return SetError ( 4 , 0 , 0 )
	Local $H = FileOpen ( $STRFILEPATH , $FO_BINARY )
	Local $BYTFILE = FileRead ( $H )
	FileClose ( $H )
	Local $STRFORMEND = @CRLF & "--" & $MULTIPART_BOUNDARY & "--" & @CRLF
	Local $STRFORMSTART
	If $STRDATAPAIRS Then
		Local $SPLIT = StringSplit ( $STRDATAPAIRS , "&" )
		Local $SPLITAGAIN
		For $I = 1 To $SPLIT [ 0 ]
			$SPLITAGAIN = StringSplit ( $SPLIT [ $I ] , "=" )
			$STRFORMSTART &= "--" & $MULTIPART_BOUNDARY & @CRLF & "Content-Disposition: form-data; " & "name=""" & $SPLITAGAIN [ 1 ] & """" & @CRLF & @CRLF & URLDECODE ( $SPLITAGAIN [ 2 ] ) & @CRLF
		Next
	EndIf
	$STRFORMSTART &= "--" & $MULTIPART_BOUNDARY & @CRLF & "Content-Disposition: form-data; " & "name=""" & $STRFILEFIELD & """; " & "filename=""" & $STRFILENAME & """" & @CRLF & "Content-Type: application/upload" & @CRLF & @CRLF
	Local $BYTFORMDATA = StringToBinary ( $STRFORMSTART ) & $BYTFILE & StringToBinary ( $STRFORMEND )
	Local $OHTTP = ObjCreate ( "winhttp.winhttprequest.5.1" )
	$OHTTP .Open ( "POST" , $STRUPLOADURL , False )
	If @error Then Return SetError ( 1 , 0 , 0 )
	$OHTTP .SetRequestHeader ( "Content-Type" , "multipart/form-data; boundary=" & $MULTIPART_BOUNDARY )
	$OHTTP .Send ( $BYTFORMDATA )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local $SRECEIVED = $OHTTP .ResponseText
	Local $ISTATUS = $OHTTP .Status
	If $ISTATUS = 200 Then Return $SRECEIVED
	Return SetError ( 3 , $ISTATUS , $SRECEIVED )
EndFunc
Func URLENCODE ( $URLTEXT )
	Local $URL = "" , $ACODE
	For $I = 1 To StringLen ( $URLTEXT )
		$ACODE = Asc ( StringMid ( $URLTEXT , $I , 1 ) )
		Select
		Case ( $ACODE >= 48 And $ACODE <= 57 ) Or ( $ACODE >= 65 And $ACODE <= 90 ) Or ( $ACODE >= 97 And $ACODE <= 122 )
			$URL &= StringMid ( $URLTEXT , $I , 1 )
		Case $ACODE = 32
			$URL &= "+"
	Case Else
			$URL &= "%" & Hex ( $ACODE , 2 )
		EndSelect
	Next
	Return $URL
EndFunc
Func URLDECODE ( $URLTEXT )
	$URLTEXT = StringReplace ( $URLTEXT , "+" , " " )
	Local $MATCHES = StringRegExp ( $URLTEXT , "\%([abcdefABCDEF0-9]{2})" , 3 )
	If Not @error Then
		For $MATCH In $MATCHES
			$URLTEXT = StringReplace ( $URLTEXT , "%" & $MATCH , BinaryToString ( "0x" & $MATCH ) )
		Next
	EndIf
	Return $URLTEXT
EndFunc
#Region Global Variables and Constants
Global $_G_ARRAYDISPLAY_BUSERFUNC = False
Global $_G_ARRAYDISPLAY_HLISTVIEW
Global $_G_ARRAYDISPLAY_ITRANSPOSE
Global $_G_ARRAYDISPLAY_IDISPLAYROW
Global $_G_ARRAYDISPLAY_AARRAY
Global $_G_ARRAYDISPLAY_IDIMS
Global $_G_ARRAYDISPLAY_NROWS
Global $_G_ARRAYDISPLAY_NCOLS
Global $_G_ARRAYDISPLAY_IITEM_START
Global $_G_ARRAYDISPLAY_IITEM_END
Global $_G_ARRAYDISPLAY_ISUBITEM_START
Global $_G_ARRAYDISPLAY_ISUBITEM_END
Global $_G_ARRAYDISPLAY_AINDEX
Global $_G_ARRAYDISPLAY_AINDEXES [ 1 ]
Global $_G_ARRAYDISPLAY_ISORTDIR
Global $_G_ARRAYDISPLAY_ASHEADER
Global $_G_ARRAYDISPLAY_ANUMERICSORT
Global $ARRAYDISPLAY_ROWPREFIX = "#"
Global $ARRAYDISPLAY_NUMERICSORT = "*"
Global Const $ARRAYDISPLAY_COLALIGNLEFT = 0
Global Const $ARRAYDISPLAY_TRANSPOSE = 1
Global Const $ARRAYDISPLAY_COLALIGNRIGHT = 2
Global Const $ARRAYDISPLAY_COLALIGNCENTER = 4
Global Const $ARRAYDISPLAY_VERBOSE = 8
Global Const $ARRAYDISPLAY_NOROW = 64
Global Const $ARRAYDISPLAY_CHECKERROR = 128
Global Const $_ARRAYCONSTANT_TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __ARRAYDISPLAY_SHARE ( Const ByRef $AARRAY , $STITLE = Default , $SARRAYRANGE = Default , $IFLAGS = Default , $VUSER_SEPARATOR = Default , $SHEADER = Default , $IDESIRED_COLWIDTH = Default , $HUSER_FUNCTION = Default , $BDEBUG = True , Const $_ISCRIPTLINENUMBER = @ScriptLineNumber , Const $_ICALLERERROR = @error , Const $_ICALLEREXTENDED = @extended )
	Local $SMSGBOXTITLE = ( ( $BDEBUG ) ? ( "_DebugArrayDisplay" ) : ( "_ArrayDisplay" ) )
	If $_G_ARRAYDISPLAY_BUSERFUNC Then
		$HUSER_FUNCTION = Default
		$BDEBUG = False
	EndIf
	If Not IsKeyword ( $HUSER_FUNCTION ) = $KEYWORD_DEFAULT Then
		$_G_ARRAYDISPLAY_BUSERFUNC = True
	EndIf
	If $STITLE = Default Then $STITLE = $SMSGBOXTITLE
	If $SARRAYRANGE = Default Then $SARRAYRANGE = ""
	If $IFLAGS = Default Then $IFLAGS = 0
	If $VUSER_SEPARATOR = Default Then $VUSER_SEPARATOR = ""
	If $SHEADER = Default Then $SHEADER = ""
	Local $IMIN_COLWIDTH = 55
	Local $IMAX_COLWIDTH = 350
	If $IDESIRED_COLWIDTH > 0 Then $IMAX_COLWIDTH = $IDESIRED_COLWIDTH
	If $IDESIRED_COLWIDTH < 0 Then $IMIN_COLWIDTH = - $IDESIRED_COLWIDTH
	If $IMAX_COLWIDTH = Default Then $IMAX_COLWIDTH = 350
	If $IMAX_COLWIDTH > 4095 Then $IMAX_COLWIDTH = 4095
	If $HUSER_FUNCTION = Default Then $HUSER_FUNCTION = 0
	$_G_ARRAYDISPLAY_ITRANSPOSE = BitAND ( $IFLAGS , $ARRAYDISPLAY_TRANSPOSE )
	Local $ICOLALIGN = BitAND ( $IFLAGS , 6 )
	Local $IVERBOSE = Int ( BitAND ( $IFLAGS , $ARRAYDISPLAY_VERBOSE ) )
	$_G_ARRAYDISPLAY_IDISPLAYROW = Int ( BitAND ( $IFLAGS , $ARRAYDISPLAY_NOROW ) = 0 )
	Local $IBUTTONBORDER = ( ( $BDEBUG ) ? ( 40 ) : ( 20 ) )
	#Region Check valid array
	Local $SMSG = "" , $IRET = 1
	Local $FTIMER = 0
	If IsArray ( $AARRAY ) Then
		$_G_ARRAYDISPLAY_AARRAY = $AARRAY
		$_G_ARRAYDISPLAY_IDIMS = UBound ( $_G_ARRAYDISPLAY_AARRAY , $UBOUND_DIMENSIONS )
		If $_G_ARRAYDISPLAY_IDIMS = 1 Then $_G_ARRAYDISPLAY_ITRANSPOSE = 0
		$_G_ARRAYDISPLAY_NROWS = UBound ( $_G_ARRAYDISPLAY_AARRAY , $UBOUND_ROWS )
		$_G_ARRAYDISPLAY_NCOLS = ( $_G_ARRAYDISPLAY_IDIMS = 2 ) ? UBound ( $_G_ARRAYDISPLAY_AARRAY , $UBOUND_COLUMNS ) : 1
		Dim $_G_ARRAYDISPLAY_ANUMERICSORT [ $_G_ARRAYDISPLAY_NCOLS ]
		If $_G_ARRAYDISPLAY_IDIMS > 2 Then
			$SMSG = "Larger than 2D array passed to function"
			$IRET = 2
		EndIf
		If $_ICALLERERROR Then
			If $BDEBUG Then
				If IsDeclared ( "__g_sReportCallBack_DebugReport_Debug" ) Then
					$SMSG = "@@ Debug( " & $_ISCRIPTLINENUMBER & ") : @error = " & $_ICALLERERROR & " in " & $SMSGBOXTITLE & "( '" & $STITLE & "' )"
					Execute ( "$__g_sReportCallBack_DebugReport_Debug(""" & $SMSG & """)" )
				EndIf
				$IRET = 3
			ElseIf BitAND ( $IFLAGS , $ARRAYDISPLAY_CHECKERROR ) Then
				$SMSG = "@error = " & $_ICALLERERROR & " when calling the function"
				If $_ISCRIPTLINENUMBER > 0 Then $SMSG &= " at line " & $_ISCRIPTLINENUMBER
				$IRET = 3
			EndIf
		EndIf
	Else
		$SMSG = "No array variable passed to function"
	EndIf
	If $SMSG Then
		If $IVERBOSE And MsgBox ( $MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO , $SMSGBOXTITLE & "() Error: " & $STITLE , $SMSG & @CRLF & @CRLF & "Exit the script?" ) = $IDYES Then
			Exit
		Else
			Return SetError ( $IRET , 0 , 0 )
		EndIf
	EndIf
	#EndRegion Check valid array
	#Region Check array range
	Local $ICW_COLWIDTH = Number ( $VUSER_SEPARATOR )
	Local $SCURR_SEPARATOR = Opt ( "GUIDataSeparatorChar" )
	If $VUSER_SEPARATOR = "" Then $VUSER_SEPARATOR = $SCURR_SEPARATOR
	$_G_ARRAYDISPLAY_IITEM_START = 0
	$_G_ARRAYDISPLAY_IITEM_END = $_G_ARRAYDISPLAY_NROWS + 4294967295
	$_G_ARRAYDISPLAY_ISUBITEM_START = 0
	$_G_ARRAYDISPLAY_ISUBITEM_END = ( ( $_G_ARRAYDISPLAY_IDIMS = 2 ) ? ( $_G_ARRAYDISPLAY_NCOLS + 4294967295 ) : ( 0 ) )
	Local $AVRANGESPLIT
	If $SARRAYRANGE Then
		Local $VTMP , $AARRAY_RANGE = StringRegExp ( $SARRAYRANGE & "||" , "(?U)(.*)\|" , $STR_REGEXPARRAYGLOBALMATCH )
		If $AARRAY_RANGE [ 0 ] Then
			$AVRANGESPLIT = StringSplit ( $AARRAY_RANGE [ 0 ] , ":" )
			If @error Then
				$_G_ARRAYDISPLAY_IITEM_END = Number ( $AARRAY_RANGE [ 0 ] )
			Else
				$_G_ARRAYDISPLAY_IITEM_START = Number ( $AVRANGESPLIT [ 1 ] )
				If $AVRANGESPLIT [ 2 ] <> "" Then
					$_G_ARRAYDISPLAY_IITEM_END = Number ( $AVRANGESPLIT [ 2 ] )
				EndIf
			EndIf
		EndIf
		If $_G_ARRAYDISPLAY_IITEM_START < 0 Then $_G_ARRAYDISPLAY_IITEM_START = 0
		If $_G_ARRAYDISPLAY_IITEM_END >= $_G_ARRAYDISPLAY_NROWS Then $_G_ARRAYDISPLAY_IITEM_END = $_G_ARRAYDISPLAY_NROWS + 4294967295
		If ( $_G_ARRAYDISPLAY_IITEM_START > $_G_ARRAYDISPLAY_IITEM_END ) And ( $_G_ARRAYDISPLAY_IITEM_END > 0 ) Then
			$VTMP = $_G_ARRAYDISPLAY_IITEM_START
			$_G_ARRAYDISPLAY_IITEM_START = $_G_ARRAYDISPLAY_IITEM_END
			$_G_ARRAYDISPLAY_IITEM_END = $VTMP
		EndIf
		If $_G_ARRAYDISPLAY_IDIMS = 2 And $AARRAY_RANGE [ 1 ] Then
			$AVRANGESPLIT = StringSplit ( $AARRAY_RANGE [ 1 ] , ":" )
			If @error Then
				$_G_ARRAYDISPLAY_ISUBITEM_END = Number ( $AARRAY_RANGE [ 1 ] )
			Else
				$_G_ARRAYDISPLAY_ISUBITEM_START = Number ( $AVRANGESPLIT [ 1 ] )
				If $AVRANGESPLIT [ 2 ] <> "" Then
					$_G_ARRAYDISPLAY_ISUBITEM_END = Number ( $AVRANGESPLIT [ 2 ] )
				EndIf
			EndIf
			If $_G_ARRAYDISPLAY_ISUBITEM_START > $_G_ARRAYDISPLAY_ISUBITEM_END Then
				$VTMP = $_G_ARRAYDISPLAY_ISUBITEM_START
				$_G_ARRAYDISPLAY_ISUBITEM_START = $_G_ARRAYDISPLAY_ISUBITEM_END
				$_G_ARRAYDISPLAY_ISUBITEM_END = $VTMP
			EndIf
			If $_G_ARRAYDISPLAY_ISUBITEM_START < 0 Then $_G_ARRAYDISPLAY_ISUBITEM_START = 0
			If $_G_ARRAYDISPLAY_ISUBITEM_END >= $_G_ARRAYDISPLAY_NCOLS Then $_G_ARRAYDISPLAY_ISUBITEM_END = $_G_ARRAYDISPLAY_NCOLS + 4294967295
		EndIf
	EndIf
	Local $SDISPLAYDATA = "[" & $_G_ARRAYDISPLAY_NROWS & "]"
	If $_G_ARRAYDISPLAY_IDIMS = 2 Then
		$SDISPLAYDATA &= " [" & $_G_ARRAYDISPLAY_NCOLS & "]"
	EndIf
	Local $STIPDATA = ""
	If $SARRAYRANGE Then
		If $STIPDATA Then $STIPDATA &= " - "
		$STIPDATA &= "Range set " & $SARRAYRANGE
	EndIf
	If $_G_ARRAYDISPLAY_ITRANSPOSE Then
		If $STIPDATA Then $STIPDATA &= " - "
		$STIPDATA &= "Transposed"
	EndIf
	If $SARRAYRANGE Or $_G_ARRAYDISPLAY_ITRANSPOSE Then $_G_ARRAYDISPLAY_AARRAY = __ARRAYDISPLAY_CREATESUBARRAY ( )
	#EndRegion Check array range
	#Region Check custom header
	$_G_ARRAYDISPLAY_ASHEADER = StringSplit ( $SHEADER , $SCURR_SEPARATOR , $STR_NOCOUNT )
	If UBound ( $_G_ARRAYDISPLAY_ASHEADER ) = 0 Then Dim $_G_ARRAYDISPLAY_ASHEADER [ 1 ] = [ "" ]
	$SHEADER = "Row"
	Local $IINDEX = $_G_ARRAYDISPLAY_ISUBITEM_START
	If $_G_ARRAYDISPLAY_ITRANSPOSE Then
		$SHEADER = "Row"
		For $J = 0 To $_G_ARRAYDISPLAY_NCOLS + 4294967295
			$SHEADER &= $SCURR_SEPARATOR & $ARRAYDISPLAY_ROWPREFIX & " " & $J + $_G_ARRAYDISPLAY_ISUBITEM_START
		Next
	Else
		If $_G_ARRAYDISPLAY_ASHEADER [ 0 ] Then
			For $IINDEX = $_G_ARRAYDISPLAY_ISUBITEM_START To $_G_ARRAYDISPLAY_ISUBITEM_END
				If $IINDEX >= UBound ( $_G_ARRAYDISPLAY_ASHEADER ) Then ExitLoop
				If StringRight ( $_G_ARRAYDISPLAY_ASHEADER [ $IINDEX ] , 1 ) = $ARRAYDISPLAY_NUMERICSORT Then
					$_G_ARRAYDISPLAY_ASHEADER [ $IINDEX ] = StringTrimRight ( $_G_ARRAYDISPLAY_ASHEADER [ $IINDEX ] , 1 )
					$_G_ARRAYDISPLAY_ANUMERICSORT [ $IINDEX - $_G_ARRAYDISPLAY_ISUBITEM_START ] = 1
				EndIf
				$SHEADER &= $SCURR_SEPARATOR & $_G_ARRAYDISPLAY_ASHEADER [ $IINDEX ]
			Next
		EndIf
		For $J = $IINDEX To $_G_ARRAYDISPLAY_ISUBITEM_END
			$SHEADER &= $SCURR_SEPARATOR & "Col " & $J
		Next
	EndIf
	If Not $_G_ARRAYDISPLAY_IDISPLAYROW Then $SHEADER = StringTrimLeft ( $SHEADER , 4 )
	#EndRegion Check custom header
	#Region Generate Sort index for columns
	__ARRAYDISPLAY_SORTINDEXES ( 0 , + 4294967295 )
	Local $HTIMER = TimerInit ( )
	__ARRAYDISPLAY_SORTINDEXES ( 1 , 1 )
	$FTIMER = TimerDiff ( $HTIMER )
	If $FTIMER * $_G_ARRAYDISPLAY_NCOLS < 1000 Then
		__ARRAYDISPLAY_SORTINDEXES ( 2 , $_G_ARRAYDISPLAY_NCOLS )
	Else
	EndIf
	#EndRegion Generate Sort index for columns
	#Region GUI and Listview generation
	If $IVERBOSE And ( $_G_ARRAYDISPLAY_NROWS * $_G_ARRAYDISPLAY_NCOLS ) > 1000 Then
		SplashTextOn ( $SMSGBOXTITLE , "Preparing display" & @CRLF & @CRLF & "Please be patient" , 300 , 100 )
	EndIf
	Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
	Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
	Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
	Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
	Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
	Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
	Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = + 4294967293
	Local Const $_ARRAYCONSTANT_GUI_EVENT_ARRAY = 1
	Local Const $_ARRAYCONSTANT_GUI_FOCUS = 256
	Local Const $_ARRAYCONSTANT_SS_CENTER = 1
	Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 512
	Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT = ( 4096 + 14 )
	Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE = ( 4096 + 44 )
	Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = ( 4096 + 50 )
	Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = ( 4096 + 54 )
	Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 1
	Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 2
	Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 8
	Local Const $_ARRAYCONSTANT_LVS_OWNERDATA = 4096
	Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 32
	Local Const $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER = 65536
	Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 512
	Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 65536
	Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 131072
	Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 262144
	Local $ICOORDMODE = Opt ( "GUICoordMode" , 1 )
	Local $IORGWIDTH = 210 , $IHEIGHT = 200 , $IMINSIZE = 250
	Local $HGUI = GUICreate ( $STITLE , $IORGWIDTH , $IHEIGHT , Default , Default , BitOR ( $_ARRAYCONSTANT_WS_SIZEBOX , $_ARRAYCONSTANT_WS_MINIMIZEBOX , $_ARRAYCONSTANT_WS_MAXIMIZEBOX ) )
	Local $AIGUISIZE = WinGetClientSize ( $HGUI )
	Local $IDLISTVIEW = GUICtrlCreateListView ( $SHEADER , 0 , 0 , $AIGUISIZE [ 0 ] , $AIGUISIZE [ 1 ] - $IBUTTONBORDER , BitOR ( $_ARRAYCONSTANT_LVS_SHOWSELALWAYS , $_ARRAYCONSTANT_LVS_OWNERDATA ) )
	$_G_ARRAYDISPLAY_HLISTVIEW = GUICtrlGetHandle ( $IDLISTVIEW )
	GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE , $_ARRAYCONSTANT_LVS_EX_GRIDLINES , $_ARRAYCONSTANT_LVS_EX_GRIDLINES )
	GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE , $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT , $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT )
	GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE , $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER , $_ARRAYCONSTANT_LVS_EX_DOUBLEBUFFER )
	GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE , $_ARRAYCONSTANT_WS_EX_CLIENTEDGE , $_ARRAYCONSTANT_WS_EX_CLIENTEDGE )
	Local $HHEADER = HWnd ( GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 31 ) , 0 , 0 ) )
	GUICtrlSetResizing ( $IDLISTVIEW , $_ARRAYCONSTANT_GUI_DOCKBORDERS )
	Local $ICOLFILL = $_G_ARRAYDISPLAY_NCOLS + $_G_ARRAYDISPLAY_IDISPLAYROW
	If $ICOLALIGN Then
		For $I = 0 To $ICOLFILL + 4294967295
			__ARRAYDISPLAY_JUSTIFYCOLUMN ( $IDLISTVIEW , $I , $ICOLALIGN / 2 )
		Next
	EndIf
	GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 47 ) , $_G_ARRAYDISPLAY_NROWS , 0 )
	Local $TRECT = DllStructCreate ( "struct; long Left;long Top;long Right;long Bottom; endstruct" )
	DllCall ( "user32.dll" , "struct*" , "SendMessageW" , "hwnd" , $_G_ARRAYDISPLAY_HLISTVIEW , "uint" , $_ARRAYCONSTANT_LVM_GETITEMRECT , "wparam" , 0 , "struct*" , $TRECT )
	Local $AIWIN_POS = WinGetPos ( $HGUI )
	Local $AILV_POS = ControlGetPos ( $HGUI , "" , $IDLISTVIEW )
	$IHEIGHT = ( ( $_G_ARRAYDISPLAY_NROWS + 3 ) * ( DllStructGetData ( $TRECT , "Bottom" ) - DllStructGetData ( $TRECT , "Top" ) ) ) + $AIWIN_POS [ 3 ] - $AILV_POS [ 3 ]
	If $IHEIGHT > @DesktopHeight + 4294967196 Then
		$IHEIGHT = @DesktopHeight + 4294967196
	ElseIf $IHEIGHT < $IMINSIZE Then
		$IHEIGHT = $IMINSIZE
	EndIf
	If $IVERBOSE Then SplashOff ( )
	$_G_ARRAYDISPLAY_ISORTDIR = 1024
	Local $ICOLUMN = 0 , $ICOLUMNPREV = + 4294967295
	If $_G_ARRAYDISPLAY_IDISPLAYROW Then
		$ICOLUMNPREV = $ICOLUMN
		__ARRAYDISPLAY_HEADERSETITEMFORMAT ( $HHEADER , $ICOLUMN , 16384 + $_G_ARRAYDISPLAY_ISORTDIR + $ICOLALIGN / 2 )
	EndIf
	$_G_ARRAYDISPLAY_AINDEX = $_G_ARRAYDISPLAY_AINDEXES [ 0 ]
	#EndRegion GUI and Listview generation
	Local $P__ARRAYDISPLAY_NOTIFYHANDLER = DllCallbackGetPtr ( DllCallbackRegister ( "__ArrayDisplay_NotifyHandler" , "lresult" , "hwnd;uint;wparam;lparam;uint_ptr;dword_ptr" ) )
	DllCall ( "comctl32.dll" , "bool" , "SetWindowSubclass" , "hwnd" , $HGUI , "ptr" , $P__ARRAYDISPLAY_NOTIFYHANDLER , "uint_ptr" , 0 , "dword_ptr" , 0 )
	#Region Adjust dialog width
	Local $IWIDTH = 40 , $ICOLWIDTH = 0 , $AICOLWIDTH [ $ICOLFILL ]
	Local $ICOLWIDTHHEADER , $IMIN_COLW = 55
	For $I = 0 To $ICOLFILL + 4294967295
		If $I > 0 Then $IMIN_COLW = $IMIN_COLWIDTH
		GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 30 ) , $I , + 4294967295 )
		$ICOLWIDTH = GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 29 ) , $I , 0 )
		If $SHEADER <> "" Then
			If $ICOLWIDTH = 0 Then ExitLoop
			GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 30 ) , $I , + 4294967294 )
			$ICOLWIDTHHEADER = GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 29 ) , $I , 0 )
			If $ICOLWIDTH < $IMIN_COLW And $ICOLWIDTHHEADER < $IMIN_COLW Then
				GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 30 ) , $I , $IMIN_COLW )
				$ICOLWIDTH = $IMIN_COLW
			ElseIf $ICOLWIDTHHEADER < $ICOLWIDTH Then
				GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 30 ) , $I , $ICOLWIDTH )
			Else
				$ICOLWIDTH = $ICOLWIDTHHEADER
			EndIf
		Else
			If $ICOLWIDTH < $IMIN_COLW Then
				GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 30 ) , $I , $IMIN_COLW )
				$ICOLWIDTH = $IMIN_COLW
			EndIf
		EndIf
		$IWIDTH += $ICOLWIDTH
		$AICOLWIDTH [ $I ] = $ICOLWIDTH
	Next
	If $IWIDTH > @DesktopWidth + 4294967196 Then
		$IWIDTH = 40
		For $I = 0 To $ICOLFILL + 4294967295
			If $AICOLWIDTH [ $I ] > $IMAX_COLWIDTH Then
				GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 30 ) , $I , $IMAX_COLWIDTH )
				$IWIDTH += $IMAX_COLWIDTH
			Else
				$IWIDTH += $AICOLWIDTH [ $I ]
			EndIf
			If $I < 20 And $BDEBUG Then ConsoleWrite ( "@@ Debug(" & @ScriptLineNumber & ") : $iWidth = " & $IWIDTH & " $i = " & $I & @CRLF )
		Next
	EndIf
	If $IWIDTH > @DesktopWidth + 4294967196 Then
		$IWIDTH = @DesktopWidth + 4294967196
	ElseIf $IWIDTH < $IMINSIZE Then
		$IWIDTH = $IMINSIZE
	EndIf
	#EndRegion Adjust dialog width
	Local $ISCROLLBARSIZE = 0
	If $IHEIGHT = ( @DesktopHeight + 4294967196 ) Then $ISCROLLBARSIZE = 15
	WinMove ( $HGUI , "" , ( @DesktopWidth - $IWIDTH + $ISCROLLBARSIZE ) / 2 , ( @DesktopHeight - $IHEIGHT ) / 2 , $IWIDTH + $ISCROLLBARSIZE , $IHEIGHT )
	$AIGUISIZE = WinGetClientSize ( $HGUI )
	GUICtrlSetPos ( $IDLISTVIEW , 0 , 0 , $IWIDTH , $AIGUISIZE [ 1 ] - $IBUTTONBORDER )
	#Region Create bottom infos
	Local $IBUTTONWIDTH_1 = $AIGUISIZE [ 0 ] / 2
	Local $IBUTTONWIDTH_2 = $AIGUISIZE [ 0 ] / 3
	Local $IDCOPY_ID = 9999 , $IDCOPY_DATA = 99999 , $IDDATA_LABEL = 99999 , $IDUSER_FUNC = 99999 , $IDEXIT_SCRIPT = 99999
	If $BDEBUG Then
		$IDCOPY_ID = GUICtrlCreateButton ( "Copy Data && Hdr/Row" , 0 , $AIGUISIZE [ 1 ] - $IBUTTONBORDER , $IBUTTONWIDTH_1 , 20 )
		$IDCOPY_DATA = GUICtrlCreateButton ( "Copy Data Only" , $IBUTTONWIDTH_1 , $AIGUISIZE [ 1 ] - $IBUTTONBORDER , $IBUTTONWIDTH_1 , 20 )
		Local $IBUTTONWIDTH_VAR = $IBUTTONWIDTH_1
		Local $IOFFSET = $IBUTTONWIDTH_1
		If IsFunc ( $HUSER_FUNCTION ) Then
			$IDUSER_FUNC = GUICtrlCreateButton ( "Run User Func" , $IBUTTONWIDTH_2 , $AIGUISIZE [ 1 ] + 4294967276 , $IBUTTONWIDTH_2 , 20 )
			$IBUTTONWIDTH_VAR = $IBUTTONWIDTH_2
			$IOFFSET = $IBUTTONWIDTH_2 * 2
		EndIf
		$IDEXIT_SCRIPT = GUICtrlCreateButton ( "Exit Script" , $IOFFSET , $AIGUISIZE [ 1 ] + 4294967276 , $IBUTTONWIDTH_VAR , 20 )
		$IDDATA_LABEL = GUICtrlCreateLabel ( $SDISPLAYDATA , 0 , $AIGUISIZE [ 1 ] + 4294967276 , $IBUTTONWIDTH_VAR , 18 , BitOR ( $_ARRAYCONSTANT_SS_CENTER , $_ARRAYCONSTANT_SS_CENTERIMAGE ) )
	Else
		$IDDATA_LABEL = GUICtrlCreateLabel ( $SDISPLAYDATA , 0 , $AIGUISIZE [ 1 ] + 4294967276 , $AIGUISIZE [ 0 ] , 18 , BitOR ( $_ARRAYCONSTANT_SS_CENTER , $_ARRAYCONSTANT_SS_CENTERIMAGE ) )
	EndIf
	If $_G_ARRAYDISPLAY_ITRANSPOSE Or $SARRAYRANGE Then
		GUICtrlSetColor ( $IDDATA_LABEL , 16711680 )
		GUICtrlSetTip ( $IDDATA_LABEL , $STIPDATA )
	EndIf
	GUICtrlSetResizing ( $IDCOPY_ID , $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT )
	GUICtrlSetResizing ( $IDCOPY_DATA , $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT )
	GUICtrlSetResizing ( $IDDATA_LABEL , $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT )
	GUICtrlSetResizing ( $IDUSER_FUNC , $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT )
	GUICtrlSetResizing ( $IDEXIT_SCRIPT , $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT )
	#EndRegion Create bottom infos
	GUISetState ( @SW_SHOW , $HGUI )
	If $FTIMER > 1000 And Not $SARRAYRANGE Then
		Beep ( 750 , 250 )
		ToolTip ( "Sorting Action can take as long as " & Ceiling ( $FTIMER / 1000 ) & " sec" & @CRLF & @CRLF & "Please be patient when you click to sort a column" , 50 , 50 , $SMSGBOXTITLE , $TIP_WARNINGICON , $TIP_BALLOON )
		Sleep ( 3000 )
		ToolTip ( "" )
	EndIf
	#Region GUI Handling events
	Local $IONEVENTMODE = Opt ( "GUIOnEventMode" , 0 ) , $AMSG
	While 1
		$AMSG = GUIGetMsg ( $_ARRAYCONSTANT_GUI_EVENT_ARRAY )
		If $AMSG [ 1 ] = $HGUI Then
			Switch $AMSG [ 0 ]
			Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
				ExitLoop
			Case $IDCOPY_ID , $IDCOPY_DATA
				Local $ISEL_COUNT = GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT , 0 , 0 )
				If $IVERBOSE And ( Not $ISEL_COUNT ) And ( $_G_ARRAYDISPLAY_IITEM_END - $_G_ARRAYDISPLAY_IITEM_START ) * ( $_G_ARRAYDISPLAY_ISUBITEM_END - $_G_ARRAYDISPLAY_ISUBITEM_START ) > 10000 Then
					SplashTextOn ( $SMSGBOXTITLE , "Copying data" & @CRLF & @CRLF & "Please be patient" , 300 , 100 )
				EndIf
				Local $SCLIP = "" , $SITEM , $ASPLIT , $IFIRSTCOL = 0
				If $AMSG [ 0 ] = $IDCOPY_DATA And $_G_ARRAYDISPLAY_IDISPLAYROW Then $IFIRSTCOL = 1
				For $I = 0 To GUICtrlSendMsg ( $IDLISTVIEW , 4100 , 0 , 0 ) + 4294967295
					If $ISEL_COUNT And Not ( GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_GETITEMSTATE , $I , $_ARRAYCONSTANT_LVIS_SELECTED ) <> 0 ) Then
						ContinueLoop
					EndIf
					$SITEM = __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED ( $IDLISTVIEW , $I , $IFIRSTCOL )
					If $AMSG [ 0 ] = $IDCOPY_ID And Not $_G_ARRAYDISPLAY_IDISPLAYROW Then
						$SITEM = $ARRAYDISPLAY_ROWPREFIX & " " & ( $I + $_G_ARRAYDISPLAY_IITEM_START ) & $SCURR_SEPARATOR & $SITEM
					EndIf
					If $ICW_COLWIDTH Then
						$ASPLIT = StringSplit ( $SITEM , $SCURR_SEPARATOR )
						$SITEM = ""
						For $J = 1 To $ASPLIT [ 0 ]
							$SITEM &= StringFormat ( "%-" & $ICW_COLWIDTH + 1 & "s" , StringLeft ( $ASPLIT [ $J ] , $ICW_COLWIDTH ) )
						Next
					Else
						$SITEM = StringReplace ( $SITEM , $SCURR_SEPARATOR , $VUSER_SEPARATOR )
					EndIf
					$SCLIP &= $SITEM & @CRLF
				Next
				$SITEM = $SHEADER
				If $AMSG [ 0 ] = $IDCOPY_ID Then
					$SITEM = $SHEADER
					If Not $_G_ARRAYDISPLAY_IDISPLAYROW Then
						$SITEM = "Row" & $SCURR_SEPARATOR & $SITEM
					EndIf
					If $ICW_COLWIDTH Then
						$ASPLIT = StringSplit ( $SITEM , $SCURR_SEPARATOR )
						$SITEM = ""
						For $J = 1 To $ASPLIT [ 0 ]
							$SITEM &= StringFormat ( "%-" & $ICW_COLWIDTH + 1 & "s" , StringLeft ( $ASPLIT [ $J ] , $ICW_COLWIDTH ) )
						Next
					Else
						$SITEM = StringReplace ( $SITEM , $SCURR_SEPARATOR , $VUSER_SEPARATOR )
					EndIf
					$SCLIP = $SITEM & @CRLF & $SCLIP
				EndIf
				ClipPut ( $SCLIP )
				SplashOff ( )
				GUICtrlSetState ( $IDLISTVIEW , $_ARRAYCONSTANT_GUI_FOCUS )
			Case $IDLISTVIEW
				$ICOLUMN = GUICtrlGetState ( $IDLISTVIEW )
				If Not IsArray ( $_G_ARRAYDISPLAY_AINDEXES [ $ICOLUMN + Not $_G_ARRAYDISPLAY_IDISPLAYROW ] ) Then
					__ARRAYDISPLAY_SORTINDEXES ( $ICOLUMN + Not $_G_ARRAYDISPLAY_IDISPLAYROW )
				EndIf
				If $ICOLUMN <> $ICOLUMNPREV Then
					__ARRAYDISPLAY_HEADERSETITEMFORMAT ( $HHEADER , $ICOLUMNPREV , 16384 + $ICOLALIGN / 2 )
					If $_G_ARRAYDISPLAY_IDISPLAYROW And $ICOLUMN = 0 Then
						$_G_ARRAYDISPLAY_AINDEX = $_G_ARRAYDISPLAY_AINDEXES [ 0 ]
					Else
						$_G_ARRAYDISPLAY_AINDEX = $_G_ARRAYDISPLAY_AINDEXES [ $ICOLUMN + Not $_G_ARRAYDISPLAY_IDISPLAYROW ]
					EndIf
				EndIf
				$_G_ARRAYDISPLAY_ISORTDIR = ( $ICOLUMN = $ICOLUMNPREV ) ? $_G_ARRAYDISPLAY_ISORTDIR = 1024 ? 512 : 1024 : 1024
				__ARRAYDISPLAY_HEADERSETITEMFORMAT ( $HHEADER , $ICOLUMN , 16384 + $_G_ARRAYDISPLAY_ISORTDIR + $ICOLALIGN / 2 )
				GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 140 ) , $ICOLUMN , 0 )
				GUICtrlSendMsg ( $IDLISTVIEW , ( 4096 + 47 ) , $_G_ARRAYDISPLAY_NROWS , 0 )
				$ICOLUMNPREV = $ICOLUMN
			Case $IDUSER_FUNC
				Local $AISELITEMS [ 1 ] = [ 0 ]
				For $I = 0 To GUICtrlSendMsg ( $IDLISTVIEW , 4100 , 0 , 0 ) + 4294967295
					If ( GUICtrlSendMsg ( $IDLISTVIEW , $_ARRAYCONSTANT_LVM_GETITEMSTATE , $I , $_ARRAYCONSTANT_LVIS_SELECTED ) <> 0 ) Then
						$AISELITEMS [ 0 ] += 1
						ReDim $AISELITEMS [ $AISELITEMS [ 0 ] + 1 ]
						$AISELITEMS [ $AISELITEMS [ 0 ] ] = $I + $_G_ARRAYDISPLAY_IITEM_START
					EndIf
				Next
				$HUSER_FUNCTION ( $_G_ARRAYDISPLAY_AARRAY , $AISELITEMS )
				$_G_ARRAYDISPLAY_BUSERFUNC = False
				__ARRAYDISPLAY_CLEANUP ( $HGUI , $ICOORDMODE , $IONEVENTMODE , $_ICALLERERROR , $_ICALLEREXTENDED , $P__ARRAYDISPLAY_NOTIFYHANDLER )
				Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , + 4294967295 )
			Case $IDEXIT_SCRIPT
				GUIDelete ( $HGUI )
				Exit
			EndSwitch
		EndIf
	WEnd
	#EndRegion GUI Handling events
	__ARRAYDISPLAY_CLEANUP ( $HGUI , $ICOORDMODE , $IONEVENTMODE , $_ICALLERERROR , $_ICALLEREXTENDED , $P__ARRAYDISPLAY_NOTIFYHANDLER )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , 1 )
EndFunc
Func __ARRAYDISPLAY_CLEANUP ( $HGUI , $ICOORDMODE , $IONEVENTMODE , $_ICALLERERROR , $_ICALLEREXTENDED , $P__ARRAYDISPLAY_NOTIFYHANDLER )
	DllCall ( "comctl32.dll" , "bool" , "RemoveWindowSubclass" , "hwnd" , $HGUI , "ptr" , $P__ARRAYDISPLAY_NOTIFYHANDLER , "uint_ptr" , 0 )
	$_G_ARRAYDISPLAY_AINDEX = 0
	Dim $_G_ARRAYDISPLAY_AINDEXES [ 1 ]
	GUIDelete ( $HGUI )
	Opt ( "GUICoordMode" , $ICOORDMODE )
	Opt ( "GUIOnEventMode" , $IONEVENTMODE )
	Return SetError ( $_ICALLERERROR , $_ICALLEREXTENDED , 1 )
EndFunc
Func __ARRAYDISPLAY_NOTIFYHANDLER ( $HWND , $IMSG , $WPARAM , $LPARAM , $ISUBCLASSID , $PDATA )
	If $IMSG <> 78 Then Return DllCall ( "comctl32.dll" , "lresult" , "DefSubclassProc" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM ) [ 0 ]
	Local Static $TAGNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
	Local Static $TAGNMLVDISPINFO = $TAGNMHDR & ";" & $_ARRAYCONSTANT_TAGLVITEM
	Local $TNMLVDISPINFO = DllStructCreate ( $TAGNMLVDISPINFO , $LPARAM )
	Switch HWnd ( DllStructGetData ( $TNMLVDISPINFO , "hWndFrom" ) )
	Case $_G_ARRAYDISPLAY_HLISTVIEW
		Switch DllStructGetData ( $TNMLVDISPINFO , "Code" )
		Case + 4294967119
			Local Static $TTEXT = DllStructCreate ( "wchar[4096]" ) , $PTEXT = DllStructGetPtr ( $TTEXT )
			Local $IITEM = DllStructGetData ( $TNMLVDISPINFO , "Item" )
			Local $IROW = ( $_G_ARRAYDISPLAY_ISORTDIR = 1024 ) ? $_G_ARRAYDISPLAY_AINDEX [ $IITEM ] : $_G_ARRAYDISPLAY_AINDEX [ $_G_ARRAYDISPLAY_NROWS + 4294967295 - $IITEM ]
			Local $ICOL = DllStructGetData ( $TNMLVDISPINFO , "SubItem" )
			Local $STEMP
			If $_G_ARRAYDISPLAY_IDISPLAYROW = 0 Then
				$STEMP = __ARRAYDISPLAY_GETDATA ( $IROW , $ICOL )
				DllStructSetData ( $TTEXT , 1 , $STEMP )
				DllStructSetData ( $TNMLVDISPINFO , "Text" , $PTEXT )
			Else
				If $ICOL = 0 Then
					If $_G_ARRAYDISPLAY_ITRANSPOSE Then
						Local $SCAPTIONCPLT = ""
						If $IROW + $_G_ARRAYDISPLAY_IITEM_START < UBound ( $_G_ARRAYDISPLAY_ASHEADER ) And StringStripWS ( $_G_ARRAYDISPLAY_ASHEADER [ $IROW + $_G_ARRAYDISPLAY_IITEM_START ] , 1 + 2 ) <> "" Then
							$SCAPTIONCPLT = " (" & StringStripWS ( $_G_ARRAYDISPLAY_ASHEADER [ $IROW + $_G_ARRAYDISPLAY_IITEM_START ] , 1 + 2 )
							If StringRight ( $SCAPTIONCPLT , 1 ) = $ARRAYDISPLAY_NUMERICSORT Then $SCAPTIONCPLT = StringTrimRight ( $SCAPTIONCPLT , 1 )
							$SCAPTIONCPLT &= ")"
						EndIf
						DllStructSetData ( $TTEXT , 1 , "Col " & ( $IROW + $_G_ARRAYDISPLAY_IITEM_START ) & $SCAPTIONCPLT )
					Else
						DllStructSetData ( $TTEXT , 1 , $ARRAYDISPLAY_ROWPREFIX & " " & $IROW + $_G_ARRAYDISPLAY_IITEM_START )
					EndIf
					DllStructSetData ( $TNMLVDISPINFO , "Text" , $PTEXT )
				Else
					$STEMP = __ARRAYDISPLAY_GETDATA ( $IROW , $ICOL + 4294967295 )
					DllStructSetData ( $TTEXT , 1 , $STEMP )
					DllStructSetData ( $TNMLVDISPINFO , "Text" , $PTEXT )
				EndIf
			EndIf
			Return
		EndSwitch
	EndSwitch
	Return DllCall ( "comctl32.dll" , "lresult" , "DefSubclassProc" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM ) [ 0 ]
	#forceref $iSubclassId, $pData
EndFunc
Func __ARRAYDISPLAY_GETDATA ( $IROW , $ICOL )
	Local $STEMP
	If $_G_ARRAYDISPLAY_IDIMS = 2 Then
		$STEMP = $_G_ARRAYDISPLAY_AARRAY [ $IROW ] [ $ICOL ]
	Else
		$STEMP = $_G_ARRAYDISPLAY_AARRAY [ $IROW ]
	EndIf
	Switch VarGetType ( $STEMP )
	Case "Array"
		Local $SSUBSCRIPT = ""
		For $I = 1 To UBound ( $STEMP , 0 )
			$SSUBSCRIPT = "[" & UBound ( $STEMP , $I ) & "]"
		Next
		$STEMP = "{Array" & $SSUBSCRIPT & "}"
	Case "Map"
		$STEMP = "{Map[" & UBound ( $STEMP ) & "]}"
	Case "Object"
		$STEMP = "{Object}"
	EndSwitch
	If StringLen ( $STEMP ) > 4095 Then $STEMP = StringLeft ( $STEMP , 4095 )
	Return $STEMP
EndFunc
Func __ARRAYDISPLAY_SORTINDEXES ( $ICOLSTART , $ICOLEND = $ICOLSTART )
	Dim $_G_ARRAYDISPLAY_AINDEX [ $_G_ARRAYDISPLAY_NROWS ]
	If $ICOLEND = + 4294967295 Then
		Dim $_G_ARRAYDISPLAY_AINDEXES [ $_G_ARRAYDISPLAY_NCOLS + $_G_ARRAYDISPLAY_IDISPLAYROW + 1 ]
		For $I = 0 To $_G_ARRAYDISPLAY_NROWS + 4294967295
			$_G_ARRAYDISPLAY_AINDEX [ $I ] = $I
		Next
		$_G_ARRAYDISPLAY_AINDEXES [ 0 ] = $_G_ARRAYDISPLAY_AINDEX
	EndIf
	If $ICOLSTART = + 4294967295 Then
		$ICOLSTART = 1
		$ICOLEND = $_G_ARRAYDISPLAY_NCOLS
	EndIf
	If $ICOLSTART Then
		Local $TINDEX
		For $I = $ICOLSTART To $ICOLEND
			$TINDEX = __ARRAYDISPLAY_GETSORTCOLSTRUCT ( $_G_ARRAYDISPLAY_AARRAY , $I + 4294967295 )
			For $J = 0 To $_G_ARRAYDISPLAY_NROWS + 4294967295
				$_G_ARRAYDISPLAY_AINDEX [ $J ] = DllStructGetData ( $TINDEX , 1 , $J + 1 )
			Next
			$_G_ARRAYDISPLAY_AINDEXES [ $I ] = $_G_ARRAYDISPLAY_AINDEX
		Next
	EndIf
EndFunc
Func __ARRAYDISPLAY_GETSORTCOLSTRUCT ( Const ByRef $AARRAY , $ICOL )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) < 1 Or UBound ( $AARRAY , $UBOUND_DIMENSIONS ) > 2 Then
		Return SetError ( 6 , 0 , 0 )
	EndIf
	Return __ARRAYDISPLAY_SORTARRAYSTRUCT ( $AARRAY , $ICOL )
EndFunc
Func __ARRAYDISPLAY_SORTARRAYSTRUCT ( Const ByRef $AARRAY , $ICOL )
	Local $IDIMS = UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Local $TINDEX = DllStructCreate ( "uint[" & $_G_ARRAYDISPLAY_NROWS & "]" )
	Local $PINDEX = DllStructGetPtr ( $TINDEX )
	Static $HDLL = DllOpen ( "kernel32.dll" )
	Static $HDLLCOMP = DllOpen ( "shlwapi.dll" )
	Local $LO , $HI , $MI , $R , $NVAL1 , $NVAL2
	For $I = 1 To $_G_ARRAYDISPLAY_NROWS + 4294967295
		$LO = 0
		$HI = $I + 4294967295
		Do
			$MI = Int ( ( $LO + $HI ) / 2 )
			If Not $_G_ARRAYDISPLAY_ITRANSPOSE And $_G_ARRAYDISPLAY_ANUMERICSORT [ $ICOL ] Then
				If $IDIMS = 1 Then
					$NVAL1 = Number ( $AARRAY [ $I ] )
					$NVAL2 = Number ( $AARRAY [ DllStructGetData ( $TINDEX , 1 , $MI + 1 ) ] )
				Else
					$NVAL1 = Number ( $AARRAY [ $I ] [ $ICOL ] )
					$NVAL2 = Number ( $AARRAY [ DllStructGetData ( $TINDEX , 1 , $MI + 1 ) ] [ $ICOL ] )
				EndIf
				$R = $NVAL1 < $NVAL2 ? + 4294967295 : $NVAL1 > $NVAL2 ? 1 : 0
			Else
				If $IDIMS = 1 Then
					$R = DllCall ( $HDLLCOMP , "int" , "StrCmpLogicalW" , "wstr" , String ( $AARRAY [ $I ] ) , "wstr" , String ( $AARRAY [ DllStructGetData ( $TINDEX , 1 , $MI + 1 ) ] ) ) [ 0 ]
				Else
					$R = DllCall ( $HDLLCOMP , "int" , "StrCmpLogicalW" , "wstr" , String ( $AARRAY [ $I ] [ $ICOL ] ) , "wstr" , String ( $AARRAY [ DllStructGetData ( $TINDEX , 1 , $MI + 1 ) ] [ $ICOL ] ) ) [ 0 ]
				EndIf
			EndIf
			Switch $R
			Case + 4294967295
				$HI = $MI + 4294967295
			Case 1
				$LO = $MI + 1
			Case 0
				ExitLoop
			EndSwitch
		Until $LO > $HI
		DllCall ( $HDLL , "none" , "RtlMoveMemory" , "struct*" , $PINDEX + ( $MI + 1 ) * 4 , "struct*" , $PINDEX + $MI * 4 , "ulong_ptr" , ( $I - $MI ) * 4 )
		DllStructSetData ( $TINDEX , 1 , $I , $MI + 1 + ( $LO = $MI + 1 ) )
	Next
	Return $TINDEX
EndFunc
Func __ARRAYDISPLAY_CREATESUBARRAY ( )
	Local $NROWS = $_G_ARRAYDISPLAY_IITEM_END - $_G_ARRAYDISPLAY_IITEM_START + 1
	Local $NCOLS = $_G_ARRAYDISPLAY_ISUBITEM_END - $_G_ARRAYDISPLAY_ISUBITEM_START + 1
	Local $IROW = + 4294967295 , $ICOL , $ITEMP , $ATEMP
	If $_G_ARRAYDISPLAY_ITRANSPOSE Then
		Dim $ATEMP [ $NCOLS ] [ $NROWS ]
		For $I = $_G_ARRAYDISPLAY_IITEM_START To $_G_ARRAYDISPLAY_IITEM_END
			$IROW += 1
			$ICOL = + 4294967295
			For $J = $_G_ARRAYDISPLAY_ISUBITEM_START To $_G_ARRAYDISPLAY_ISUBITEM_END
				$ICOL += 1
				$ATEMP [ $ICOL ] [ $IROW ] = $_G_ARRAYDISPLAY_AARRAY [ $I ] [ $J ]
			Next
		Next
		$ITEMP = $_G_ARRAYDISPLAY_IITEM_START
		$_G_ARRAYDISPLAY_IITEM_START = $_G_ARRAYDISPLAY_ISUBITEM_START
		$_G_ARRAYDISPLAY_ISUBITEM_START = $ITEMP
		$ITEMP = $_G_ARRAYDISPLAY_IITEM_END
		$_G_ARRAYDISPLAY_IITEM_END = $_G_ARRAYDISPLAY_ISUBITEM_END
		$_G_ARRAYDISPLAY_ISUBITEM_END = $ITEMP
		$_G_ARRAYDISPLAY_NROWS = $NCOLS
		$_G_ARRAYDISPLAY_NCOLS = $NROWS
	Else
		If $_G_ARRAYDISPLAY_IDIMS = 1 Then
			Dim $ATEMP [ $NROWS ]
			For $I = $_G_ARRAYDISPLAY_IITEM_START To $_G_ARRAYDISPLAY_IITEM_END
				$IROW += 1
				$ATEMP [ $IROW ] = $_G_ARRAYDISPLAY_AARRAY [ $I ]
			Next
		Else
			Dim $ATEMP [ $NROWS ] [ $NCOLS ]
			For $I = $_G_ARRAYDISPLAY_IITEM_START To $_G_ARRAYDISPLAY_IITEM_END
				$IROW += 1
				$ICOL = + 4294967295
				For $J = $_G_ARRAYDISPLAY_ISUBITEM_START To $_G_ARRAYDISPLAY_ISUBITEM_END
					$ICOL += 1
					$ATEMP [ $IROW ] [ $ICOL ] = $_G_ARRAYDISPLAY_AARRAY [ $I ] [ $J ]
				Next
			Next
			$_G_ARRAYDISPLAY_NCOLS = $NCOLS
		EndIf
		$_G_ARRAYDISPLAY_NROWS = $NROWS
	EndIf
	Return $ATEMP
EndFunc
Func __ARRAYDISPLAY_HEADERSETITEMFORMAT ( $HWND , $IINDEX , $IFORMAT )
	Local Static $THDITEM = DllStructCreate ( "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State" )
	DllStructSetData ( $THDITEM , "Mask" , 4 )
	DllStructSetData ( $THDITEM , "Fmt" , $IFORMAT )
	Local $ARESULT = DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $HWND , "uint" , 4620 , "wparam" , $IINDEX , "struct*" , $THDITEM )
	Return $ARESULT [ 0 ] <> 0
EndFunc
Func __ARRAYDISPLAY_GETITEMTEXT ( $IDLISTVIEW , $IINDEX , $ISUBITEM = 0 )
	Local $TBUFFER = DllStructCreate ( "wchar Text[4096]" )
	Local $PBUFFER = DllStructGetPtr ( $TBUFFER )
	Local $TITEM = DllStructCreate ( $_ARRAYCONSTANT_TAGLVITEM )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	DllStructSetData ( $TITEM , "TextMax" , 4096 )
	DllStructSetData ( $TITEM , "Text" , $PBUFFER )
	If IsHWnd ( $IDLISTVIEW ) Then
		DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $IDLISTVIEW , "uint" , 4211 , "wparam" , $IINDEX , "struct*" , $TITEM )
	Else
		Local $PITEM = DllStructGetPtr ( $TITEM )
		GUICtrlSendMsg ( $IDLISTVIEW , 4211 , $IINDEX , $PITEM )
	EndIf
	Return DllStructGetData ( $TBUFFER , "Text" )
EndFunc
Func __ARRAYDISPLAY_GETITEMTEXTSTRINGSELECTED ( $IDLISTVIEW , $IITEM , $IFIRSTCOL )
	Local $SROW = "" , $SSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" )
	Local $ISELECTED = $IITEM
	Local $HHEADER = HWnd ( GUICtrlSendMsg ( $IDLISTVIEW , 4127 , 0 , 0 ) )
	Local $NCOL = DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $HHEADER , "uint" , 4608 , "wparam" , 0 , "lparam" , 0 ) [ 0 ]
	For $X = $IFIRSTCOL To $NCOL + 4294967295
		$SROW &= __ARRAYDISPLAY_GETITEMTEXT ( $IDLISTVIEW , $ISELECTED , $X ) & $SSEPARATORCHAR
	Next
	Return StringTrimRight ( $SROW , 1 )
EndFunc
Func __ARRAYDISPLAY_JUSTIFYCOLUMN ( $IDLISTVIEW , $IINDEX , $IALIGN = + 4294967295 )
	Local $TCOLUMN = DllStructCreate ( "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal" )
	If $IALIGN < 0 Or $IALIGN > 2 Then $IALIGN = 0
	DllStructSetData ( $TCOLUMN , "Mask" , 1 )
	DllStructSetData ( $TCOLUMN , "Fmt" , $IALIGN )
	Local $PCOLUMN = DllStructGetPtr ( $TCOLUMN )
	Local $IRET = GUICtrlSendMsg ( $IDLISTVIEW , 4192 , $IINDEX , $PCOLUMN )
	Return $IRET <> 0
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT , $ARRAYFILL_FORCE_SINGLEITEM , $ARRAYFILL_FORCE_INT , $ARRAYFILL_FORCE_NUMBER , $ARRAYFILL_FORCE_PTR , $ARRAYFILL_FORCE_HWND , $ARRAYFILL_FORCE_STRING , $ARRAYFILL_FORCE_BOOLEAN
Global Enum $ARRAYUNIQUE_NOCOUNT , $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO , $ARRAYUNIQUE_FORCE32 , $ARRAYUNIQUE_FORCE64 , $ARRAYUNIQUE_MATCH , $ARRAYUNIQUE_DISTINCT
Func _ARRAYADD ( ByRef $AARRAY , $VVALUE , $ISTART = 0 , $SDELIM_ITEM = "|" , $SDELIM_ROW = @CRLF , $IFORCE = $ARRAYFILL_FORCE_DEFAULT )
	If $ISTART = Default Then $ISTART = 0
	If $SDELIM_ITEM = Default Then $SDELIM_ITEM = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $IFORCE = Default Then $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS )
	Local $HDATATYPE = 0
	Switch $IFORCE
	Case $ARRAYFILL_FORCE_INT
		$HDATATYPE = Int
	Case $ARRAYFILL_FORCE_NUMBER
		$HDATATYPE = Number
	Case $ARRAYFILL_FORCE_PTR
		$HDATATYPE = Ptr
	Case $ARRAYFILL_FORCE_HWND
		$HDATATYPE = HWnd
	Case $ARRAYFILL_FORCE_STRING
		$HDATATYPE = String
	Case $ARRAYFILL_FORCE_BOOLEAN
		$HDATATYPE = "Boolean"
	EndSwitch
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM Then
			ReDim $AARRAY [ $IDIM_1 + 1 ]
			$AARRAY [ $IDIM_1 ] = $VVALUE
			Return $IDIM_1
		EndIf
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 5 , 0 , + 4294967295 )
			$HDATATYPE = 0
		Else
			Local $ATMP = StringSplit ( $VVALUE , $SDELIM_ITEM , $STR_NOCOUNT + $STR_ENTIRESPLIT )
			If UBound ( $ATMP , $UBOUND_ROWS ) = 1 Then
				$ATMP [ 0 ] = $VVALUE
			EndIf
			$VVALUE = $ATMP
		EndIf
		Local $IADD = UBound ( $VVALUE , $UBOUND_ROWS )
		ReDim $AARRAY [ $IDIM_1 + $IADD ]
		For $I = 0 To $IADD + 4294967295
			If String ( $HDATATYPE ) = "Boolean" Then
				Switch $VVALUE [ $I ]
				Case "True" , "1"
					$AARRAY [ $IDIM_1 + $I ] = True
				Case "False" , "0" , ""
					$AARRAY [ $IDIM_1 + $I ] = False
				EndSwitch
			ElseIf IsFunc ( $HDATATYPE ) Then
				$AARRAY [ $IDIM_1 + $I ] = $HDATATYPE ( $VVALUE [ $I ] )
			Else
				$AARRAY [ $IDIM_1 + $I ] = $VVALUE [ $I ]
			EndIf
		Next
		Return $IDIM_1 + $IADD + 4294967295
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS )
		If $ISTART < 0 Or $ISTART > $IDIM_2 + 4294967295 Then Return SetError ( 4 , 0 , + 4294967295 )
		Local $IVALDIM_1 , $IVALDIM_2 = 0 , $ICOLCOUNT
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , $UBOUND_DIMENSIONS ) <> 2 Then Return SetError ( 5 , 0 , + 4294967295 )
			$IVALDIM_1 = UBound ( $VVALUE , $UBOUND_ROWS )
			$IVALDIM_2 = UBound ( $VVALUE , $UBOUND_COLUMNS )
			$HDATATYPE = 0
		Else
			Local $ASPLIT_1 = StringSplit ( $VVALUE , $SDELIM_ROW , $STR_NOCOUNT + $STR_ENTIRESPLIT )
			$IVALDIM_1 = UBound ( $ASPLIT_1 , $UBOUND_ROWS )
			Local $ATMP [ $IVALDIM_1 ] [ 0 ] , $ASPLIT_2
			For $I = 0 To $IVALDIM_1 + 4294967295
				$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , $SDELIM_ITEM , $STR_NOCOUNT + $STR_ENTIRESPLIT )
				$ICOLCOUNT = UBound ( $ASPLIT_2 )
				If $ICOLCOUNT > $IVALDIM_2 Then
					$IVALDIM_2 = $ICOLCOUNT
					ReDim $ATMP [ $IVALDIM_1 ] [ $IVALDIM_2 ]
				EndIf
				For $J = 0 To $ICOLCOUNT + 4294967295
					$ATMP [ $I ] [ $J ] = $ASPLIT_2 [ $J ]
				Next
			Next
			$VVALUE = $ATMP
		EndIf
		If UBound ( $VVALUE , $UBOUND_COLUMNS ) + $ISTART > UBound ( $AARRAY , $UBOUND_COLUMNS ) Then Return SetError ( 3 , 0 , + 4294967295 )
		ReDim $AARRAY [ $IDIM_1 + $IVALDIM_1 ] [ $IDIM_2 ]
		For $IWRITETO_INDEX = 0 To $IVALDIM_1 + 4294967295
			For $J = 0 To $IDIM_2 + 4294967295
				If $J < $ISTART Then
					$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = ""
				ElseIf $J - $ISTART > $IVALDIM_2 + 4294967295 Then
					$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = ""
				Else
					If String ( $HDATATYPE ) = "Boolean" Then
						Switch $VVALUE [ $IWRITETO_INDEX ] [ $J - $ISTART ]
						Case "True" , "1"
							$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = True
						Case "False" , "0" , ""
							$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = False
						EndSwitch
					ElseIf IsFunc ( $HDATATYPE ) Then
						$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = $HDATATYPE ( $VVALUE [ $IWRITETO_INDEX ] [ $J - $ISTART ] )
					Else
						$AARRAY [ $IWRITETO_INDEX + $IDIM_1 ] [ $J ] = $VVALUE [ $IWRITETO_INDEX ] [ $J - $ISTART ]
					EndIf
				EndIf
			Next
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
EndFunc
Func _ARRAYBINARYSEARCH ( Const ByRef $AARRAY , $VVALUE , $ISTART = 0 , $IEND = 0 , $ICOLUMN = 0 )
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ICOLUMN = Default Then $ICOLUMN = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS )
	If $IDIM_1 = 0 Then Return SetError ( 6 , 0 , + 4294967295 )
	If $IEND < 1 Or $IEND > $IDIM_1 + 4294967295 Then $IEND = $IDIM_1 + 4294967295
	If $ISTART < 0 Then $ISTART = 0
	If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	Local $IMID = Int ( ( $IEND + $ISTART ) / 2 )
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If $AARRAY [ $ISTART ] > $VVALUE Or $AARRAY [ $IEND ] < $VVALUE Then Return SetError ( 2 , 0 , + 4294967295 )
		While $ISTART <= $IMID And $VVALUE <> $AARRAY [ $IMID ]
			If $VVALUE < $AARRAY [ $IMID ] Then
				$IEND = $IMID + 4294967295
			Else
				$ISTART = $IMID + 1
			EndIf
			$IMID = Int ( ( $IEND + $ISTART ) / 2 )
		WEnd
		If $ISTART > $IEND Then Return SetError ( 3 , 0 , + 4294967295 )
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
		If $ICOLUMN < 0 Or $ICOLUMN > $IDIM_2 Then Return SetError ( 7 , 0 , + 4294967295 )
		If $AARRAY [ $ISTART ] [ $ICOLUMN ] > $VVALUE Or $AARRAY [ $IEND ] [ $ICOLUMN ] < $VVALUE Then Return SetError ( 2 , 0 , + 4294967295 )
		While $ISTART <= $IMID And $VVALUE <> $AARRAY [ $IMID ] [ $ICOLUMN ]
			If $VVALUE < $AARRAY [ $IMID ] [ $ICOLUMN ] Then
				$IEND = $IMID + 4294967295
			Else
				$ISTART = $IMID + 1
			EndIf
			$IMID = Int ( ( $IEND + $ISTART ) / 2 )
		WEnd
		If $ISTART > $IEND Then Return SetError ( 3 , 0 , + 4294967295 )
Case Else
		Return SetError ( 5 , 0 , + 4294967295 )
	EndSwitch
	Return $IMID
EndFunc
Func _ARRAYCOLDELETE ( ByRef $AARRAY , $ICOLUMN , $BCONVERT = False )
	If $BCONVERT = Default Then $BCONVERT = False
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 2 Then Return SetError ( 2 , 0 , + 4294967295 )
	Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS )
	Switch $IDIM_2
	Case 2
		If $ICOLUMN < 0 Or $ICOLUMN > 1 Then Return SetError ( 3 , 0 , + 4294967295 )
		If $BCONVERT Then
			Local $ATEMPARRAY [ $IDIM_1 ]
			For $I = 0 To $IDIM_1 + 4294967295
				$ATEMPARRAY [ $I ] = $AARRAY [ $I ] [ ( Not $ICOLUMN ) ]
			Next
			$AARRAY = $ATEMPARRAY
		Else
			ContinueCase
		EndIf
Case Else
		If $ICOLUMN < 0 Or $ICOLUMN > $IDIM_2 + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
		For $I = 0 To $IDIM_1 + 4294967295
			For $J = $ICOLUMN To $IDIM_2 + 4294967294
				$AARRAY [ $I ] [ $J ] = $AARRAY [ $I ] [ $J + 1 ]
			Next
		Next
		ReDim $AARRAY [ $IDIM_1 ] [ $IDIM_2 + 4294967295 ]
	EndSwitch
	Return UBound ( $AARRAY , $UBOUND_COLUMNS )
EndFunc
Func _ARRAYCOLINSERT ( ByRef $AARRAY , $ICOLUMN )
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS )
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		Local $ATEMPARRAY [ $IDIM_1 ] [ 2 ]
		Switch $ICOLUMN
		Case 0 , 1
			For $I = 0 To $IDIM_1 + 4294967295
				$ATEMPARRAY [ $I ] [ ( Not $ICOLUMN ) ] = $AARRAY [ $I ]
			Next
	Case Else
			Return SetError ( 3 , 0 , + 4294967295 )
		EndSwitch
		$AARRAY = $ATEMPARRAY
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS )
		If $ICOLUMN < 0 Or $ICOLUMN > $IDIM_2 Then Return SetError ( 3 , 0 , + 4294967295 )
		ReDim $AARRAY [ $IDIM_1 ] [ $IDIM_2 + 1 ]
		For $I = 0 To $IDIM_1 + 4294967295
			For $J = $IDIM_2 To $ICOLUMN + 1 Step + 4294967295
				$AARRAY [ $I ] [ $J ] = $AARRAY [ $I ] [ $J + 4294967295 ]
			Next
			$AARRAY [ $I ] [ $ICOLUMN ] = ""
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAY , $UBOUND_COLUMNS )
EndFunc
Func _ARRAYCOMBINATIONS ( Const ByRef $AARRAY , $ISET , $SDELIMITER = "" )
	If $SDELIMITER = Default Then $SDELIMITER = ""
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 2 , 0 , 0 )
	Local $IN = UBound ( $AARRAY )
	Local $IR = $ISET
	Local $AIDX [ $IR ]
	For $I = 0 To $IR + 4294967295
		$AIDX [ $I ] = $I
	Next
	Local $ITOTAL = __ARRAY_COMBINATIONS ( $IN , $IR )
	Local $ILEFT = $ITOTAL
	Local $ARESULT [ $ITOTAL + 1 ]
	$ARESULT [ 0 ] = $ITOTAL
	Local $ICOUNT = 1
	While $ILEFT > 0
		__ARRAY_GETNEXT ( $IN , $IR , $ILEFT , $ITOTAL , $AIDX )
		For $I = 0 To $ISET + 4294967295
			$ARESULT [ $ICOUNT ] &= $AARRAY [ $AIDX [ $I ] ] & $SDELIMITER
		Next
		If $SDELIMITER <> "" Then $ARESULT [ $ICOUNT ] = StringTrimRight ( $ARESULT [ $ICOUNT ] , 1 )
		$ICOUNT += 1
	WEnd
	Return $ARESULT
EndFunc
Func _ARRAYCONCATENATE ( ByRef $AARRAYTARGET , Const ByRef $AARRAYSOURCE , $ISTART = 0 )
	If $ISTART = Default Then $ISTART = 0
	If Not IsArray ( $AARRAYTARGET ) Then Return SetError ( 1 , 0 , + 4294967295 )
	If Not IsArray ( $AARRAYSOURCE ) Then Return SetError ( 2 , 0 , + 4294967295 )
	Local $IDIM_TOTAL_TGT = UBound ( $AARRAYTARGET , $UBOUND_DIMENSIONS )
	Local $IDIM_TOTAL_SRC = UBound ( $AARRAYSOURCE , $UBOUND_DIMENSIONS )
	Local $IDIM_1_TGT = UBound ( $AARRAYTARGET , $UBOUND_ROWS )
	Local $IDIM_1_SRC = UBound ( $AARRAYSOURCE , $UBOUND_ROWS )
	If $ISTART < 0 Or $ISTART > $IDIM_1_SRC + 4294967295 Then Return SetError ( 6 , 0 , + 4294967295 )
	Switch $IDIM_TOTAL_TGT
	Case 1
		If $IDIM_TOTAL_SRC <> 1 Then Return SetError ( 4 , 0 , + 4294967295 )
		ReDim $AARRAYTARGET [ $IDIM_1_TGT + $IDIM_1_SRC - $ISTART ]
		For $I = $ISTART To $IDIM_1_SRC + 4294967295
			$AARRAYTARGET [ $IDIM_1_TGT + $I - $ISTART ] = $AARRAYSOURCE [ $I ]
		Next
	Case 2
		If $IDIM_TOTAL_SRC <> 2 Then Return SetError ( 4 , 0 , + 4294967295 )
		Local $IDIM_2_TGT = UBound ( $AARRAYTARGET , $UBOUND_COLUMNS )
		If UBound ( $AARRAYSOURCE , $UBOUND_COLUMNS ) <> $IDIM_2_TGT Then Return SetError ( 5 , 0 , + 4294967295 )
		ReDim $AARRAYTARGET [ $IDIM_1_TGT + $IDIM_1_SRC - $ISTART ] [ $IDIM_2_TGT ]
		For $I = $ISTART To $IDIM_1_SRC + 4294967295
			For $J = 0 To $IDIM_2_TGT + 4294967295
				$AARRAYTARGET [ $IDIM_1_TGT + $I - $ISTART ] [ $J ] = $AARRAYSOURCE [ $I ] [ $J ]
			Next
		Next
Case Else
		Return SetError ( 3 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAYTARGET , $UBOUND_ROWS )
EndFunc
Func _ARRAYDELETE ( ByRef $AARRAY , $VRANGE )
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	If IsArray ( $VRANGE ) Then
		If UBound ( $VRANGE , $UBOUND_DIMENSIONS ) <> 1 Or UBound ( $VRANGE , $UBOUND_ROWS ) < 2 Then Return SetError ( 4 , 0 , + 4294967295 )
	Else
		Local $INUMBER , $ASPLIT_1 , $ASPLIT_2
		$VRANGE = StringStripWS ( $VRANGE , 8 )
		$ASPLIT_1 = StringSplit ( $VRANGE , ";" )
		$VRANGE = ""
		For $I = 1 To $ASPLIT_1 [ 0 ]
			If Not StringRegExp ( $ASPLIT_1 [ $I ] , "^\d+(-\d+)?$" ) Then Return SetError ( 3 , 0 , + 4294967295 )
			$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , "-" )
			Switch $ASPLIT_2 [ 0 ]
			Case 1
				$VRANGE &= $ASPLIT_2 [ 1 ] & ";"
			Case 2
				If Number ( $ASPLIT_2 [ 2 ] ) >= Number ( $ASPLIT_2 [ 1 ] ) Then
					$INUMBER = $ASPLIT_2 [ 1 ] + 4294967295
					Do
						$INUMBER += 1
						$VRANGE &= $INUMBER & ";"
					Until $INUMBER = $ASPLIT_2 [ 2 ]
				EndIf
			EndSwitch
		Next
		$VRANGE = StringSplit ( StringTrimRight ( $VRANGE , 1 ) , ";" )
	EndIf
	For $I = 1 To $VRANGE [ 0 ]
		$VRANGE [ $I ] = Number ( $VRANGE [ $I ] )
	Next
	If $VRANGE [ 1 ] < 0 Or $VRANGE [ $VRANGE [ 0 ] ] > $IDIM_1 Then Return SetError ( 5 , 0 , + 4294967295 )
	Local $ICOPYTO_INDEX = 0
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		For $I = 1 To $VRANGE [ 0 ]
			$AARRAY [ $VRANGE [ $I ] ] = ChrW ( 64177 )
		Next
		For $IREADFROM_INDEX = 0 To $IDIM_1
			If $AARRAY [ $IREADFROM_INDEX ] == ChrW ( 64177 ) Then
				ContinueLoop
			Else
				If $IREADFROM_INDEX <> $ICOPYTO_INDEX Then
					$AARRAY [ $ICOPYTO_INDEX ] = $AARRAY [ $IREADFROM_INDEX ]
				EndIf
				$ICOPYTO_INDEX += 1
			EndIf
		Next
		ReDim $AARRAY [ $IDIM_1 - $VRANGE [ 0 ] + 1 ]
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
		For $I = 1 To $VRANGE [ 0 ]
			$AARRAY [ $VRANGE [ $I ] ] [ 0 ] = ChrW ( 64177 )
		Next
		For $IREADFROM_INDEX = 0 To $IDIM_1
			If $AARRAY [ $IREADFROM_INDEX ] [ 0 ] == ChrW ( 64177 ) Then
				ContinueLoop
			Else
				If $IREADFROM_INDEX <> $ICOPYTO_INDEX Then
					For $J = 0 To $IDIM_2
						$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $AARRAY [ $IREADFROM_INDEX ] [ $J ]
					Next
				EndIf
				$ICOPYTO_INDEX += 1
			EndIf
		Next
		ReDim $AARRAY [ $IDIM_1 - $VRANGE [ 0 ] + 1 ] [ $IDIM_2 + 1 ]
Case Else
		Return SetError ( 2 , 0 , False )
	EndSwitch
	Return UBound ( $AARRAY , $UBOUND_ROWS )
EndFunc
Func _ARRAYDISPLAY ( Const ByRef $AARRAY , $STITLE = Default , $SARRAYRANGE = Default , $IFLAGS = Default , $VUSER_SEPARATOR = Default , $SHEADER = Default , $IDESIRED_COLWIDTH = Default )
	#forceref $vUser_Separator
	Local $IRET = __ARRAYDISPLAY_SHARE ( $AARRAY , $STITLE , $SARRAYRANGE , $IFLAGS , Default , $SHEADER , $IDESIRED_COLWIDTH , 0 , False )
	Return SetError ( @error , @extended , $IRET )
EndFunc
Func _ARRAYEXTRACT ( Const ByRef $AARRAY , $ISTART_ROW = + 4294967295 , $IEND_ROW = + 4294967295 , $ISTART_COL = + 4294967295 , $IEND_COL = + 4294967295 )
	If $ISTART_ROW = Default Then $ISTART_ROW = + 4294967295
	If $IEND_ROW = Default Then $IEND_ROW = + 4294967295
	If $ISTART_COL = Default Then $ISTART_COL = + 4294967295
	If $IEND_COL = Default Then $IEND_COL = + 4294967295
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	If $IEND_ROW = + 4294967295 Then $IEND_ROW = $IDIM_1
	If $ISTART_ROW = + 4294967295 Then $ISTART_ROW = 0
	If $ISTART_ROW < + 4294967295 Or $IEND_ROW < + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART_ROW > $IDIM_1 Or $IEND_ROW > $IDIM_1 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART_ROW > $IEND_ROW Then Return SetError ( 4 , 0 , + 4294967295 )
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		Local $ARETARRAY [ $IEND_ROW - $ISTART_ROW + 1 ]
		For $I = 0 To $IEND_ROW - $ISTART_ROW
			$ARETARRAY [ $I ] = $AARRAY [ $I + $ISTART_ROW ]
		Next
		Return $ARETARRAY
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
		If $IEND_COL = + 4294967295 Then $IEND_COL = $IDIM_2
		If $ISTART_COL = + 4294967295 Then $ISTART_COL = 0
		If $ISTART_COL < + 4294967295 Or $IEND_COL < + 4294967295 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $ISTART_COL > $IDIM_2 Or $IEND_COL > $IDIM_2 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $ISTART_COL > $IEND_COL Then Return SetError ( 6 , 0 , + 4294967295 )
		If $ISTART_COL = $IEND_COL Then
			Local $ARETARRAY [ $IEND_ROW - $ISTART_ROW + 1 ]
		Else
			Local $ARETARRAY [ $IEND_ROW - $ISTART_ROW + 1 ] [ $IEND_COL - $ISTART_COL + 1 ]
		EndIf
		For $I = 0 To $IEND_ROW - $ISTART_ROW
			For $J = 0 To $IEND_COL - $ISTART_COL
				If $ISTART_COL = $IEND_COL Then
					$ARETARRAY [ $I ] = $AARRAY [ $I + $ISTART_ROW ] [ $J + $ISTART_COL ]
				Else
					$ARETARRAY [ $I ] [ $J ] = $AARRAY [ $I + $ISTART_ROW ] [ $J + $ISTART_COL ]
				EndIf
			Next
		Next
		Return $ARETARRAY
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return 1
EndFunc
Func _ARRAYFINDALL ( Const ByRef $AARRAY , $VVALUE , $ISTART = 0 , $IEND = 0 , $ICASE = 0 , $ICOMPARE = 0 , $ISUBITEM = 0 , $BROW = False )
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ICASE = Default Then $ICASE = 0
	If $ICOMPARE = Default Then $ICOMPARE = 0
	If $ISUBITEM = Default Then $ISUBITEM = 0
	If $BROW = Default Then $BROW = False
	$ISTART = _ARRAYSEARCH ( $AARRAY , $VVALUE , $ISTART , $IEND , $ICASE , $ICOMPARE , 1 , $ISUBITEM , $BROW )
	If @error Then Return SetError ( @error , 0 , + 4294967295 )
	Local $IINDEX = 0 , $AVRESULT [ UBound ( $AARRAY , ( $BROW ? $UBOUND_COLUMNS : $UBOUND_ROWS ) ) ]
	Do
		$AVRESULT [ $IINDEX ] = $ISTART
		$IINDEX += 1
		$ISTART = _ARRAYSEARCH ( $AARRAY , $VVALUE , $ISTART + 1 , $IEND , $ICASE , $ICOMPARE , 1 , $ISUBITEM , $BROW )
	Until @error
	ReDim $AVRESULT [ $IINDEX ]
	Return $AVRESULT
EndFunc
Func _ARRAYFROMSTRING ( $SARRAYSTR , $SDELIM_COL = "|" , $SDELIM_ROW = @CRLF , $BFORCE2D = False , $ISTRIPWS = $STR_STRIPLEADING + $STR_STRIPTRAILING )
	If $SDELIM_COL = Default Then $SDELIM_COL = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $BFORCE2D = Default Then $BFORCE2D = False
	If $ISTRIPWS = Default Then $ISTRIPWS = $STR_STRIPLEADING + $STR_STRIPTRAILING
	Local $AROW , $ACOL = StringSplit ( $SARRAYSTR , $SDELIM_ROW , $STR_ENTIRESPLIT + $STR_NOCOUNT )
	$AROW = StringSplit ( $ACOL [ 0 ] , $SDELIM_COL , $STR_ENTIRESPLIT + $STR_NOCOUNT )
	If UBound ( $ACOL ) = 1 And Not $BFORCE2D Then
		For $M = 0 To UBound ( $AROW ) + 4294967295
			$AROW [ $M ] = ( $ISTRIPWS ? StringStripWS ( $AROW [ $M ] , $ISTRIPWS ) : $AROW [ $M ] )
		Next
		Return $AROW
	EndIf
	Local $ARET [ UBound ( $ACOL ) ] [ UBound ( $AROW ) ]
	For $N = 0 To UBound ( $ACOL ) + 4294967295
		$AROW = StringSplit ( $ACOL [ $N ] , $SDELIM_COL , $STR_ENTIRESPLIT + $STR_NOCOUNT )
		If UBound ( $AROW ) > UBound ( $ARET , 2 ) Then Return SetError ( 1 )
		For $M = 0 To UBound ( $AROW ) + 4294967295
			$ARET [ $N ] [ $M ] = ( $ISTRIPWS ? StringStripWS ( $AROW [ $M ] , $ISTRIPWS ) : $AROW [ $M ] )
		Next
	Next
	Return $ARET
EndFunc
Func _ARRAYINSERT ( ByRef $AARRAY , $VRANGE , $VVALUE = "" , $ISTART = 0 , $SDELIM_ITEM = "|" , $SDELIM_ROW = @CRLF , $IFORCE = $ARRAYFILL_FORCE_DEFAULT )
	If $VVALUE = Default Then $VVALUE = ""
	If $ISTART = Default Then $ISTART = 0
	If $SDELIM_ITEM = Default Then $SDELIM_ITEM = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $IFORCE = Default Then $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	Local $HDATATYPE = 0
	Switch $IFORCE
	Case $ARRAYFILL_FORCE_INT
		$HDATATYPE = Int
	Case $ARRAYFILL_FORCE_NUMBER
		$HDATATYPE = Number
	Case $ARRAYFILL_FORCE_PTR
		$HDATATYPE = Ptr
	Case $ARRAYFILL_FORCE_HWND
		$HDATATYPE = HWnd
	Case $ARRAYFILL_FORCE_STRING
		$HDATATYPE = String
	EndSwitch
	Local $ASPLIT_1 , $ASPLIT_2
	If IsArray ( $VRANGE ) Then
		If UBound ( $VRANGE , $UBOUND_DIMENSIONS ) <> 1 Or UBound ( $VRANGE , $UBOUND_ROWS ) < 2 Then Return SetError ( 4 , 0 , + 4294967295 )
	Else
		Local $INUMBER
		$VRANGE = StringStripWS ( $VRANGE , 8 )
		$ASPLIT_1 = StringSplit ( $VRANGE , ";" )
		$VRANGE = ""
		For $I = 1 To $ASPLIT_1 [ 0 ]
			If Not StringRegExp ( $ASPLIT_1 [ $I ] , "^\d+(-\d+)?$" ) Then Return SetError ( 3 , 0 , + 4294967295 )
			$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , "-" )
			Switch $ASPLIT_2 [ 0 ]
			Case 1
				$VRANGE &= $ASPLIT_2 [ 1 ] & ";"
			Case 2
				If Number ( $ASPLIT_2 [ 2 ] ) >= Number ( $ASPLIT_2 [ 1 ] ) Then
					$INUMBER = $ASPLIT_2 [ 1 ] + 4294967295
					Do
						$INUMBER += 1
						$VRANGE &= $INUMBER & ";"
					Until $INUMBER = $ASPLIT_2 [ 2 ]
				EndIf
			EndSwitch
		Next
		$VRANGE = StringSplit ( StringTrimRight ( $VRANGE , 1 ) , ";" )
	EndIf
	For $I = 1 To $VRANGE [ 0 ]
		$VRANGE [ $I ] = Number ( $VRANGE [ $I ] )
	Next
	If $VRANGE [ 1 ] < 0 Or $VRANGE [ $VRANGE [ 0 ] ] > $IDIM_1 Then Return SetError ( 5 , 0 , + 4294967295 )
	For $I = 2 To $VRANGE [ 0 ]
		If $VRANGE [ $I ] < $VRANGE [ $I + 4294967295 ] Then Return SetError ( 3 , 0 , + 4294967295 )
	Next
	Local $ICOPYTO_INDEX = $IDIM_1 + $VRANGE [ 0 ]
	Local $IINSERTPOINT_INDEX = $VRANGE [ 0 ]
	Local $IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM Then
			ReDim $AARRAY [ $IDIM_1 + $VRANGE [ 0 ] + 1 ]
			For $IREADFROMINDEX = $IDIM_1 To 0 Step + 4294967295
				$AARRAY [ $ICOPYTO_INDEX ] = $AARRAY [ $IREADFROMINDEX ]
				$ICOPYTO_INDEX -= 1
				$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
				While $IREADFROMINDEX = $IINSERT_INDEX
					$AARRAY [ $ICOPYTO_INDEX ] = $VVALUE
					$ICOPYTO_INDEX -= 1
					$IINSERTPOINT_INDEX -= 1
					If $IINSERTPOINT_INDEX < 1 Then ExitLoop 2
					$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
				WEnd
			Next
			Return $IDIM_1 + $VRANGE [ 0 ] + 1
		EndIf
		ReDim $AARRAY [ $IDIM_1 + $VRANGE [ 0 ] + 1 ]
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 5 , 0 , + 4294967295 )
			$HDATATYPE = 0
		Else
			Local $ATMP = StringSplit ( $VVALUE , $SDELIM_ITEM , $STR_NOCOUNT + $STR_ENTIRESPLIT )
			If UBound ( $ATMP , $UBOUND_ROWS ) = 1 Then
				$ATMP [ 0 ] = $VVALUE
				$HDATATYPE = 0
			EndIf
			$VVALUE = $ATMP
		EndIf
		For $IREADFROMINDEX = $IDIM_1 To 0 Step + 4294967295
			$AARRAY [ $ICOPYTO_INDEX ] = $AARRAY [ $IREADFROMINDEX ]
			$ICOPYTO_INDEX -= 1
			$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			While $IREADFROMINDEX = $IINSERT_INDEX
				If $IINSERTPOINT_INDEX <= UBound ( $VVALUE , $UBOUND_ROWS ) Then
					If IsFunc ( $HDATATYPE ) Then
						$AARRAY [ $ICOPYTO_INDEX ] = $HDATATYPE ( $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ] )
					Else
						$AARRAY [ $ICOPYTO_INDEX ] = $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ]
					EndIf
				Else
					$AARRAY [ $ICOPYTO_INDEX ] = ""
				EndIf
				$ICOPYTO_INDEX -= 1
				$IINSERTPOINT_INDEX -= 1
				If $IINSERTPOINT_INDEX = 0 Then ExitLoop 2
				$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			WEnd
		Next
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS )
		If $ISTART < 0 Or $ISTART > $IDIM_2 + 4294967295 Then Return SetError ( 6 , 0 , + 4294967295 )
		Local $IVALDIM_1 , $IVALDIM_2
		If IsArray ( $VVALUE ) Then
			If UBound ( $VVALUE , $UBOUND_DIMENSIONS ) <> 2 Then Return SetError ( 7 , 0 , + 4294967295 )
			$IVALDIM_1 = UBound ( $VVALUE , $UBOUND_ROWS )
			$IVALDIM_2 = UBound ( $VVALUE , $UBOUND_COLUMNS )
			$HDATATYPE = 0
		Else
			$ASPLIT_1 = StringSplit ( $VVALUE , $SDELIM_ROW , $STR_NOCOUNT + $STR_ENTIRESPLIT )
			$IVALDIM_1 = UBound ( $ASPLIT_1 , $UBOUND_ROWS )
			StringReplace ( $ASPLIT_1 [ 0 ] , $SDELIM_ITEM , "" )
			$IVALDIM_2 = @extended + 1
			Local $ATMP [ $IVALDIM_1 ] [ $IVALDIM_2 ]
			For $I = 0 To $IVALDIM_1 + 4294967295
				$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , $SDELIM_ITEM , $STR_NOCOUNT + $STR_ENTIRESPLIT )
				For $J = 0 To $IVALDIM_2 + 4294967295
					$ATMP [ $I ] [ $J ] = $ASPLIT_2 [ $J ]
				Next
			Next
			$VVALUE = $ATMP
		EndIf
		If UBound ( $VVALUE , $UBOUND_COLUMNS ) + $ISTART > UBound ( $AARRAY , $UBOUND_COLUMNS ) Then Return SetError ( 8 , 0 , + 4294967295 )
		ReDim $AARRAY [ $IDIM_1 + $VRANGE [ 0 ] + 1 ] [ $IDIM_2 ]
		For $IREADFROMINDEX = $IDIM_1 To 0 Step + 4294967295
			For $J = 0 To $IDIM_2 + 4294967295
				$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $AARRAY [ $IREADFROMINDEX ] [ $J ]
			Next
			$ICOPYTO_INDEX -= 1
			$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			While $IREADFROMINDEX = $IINSERT_INDEX
				For $J = 0 To $IDIM_2 + 4294967295
					If $J < $ISTART Then
						$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = ""
					ElseIf $J - $ISTART > $IVALDIM_2 + 4294967295 Then
						$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = ""
					Else
						If $IINSERTPOINT_INDEX + 4294967295 < $IVALDIM_1 Then
							If IsFunc ( $HDATATYPE ) Then
								$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $HDATATYPE ( $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ] [ $J - $ISTART ] )
							Else
								$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = $VVALUE [ $IINSERTPOINT_INDEX + 4294967295 ] [ $J - $ISTART ]
							EndIf
						Else
							$AARRAY [ $ICOPYTO_INDEX ] [ $J ] = ""
						EndIf
					EndIf
				Next
				$ICOPYTO_INDEX -= 1
				$IINSERTPOINT_INDEX -= 1
				If $IINSERTPOINT_INDEX = 0 Then ExitLoop 2
				$IINSERT_INDEX = $VRANGE [ $IINSERTPOINT_INDEX ]
			WEnd
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return UBound ( $AARRAY , $UBOUND_ROWS )
EndFunc
Func _ARRAYMAX ( Const ByRef $AARRAY , $ICOMPNUMERIC = 0 , $ISTART = + 4294967295 , $IEND = + 4294967295 , $ISUBITEM = 0 )
	Local $IRESULT = _ARRAYMAXINDEX ( $AARRAY , $ICOMPNUMERIC , $ISTART , $IEND , $ISUBITEM )
	If @error Then Return SetError ( @error , 0 , "" )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) = 1 Then
		Return $AARRAY [ $IRESULT ]
	Else
		Return $AARRAY [ $IRESULT ] [ $ISUBITEM ]
	EndIf
EndFunc
Func _ARRAYMAXINDEX ( Const ByRef $AARRAY , $ICOMPNUMERIC = 0 , $ISTART = + 4294967295 , $IEND = + 4294967295 , $ISUBITEM = 0 )
	If $ICOMPNUMERIC = Default Then $ICOMPNUMERIC = 0
	If $ISTART = Default Then $ISTART = + 4294967295
	If $IEND = Default Then $IEND = + 4294967295
	If $ISUBITEM = Default Then $ISUBITEM = 0
	Local $IRET = __ARRAY_MINMAXINDEX ( $AARRAY , $ICOMPNUMERIC , $ISTART , $IEND , $ISUBITEM , __ARRAY_GREATERTHAN )
	Return SetError ( @error , 0 , $IRET )
EndFunc
Func _ARRAYMIN ( Const ByRef $AARRAY , $ICOMPNUMERIC = 0 , $ISTART = + 4294967295 , $IEND = + 4294967295 , $ISUBITEM = 0 )
	Local $IRESULT = _ARRAYMININDEX ( $AARRAY , $ICOMPNUMERIC , $ISTART , $IEND , $ISUBITEM )
	If @error Then Return SetError ( @error , 0 , "" )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) = 1 Then
		Return $AARRAY [ $IRESULT ]
	Else
		Return $AARRAY [ $IRESULT ] [ $ISUBITEM ]
	EndIf
EndFunc
Func _ARRAYMININDEX ( Const ByRef $AARRAY , $ICOMPNUMERIC = 0 , $ISTART = + 4294967295 , $IEND = + 4294967295 , $ISUBITEM = 0 )
	If $ICOMPNUMERIC = Default Then $ICOMPNUMERIC = 0
	If $ISTART = Default Then $ISTART = + 4294967295
	If $IEND = Default Then $IEND = + 4294967295
	If $ISUBITEM = Default Then $ISUBITEM = 0
	Local $IRET = __ARRAY_MINMAXINDEX ( $AARRAY , $ICOMPNUMERIC , $ISTART , $IEND , $ISUBITEM , __ARRAY_LESSTHAN )
	Return SetError ( @error , 0 , $IRET )
EndFunc
Func _ARRAYPERMUTE ( ByRef $AARRAY , $SDELIMITER = "" )
	If $SDELIMITER = Default Then $SDELIMITER = ""
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 2 , 0 , 0 )
	Local $ISIZE = UBound ( $AARRAY ) , $IFACTORIAL = 1 , $AIDX [ $ISIZE ] , $ARESULT [ 1 ] , $ICOUNT = 1
	If UBound ( $AARRAY ) Then
		For $I = 0 To $ISIZE + 4294967295
			$AIDX [ $I ] = $I
		Next
		For $I = $ISIZE To 1 Step + 4294967295
			$IFACTORIAL *= $I
		Next
		ReDim $ARESULT [ $IFACTORIAL + 1 ]
		$ARESULT [ 0 ] = $IFACTORIAL
		__ARRAY_EXETERINTERNAL ( $AARRAY , 0 , $ISIZE , $SDELIMITER , $AIDX , $ARESULT , $ICOUNT )
	Else
		$ARESULT [ 0 ] = 0
	EndIf
	Return $ARESULT
EndFunc
Func _ARRAYPOP ( ByRef $AARRAY )
	If ( Not IsArray ( $AARRAY ) ) Then Return SetError ( 1 , 0 , "" )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 2 , 0 , "" )
	Local $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $IUBOUND = + 4294967295 Then Return SetError ( 3 , 0 , "" )
	Local $SLASTVAL = $AARRAY [ $IUBOUND ]
	If $IUBOUND > + 4294967295 Then
		ReDim $AARRAY [ $IUBOUND ]
	EndIf
	Return $SLASTVAL
EndFunc
Func _ARRAYPUSH ( ByRef $AARRAY , $VVALUE , $IDIRECTION = 0 )
	If $IDIRECTION = Default Then $IDIRECTION = 0
	If ( Not IsArray ( $AARRAY ) ) Then Return SetError ( 1 , 0 , 0 )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 3 , 0 , 0 )
	Local $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If IsArray ( $VVALUE ) Then
		Local $IUBOUNDS = UBound ( $VVALUE )
		If ( $IUBOUNDS + 4294967295 ) > $IUBOUND Then Return SetError ( 2 , 0 , 0 )
		If $IDIRECTION Then
			For $I = $IUBOUND To $IUBOUNDS Step + 4294967295
				$AARRAY [ $I ] = $AARRAY [ $I - $IUBOUNDS ]
			Next
			For $I = 0 To $IUBOUNDS + 4294967295
				$AARRAY [ $I ] = $VVALUE [ $I ]
			Next
		Else
			For $I = 0 To $IUBOUND - $IUBOUNDS
				$AARRAY [ $I ] = $AARRAY [ $I + $IUBOUNDS ]
			Next
			For $I = 0 To $IUBOUNDS + 4294967295
				$AARRAY [ $I + $IUBOUND - $IUBOUNDS + 1 ] = $VVALUE [ $I ]
			Next
		EndIf
	Else
		If $IUBOUND > + 4294967295 Then
			If $IDIRECTION Then
				For $I = $IUBOUND To 1 Step + 4294967295
					$AARRAY [ $I ] = $AARRAY [ $I + 4294967295 ]
				Next
				$AARRAY [ 0 ] = $VVALUE
			Else
				For $I = 0 To $IUBOUND + 4294967295
					$AARRAY [ $I ] = $AARRAY [ $I + 1 ]
				Next
				$AARRAY [ $IUBOUND ] = $VVALUE
			EndIf
		EndIf
	EndIf
	Return 1
EndFunc
Func _ARRAYREVERSE ( ByRef $AARRAY , $ISTART = 0 , $IEND = 0 )
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 3 , 0 , 0 )
	If Not UBound ( $AARRAY ) Then Return SetError ( 4 , 0 , 0 )
	Local $VTMP , $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $IEND < 1 Or $IEND > $IUBOUND Then $IEND = $IUBOUND
	If $ISTART < 0 Then $ISTART = 0
	If $ISTART > $IEND Then Return SetError ( 2 , 0 , 0 )
	For $I = $ISTART To Int ( ( $ISTART + $IEND + 4294967295 ) / 2 )
		$VTMP = $AARRAY [ $I ]
		$AARRAY [ $I ] = $AARRAY [ $IEND ]
		$AARRAY [ $IEND ] = $VTMP
		$IEND -= 1
	Next
	Return 1
EndFunc
Func _ARRAYSEARCH ( Const ByRef $AARRAY , $VVALUE , $ISTART = 0 , $IEND = 0 , $ICASE = 0 , $ICOMPARE = 0 , $IFORWARD = 1 , $ISUBITEM = + 4294967295 , $BROW = False )
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ICASE = Default Then $ICASE = 0
	If $ICOMPARE = Default Then $ICOMPARE = 0
	If $IFORWARD = Default Then $IFORWARD = 1
	If $ISUBITEM = Default Then $ISUBITEM = + 4294967295
	If $BROW = Default Then $BROW = False
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY ) + 4294967295
	If $IDIM_1 = + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
	Local $BCOMPTYPE = False
	If $ICOMPARE = 2 Then
		$ICOMPARE = 0
		$BCOMPTYPE = True
	EndIf
	If $BROW Then
		If UBound ( $AARRAY , $UBOUND_DIMENSIONS ) = 1 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $IEND < 1 Or $IEND > $IDIM_2 Then $IEND = $IDIM_2
		If $ISTART < 0 Then $ISTART = 0
		If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	Else
		If $IEND < 1 Or $IEND > $IDIM_1 Then $IEND = $IDIM_1
		If $ISTART < 0 Then $ISTART = 0
		If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	EndIf
	Local $ISTEP = 1
	If Not $IFORWARD Then
		Local $ITMP = $ISTART
		$ISTART = $IEND
		$IEND = $ITMP
		$ISTEP = + 4294967295
	EndIf
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If Not $ICOMPARE Then
			If Not $ICASE Then
				For $I = $ISTART To $IEND Step $ISTEP
					If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
					If $AARRAY [ $I ] = $VVALUE Then Return $I
				Next
			Else
				For $I = $ISTART To $IEND Step $ISTEP
					If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
					If $AARRAY [ $I ] == $VVALUE Then Return $I
				Next
			EndIf
		Else
			For $I = $ISTART To $IEND Step $ISTEP
				If $ICOMPARE = 3 Then
					If StringRegExp ( $AARRAY [ $I ] , $VVALUE ) Then Return $I
				Else
					If StringInStr ( $AARRAY [ $I ] , $VVALUE , $ICASE ) > 0 Then Return $I
				EndIf
			Next
		EndIf
	Case 2
		Local $IDIM_SUB
		If $BROW Then
			$IDIM_SUB = $IDIM_1
			If $ISUBITEM > $IDIM_SUB Then $ISUBITEM = $IDIM_SUB
			If $ISUBITEM < 0 Then
				$ISUBITEM = 0
			Else
				$IDIM_SUB = $ISUBITEM
			EndIf
		Else
			$IDIM_SUB = $IDIM_2
			If $ISUBITEM > $IDIM_SUB Then $ISUBITEM = $IDIM_SUB
			If $ISUBITEM < 0 Then
				$ISUBITEM = 0
			Else
				$IDIM_SUB = $ISUBITEM
			EndIf
		EndIf
		For $J = $ISUBITEM To $IDIM_SUB
			If Not $ICOMPARE Then
				If Not $ICASE Then
					For $I = $ISTART To $IEND Step $ISTEP
						If $BROW Then
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $J ] [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $J ] [ $I ] = $VVALUE Then Return $I
						Else
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] [ $J ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $I ] [ $J ] = $VVALUE Then Return $I
						EndIf
					Next
				Else
					For $I = $ISTART To $IEND Step $ISTEP
						If $BROW Then
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $J ] [ $I ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $J ] [ $I ] == $VVALUE Then Return $I
						Else
							If $BCOMPTYPE And VarGetType ( $AARRAY [ $I ] [ $J ] ) <> VarGetType ( $VVALUE ) Then ContinueLoop
							If $AARRAY [ $I ] [ $J ] == $VVALUE Then Return $I
						EndIf
					Next
				EndIf
			Else
				For $I = $ISTART To $IEND Step $ISTEP
					If $ICOMPARE = 3 Then
						If $BROW Then
							If StringRegExp ( $AARRAY [ $J ] [ $I ] , $VVALUE ) Then Return $I
						Else
							If StringRegExp ( $AARRAY [ $I ] [ $J ] , $VVALUE ) Then Return $I
						EndIf
					Else
						If $BROW Then
							If StringInStr ( $AARRAY [ $J ] [ $I ] , $VVALUE , $ICASE ) > 0 Then Return $I
						Else
							If StringInStr ( $AARRAY [ $I ] [ $J ] , $VVALUE , $ICASE ) > 0 Then Return $I
						EndIf
					EndIf
				Next
			EndIf
		Next
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return SetError ( 6 , 0 , + 4294967295 )
EndFunc
Func _ARRAYSHUFFLE ( ByRef $AARRAY , $ISTART_ROW = 0 , $IEND_ROW = 0 , $ICOL = + 4294967295 )
	If $ISTART_ROW = Default Then $ISTART_ROW = 0
	If $IEND_ROW = Default Then $IEND_ROW = 0
	If $ICOL = Default Then $ICOL = + 4294967295
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS )
	If $IEND_ROW = 0 Then $IEND_ROW = $IDIM_1 + 4294967295
	If $ISTART_ROW < 0 Or $ISTART_ROW > $IDIM_1 + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $IEND_ROW < 1 Or $IEND_ROW > $IDIM_1 + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART_ROW > $IEND_ROW Then Return SetError ( 4 , 0 , + 4294967295 )
	Local $VTMP , $IRAND
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		For $I = $IEND_ROW To $ISTART_ROW + 1 Step + 4294967295
			$IRAND = Random ( $ISTART_ROW , $I , 1 )
			$VTMP = $AARRAY [ $I ]
			$AARRAY [ $I ] = $AARRAY [ $IRAND ]
			$AARRAY [ $IRAND ] = $VTMP
		Next
		Return 1
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS )
		If $ICOL < + 4294967295 Or $ICOL > $IDIM_2 + 4294967295 Then Return SetError ( 5 , 0 , + 4294967295 )
		Local $ICOL_START , $ICOL_END
		If $ICOL = + 4294967295 Then
			$ICOL_START = 0
			$ICOL_END = $IDIM_2 + 4294967295
		Else
			$ICOL_START = $ICOL
			$ICOL_END = $ICOL
		EndIf
		For $I = $IEND_ROW To $ISTART_ROW + 1 Step + 4294967295
			$IRAND = Random ( $ISTART_ROW , $I , 1 )
			For $J = $ICOL_START To $ICOL_END
				$VTMP = $AARRAY [ $I ] [ $J ]
				$AARRAY [ $I ] [ $J ] = $AARRAY [ $IRAND ] [ $J ]
				$AARRAY [ $IRAND ] [ $J ] = $VTMP
			Next
		Next
		Return 1
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
EndFunc
Func _ARRAYSORT ( ByRef $AARRAY , $IDESCENDING = 0 , $ISTART = 0 , $IEND = 0 , $ISUBITEM = 0 , $IPIVOT = 0 )
	If $IDESCENDING = Default Then $IDESCENDING = 0
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ISUBITEM = Default Then $ISUBITEM = 0
	If $IPIVOT = Default Then $IPIVOT = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	Local $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $IUBOUND = + 4294967295 Then Return SetError ( 5 , 0 , 0 )
	If $IEND = Default Then $IEND = 0
	If $IEND < 1 Or $IEND > $IUBOUND Or $IEND = Default Then $IEND = $IUBOUND
	If $ISTART < 0 Or $ISTART = Default Then $ISTART = 0
	If $ISTART > $IEND Then Return SetError ( 2 , 0 , 0 )
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If $IPIVOT Then
			__ARRAYDUALPIVOTSORT ( $AARRAY , $ISTART , $IEND )
		Else
			__ARRAYQUICKSORT1D ( $AARRAY , $ISTART , $IEND )
		EndIf
		If $IDESCENDING Then _ARRAYREVERSE ( $AARRAY , $ISTART , $IEND )
	Case 2
		If $IPIVOT Then Return SetError ( 6 , 0 , 0 )
		Local $ISUBMAX = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
		If $ISUBITEM > $ISUBMAX Then Return SetError ( 3 , 0 , 0 )
		If $IDESCENDING Then
			$IDESCENDING = + 4294967295
		Else
			$IDESCENDING = 1
		EndIf
		__ARRAYQUICKSORT2D ( $AARRAY , $IDESCENDING , $ISTART , $IEND , $ISUBITEM , $ISUBMAX )
Case Else
		Return SetError ( 4 , 0 , 0 )
	EndSwitch
	Return 1
EndFunc
Func __ARRAYQUICKSORT1D ( ByRef $AARRAY , Const ByRef $ISTART , Const ByRef $IEND )
	If $IEND <= $ISTART Then Return
	Local $VTMP
	If ( $IEND - $ISTART ) < 15 Then
		Local $VCUR
		For $I = $ISTART + 1 To $IEND
			$VTMP = $AARRAY [ $I ]
			If IsNumber ( $VTMP ) Then
				For $J = $I + 4294967295 To $ISTART Step + 4294967295
					$VCUR = $AARRAY [ $J ]
					If ( $VTMP >= $VCUR And IsNumber ( $VCUR ) ) Or ( Not IsNumber ( $VCUR ) And StringCompare ( $VTMP , $VCUR ) >= 0 ) Then ExitLoop
					$AARRAY [ $J + 1 ] = $VCUR
				Next
			Else
				For $J = $I + 4294967295 To $ISTART Step + 4294967295
					If ( StringCompare ( $VTMP , $AARRAY [ $J ] ) >= 0 ) Then ExitLoop
					$AARRAY [ $J + 1 ] = $AARRAY [ $J ]
				Next
			EndIf
			$AARRAY [ $J + 1 ] = $VTMP
		Next
		Return
	EndIf
	Local $L = $ISTART , $R = $IEND , $VPIVOT = $AARRAY [ Int ( ( $ISTART + $IEND ) / 2 ) ] , $BNUM = IsNumber ( $VPIVOT )
	Do
		If $BNUM Then
			While ( $AARRAY [ $L ] < $VPIVOT And IsNumber ( $AARRAY [ $L ] ) ) Or ( Not IsNumber ( $AARRAY [ $L ] ) And StringCompare ( $AARRAY [ $L ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( $AARRAY [ $R ] > $VPIVOT And IsNumber ( $AARRAY [ $R ] ) ) Or ( Not IsNumber ( $AARRAY [ $R ] ) And StringCompare ( $AARRAY [ $R ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		Else
			While ( StringCompare ( $AARRAY [ $L ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( StringCompare ( $AARRAY [ $R ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		EndIf
		If $L <= $R Then
			$VTMP = $AARRAY [ $L ]
			$AARRAY [ $L ] = $AARRAY [ $R ]
			$AARRAY [ $R ] = $VTMP
			$L += 1
			$R -= 1
		EndIf
	Until $L > $R
	__ARRAYQUICKSORT1D ( $AARRAY , $ISTART , $R )
	__ARRAYQUICKSORT1D ( $AARRAY , $L , $IEND )
EndFunc
Func __ARRAYQUICKSORT2D ( ByRef $AARRAY , Const ByRef $ISTEP , Const ByRef $ISTART , Const ByRef $IEND , Const ByRef $ISUBITEM , Const ByRef $ISUBMAX )
	If $IEND <= $ISTART Then Return
	Local $VTMP , $L = $ISTART , $R = $IEND , $VPIVOT = $AARRAY [ Int ( ( $ISTART + $IEND ) / 2 ) ] [ $ISUBITEM ] , $BNUM = IsNumber ( $VPIVOT )
	Do
		If $BNUM Then
			While ( $ISTEP * ( $AARRAY [ $L ] [ $ISUBITEM ] - $VPIVOT ) < 0 And IsNumber ( $AARRAY [ $L ] [ $ISUBITEM ] ) ) Or ( Not IsNumber ( $AARRAY [ $L ] [ $ISUBITEM ] ) And $ISTEP * StringCompare ( $AARRAY [ $L ] [ $ISUBITEM ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( $ISTEP * ( $AARRAY [ $R ] [ $ISUBITEM ] - $VPIVOT ) > 0 And IsNumber ( $AARRAY [ $R ] [ $ISUBITEM ] ) ) Or ( Not IsNumber ( $AARRAY [ $R ] [ $ISUBITEM ] ) And $ISTEP * StringCompare ( $AARRAY [ $R ] [ $ISUBITEM ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		Else
			While ( $ISTEP * StringCompare ( $AARRAY [ $L ] [ $ISUBITEM ] , $VPIVOT ) < 0 )
				$L += 1
			WEnd
			While ( $ISTEP * StringCompare ( $AARRAY [ $R ] [ $ISUBITEM ] , $VPIVOT ) > 0 )
				$R -= 1
			WEnd
		EndIf
		If $L <= $R Then
			For $I = 0 To $ISUBMAX
				$VTMP = $AARRAY [ $L ] [ $I ]
				$AARRAY [ $L ] [ $I ] = $AARRAY [ $R ] [ $I ]
				$AARRAY [ $R ] [ $I ] = $VTMP
			Next
			$L += 1
			$R -= 1
		EndIf
	Until $L > $R
	__ARRAYQUICKSORT2D ( $AARRAY , $ISTEP , $ISTART , $R , $ISUBITEM , $ISUBMAX )
	__ARRAYQUICKSORT2D ( $AARRAY , $ISTEP , $L , $IEND , $ISUBITEM , $ISUBMAX )
EndFunc
Func __ARRAYDUALPIVOTSORT ( ByRef $AARRAY , $IPIVOT_LEFT , $IPIVOT_RIGHT , $BLEFTMOST = True )
	If $IPIVOT_LEFT > $IPIVOT_RIGHT Then Return
	Local $ILENGTH = $IPIVOT_RIGHT - $IPIVOT_LEFT + 1
	Local $I , $J , $K , $IAI , $IAK , $IA1 , $IA2 , $ILAST
	If $ILENGTH < 45 Then
		If $BLEFTMOST Then
			$I = $IPIVOT_LEFT
			While $I < $IPIVOT_RIGHT
				$J = $I
				$IAI = $AARRAY [ $I + 1 ]
				While $IAI < $AARRAY [ $J ]
					$AARRAY [ $J + 1 ] = $AARRAY [ $J ]
					$J -= 1
					If $J + 1 = $IPIVOT_LEFT Then ExitLoop
				WEnd
				$AARRAY [ $J + 1 ] = $IAI
				$I += 1
			WEnd
		Else
			While 1
				If $IPIVOT_LEFT >= $IPIVOT_RIGHT Then Return 1
				$IPIVOT_LEFT += 1
				If $AARRAY [ $IPIVOT_LEFT ] < $AARRAY [ $IPIVOT_LEFT + 4294967295 ] Then ExitLoop
			WEnd
			While 1
				$K = $IPIVOT_LEFT
				$IPIVOT_LEFT += 1
				If $IPIVOT_LEFT > $IPIVOT_RIGHT Then ExitLoop
				$IA1 = $AARRAY [ $K ]
				$IA2 = $AARRAY [ $IPIVOT_LEFT ]
				If $IA1 < $IA2 Then
					$IA2 = $IA1
					$IA1 = $AARRAY [ $IPIVOT_LEFT ]
				EndIf
				$K -= 1
				While $IA1 < $AARRAY [ $K ]
					$AARRAY [ $K + 2 ] = $AARRAY [ $K ]
					$K -= 1
				WEnd
				$AARRAY [ $K + 2 ] = $IA1
				While $IA2 < $AARRAY [ $K ]
					$AARRAY [ $K + 1 ] = $AARRAY [ $K ]
					$K -= 1
				WEnd
				$AARRAY [ $K + 1 ] = $IA2
				$IPIVOT_LEFT += 1
			WEnd
			$ILAST = $AARRAY [ $IPIVOT_RIGHT ]
			$IPIVOT_RIGHT -= 1
			While $ILAST < $AARRAY [ $IPIVOT_RIGHT ]
				$AARRAY [ $IPIVOT_RIGHT + 1 ] = $AARRAY [ $IPIVOT_RIGHT ]
				$IPIVOT_RIGHT -= 1
			WEnd
			$AARRAY [ $IPIVOT_RIGHT + 1 ] = $ILAST
		EndIf
		Return 1
	EndIf
	Local $ISEVENTH = BitShift ( $ILENGTH , 3 ) + BitShift ( $ILENGTH , 6 ) + 1
	Local $IE1 , $IE2 , $IE3 , $IE4 , $IE5 , $T
	$IE3 = Ceiling ( ( $IPIVOT_LEFT + $IPIVOT_RIGHT ) / 2 )
	$IE2 = $IE3 - $ISEVENTH
	$IE1 = $IE2 - $ISEVENTH
	$IE4 = $IE3 + $ISEVENTH
	$IE5 = $IE4 + $ISEVENTH
	If $AARRAY [ $IE2 ] < $AARRAY [ $IE1 ] Then
		$T = $AARRAY [ $IE2 ]
		$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
		$AARRAY [ $IE1 ] = $T
	EndIf
	If $AARRAY [ $IE3 ] < $AARRAY [ $IE2 ] Then
		$T = $AARRAY [ $IE3 ]
		$AARRAY [ $IE3 ] = $AARRAY [ $IE2 ]
		$AARRAY [ $IE2 ] = $T
		If $T < $AARRAY [ $IE1 ] Then
			$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
			$AARRAY [ $IE1 ] = $T
		EndIf
	EndIf
	If $AARRAY [ $IE4 ] < $AARRAY [ $IE3 ] Then
		$T = $AARRAY [ $IE4 ]
		$AARRAY [ $IE4 ] = $AARRAY [ $IE3 ]
		$AARRAY [ $IE3 ] = $T
		If $T < $AARRAY [ $IE2 ] Then
			$AARRAY [ $IE3 ] = $AARRAY [ $IE2 ]
			$AARRAY [ $IE2 ] = $T
			If $T < $AARRAY [ $IE1 ] Then
				$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
				$AARRAY [ $IE1 ] = $T
			EndIf
		EndIf
	EndIf
	If $AARRAY [ $IE5 ] < $AARRAY [ $IE4 ] Then
		$T = $AARRAY [ $IE5 ]
		$AARRAY [ $IE5 ] = $AARRAY [ $IE4 ]
		$AARRAY [ $IE4 ] = $T
		If $T < $AARRAY [ $IE3 ] Then
			$AARRAY [ $IE4 ] = $AARRAY [ $IE3 ]
			$AARRAY [ $IE3 ] = $T
			If $T < $AARRAY [ $IE2 ] Then
				$AARRAY [ $IE3 ] = $AARRAY [ $IE2 ]
				$AARRAY [ $IE2 ] = $T
				If $T < $AARRAY [ $IE1 ] Then
					$AARRAY [ $IE2 ] = $AARRAY [ $IE1 ]
					$AARRAY [ $IE1 ] = $T
				EndIf
			EndIf
		EndIf
	EndIf
	Local $ILESS = $IPIVOT_LEFT
	Local $IGREATER = $IPIVOT_RIGHT
	If ( ( $AARRAY [ $IE1 ] <> $AARRAY [ $IE2 ] ) And ( $AARRAY [ $IE2 ] <> $AARRAY [ $IE3 ] ) And ( $AARRAY [ $IE3 ] <> $AARRAY [ $IE4 ] ) And ( $AARRAY [ $IE4 ] <> $AARRAY [ $IE5 ] ) ) Then
		Local $IPIVOT_1 = $AARRAY [ $IE2 ]
		Local $IPIVOT_2 = $AARRAY [ $IE4 ]
		$AARRAY [ $IE2 ] = $AARRAY [ $IPIVOT_LEFT ]
		$AARRAY [ $IE4 ] = $AARRAY [ $IPIVOT_RIGHT ]
		Do
			$ILESS += 1
		Until $AARRAY [ $ILESS ] >= $IPIVOT_1
		Do
			$IGREATER -= 1
		Until $AARRAY [ $IGREATER ] <= $IPIVOT_2
		$K = $ILESS
		While $K <= $IGREATER
			$IAK = $AARRAY [ $K ]
			If $IAK < $IPIVOT_1 Then
				$AARRAY [ $K ] = $AARRAY [ $ILESS ]
				$AARRAY [ $ILESS ] = $IAK
				$ILESS += 1
			ElseIf $IAK > $IPIVOT_2 Then
				While $AARRAY [ $IGREATER ] > $IPIVOT_2
					$IGREATER -= 1
					If $IGREATER + 1 = $K Then ExitLoop 2
				WEnd
				If $AARRAY [ $IGREATER ] < $IPIVOT_1 Then
					$AARRAY [ $K ] = $AARRAY [ $ILESS ]
					$AARRAY [ $ILESS ] = $AARRAY [ $IGREATER ]
					$ILESS += 1
				Else
					$AARRAY [ $K ] = $AARRAY [ $IGREATER ]
				EndIf
				$AARRAY [ $IGREATER ] = $IAK
				$IGREATER -= 1
			EndIf
			$K += 1
		WEnd
		$AARRAY [ $IPIVOT_LEFT ] = $AARRAY [ $ILESS + 4294967295 ]
		$AARRAY [ $ILESS + 4294967295 ] = $IPIVOT_1
		$AARRAY [ $IPIVOT_RIGHT ] = $AARRAY [ $IGREATER + 1 ]
		$AARRAY [ $IGREATER + 1 ] = $IPIVOT_2
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IPIVOT_LEFT , $ILESS + 4294967294 , True )
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IGREATER + 2 , $IPIVOT_RIGHT , False )
		If ( $ILESS < $IE1 ) And ( $IE5 < $IGREATER ) Then
			While $AARRAY [ $ILESS ] = $IPIVOT_1
				$ILESS += 1
			WEnd
			While $AARRAY [ $IGREATER ] = $IPIVOT_2
				$IGREATER -= 1
			WEnd
			$K = $ILESS
			While $K <= $IGREATER
				$IAK = $AARRAY [ $K ]
				If $IAK = $IPIVOT_1 Then
					$AARRAY [ $K ] = $AARRAY [ $ILESS ]
					$AARRAY [ $ILESS ] = $IAK
					$ILESS += 1
				ElseIf $IAK = $IPIVOT_2 Then
					While $AARRAY [ $IGREATER ] = $IPIVOT_2
						$IGREATER -= 1
						If $IGREATER + 1 = $K Then ExitLoop 2
					WEnd
					If $AARRAY [ $IGREATER ] = $IPIVOT_1 Then
						$AARRAY [ $K ] = $AARRAY [ $ILESS ]
						$AARRAY [ $ILESS ] = $IPIVOT_1
						$ILESS += 1
					Else
						$AARRAY [ $K ] = $AARRAY [ $IGREATER ]
					EndIf
					$AARRAY [ $IGREATER ] = $IAK
					$IGREATER -= 1
				EndIf
				$K += 1
			WEnd
		EndIf
		__ARRAYDUALPIVOTSORT ( $AARRAY , $ILESS , $IGREATER , False )
	Else
		Local $IPIVOT = $AARRAY [ $IE3 ]
		$K = $ILESS
		While $K <= $IGREATER
			If $AARRAY [ $K ] = $IPIVOT Then
				$K += 1
				ContinueLoop
			EndIf
			$IAK = $AARRAY [ $K ]
			If $IAK < $IPIVOT Then
				$AARRAY [ $K ] = $AARRAY [ $ILESS ]
				$AARRAY [ $ILESS ] = $IAK
				$ILESS += 1
			Else
				While $AARRAY [ $IGREATER ] > $IPIVOT
					$IGREATER -= 1
				WEnd
				If $AARRAY [ $IGREATER ] < $IPIVOT Then
					$AARRAY [ $K ] = $AARRAY [ $ILESS ]
					$AARRAY [ $ILESS ] = $AARRAY [ $IGREATER ]
					$ILESS += 1
				Else
					$AARRAY [ $K ] = $IPIVOT
				EndIf
				$AARRAY [ $IGREATER ] = $IAK
				$IGREATER -= 1
			EndIf
			$K += 1
		WEnd
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IPIVOT_LEFT , $ILESS + 4294967295 , True )
		__ARRAYDUALPIVOTSORT ( $AARRAY , $IGREATER + 1 , $IPIVOT_RIGHT , False )
	EndIf
EndFunc
Func _ARRAYSWAP ( ByRef $AARRAY , $IINDEX_1 , $IINDEX_2 , $BCOL = False , $ISTART = + 4294967295 , $IEND = + 4294967295 )
	If $BCOL = Default Then $BCOL = False
	If $ISTART = Default Then $ISTART = + 4294967295
	If $IEND = Default Then $IEND = + 4294967295
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
	If $IDIM_2 = + 4294967295 Then
		$BCOL = False
		$ISTART = + 4294967295
		$IEND = + 4294967295
	EndIf
	If $ISTART > $IEND Then Return SetError ( 5 , 0 , + 4294967295 )
	If $BCOL Then
		If $IINDEX_1 < 0 Or $IINDEX_2 > $IDIM_2 Then Return SetError ( 3 , 0 , + 4294967295 )
		If $ISTART = + 4294967295 Then $ISTART = 0
		If $IEND = + 4294967295 Then $IEND = $IDIM_1
	Else
		If $IINDEX_1 < 0 Or $IINDEX_2 > $IDIM_1 Then Return SetError ( 3 , 0 , + 4294967295 )
		If $ISTART = + 4294967295 Then $ISTART = 0
		If $IEND = + 4294967295 Then $IEND = $IDIM_2
	EndIf
	Local $VTMP
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		$VTMP = $AARRAY [ $IINDEX_1 ]
		$AARRAY [ $IINDEX_1 ] = $AARRAY [ $IINDEX_2 ]
		$AARRAY [ $IINDEX_2 ] = $VTMP
	Case 2
		If $ISTART < + 4294967295 Or $IEND < + 4294967295 Then Return SetError ( 4 , 0 , + 4294967295 )
		If $BCOL Then
			If $ISTART > $IDIM_1 Or $IEND > $IDIM_1 Then Return SetError ( 4 , 0 , + 4294967295 )
			For $J = $ISTART To $IEND
				$VTMP = $AARRAY [ $J ] [ $IINDEX_1 ]
				$AARRAY [ $J ] [ $IINDEX_1 ] = $AARRAY [ $J ] [ $IINDEX_2 ]
				$AARRAY [ $J ] [ $IINDEX_2 ] = $VTMP
			Next
		Else
			If $ISTART > $IDIM_2 Or $IEND > $IDIM_2 Then Return SetError ( 4 , 0 , + 4294967295 )
			For $J = $ISTART To $IEND
				$VTMP = $AARRAY [ $IINDEX_1 ] [ $J ]
				$AARRAY [ $IINDEX_1 ] [ $J ] = $AARRAY [ $IINDEX_2 ] [ $J ]
				$AARRAY [ $IINDEX_2 ] [ $J ] = $VTMP
			Next
		EndIf
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return 1
EndFunc
Func _ARRAYTOCLIP ( Const ByRef $AARRAY , $SDELIM_COL = "|" , $ISTART_ROW = + 4294967295 , $IEND_ROW = + 4294967295 , $SDELIM_ROW = @CRLF , $ISTART_COL = + 4294967295 , $IEND_COL = + 4294967295 )
	Local $SRESULT = _ARRAYTOSTRING ( $AARRAY , $SDELIM_COL , $ISTART_ROW , $IEND_ROW , $SDELIM_ROW , $ISTART_COL , $IEND_COL )
	If @error Then Return SetError ( @error , 0 , 0 )
	If ClipPut ( $SRESULT ) Then Return 1
	Return SetError ( + 4294967295 , 0 , 0 )
EndFunc
Func _ARRAYTOSTRING ( Const ByRef $AARRAY , $SDELIM_COL = "|" , $ISTART_ROW = Default , $IEND_ROW = Default , $SDELIM_ROW = @CRLF , $ISTART_COL = Default , $IEND_COL = Default )
	If $SDELIM_COL = Default Then $SDELIM_COL = "|"
	If $SDELIM_ROW = Default Then $SDELIM_ROW = @CRLF
	If $ISTART_ROW = Default Then $ISTART_ROW = + 4294967295
	If $IEND_ROW = Default Then $IEND_ROW = + 4294967295
	If $ISTART_COL = Default Then $ISTART_COL = + 4294967295
	If $IEND_COL = Default Then $IEND_COL = + 4294967295
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	If $IDIM_1 = + 4294967295 Then Return ""
	If $ISTART_ROW = + 4294967295 Then $ISTART_ROW = 0
	If $IEND_ROW = + 4294967295 Then $IEND_ROW = $IDIM_1
	If $ISTART_ROW < + 4294967295 Or $IEND_ROW < + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART_ROW > $IDIM_1 Or $IEND_ROW > $IDIM_1 Then Return SetError ( 3 , 0 , "" )
	If $ISTART_ROW > $IEND_ROW Then Return SetError ( 4 , 0 , + 4294967295 )
	Local $SRET = ""
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		For $I = $ISTART_ROW To $IEND_ROW
			$SRET &= $AARRAY [ $I ] & $SDELIM_COL
		Next
		Return StringTrimRight ( $SRET , StringLen ( $SDELIM_COL ) )
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
		If $IDIM_2 = + 4294967295 Then Return ""
		If $ISTART_COL = + 4294967295 Then $ISTART_COL = 0
		If $IEND_COL = + 4294967295 Then $IEND_COL = $IDIM_2
		If $ISTART_COL < + 4294967295 Or $IEND_COL < + 4294967295 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $ISTART_COL > $IDIM_2 Or $IEND_COL > $IDIM_2 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $ISTART_COL > $IEND_COL Then Return SetError ( 6 , 0 , + 4294967295 )
		Local $IDELIMCOLLEN = StringLen ( $SDELIM_COL )
		For $I = $ISTART_ROW To $IEND_ROW
			For $J = $ISTART_COL To $IEND_COL
				$SRET &= $AARRAY [ $I ] [ $J ] & $SDELIM_COL
			Next
			$SRET = StringTrimRight ( $SRET , $IDELIMCOLLEN ) & $SDELIM_ROW
		Next
		Return StringTrimRight ( $SRET , StringLen ( $SDELIM_ROW ) )
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return 1
EndFunc
Func _ARRAYTRANSPOSE ( ByRef $AARRAY , $BFORCE1D = False )
	Local $ATEMP
	Switch $BFORCE1D
	Case Default
		$BFORCE1D = False
	Case True , False
Case Else
		Return SetError ( 3 , 0 , 0 )
	EndSwitch
	Switch UBound ( $AARRAY , 0 )
	Case 0
		Return SetError ( 2 , 0 , 0 )
	Case 1
		Local $ATEMP [ 1 ] [ UBound ( $AARRAY ) ]
		For $I = 0 To UBound ( $AARRAY ) + 4294967295
			$ATEMP [ 0 ] [ $I ] = $AARRAY [ $I ]
		Next
		$AARRAY = $ATEMP
	Case 2
		Local $IDIM_1 = UBound ( $AARRAY , 1 ) , $IDIM_2 = UBound ( $AARRAY , 2 )
		If $IDIM_1 <> $IDIM_2 Then
			Local $ATEMP [ $IDIM_2 ] [ $IDIM_1 ]
			For $I = 0 To $IDIM_1 + 4294967295
				For $J = 0 To $IDIM_2 + 4294967295
					$ATEMP [ $J ] [ $I ] = $AARRAY [ $I ] [ $J ]
				Next
			Next
			$AARRAY = $ATEMP
		Else
			Local $VELEMENT
			For $I = 0 To $IDIM_1 + 4294967295
				For $J = $I + 1 To $IDIM_2 + 4294967295
					$VELEMENT = $AARRAY [ $I ] [ $J ]
					$AARRAY [ $I ] [ $J ] = $AARRAY [ $J ] [ $I ]
					$AARRAY [ $J ] [ $I ] = $VELEMENT
				Next
			Next
		EndIf
		If $BFORCE1D = True And UBound ( $AARRAY , 2 ) = 1 Then
			$ATEMP = $AARRAY
			ReDim $AARRAY [ UBound ( $ATEMP ) ]
			For $I = 0 To UBound ( $ATEMP ) + 4294967295
				$AARRAY [ $I ] = $ATEMP [ $I ] [ 0 ]
			Next
		EndIf
Case Else
		Return SetError ( 1 , 0 , 0 )
	EndSwitch
	Return 1
EndFunc
Func _ARRAYTRIM ( ByRef $AARRAY , $ITRIMNUM , $IDIRECTION = 0 , $ISTART = 0 , $IEND = 0 , $ISUBITEM = 0 )
	If $IDIRECTION = Default Then $IDIRECTION = 0
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ISUBITEM = Default Then $ISUBITEM = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , 0 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	If $IEND = 0 Then $IEND = $IDIM_1
	If $ISTART > $IEND Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART < 0 Or $IEND < 0 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART > $IDIM_1 Or $IEND > $IDIM_1 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If $IDIRECTION Then
			For $I = $ISTART To $IEND
				$AARRAY [ $I ] = StringTrimRight ( $AARRAY [ $I ] , $ITRIMNUM )
			Next
		Else
			For $I = $ISTART To $IEND
				$AARRAY [ $I ] = StringTrimLeft ( $AARRAY [ $I ] , $ITRIMNUM )
			Next
		EndIf
	Case 2
		Local $IDIM_2 = UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
		If $ISUBITEM < 0 Or $ISUBITEM > $IDIM_2 Then Return SetError ( 5 , 0 , + 4294967295 )
		If $IDIRECTION Then
			For $I = $ISTART To $IEND
				$AARRAY [ $I ] [ $ISUBITEM ] = StringTrimRight ( $AARRAY [ $I ] [ $ISUBITEM ] , $ITRIMNUM )
			Next
		Else
			For $I = $ISTART To $IEND
				$AARRAY [ $I ] [ $ISUBITEM ] = StringTrimLeft ( $AARRAY [ $I ] [ $ISUBITEM ] , $ITRIMNUM )
			Next
		EndIf
Case Else
		Return SetError ( 2 , 0 , 0 )
	EndSwitch
	Return 1
EndFunc
Func _ARRAYUNIQUE ( Const ByRef $AARRAY , $ICOLUMN = 0 , $IBASE = 0 , $ICASE = 0 , $ICOUNT = $ARRAYUNIQUE_COUNT , $IINTTYPE = $ARRAYUNIQUE_AUTO )
	If $ICOLUMN = Default Then $ICOLUMN = 0
	If $IBASE = Default Then $IBASE = 0
	If $ICASE = Default Then $ICASE = 0
	If $ICOUNT = Default Then $ICOUNT = $ARRAYUNIQUE_COUNT
	If $IINTTYPE = Default Then $IINTTYPE = $ARRAYUNIQUE_AUTO
	If UBound ( $AARRAY , $UBOUND_ROWS ) = 0 Then Return SetError ( 1 , 0 , 0 )
	Local $IDIMS = UBound ( $AARRAY , $UBOUND_DIMENSIONS ) , $INUMCOLUMNS = UBound ( $AARRAY , $UBOUND_COLUMNS )
	If $IDIMS > 2 Then Return SetError ( 2 , 0 , 0 )
	If $IBASE < 0 Or $IBASE > 1 Or ( Not IsInt ( $IBASE ) ) Then Return SetError ( 3 , 0 , 0 )
	If $ICASE < 0 Or $ICASE > 1 Or ( Not IsInt ( $ICASE ) ) Then Return SetError ( 3 , 0 , 0 )
	If $ICOUNT < 0 Or $ICOUNT > 1 Or ( Not IsInt ( $ICOUNT ) ) Then Return SetError ( 4 , 0 , 0 )
	If $IINTTYPE < 0 Or $IINTTYPE > 4 Or ( Not IsInt ( $IINTTYPE ) ) Then Return SetError ( 5 , 0 , 0 )
	If $ICOLUMN < 0 Or ( $INUMCOLUMNS = 0 And $ICOLUMN > 0 ) Or ( $INUMCOLUMNS > 0 And $ICOLUMN >= $INUMCOLUMNS ) Then Return SetError ( 6 , 0 , 0 )
	If $IINTTYPE = $ARRAYUNIQUE_AUTO Then
		Local $BINT , $SVARTYPE
		If $IDIMS = 1 Then
			$BINT = IsInt ( $AARRAY [ $IBASE ] )
			$SVARTYPE = VarGetType ( $AARRAY [ $IBASE ] )
		Else
			$BINT = IsInt ( $AARRAY [ $IBASE ] [ $ICOLUMN ] )
			$SVARTYPE = VarGetType ( $AARRAY [ $IBASE ] [ $ICOLUMN ] )
		EndIf
		If $BINT And $SVARTYPE = "Int64" Then
			$IINTTYPE = $ARRAYUNIQUE_FORCE64
		Else
			$IINTTYPE = $ARRAYUNIQUE_FORCE32
		EndIf
	EndIf
	ObjEvent ( "AutoIt.Error" , __ARRAYUNIQUE_AUTOERRFUNC )
	Local $ODICTIONARY = ObjCreate ( "Scripting.Dictionary" )
	$ODICTIONARY .CompareMode = Number ( Not $ICASE )
	Local $VELEM , $STYPE , $VKEY , $BCOMERROR = False
	For $I = $IBASE To UBound ( $AARRAY ) + 4294967295
		If $IDIMS = 1 Then
			$VELEM = $AARRAY [ $I ]
		Else
			$VELEM = $AARRAY [ $I ] [ $ICOLUMN ]
		EndIf
		Switch $IINTTYPE
		Case $ARRAYUNIQUE_FORCE32
			$ODICTIONARY .Item ( $VELEM )
			If @error Then
				$BCOMERROR = True
				ExitLoop
			EndIf
		Case $ARRAYUNIQUE_FORCE64
			$STYPE = VarGetType ( $VELEM )
			If $STYPE = "Int32" Then
				$BCOMERROR = True
				ExitLoop
			EndIf
			$VKEY = "#" & $STYPE & "#" & String ( $VELEM )
			If Not $ODICTIONARY .Item ( $VKEY ) Then
				$ODICTIONARY ( $VKEY ) = $VELEM
			EndIf
		Case $ARRAYUNIQUE_MATCH
			$STYPE = VarGetType ( $VELEM )
			If StringLeft ( $STYPE , 3 ) = "Int" Then
				$VKEY = "#Int#" & String ( $VELEM )
			Else
				$VKEY = "#" & $STYPE & "#" & String ( $VELEM )
			EndIf
			If Not $ODICTIONARY .Item ( $VKEY ) Then
				$ODICTIONARY ( $VKEY ) = $VELEM
			EndIf
		Case $ARRAYUNIQUE_DISTINCT
			$VKEY = "#" & VarGetType ( $VELEM ) & "#" & String ( $VELEM )
			If Not $ODICTIONARY .Item ( $VKEY ) Then
				$ODICTIONARY ( $VKEY ) = $VELEM
			EndIf
		EndSwitch
	Next
	Local $AVALUES , $J = 0
	If $BCOMERROR Then
		Return SetError ( 7 , 0 , 0 )
	ElseIf $IINTTYPE <> $ARRAYUNIQUE_FORCE32 Then
		Local $AVALUES [ $ODICTIONARY .Count ]
		For $VKEY In $ODICTIONARY .Keys ( )
			$AVALUES [ $J ] = $ODICTIONARY ( $VKEY )
			If StringLeft ( $VKEY , 5 ) = "#Ptr#" Then
				$AVALUES [ $J ] = Ptr ( $AVALUES [ $J ] )
			EndIf
			$J += 1
		Next
	Else
		$AVALUES = $ODICTIONARY .Keys ( )
	EndIf
	If $ICOUNT Then
		_ARRAYINSERT ( $AVALUES , 0 , $ODICTIONARY .Count )
	EndIf
	Return $AVALUES
EndFunc
Func _ARRAY1DTOHISTOGRAM ( $AARRAY , $ISIZING = 100 )
	If UBound ( $AARRAY , 0 ) > 1 Then Return SetError ( 1 , 0 , "" )
	$ISIZING = $ISIZING * 8
	Local $T , $N , $IMIN = 0 , $IMAX = 0 , $IOFFSET = 0
	For $I = 0 To UBound ( $AARRAY ) + 4294967295
		$T = $AARRAY [ $I ]
		$T = IsNumber ( $T ) ? Round ( $T ) : 0
		If $T < $IMIN Then $IMIN = $T
		If $T > $IMAX Then $IMAX = $T
	Next
	Local $IRANGE = Int ( Round ( ( $IMAX - $IMIN ) / 8 ) ) * 8
	Local $ISPACERATIO = 4
	For $I = 0 To UBound ( $AARRAY ) + 4294967295
		$T = $AARRAY [ $I ]
		If $T Then
			$N = Abs ( Round ( ( $ISIZING * $T ) / $IRANGE ) / 8 )
			$AARRAY [ $I ] = ""
			If $T > 0 Then
				If $IMIN Then
					$IOFFSET = Int ( Abs ( Round ( ( $ISIZING * $IMIN ) / $IRANGE ) / 8 ) / 8 * $ISPACERATIO )
					$AARRAY [ $I ] = __ARRAY_STRINGREPEAT ( ChrW ( 32 ) , $IOFFSET )
				EndIf
			Else
				If $IMIN <> $T Then
					$IOFFSET = Int ( Abs ( Round ( ( $ISIZING * ( $T - $IMIN ) ) / $IRANGE ) / 8 ) / 8 * $ISPACERATIO )
					$AARRAY [ $I ] = __ARRAY_STRINGREPEAT ( ChrW ( 32 ) , $IOFFSET )
				EndIf
			EndIf
			$AARRAY [ $I ] &= __ARRAY_STRINGREPEAT ( ChrW ( 9608 ) , Int ( $N / 8 ) )
			$N = Mod ( $N , 8 )
			If $N > 0 Then $AARRAY [ $I ] &= ChrW ( 9608 + 8 - $N )
			$AARRAY [ $I ] &= " " & $T
		Else
			$AARRAY [ $I ] = ""
		EndIf
	Next
	Return $AARRAY
EndFunc
Func _ARRAY2DCREATE ( $AARRAY1 , $AARRAY2 )
	If Not IsArray ( $AARRAY1 ) Or Not IsArray ( $AARRAY2 ) Then Return SetError ( 3 , 0 , "" )
	Local $IDIM1 = UBound ( $AARRAY1 , $UBOUND_DIMENSIONS ) , $IDIM2 = UBound ( $AARRAY2 , $UBOUND_DIMENSIONS )
	If $IDIM1 > 2 Or $IDIM2 > 2 Then Return SetError ( 1 , 0 , "" )
	Local $NROWS = UBound ( $AARRAY1 , $UBOUND_ROWS )
	If $NROWS <> UBound ( $AARRAY2 , $UBOUND_ROWS ) Then Return SetError ( 2 , 0 , "" )
	Local $NCOLS1 = ( $IDIM1 = 1 ? 1 : UBound ( $AARRAY1 , $UBOUND_COLUMNS ) )
	Local $NCOLS2 = ( $IDIM2 = 1 ? 1 : UBound ( $AARRAY2 , $UBOUND_COLUMNS ) )
	Local $ATMP [ $NROWS ] [ $NCOLS1 + $NCOLS2 ]
	Select
	Case $IDIM1 = 1 And $IDIM2 = 1
		For $I = 0 To $NROWS + 4294967295
			$ATMP [ $I ] [ 0 ] = $AARRAY1 [ $I ]
			$ATMP [ $I ] [ 1 ] = $AARRAY2 [ $I ]
		Next
	Case $IDIM1 = 1 And $IDIM2 = 2
		For $I = 0 To $NROWS + 4294967295
			$ATMP [ $I ] [ 0 ] = $AARRAY1 [ $I ]
		Next
		For $J = 1 To $NCOLS2
			For $I = 0 To $NROWS + 4294967295
				$ATMP [ $I ] [ $J ] = $AARRAY2 [ $I ] [ $J + 4294967295 ]
			Next
		Next
	Case $IDIM1 = 2 And $IDIM2 = 1
		For $J = 0 To $NCOLS1 + 4294967295
			For $I = 0 To $NROWS + 4294967295
				$ATMP [ $I ] [ $J ] = $AARRAY1 [ $I ] [ $J ]
			Next
		Next
		For $I = 0 To $NROWS + 4294967295
			$ATMP [ $I ] [ $NCOLS1 ] = $AARRAY2 [ $I ]
		Next
	Case $IDIM1 = 2 And $IDIM2 = 2
		For $J = 0 To $NCOLS1 + 4294967295
			For $I = 0 To $NROWS + 4294967295
				$ATMP [ $I ] [ $J ] = $AARRAY1 [ $I ] [ $J ]
			Next
		Next
		For $J = $NCOLS1 To ( $NCOLS1 + $NCOLS2 ) + 4294967295
			For $I = 0 To $NROWS + 4294967295
				$ATMP [ $I ] [ $J ] = $AARRAY2 [ $I ] [ $J - $NCOLS1 ]
			Next
		Next
	EndSelect
	Return $ATMP
EndFunc
Func __ARRAY_STRINGREPEAT ( $SSTRING , $IREPEATCOUNT )
	$IREPEATCOUNT = Int ( $IREPEATCOUNT )
	If StringLen ( $SSTRING ) < 1 Or $IREPEATCOUNT <= 0 Then Return SetError ( 1 , 0 , "" )
	Local $SRESULT = ""
	While $IREPEATCOUNT > 1
		If BitAND ( $IREPEATCOUNT , 1 ) Then $SRESULT &= $SSTRING
		$SSTRING &= $SSTRING
		$IREPEATCOUNT = BitShift ( $IREPEATCOUNT , 1 )
	WEnd
	Return $SSTRING & $SRESULT
EndFunc
Func __ARRAY_EXETERINTERNAL ( ByRef $AARRAY , $ISTART , $ISIZE , $SDELIMITER , ByRef $AIDX , ByRef $ARESULT , ByRef $ICOUNT )
	If $ISTART == $ISIZE + 4294967295 Then
		For $I = 0 To $ISIZE + 4294967295
			$ARESULT [ $ICOUNT ] &= $AARRAY [ $AIDX [ $I ] ] & $SDELIMITER
		Next
		If $SDELIMITER <> "" Then $ARESULT [ $ICOUNT ] = StringTrimRight ( $ARESULT [ $ICOUNT ] , StringLen ( $SDELIMITER ) )
		$ICOUNT += 1
	Else
		Local $ITEMP
		For $I = $ISTART To $ISIZE + 4294967295
			$ITEMP = $AIDX [ $I ]
			$AIDX [ $I ] = $AIDX [ $ISTART ]
			$AIDX [ $ISTART ] = $ITEMP
			__ARRAY_EXETERINTERNAL ( $AARRAY , $ISTART + 1 , $ISIZE , $SDELIMITER , $AIDX , $ARESULT , $ICOUNT )
			$AIDX [ $ISTART ] = $AIDX [ $I ]
			$AIDX [ $I ] = $ITEMP
		Next
	EndIf
EndFunc
Func __ARRAY_COMBINATIONS ( $IN , $IR )
	Local $I_TOTAL = 1
	For $I = $IR To 1 Step + 4294967295
		$I_TOTAL *= ( $IN / $I )
		$IN -= 1
	Next
	Return Round ( $I_TOTAL )
EndFunc
Func __ARRAY_GETNEXT ( $IN , $IR , ByRef $ILEFT , $ITOTAL , ByRef $AIDX )
	If $ILEFT == $ITOTAL Then
		$ILEFT -= 1
		Return
	EndIf
	Local $I = $IR + 4294967295
	While $AIDX [ $I ] == $IN - $IR + $I
		$I -= 1
	WEnd
	$AIDX [ $I ] += 1
	For $J = $I + 1 To $IR + 4294967295
		$AIDX [ $J ] = $AIDX [ $I ] + $J - $I
	Next
	$ILEFT -= 1
EndFunc
Func __ARRAY_MINMAXINDEX ( Const ByRef $AARRAY , $ICOMPNUMERIC , $ISTART , $IEND , $ISUBITEM , $FUCOMPARISON )
	If $ICOMPNUMERIC = Default Then $ICOMPNUMERIC = 0
	If $ICOMPNUMERIC <> 1 Then $ICOMPNUMERIC = 0
	If $ISTART = Default Then $ISTART = 0
	If $IEND = Default Then $IEND = 0
	If $ISUBITEM = Default Then $ISUBITEM = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $IDIM_1 = UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
	If $IDIM_1 < 0 Then Return SetError ( 1 , 0 , + 4294967295 )
	If $IEND = + 4294967295 Then $IEND = $IDIM_1
	If $ISTART = + 4294967295 Then $ISTART = 0
	If $ISTART < + 4294967295 Or $IEND < + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART > $IDIM_1 Or $IEND > $IDIM_1 Then Return SetError ( 3 , 0 , + 4294967295 )
	If $ISTART > $IEND Then Return SetError ( 4 , 0 , + 4294967295 )
	If $IDIM_1 < 0 Then Return SetError ( 5 , 0 , + 4294967295 )
	Local $IMAXMININDEX = $ISTART
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		If $ICOMPNUMERIC Then
			For $I = $ISTART To $IEND
				If $FUCOMPARISON ( Number ( $AARRAY [ $I ] ) , Number ( $AARRAY [ $IMAXMININDEX ] ) ) Then $IMAXMININDEX = $I
			Next
		Else
			For $I = $ISTART To $IEND
				If $FUCOMPARISON ( $AARRAY [ $I ] , $AARRAY [ $IMAXMININDEX ] ) Then $IMAXMININDEX = $I
			Next
		EndIf
	Case 2
		If $ISUBITEM < 0 Or $ISUBITEM > UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295 Then Return SetError ( 6 , 0 , + 4294967295 )
		If $ICOMPNUMERIC Then
			For $I = $ISTART To $IEND
				If $FUCOMPARISON ( Number ( $AARRAY [ $I ] [ $ISUBITEM ] ) , Number ( $AARRAY [ $IMAXMININDEX ] [ $ISUBITEM ] ) ) Then $IMAXMININDEX = $I
			Next
		Else
			For $I = $ISTART To $IEND
				If $FUCOMPARISON ( $AARRAY [ $I ] [ $ISUBITEM ] , $AARRAY [ $IMAXMININDEX ] [ $ISUBITEM ] ) Then $IMAXMININDEX = $I
			Next
		EndIf
Case Else
		Return SetError ( 2 , 0 , + 4294967295 )
	EndSwitch
	Return $IMAXMININDEX
EndFunc
Func __ARRAY_GREATERTHAN ( $VVALUE1 , $VVALUE2 )
	Return $VVALUE1 > $VVALUE2
EndFunc
Func __ARRAY_LESSTHAN ( $VVALUE1 , $VVALUE2 )
	Return $VVALUE1 < $VVALUE2
EndFunc
Func __ARRAYUNIQUE_AUTOERRFUNC ( )
EndFunc
Global Const $GMEM_FIXED = 0
Global Const $GMEM_MOVEABLE = 2
Global Const $GMEM_NOCOMPACT = 16
Global Const $GMEM_NODISCARD = 32
Global Const $GMEM_ZEROINIT = 64
Global Const $GMEM_MODIFY = 128
Global Const $GMEM_DISCARDABLE = 256
Global Const $GMEM_NOT_BANKED = 4096
Global Const $GMEM_SHARE = 8192
Global Const $GMEM_DDESHARE = 8192
Global Const $GMEM_NOTIFY = 16384
Global Const $GMEM_LOWER = 4096
Global Const $GMEM_VALID_FLAGS = 32626
Global Const $GMEM_INVALID_HANDLE = 32768
Global Const $GPTR = BitOR ( $GMEM_FIXED , $GMEM_ZEROINIT )
Global Const $GHND = BitOR ( $GMEM_MOVEABLE , $GMEM_ZEROINIT )
Global Const $MEM_COMMIT = 4096
Global Const $MEM_RESERVE = 8192
Global Const $MEM_TOP_DOWN = 1048576
Global Const $MEM_SHARED = 134217728
Global Const $PAGE_NOACCESS = 1
Global Const $PAGE_READONLY = 2
Global Const $PAGE_READWRITE = 4
Global Const $PAGE_EXECUTE = 16
Global Const $PAGE_EXECUTE_READ = 32
Global Const $PAGE_EXECUTE_READWRITE = 64
Global Const $PAGE_EXECUTE_WRITECOPY = 128
Global Const $PAGE_GUARD = 256
Global Const $PAGE_NOCACHE = 512
Global Const $PAGE_WRITECOMBINE = 1024
Global Const $PAGE_WRITECOPY = 8
Global Const $MEM_DECOMMIT = 16384
Global Const $MEM_RELEASE = 32768
Global Enum $MEM_LOAD , $MEM_TOTALPHYSRAM , $MEM_AVAILPHYSRAM , $MEM_TOTALPAGEFILE , $MEM_AVAILPAGEFILE , $MEM_TOTALVIRTUAL , $MEM_AVAILVIRTUAL
Global Const $PROCESS_TERMINATE = 1
Global Const $PROCESS_CREATE_THREAD = 2
Global Const $PROCESS_SET_SESSIONID = 4
Global Const $PROCESS_VM_OPERATION = 8
Global Const $PROCESS_VM_READ = 16
Global Const $PROCESS_VM_WRITE = 32
Global Const $PROCESS_DUP_HANDLE = 64
Global Const $PROCESS_CREATE_PROCESS = 128
Global Const $PROCESS_SET_QUOTA = 256
Global Const $PROCESS_SET_INFORMATION = 512
Global Const $PROCESS_QUERY_INFORMATION = 1024
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 4096
Global Const $PROCESS_SUSPEND_RESUME = 2048
Global Const $PROCESS_ALL_ACCESS = 2035711
Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
Global Const $SE_AUDIT_NAME = "SeAuditPrivilege"
Global Const $SE_BACKUP_NAME = "SeBackupPrivilege"
Global Const $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
Global Const $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
Global Const $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
Global Const $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = "SeCreateSymbolicLinkPrivilege"
Global Const $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Const $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
Global Const $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
Global Const $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
Global Const $SE_INC_WORKING_SET_NAME = "SeIncreaseWorkingSetPrivilege"
Global Const $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
Global Const $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
Global Const $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
Global Const $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
Global Const $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
Global Const $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
Global Const $SE_RELABEL_NAME = "SeRelabelPrivilege"
Global Const $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
Global Const $SE_RESTORE_NAME = "SeRestorePrivilege"
Global Const $SE_SECURITY_NAME = "SeSecurityPrivilege"
Global Const $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
Global Const $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
Global Const $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
Global Const $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
Global Const $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
Global Const $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
Global Const $SE_TCB_NAME = "SeTcbPrivilege"
Global Const $SE_TIME_ZONE_NAME = "SeTimeZonePrivilege"
Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege"
Global Const $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
Global Const $SE_UNDOCK_NAME = "SeUndockPrivilege"
Global Const $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 1
Global Const $SE_PRIVILEGE_ENABLED = 2
Global Const $SE_PRIVILEGE_REMOVED = 4
Global Const $SE_PRIVILEGE_USED_FOR_ACCESS = 2147483648
Global Const $SE_GROUP_MANDATORY = 1
Global Const $SE_GROUP_ENABLED_BY_DEFAULT = 2
Global Const $SE_GROUP_ENABLED = 4
Global Const $SE_GROUP_OWNER = 8
Global Const $SE_GROUP_USE_FOR_DENY_ONLY = 16
Global Const $SE_GROUP_INTEGRITY = 32
Global Const $SE_GROUP_INTEGRITY_ENABLED = 64
Global Const $SE_GROUP_RESOURCE = 536870912
Global Const $SE_GROUP_LOGON_ID = 3221225472
Global Enum $TOKENPRIMARY = 1 , $TOKENIMPERSONATION
Global Enum $SECURITYANONYMOUS = 0 , $SECURITYIDENTIFICATION , $SECURITYIMPERSONATION , $SECURITYDELEGATION
Global Enum $TOKENUSER = 1 , $TOKENGROUPS , $TOKENPRIVILEGES , $TOKENOWNER , $TOKENPRIMARYGROUP , $TOKENDEFAULTDACL , $TOKENSOURCE , $TOKENTYPE , $TOKENIMPERSONATIONLEVEL , $TOKENSTATISTICS , $TOKENRESTRICTEDSIDS , $TOKENSESSIONID , $TOKENGROUPSANDPRIVILEGES , $TOKENSESSIONREFERENCE , $TOKENSANDBOXINERT , $TOKENAUDITPOLICY , $TOKENORIGIN , $TOKENELEVATIONTYPE , $TOKENLINKEDTOKEN , $TOKENELEVATION , $TOKENHASRESTRICTIONS , $TOKENACCESSINFORMATION , $TOKENVIRTUALIZATIONALLOWED , $TOKENVIRTUALIZATIONENABLED , $TOKENINTEGRITYLEVEL , $TOKENUIACCESS , $TOKENMANDATORYPOLICY , $TOKENLOGONSID
Global Const $TOKEN_ASSIGN_PRIMARY = 1
Global Const $TOKEN_DUPLICATE = 2
Global Const $TOKEN_IMPERSONATE = 4
Global Const $TOKEN_QUERY = 8
Global Const $TOKEN_QUERY_SOURCE = 16
Global Const $TOKEN_ADJUST_PRIVILEGES = 32
Global Const $TOKEN_ADJUST_GROUPS = 64
Global Const $TOKEN_ADJUST_DEFAULT = 128
Global Const $TOKEN_ADJUST_SESSIONID = 256
Global Const $TOKEN_ALL_ACCESS = 983551
Global Const $TOKEN_READ = 131080
Global Const $TOKEN_WRITE = 131296
Global Const $TOKEN_EXECUTE = 131072
Global Const $TOKEN_HAS_TRAVERSE_PRIVILEGE = 1
Global Const $TOKEN_HAS_BACKUP_PRIVILEGE = 2
Global Const $TOKEN_HAS_RESTORE_PRIVILEGE = 4
Global Const $TOKEN_HAS_ADMIN_GROUP = 8
Global Const $TOKEN_IS_RESTRICTED = 16
Global Const $TOKEN_SESSION_NOT_REFERENCED = 32
Global Const $TOKEN_SANDBOX_INERT = 64
Global Const $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 128
Global Const $STANDARD_RIGHTS_DELETE = 65536
Global Const $READ_CONTROL = 131072
Global Const $WRITE_DAC = 262144
Global Const $WRITE_OWNER = 524288
Global Const $STANDARD_RIGHTS_SYNCHRONIZE = 1048576
Global Const $ACCESS_SYSTEM_SECURITY = 16777216
Global Const $STANDARD_RIGHTS_REQUIRED = 983040
Global Const $STANDARD_RIGHTS_READ = $READ_CONTROL
Global Const $STANDARD_RIGHTS_WRITE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_ALL = 2031616
Global Const $SPECIFIC_RIGHTS_ALL = 65535
Global Enum $NOT_USED_ACCESS = 0 , $GRANT_ACCESS , $SET_ACCESS , $DENY_ACCESS , $REVOKE_ACCESS , $SET_AUDIT_SUCCESS , $SET_AUDIT_FAILURE
Global Enum $TRUSTEE_IS_UNKNOWN = 0 , $TRUSTEE_IS_USER , $TRUSTEE_IS_GROUP , $TRUSTEE_IS_DOMAIN , $TRUSTEE_IS_ALIAS , $TRUSTEE_IS_WELL_KNOWN_GROUP , $TRUSTEE_IS_DELETED , $TRUSTEE_IS_INVALID , $TRUSTEE_IS_COMPUTER
Global Const $LOGON_WITH_PROFILE = 1
Global Const $LOGON_NETCREDENTIALS_ONLY = 2
Global Enum $SIDTYPEUSER = 1 , $SIDTYPEGROUP , $SIDTYPEDOMAIN , $SIDTYPEALIAS , $SIDTYPEWELLKNOWNGROUP , $SIDTYPEDELETEDACCOUNT , $SIDTYPEINVALID , $SIDTYPEUNKNOWN , $SIDTYPECOMPUTER , $SIDTYPELABEL
Global Const $SID_ADMINISTRATORS = "S-1-5-32-544"
Global Const $SID_USERS = "S-1-5-32-545"
Global Const $SID_GUESTS = "S-1-5-32-546"
Global Const $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
Global Const $SID_SERVER_OPERATORS = "S-1-5-32-549"
Global Const $SID_PRINT_OPERATORS = "S-1-5-32-550"
Global Const $SID_BACKUP_OPERATORS = "S-1-5-32-551"
Global Const $SID_REPLICATOR = "S-1-5-32-552"
Global Const $SID_OWNER = "S-1-3-0"
Global Const $SID_EVERYONE = "S-1-1-0"
Global Const $SID_NETWORK = "S-1-5-2"
Global Const $SID_INTERACTIVE = "S-1-5-4"
Global Const $SID_SYSTEM = "S-1-5-18"
Global Const $SID_AUTHENTICATED_USERS = "S-1-5-11"
Global Const $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
Global Const $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
Global Const $SID_NT_SERVICE = "S-1-5-80"
Global Const $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
Global Const $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
Global Const $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
Global Const $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
Global Const $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
Global Const $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
Global Const $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
Global Const $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
Global Const $SID_ALL_SERVICES = "S-1-5-80-0"
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _SECURITY__ADJUSTTOKENPRIVILEGES ( $HTOKEN , $BDISABLEALL , $TNEWSTATE , $IBUFFERLEN , $TPREVSTATE = 0 , $PREQUIRED = 0 )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "AdjustTokenPrivileges" , "handle" , $HTOKEN , "bool" , $BDISABLEALL , "struct*" , $TNEWSTATE , "dword" , $IBUFFERLEN , "struct*" , $TPREVSTATE , "struct*" , $PREQUIRED )
	If @error Then Return SetError ( @error , @extended , False )
	Return Not ( $ACALL [ 0 ] = 0 )
EndFunc
Func _SECURITY__CREATEPROCESSWITHTOKEN ( $HTOKEN , $ILOGONFLAGS , $SCOMMANDLINE , $ICREATIONFLAGS , $SCURDIR , $TSTARTUPINFO , $TPROCESS_INFORMATION )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "CreateProcessWithTokenW" , "handle" , $HTOKEN , "dword" , $ILOGONFLAGS , "ptr" , 0 , "wstr" , $SCOMMANDLINE , "dword" , $ICREATIONFLAGS , "struct*" , 0 , "wstr" , $SCURDIR , "struct*" , $TSTARTUPINFO , "struct*" , $TPROCESS_INFORMATION )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , False )
	Return True
EndFunc
Func _SECURITY__DUPLICATETOKENEX ( $HEXISTINGTOKEN , $IDESIREDACCESS , $IIMPERSONATIONLEVEL , $ITOKENTYPE )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "DuplicateTokenEx" , "handle" , $HEXISTINGTOKEN , "dword" , $IDESIREDACCESS , "struct*" , 0 , "int" , $IIMPERSONATIONLEVEL , "int" , $ITOKENTYPE , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _SECURITY__GETACCOUNTSID ( $SACCOUNT , $SSYSTEM = "" )
	Local $AACCT = _SECURITY__LOOKUPACCOUNTNAME ( $SACCOUNT , $SSYSTEM )
	If @error Then Return SetError ( @error , @extended , 0 )
	If IsArray ( $AACCT ) Then Return _SECURITY__STRINGSIDTOSID ( $AACCT [ 0 ] )
	Return ""
EndFunc
Func _SECURITY__GETLENGTHSID ( $PSID )
	If Not _SECURITY__ISVALIDSID ( $PSID ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ACALL = DllCall ( "advapi32.dll" , "dword" , "GetLengthSid" , "struct*" , $PSID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _SECURITY__GETTOKENINFORMATION ( $HTOKEN , $ICLASS )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "GetTokenInformation" , "handle" , $HTOKEN , "int" , $ICLASS , "struct*" , 0 , "dword" , 0 , "dword*" , 0 )
	If @error Or Not $ACALL [ 5 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ILEN = $ACALL [ 5 ]
	Local $TBUFFER = DllStructCreate ( "byte[" & $ILEN & "]" )
	$ACALL = DllCall ( "advapi32.dll" , "bool" , "GetTokenInformation" , "handle" , $HTOKEN , "int" , $ICLASS , "struct*" , $TBUFFER , "dword" , DllStructGetSize ( $TBUFFER ) , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TBUFFER
EndFunc
Func _SECURITY__IMPERSONATESELF ( $ILEVEL = $SECURITYIMPERSONATION )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "ImpersonateSelf" , "int" , $ILEVEL )
	If @error Then Return SetError ( @error , @extended , False )
	Return Not ( $ACALL [ 0 ] = 0 )
EndFunc
Func _SECURITY__ISVALIDSID ( $PSID )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "IsValidSid" , "struct*" , $PSID )
	If @error Then Return SetError ( @error , @extended , False )
	Return Not ( $ACALL [ 0 ] = 0 )
EndFunc
Func _SECURITY__LOOKUPACCOUNTNAME ( $SACCOUNT , $SSYSTEM = "" )
	Local $TDATA = DllStructCreate ( "byte SID[256]" )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupAccountNameW" , "wstr" , $SSYSTEM , "wstr" , $SACCOUNT , "struct*" , $TDATA , "dword*" , DllStructGetSize ( $TDATA ) , "wstr" , "" , "dword*" , DllStructGetSize ( $TDATA ) , "int*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AACCT [ 3 ]
	$AACCT [ 0 ] = _SECURITY__SIDTOSTRINGSID ( DllStructGetPtr ( $TDATA , "SID" ) )
	$AACCT [ 1 ] = $ACALL [ 5 ]
	$AACCT [ 2 ] = $ACALL [ 7 ]
	Return $AACCT
EndFunc
Func _SECURITY__LOOKUPACCOUNTSID ( $VSID , $SSYSTEM = "" )
	Local $PSID , $AACCT [ 3 ]
	If IsString ( $VSID ) Then
		$PSID = _SECURITY__STRINGSIDTOSID ( $VSID )
	Else
		$PSID = $VSID
	EndIf
	If Not _SECURITY__ISVALIDSID ( $PSID ) Then Return SetError ( @error + 20 , @extended , 0 )
	If $SSYSTEM = "" Then $SSYSTEM = Null
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupAccountSidW" , "wstr" , $SSYSTEM , "struct*" , $PSID , "wstr" , "" , "dword*" , 65536 , "wstr" , "" , "dword*" , 65536 , "int*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AACCT [ 3 ]
	$AACCT [ 0 ] = $ACALL [ 3 ]
	$AACCT [ 1 ] = $ACALL [ 5 ]
	$AACCT [ 2 ] = $ACALL [ 7 ]
	Return $AACCT
EndFunc
Func _SECURITY__LOOKUPPRIVILEGEVALUE ( $SSYSTEM , $SNAME )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupPrivilegeValueW" , "wstr" , $SSYSTEM , "wstr" , $SNAME , "int64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _SECURITY__OPENPROCESSTOKEN ( $HPROCESS , $IACCESS )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "OpenProcessToken" , "handle" , $HPROCESS , "dword" , $IACCESS , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _SECURITY__OPENTHREADTOKEN ( $IACCESS , $HTHREAD = 0 , $BOPENASSELF = False )
	Local $ACALL
	If $HTHREAD = 0 Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "GetCurrentThread" )
		If @error Then Return SetError ( @error + 20 , @extended , 0 )
		$HTHREAD = $ACALL [ 0 ]
	EndIf
	$ACALL = DllCall ( "advapi32.dll" , "bool" , "OpenThreadToken" , "handle" , $HTHREAD , "dword" , $IACCESS , "bool" , $BOPENASSELF , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _SECURITY__OPENTHREADTOKENEX ( $IACCESS , $HTHREAD = 0 , $BOPENASSELF = False )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKEN ( $IACCESS , $HTHREAD , $BOPENASSELF )
	If $HTOKEN = 0 Then
		Local Const $ERROR_NO_TOKEN = 1008
		If _WINAPI_GETLASTERROR ( ) <> $ERROR_NO_TOKEN Then Return SetError ( 20 , _WINAPI_GETLASTERROR ( ) , 0 )
		If Not _SECURITY__IMPERSONATESELF ( ) Then Return SetError ( @error + 10 , _WINAPI_GETLASTERROR ( ) , 0 )
		$HTOKEN = _SECURITY__OPENTHREADTOKEN ( $IACCESS , $HTHREAD , $BOPENASSELF )
		If $HTOKEN = 0 Then Return SetError ( @error , _WINAPI_GETLASTERROR ( ) , 0 )
	EndIf
	Return $HTOKEN
EndFunc
Func _SECURITY__SETPRIVILEGE ( $HTOKEN , $SPRIVILEGE , $BENABLE )
	Local $ILUID = _SECURITY__LOOKUPPRIVILEGEVALUE ( "" , $SPRIVILEGE )
	If $ILUID = 0 Then Return SetError ( @error + 10 , @extended , False )
	Local Const $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
	Local $TCURRSTATE = DllStructCreate ( $TAGTOKEN_PRIVILEGES )
	Local $ICURRSTATE = DllStructGetSize ( $TCURRSTATE )
	Local $TPREVSTATE = DllStructCreate ( $TAGTOKEN_PRIVILEGES )
	Local $IPREVSTATE = DllStructGetSize ( $TPREVSTATE )
	Local $TREQUIRED = DllStructCreate ( "int Data" )
	DllStructSetData ( $TCURRSTATE , "Count" , 1 )
	DllStructSetData ( $TCURRSTATE , "LUID" , $ILUID )
	If Not _SECURITY__ADJUSTTOKENPRIVILEGES ( $HTOKEN , False , $TCURRSTATE , $ICURRSTATE , $TPREVSTATE , $TREQUIRED ) Then Return SetError ( 2 , @error , False )
	DllStructSetData ( $TPREVSTATE , "Count" , 1 )
	DllStructSetData ( $TPREVSTATE , "LUID" , $ILUID )
	Local $IATTRIBUTES = DllStructGetData ( $TPREVSTATE , "Attributes" )
	If $BENABLE Then
		$IATTRIBUTES = BitOR ( $IATTRIBUTES , $SE_PRIVILEGE_ENABLED )
	Else
		$IATTRIBUTES = BitAND ( $IATTRIBUTES , BitNOT ( $SE_PRIVILEGE_ENABLED ) )
	EndIf
	DllStructSetData ( $TPREVSTATE , "Attributes" , $IATTRIBUTES )
	If Not _SECURITY__ADJUSTTOKENPRIVILEGES ( $HTOKEN , False , $TPREVSTATE , $IPREVSTATE , $TCURRSTATE , $TREQUIRED ) Then Return SetError ( 3 , @error , False )
	Return True
EndFunc
Func _SECURITY__SETTOKENINFORMATION ( $HTOKEN , $ITOKENINFORMATION , $VTOKENINFORMATION , $ITOKENINFORMATIONLENGTH )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "SetTokenInformation" , "handle" , $HTOKEN , "int" , $ITOKENINFORMATION , "struct*" , $VTOKENINFORMATION , "dword" , $ITOKENINFORMATIONLENGTH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , False )
	Return True
EndFunc
Func _SECURITY__SIDTOSTRINGSID ( $PSID )
	If Not _SECURITY__ISVALIDSID ( $PSID ) Then Return SetError ( @error + 10 , 0 , "" )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "ConvertSidToStringSidW" , "struct*" , $PSID , "ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Local $PSTRINGSID = $ACALL [ 2 ]
	Local $ALEN = DllCall ( "kernel32.dll" , "int" , "lstrlenW" , "struct*" , $PSTRINGSID )
	Local $SSID = DllStructGetData ( DllStructCreate ( "wchar Text[" & $ALEN [ 0 ] + 1 & "]" , $PSTRINGSID ) , "Text" )
	DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $PSTRINGSID )
	Return $SSID
EndFunc
Func _SECURITY__SIDTYPESTR ( $ITYPE )
	Switch $ITYPE
	Case $SIDTYPEUSER
		Return "User"
	Case $SIDTYPEGROUP
		Return "Group"
	Case $SIDTYPEDOMAIN
		Return "Domain"
	Case $SIDTYPEALIAS
		Return "Alias"
	Case $SIDTYPEWELLKNOWNGROUP
		Return "Well Known Group"
	Case $SIDTYPEDELETEDACCOUNT
		Return "Deleted Account"
	Case $SIDTYPEINVALID
		Return "Invalid"
	Case $SIDTYPEUNKNOWN
		Return "Unknown Type"
	Case $SIDTYPECOMPUTER
		Return "Computer"
	Case $SIDTYPELABEL
		Return "A mandatory integrity label SID"
Case Else
		Return "Unknown SID Type"
	EndSwitch
EndFunc
Func _SECURITY__STRINGSIDTOSID ( $SSID )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "ConvertStringSidToSidW" , "wstr" , $SSID , "ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $PSID = $ACALL [ 2 ]
	Local $TBUFFER = DllStructCreate ( "byte Data[" & _SECURITY__GETLENGTHSID ( $PSID ) & "]" , $PSID )
	Local $TSID = DllStructCreate ( "byte Data[" & DllStructGetSize ( $TBUFFER ) & "]" )
	DllStructSetData ( $TSID , "Data" , DllStructGetData ( $TBUFFER , "Data" ) )
	DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $PSID )
	Return $TSID
EndFunc
#EndRegion Public Functions
#Region Functions list
#EndRegion Functions list
#Region Global Variables and Constants
Global Const $TAGMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
#EndRegion Global Variables and Constants
#Region Public Functions
Func _MEMFREE ( ByRef $TMEMMAP )
	Local $PMEMORY = DllStructGetData ( $TMEMMAP , "Mem" )
	Local $HPROCESS = DllStructGetData ( $TMEMMAP , "hProc" )
	Local $BRESULT = _MEMVIRTUALFREEEX ( $HPROCESS , $PMEMORY , 0 , $MEM_RELEASE )
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $BRESULT
EndFunc
Func _MEMGLOBALALLOC ( $IBYTES , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GlobalAlloc" , "uint" , $IFLAGS , "ulong_ptr" , $IBYTES )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMGLOBALFREE ( $HMEMORY )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "GlobalFree" , "handle" , $HMEMORY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMGLOBALLOCK ( $HMEMORY )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "GlobalLock" , "handle" , $HMEMORY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMGLOBALREALLOC ( $HMEMORY , $IBYTES , $IFLAGS = 0 )
	Local $ARESULT = DllCall ( "kernel32.dll" , "handle" , "GlobalReAlloc" , "handle" , $HMEMORY , "ulong_ptr" , $IBYTES , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ARESULT [ 0 ]
EndFunc
Func _MEMGLOBALSIZE ( $HMEMORY )
	Local $ACALL = DllCall ( "kernel32.dll" , "ulong_ptr" , "GlobalSize" , "handle" , $HMEMORY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMGLOBALUNLOCK ( $HMEMORY )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GlobalUnlock" , "handle" , $HMEMORY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMINIT ( $HWND , $ISIZE , ByRef $TMEMMAP )
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "GetWindowThreadProcessId" , "hwnd" , $HWND , "dword*" , 0 )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Local $IPROCESSID = $ACALL [ 2 ]
	If $IPROCESSID = 0 Then Return SetError ( 1 , 0 , 0 )
	Local $IACCESS = BitOR ( $PROCESS_VM_OPERATION , $PROCESS_VM_READ , $PROCESS_VM_WRITE )
	Local $HPROCESS = __MEM_OPENPROCESS ( $IACCESS , False , $IPROCESSID , True )
	Local $IALLOC = BitOR ( $MEM_RESERVE , $MEM_COMMIT )
	Local $PMEMORY = _MEMVIRTUALALLOCEX ( $HPROCESS , 0 , $ISIZE , $IALLOC , $PAGE_READWRITE )
	If $PMEMORY = 0 Then Return SetError ( 2 , 0 , 0 )
	$TMEMMAP = DllStructCreate ( $TAGMEMMAP )
	DllStructSetData ( $TMEMMAP , "hProc" , $HPROCESS )
	DllStructSetData ( $TMEMMAP , "Size" , $ISIZE )
	DllStructSetData ( $TMEMMAP , "Mem" , $PMEMORY )
	Return $PMEMORY
EndFunc
Func _MEMMOVEMEMORY ( $PSOURCE , $PDEST , $ILENGTH )
	DllCall ( "kernel32.dll" , "none" , "RtlMoveMemory" , "struct*" , $PDEST , "struct*" , $PSOURCE , "ulong_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended )
EndFunc
Func _MEMREAD ( ByRef $TMEMMAP , $PSRCE , $PDEST , $ISIZE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , DllStructGetData ( $TMEMMAP , "hProc" ) , "ptr" , $PSRCE , "struct*" , $PDEST , "ulong_ptr" , $ISIZE , "ulong_ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMWRITE ( ByRef $TMEMMAP , $PSRCE , $PDEST = 0 , $ISIZE = 0 , $SSRCE = "struct*" )
	If $PDEST = 0 Then $PDEST = DllStructGetData ( $TMEMMAP , "Mem" )
	If $ISIZE = 0 Then $ISIZE = DllStructGetData ( $TMEMMAP , "Size" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "WriteProcessMemory" , "handle" , DllStructGetData ( $TMEMMAP , "hProc" ) , "ptr" , $PDEST , $SSRCE , $PSRCE , "ulong_ptr" , $ISIZE , "ulong_ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMVIRTUALALLOC ( $PADDRESS , $ISIZE , $IALLOCATION , $IPROTECT )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "VirtualAlloc" , "ptr" , $PADDRESS , "ulong_ptr" , $ISIZE , "dword" , $IALLOCATION , "dword" , $IPROTECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMVIRTUALALLOCEX ( $HPROCESS , $PADDRESS , $ISIZE , $IALLOCATION , $IPROTECT )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "VirtualAllocEx" , "handle" , $HPROCESS , "ptr" , $PADDRESS , "ulong_ptr" , $ISIZE , "dword" , $IALLOCATION , "dword" , $IPROTECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMVIRTUALFREE ( $PADDRESS , $ISIZE , $IFREETYPE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "VirtualFree" , "ptr" , $PADDRESS , "ulong_ptr" , $ISIZE , "dword" , $IFREETYPE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _MEMVIRTUALFREEEX ( $HPROCESS , $PADDRESS , $ISIZE , $IFREETYPE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "VirtualFreeEx" , "handle" , $HPROCESS , "ptr" , $PADDRESS , "ulong_ptr" , $ISIZE , "dword" , $IFREETYPE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __MEM_OPENPROCESS ( $IACCESS , $BINHERIT , $IPID , $BDEBUGPRIV = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return $ACALL [ 0 ]
	If Not $BDEBUGPRIV Then Return SetError ( 100 , 0 , 0 )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKENEX ( BitOR ( $TOKEN_ADJUST_PRIVILEGES , $TOKEN_QUERY ) )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_DEBUG_NAME , True )
	Local $IERROR = @error
	Local $IEXTENDED = @extended
	Local $IRET = 0
	If Not @error Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
		$IERROR = @error
		$IEXTENDED = @extended
		If $ACALL [ 0 ] Then $IRET = $ACALL [ 0 ]
		_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_DEBUG_NAME , False )
		If @error Then
			$IERROR = @error + 20
			$IEXTENDED = @extended
		EndIf
	Else
		$IERROR = @error + 30
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HTOKEN )
	Return SetError ( $IERROR , $IEXTENDED , $IRET )
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global $__G_HGUICTRL_LASTWND
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , ByRef $TITEM , $TBUFFER = 0 , $BRETITEM = False , $IELEMENT = + 4294967295 , $BRETBUFFER = False , $IELEMENTMAX = $IELEMENT )
	If $IELEMENT > 0 Then
		DllStructSetData ( $TITEM , $IELEMENT , DllStructGetPtr ( $TBUFFER ) )
		If $IELEMENT = $IELEMENTMAX Then DllStructSetData ( $TITEM , $IELEMENT + 1 , DllStructGetSize ( $TBUFFER ) )
	EndIf
	Local $IRET
	If IsHWnd ( $HWND ) Then
		If _WINAPI_INPROCESS ( $HWND , $__G_HGUICTRL_LASTWND ) Then
			$IRET = DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $IINDEX , "struct*" , $TITEM ) [ 0 ]
		Else
			Local $IITEM = DllStructGetSize ( $TITEM )
			Local $TMEMMAP , $PTEXT
			Local $IBUFFER = 0
			If ( $IELEMENT > 0 ) Or ( $IELEMENTMAX = 0 ) Then $IBUFFER = DllStructGetSize ( $TBUFFER )
			Local $PMEMORY = _MEMINIT ( $HWND , $IITEM + $IBUFFER , $TMEMMAP )
			If $IBUFFER Then
				$PTEXT = $PMEMORY + $IITEM
				If $IELEMENTMAX Then
					DllStructSetData ( $TITEM , $IELEMENT , $PTEXT )
				Else
					$IINDEX = $PTEXT
				EndIf
				_MEMWRITE ( $TMEMMAP , $TBUFFER , $PTEXT , $IBUFFER )
			EndIf
			_MEMWRITE ( $TMEMMAP , $TITEM , $PMEMORY , $IITEM )
			$IRET = DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $IINDEX , "ptr" , $PMEMORY ) [ 0 ]
			If $IBUFFER And $BRETBUFFER Then _MEMREAD ( $TMEMMAP , $PTEXT , $TBUFFER , $IBUFFER )
			If $BRETITEM Then _MEMREAD ( $TMEMMAP , $PMEMORY , $TITEM , $IITEM )
			_MEMFREE ( $TMEMMAP )
		EndIf
	Else
		$IRET = GUICtrlSendMsg ( $HWND , $IMSG , $IINDEX , DllStructGetPtr ( $TITEM ) )
	EndIf
	Return $IRET
EndFunc
Func __GUICTRL_SENDMSG_INIT ( $HWND , $IMSG , $IINDEX , ByRef $TITEM , $TBUFFER = 0 , $BRETITEM = False , $IELEMENT = + 4294967295 , $BRETBUFFER = False , $IELEMENTMAX = $IELEMENT )
	#forceref $iMsg, $iIndex, $bRetItem, $bRetBuffer
	DllStructSetData ( $TITEM , $IELEMENT , DllStructGetPtr ( $TBUFFER ) )
	If $IELEMENT = $IELEMENTMAX Then DllStructSetData ( $TITEM , $IELEMENT + 1 , DllStructGetSize ( $TBUFFER ) )
	Local $PFUNC
	If IsHWnd ( $HWND ) Then
		If _WINAPI_INPROCESS ( $HWND , $__G_HGUICTRL_LASTWND ) Then
			$PFUNC = __GUICTRL_SENDMSG_INPROCESS
			SetExtended ( 1 )
		Else
			$PFUNC = __GUICTRL_SENDMSG_OUTPROCESS
			SetExtended ( 2 )
		EndIf
	Else
		$PFUNC = __GUICTRL_SENDMSG_INTERNAL
		SetExtended ( 3 )
	EndIf
	Return $PFUNC
EndFunc
Func __GUICTRL_SENDMSG_INPROCESS ( $HWND , $IMSG , $IINDEX , ByRef $TITEM , $TBUFFER = 0 , $BRETITEM = False , $IELEMENT = + 4294967295 , $BRETBUFFER = False , $IELEMENTMAX = $IELEMENT )
	#forceref $tBuffer, $bRetItem, $bRetBuffer, $iElementMax
	Return DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $IINDEX , "struct*" , $TITEM ) [ 0 ]
EndFunc
Func __GUICTRL_SENDMSG_OUTPROCESS ( $HWND , $IMSG , $IINDEX , ByRef $TITEM , $TBUFFER = 0 , $BRETITEM = False , $IELEMENT = + 4294967295 , $BRETBUFFER = False , $IELEMENTMAX = $IELEMENT )
	Local $IITEM = DllStructGetSize ( $TITEM )
	Local $TMEMMAP , $PTEXT
	Local $IBUFFER = 0
	If ( $IELEMENT > 0 ) Or ( $IELEMENTMAX = 0 ) Then $IBUFFER = DllStructGetSize ( $TBUFFER )
	Local $PMEMORY = _MEMINIT ( $HWND , $IITEM + $IBUFFER , $TMEMMAP )
	If $IBUFFER Then
		$PTEXT = $PMEMORY + $IITEM
		If $IELEMENTMAX Then
			DllStructSetData ( $TITEM , $IELEMENT , $PTEXT )
		Else
			$IINDEX = $PTEXT
		EndIf
		_MEMWRITE ( $TMEMMAP , $TBUFFER , $PTEXT , $IBUFFER )
	EndIf
	_MEMWRITE ( $TMEMMAP , $TITEM , $PMEMORY , $IITEM )
	Local $IRET = DllCall ( "user32.dll" , "lresult" , "SendMessageW" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $IINDEX , "ptr" , $PMEMORY ) [ 0 ]
	If $IBUFFER And $BRETBUFFER Then _MEMREAD ( $TMEMMAP , $PTEXT , $TBUFFER , $IBUFFER )
	If $BRETITEM Then _MEMREAD ( $TMEMMAP , $PMEMORY , $TITEM , $IITEM )
	_MEMFREE ( $TMEMMAP )
	Return $IRET
EndFunc
Func __GUICTRL_SENDMSG_INTERNAL ( $HWND , $IMSG , $IINDEX , ByRef $TITEM , $TBUFFER = 0 , $BRETITEM = False , $IELEMENT = + 4294967295 , $BRETBUFFER = False , $IELEMENTMAX = $IELEMENT )
	#forceref $tBuffer, $bRetItem, $bRetBuffer, $iElementMax
	Return GUICtrlSendMsg ( $HWND , $IMSG , $IINDEX , DllStructGetPtr ( $TITEM ) )
EndFunc
Global Const $HDF_LEFT = 0
Global Const $HDF_RIGHT = 1
Global Const $HDF_CENTER = 2
Global Const $HDF_JUSTIFYMASK = 3
Global Const $HDF_BITMAP_ON_RIGHT = 4096
Global Const $HDF_BITMAP = 8192
Global Const $HDF_STRING = 16384
Global Const $HDF_OWNERDRAW = 32768
Global Const $HDF_DISPLAYMASK = 61440
Global Const $HDF_RTLREADING = 4
Global Const $HDF_SORTDOWN = 512
Global Const $HDF_IMAGE = 2048
Global Const $HDF_SORTUP = 1024
Global Const $HDF_FLAGMASK = 3588
Global Const $HDI_WIDTH = 1
Global Const $HDI_TEXT = 2
Global Const $HDI_FORMAT = 4
Global Const $HDI_PARAM = 8
Global Const $HDI_BITMAP = 16
Global Const $HDI_IMAGE = 32
Global Const $HDI_DI_SETITEM = 64
Global Const $HDI_ORDER = 128
Global Const $HDI_FILTER = 256
Global Const $HHT_NOWHERE = 1
Global Const $HHT_ONHEADER = 2
Global Const $HHT_ONDIVIDER = 4
Global Const $HHT_ONDIVOPEN = 8
Global Const $HHT_ONFILTER = 16
Global Const $HHT_ONFILTERBUTTON = 32
Global Const $HHT_ABOVE = 256
Global Const $HHT_BELOW = 512
Global Const $HHT_TORIGHT = 1024
Global Const $HHT_TOLEFT = 2048
Global Const $HDM_FIRST = 4608
Global Const $HDM_CLEARFILTER = $HDM_FIRST + 24
Global Const $HDM_CREATEDRAGIMAGE = $HDM_FIRST + 16
Global Const $HDM_DELETEITEM = $HDM_FIRST + 2
Global Const $HDM_EDITFILTER = $HDM_FIRST + 23
Global Const $HDM_GETBITMAPMARGIN = $HDM_FIRST + 21
Global Const $HDM_GETFOCUSEDITEM = $HDM_FIRST + 27
Global Const $HDM_GETIMAGELIST = $HDM_FIRST + 9
Global Const $HDM_GETITEMA = $HDM_FIRST + 3
Global Const $HDM_GETITEMW = $HDM_FIRST + 11
Global Const $HDM_GETITEMCOUNT = $HDM_FIRST + 0
Global Const $HDM_GETITEMDROPDOWNRECT = $HDM_FIRST + 25
Global Const $HDM_GETITEMRECT = $HDM_FIRST + 7
Global Const $HDM_GETORDERARRAY = $HDM_FIRST + 17
Global Const $HDM_GETOVERFLOWRECT = $HDM_FIRST + 26
Global Const $HDM_GETUNICODEFORMAT = 8192 + 6
Global Const $HDM_HITTEST = $HDM_FIRST + 6
Global Const $HDM_INSERTITEMA = $HDM_FIRST + 1
Global Const $HDM_INSERTITEMW = $HDM_FIRST + 10
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global Const $HDM_ORDERTOINDEX = $HDM_FIRST + 15
Global Const $HDM_SETBITMAPMARGIN = $HDM_FIRST + 20
Global Const $HDM_SETFILTERCHANGETIMEOUT = $HDM_FIRST + 22
Global Const $HDM_SETFOCUSEDITEM = $HDM_FIRST + 28
Global Const $HDM_SETHOTDIVIDER = $HDM_FIRST + 19
Global Const $HDM_SETIMAGELIST = $HDM_FIRST + 8
Global Const $HDM_SETITEMA = $HDM_FIRST + 4
Global Const $HDM_SETITEMW = $HDM_FIRST + 12
Global Const $HDM_SETORDERARRAY = $HDM_FIRST + 18
Global Const $HDM_SETUNICODEFORMAT = 8192 + 5
Global Const $HDN_FIRST = + 4294966996
Global Const $HDN_BEGINDRAG = $HDN_FIRST + 4294967286
Global Const $HDN_BEGINTRACK = $HDN_FIRST + 4294967290
Global Const $HDN_DIVIDERDBLCLICK = $HDN_FIRST + 4294967291
Global Const $HDN_ENDDRAG = $HDN_FIRST + 4294967285
Global Const $HDN_ENDTRACK = $HDN_FIRST + 4294967289
Global Const $HDN_FILTERBTNCLICK = $HDN_FIRST + 4294967283
Global Const $HDN_FILTERCHANGE = $HDN_FIRST + 4294967284
Global Const $HDN_GETDISPINFO = $HDN_FIRST + 4294967287
Global Const $HDN_ITEMCHANGED = $HDN_FIRST + 4294967295
Global Const $HDN_ITEMCHANGING = $HDN_FIRST + 0
Global Const $HDN_ITEMCLICK = $HDN_FIRST + 4294967294
Global Const $HDN_ITEMDBLCLICK = $HDN_FIRST + 4294967293
Global Const $HDN_TRACK = $HDN_FIRST + 4294967288
Global Const $HDN_BEGINTRACKW = $HDN_FIRST + 4294967270
Global Const $HDN_DIVIDERDBLCLICKW = $HDN_FIRST + 4294967271
Global Const $HDN_ENDTRACKW = $HDN_FIRST + 4294967269
Global Const $HDN_GETDISPINFOW = $HDN_FIRST + 4294967267
Global Const $HDN_ITEMCHANGEDW = $HDN_FIRST + 4294967275
Global Const $HDN_ITEMCHANGINGW = $HDN_FIRST + 4294967276
Global Const $HDN_ITEMCLICKW = $HDN_FIRST + 4294967274
Global Const $HDN_ITEMDBLCLICKW = $HDN_FIRST + 4294967273
Global Const $HDN_TRACKW = $HDN_FIRST + 4294967268
Global Const $HDS_BUTTONS = 2
Global Const $HDS_CHECKBOXES = 1024
Global Const $HDS_DRAGDROP = 64
Global Const $HDS_FILTERBAR = 256
Global Const $HDS_FLAT = 512
Global Const $HDS_FULLDRAG = 128
Global Const $HDS_HIDDEN = 8
Global Const $HDS_HORZ = 0
Global Const $HDS_HOTTRACK = 4
Global Const $HDS_NOSIZING = 2048
Global Const $HDS_OVERFLOW = 4096
Global Const $HDS_DEFAULT = 70
Global $__G_THEADERBUFFER , $__G_THEADERBUFFERANSI
Global Const $__HEADERCONSTANT_CLASSNAME = "SysHeader32"
Global Const $__HEADERCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__HEADERCONSTANT_SWP_SHOWWINDOW = 64
Global Const $TAGHDHITTESTINFO = $TAGPOINT & ";uint Flags;int Item"
Global Const $TAGHDLAYOUT = "ptr Rect;ptr WindowPos"
Global Const $TAGHDTEXTFILTER = "ptr Text;int TextMax"
Func _GUICTRLHEADER_ADDITEM ( $HWND , $STEXT , $IWIDTH = 50 , $IALIGN = 0 , $IIMAGE = + 4294967295 , $BONRIGHT = False )
	Return _GUICTRLHEADER_INSERTITEM ( $HWND , _GUICTRLHEADER_GETITEMCOUNT ( $HWND ) , $STEXT , $IWIDTH , $IALIGN , $IIMAGE , $BONRIGHT )
EndFunc
Func _GUICTRLHEADER_CLEARFILTER ( $HWND , $IINDEX )
	Return _SENDMESSAGE ( $HWND , $HDM_CLEARFILTER , $IINDEX ) <> 0
EndFunc
Func _GUICTRLHEADER_CLEARFILTERALL ( $HWND )
	Return _SENDMESSAGE ( $HWND , $HDM_CLEARFILTER , + 4294967295 ) <> 0
EndFunc
Func _GUICTRLHEADER_CREATE ( $HWND , $ISTYLE = 70 )
	$ISTYLE = BitOR ( $ISTYLE , $__UDFGUICONSTANT_WS_CHILD , $__UDFGUICONSTANT_WS_VISIBLE )
	Local $NCTRLID = __UDF_GETNEXTGLOBALID ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $HHEADER = _WINAPI_CREATEWINDOWEX ( 0 , $__HEADERCONSTANT_CLASSNAME , "" , $ISTYLE , 0 , 0 , 0 , 0 , $HWND , $NCTRLID )
	Local $TRECT = _WINAPI_GETCLIENTRECT ( $HWND )
	Local $TWINDOWPOS = _GUICTRLHEADER_LAYOUT ( $HHEADER , $TRECT )
	Local $IFLAGS = BitOR ( DllStructGetData ( $TWINDOWPOS , "Flags" ) , $__HEADERCONSTANT_SWP_SHOWWINDOW )
	_WINAPI_SETWINDOWPOS ( $HHEADER , DllStructGetData ( $TWINDOWPOS , "InsertAfter" ) , DllStructGetData ( $TWINDOWPOS , "X" ) , DllStructGetData ( $TWINDOWPOS , "Y" ) , DllStructGetData ( $TWINDOWPOS , "CX" ) , DllStructGetData ( $TWINDOWPOS , "CY" ) , $IFLAGS )
	_WINAPI_SETFONT ( $HHEADER , _WINAPI_GETSTOCKOBJECT ( $__HEADERCONSTANT_DEFAULT_GUI_FONT ) )
	Return $HHEADER
EndFunc
Func _GUICTRLHEADER_CREATEDRAGIMAGE ( $HWND , $IINDEX )
	Return Ptr ( _SENDMESSAGE ( $HWND , $HDM_CREATEDRAGIMAGE , $IINDEX ) )
EndFunc
Func _GUICTRLHEADER_DELETEITEM ( $HWND , $IINDEX )
	Return _SENDMESSAGE ( $HWND , $HDM_DELETEITEM , $IINDEX ) <> 0
EndFunc
Func _GUICTRLHEADER_DESTROY ( ByRef $HWND )
	If Not _WINAPI_ISCLASSNAME ( $HWND , $__HEADERCONSTANT_CLASSNAME ) Then Return SetError ( 2 , 2 , False )
	Local $IDESTROYED = 0
	If IsHWnd ( $HWND ) Then
		If _WINAPI_INPROCESS ( $HWND , $__G_HGUICTRL_LASTWND ) Then
			Local $NCTRLID = _WINAPI_GETDLGCTRLID ( $HWND )
			Local $HPARENT = _WINAPI_GETPARENT ( $HWND )
			$IDESTROYED = _WINAPI_DESTROYWINDOW ( $HWND )
			Local $IRET = __UDF_FREEGLOBALID ( $HPARENT , $NCTRLID )
			If Not $IRET Then
			EndIf
		Else
			Return SetError ( 1 , 1 , False )
		EndIf
	Else
		$IDESTROYED = GUICtrlDelete ( $HWND )
	EndIf
	If $IDESTROYED Then $HWND = 0
	Return $IDESTROYED <> 0
EndFunc
Func _GUICTRLHEADER_EDITFILTER ( $HWND , $IINDEX , $BDISCARD = True )
	Return _SENDMESSAGE ( $HWND , $HDM_EDITFILTER , $IINDEX , $BDISCARD ) <> 0
EndFunc
Func _GUICTRLHEADER_GETFILTERTEXT ( $HWND , $IINDEX )
	Local $TBUFFER , $IMSG
	If _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = DllStructCreate ( "wchar Text[64]" )
		$IMSG = $HDM_GETITEMW
	Else
		$TBUFFER = DllStructCreate ( "char Text[64]" )
		$IMSG = $HDM_GETITEMA
	EndIf
	Local $TFILTER = DllStructCreate ( $TAGHDTEXTFILTER )
	DllStructSetData ( $TFILTER , "Text" , DllStructGetPtr ( $TBUFFER ) )
	DllStructSetData ( $TFILTER , "TextMax" , DllStructGetSize ( $TBUFFER ) )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_FILTER )
	DllStructSetData ( $TITEM , "Type" , 0 )
	DllStructSetData ( $TITEM , "pFilter" , DllStructGetPtr ( $TFILTER ) )
	__GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM , $TBUFFER , False , + 4294967295 , True )
	Return DllStructGetData ( $TBUFFER , "Text" )
EndFunc
Func _GUICTRLHEADER_GETBITMAPMARGIN ( $HWND )
	Return _SENDMESSAGE ( $HWND , $HDM_GETBITMAPMARGIN )
EndFunc
Func _GUICTRLHEADER_GETIMAGELIST ( $HWND )
	Return Ptr ( _SENDMESSAGE ( $HWND , $HDM_GETIMAGELIST ) )
EndFunc
Func _GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , ByRef $TITEM )
	Local $IMSG
	If _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $HDM_GETITEMW
	Else
		$IMSG = $HDM_GETITEMA
	EndIf
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM , 0 , True )
	Return $IRET <> 0
EndFunc
Func _GUICTRLHEADER_GETITEMALIGN ( $HWND , $IINDEX )
	Switch BitAND ( _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX ) , $HDF_JUSTIFYMASK )
	Case $HDF_LEFT
		Return 0
	Case $HDF_RIGHT
		Return 1
	Case $HDF_CENTER
		Return 2
Case Else
		Return + 4294967295
	EndSwitch
EndFunc
Func _GUICTRLHEADER_GETITEMBITMAP ( $HWND , $IINDEX )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_BITMAP )
	_GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , $TITEM )
	Return DllStructGetData ( $TITEM , "hBmp" )
EndFunc
Func _GUICTRLHEADER_GETITEMCOUNT ( $HWND )
	Return _SENDMESSAGE ( $HWND , $HDM_GETITEMCOUNT )
EndFunc
Func _GUICTRLHEADER_GETITEMDISPLAY ( $HWND , $IINDEX )
	Local $IRET = 0
	Local $IFORMAT = _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX )
	If BitAND ( $IFORMAT , $HDF_BITMAP ) <> 0 Then $IRET = BitOR ( $IRET , 1 )
	If BitAND ( $IFORMAT , $HDF_BITMAP_ON_RIGHT ) <> 0 Then $IRET = BitOR ( $IRET , 2 )
	If BitAND ( $IFORMAT , $HDF_OWNERDRAW ) <> 0 Then $IRET = BitOR ( $IRET , 4 )
	If BitAND ( $IFORMAT , $HDF_STRING ) <> 0 Then $IRET = BitOR ( $IRET , 8 )
	Return $IRET
EndFunc
Func _GUICTRLHEADER_GETITEMFLAGS ( $HWND , $IINDEX )
	Local $IRET = 0
	Local $IFORMAT = _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX )
	If BitAND ( $IFORMAT , $HDF_IMAGE ) <> 0 Then $IRET = BitOR ( $IRET , 1 )
	If BitAND ( $IFORMAT , $HDF_RTLREADING ) <> 0 Then $IRET = BitOR ( $IRET , 2 )
	If BitAND ( $IFORMAT , $HDF_SORTDOWN ) <> 0 Then $IRET = BitOR ( $IRET , 4 )
	If BitAND ( $IFORMAT , $HDF_SORTUP ) <> 0 Then $IRET = BitOR ( $IRET , 8 )
	Return $IRET
EndFunc
Func _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_FORMAT )
	_GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , $TITEM )
	Return DllStructGetData ( $TITEM , "Fmt" )
EndFunc
Func _GUICTRLHEADER_GETITEMIMAGE ( $HWND , $IINDEX )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_IMAGE )
	_GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , $TITEM )
	Return DllStructGetData ( $TITEM , "Image" )
EndFunc
Func _GUICTRLHEADER_GETITEMORDER ( $HWND , $IINDEX )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_ORDER )
	_GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , $TITEM )
	Return DllStructGetData ( $TITEM , "Order" )
EndFunc
Func _GUICTRLHEADER_GETITEMPARAM ( $HWND , $IINDEX )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_PARAM )
	_GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , $TITEM )
	Return DllStructGetData ( $TITEM , "Param" )
EndFunc
Func _GUICTRLHEADER_GETITEMRECT ( $HWND , $IINDEX )
	Local $ARECT [ 4 ]
	Local $TRECT = _GUICTRLHEADER_GETITEMRECTEX ( $HWND , $IINDEX )
	$ARECT [ 0 ] = DllStructGetData ( $TRECT , "Left" )
	$ARECT [ 1 ] = DllStructGetData ( $TRECT , "Top" )
	$ARECT [ 2 ] = DllStructGetData ( $TRECT , "Right" )
	$ARECT [ 3 ] = DllStructGetData ( $TRECT , "Bottom" )
	Return $ARECT
EndFunc
Func _GUICTRLHEADER_GETITEMRECTEX ( $HWND , $IINDEX )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	__GUICTRL_SENDMSG ( $HWND , $HDM_GETITEMRECT , $IINDEX , $TRECT , 0 , True )
	Return $TRECT
EndFunc
Func _GUICTRLHEADER_GETITEMTEXT ( $HWND , $IINDEX )
	Local $TBUFFER , $IMSG
	If _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_THEADERBUFFER
		$IMSG = $HDM_GETITEMW
	Else
		$TBUFFER = $__G_THEADERBUFFERANSI
		$IMSG = $HDM_GETITEMA
	EndIf
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_TEXT )
	DllStructSetData ( $TITEM , "TextMax" , DllStructGetSize ( $TBUFFER ) )
	__GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM , $TBUFFER , False , 3 , True , 5 )
	Return DllStructGetData ( $TBUFFER , "Text" )
EndFunc
Func _GUICTRLHEADER_GETITEMWIDTH ( $HWND , $IINDEX )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_WIDTH )
	_GUICTRLHEADER_GETITEM ( $HWND , $IINDEX , $TITEM )
	Return DllStructGetData ( $TITEM , "XY" )
EndFunc
Func _GUICTRLHEADER_GETORDERARRAY ( $HWND )
	Local $IITEMS = _GUICTRLHEADER_GETITEMCOUNT ( $HWND )
	Local $TBUFFER = DllStructCreate ( "int[" & $IITEMS & "]" )
	__GUICTRL_SENDMSG ( $HWND , $HDM_GETORDERARRAY , $IITEMS , $TBUFFER , 0 , True )
	Local $ABUFFER [ $IITEMS + 1 ]
	$ABUFFER [ 0 ] = $IITEMS
	For $II = 1 To $IITEMS
		$ABUFFER [ $II ] = DllStructGetData ( $TBUFFER , 1 , $II )
	Next
	Return $ABUFFER
EndFunc
Func _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND )
	If Not IsDllStruct ( $__G_THEADERBUFFER ) Then
		$__G_THEADERBUFFER = DllStructCreate ( "wchar Text[4096]" )
		$__G_THEADERBUFFERANSI = DllStructCreate ( "char Text[4096]" , DllStructGetPtr ( $__G_THEADERBUFFER ) )
	EndIf
	Return _SENDMESSAGE ( $HWND , $HDM_GETUNICODEFORMAT ) <> 0
EndFunc
Func _GUICTRLHEADER_HITTEST ( $HWND , $IX , $IY )
	Local $TTEST = DllStructCreate ( $TAGHDHITTESTINFO )
	DllStructSetData ( $TTEST , "X" , $IX )
	DllStructSetData ( $TTEST , "Y" , $IY )
	Local $ATEST [ 11 ]
	$ATEST [ 0 ] = __GUICTRL_SENDMSG ( $HWND , $HDM_HITTEST , 0 , $TTEST , 0 , True )
	Local $IFLAGS = DllStructGetData ( $TTEST , "Flags" )
	$ATEST [ 1 ] = BitAND ( $IFLAGS , $HHT_NOWHERE ) <> 0
	$ATEST [ 2 ] = BitAND ( $IFLAGS , $HHT_ONHEADER ) <> 0
	$ATEST [ 3 ] = BitAND ( $IFLAGS , $HHT_ONDIVIDER ) <> 0
	$ATEST [ 4 ] = BitAND ( $IFLAGS , $HHT_ONDIVOPEN ) <> 0
	$ATEST [ 5 ] = BitAND ( $IFLAGS , $HHT_ONFILTER ) <> 0
	$ATEST [ 6 ] = BitAND ( $IFLAGS , $HHT_ONFILTERBUTTON ) <> 0
	$ATEST [ 7 ] = BitAND ( $IFLAGS , $HHT_ABOVE ) <> 0
	$ATEST [ 8 ] = BitAND ( $IFLAGS , $HHT_BELOW ) <> 0
	$ATEST [ 9 ] = BitAND ( $IFLAGS , $HHT_TORIGHT ) <> 0
	$ATEST [ 10 ] = BitAND ( $IFLAGS , $HHT_TOLEFT ) <> 0
	Return $ATEST
EndFunc
Func _GUICTRLHEADER_INSERTITEM ( $HWND , $IINDEX , $STEXT , $IWIDTH = 50 , $IALIGN = 0 , $IIMAGE = + 4294967295 , $BONRIGHT = False )
	Local $AALIGN [ 3 ] = [ $HDF_LEFT , $HDF_RIGHT , $HDF_CENTER ]
	Local $TBUFFER , $PBUFFER , $IMSG
	If _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $HDM_INSERTITEMW
		$TBUFFER = $__G_THEADERBUFFER
	Else
		$TBUFFER = $__G_THEADERBUFFERANSI
		$IMSG = $HDM_INSERTITEMA
	EndIf
	Local $IBUFFER
	If $STEXT <> + 4294967295 Then
		$IBUFFER = StringLen ( $STEXT ) + 1
		DllStructSetData ( $TBUFFER , "Text" , $STEXT )
		$PBUFFER = DllStructGetPtr ( $TBUFFER )
	Else
		$IBUFFER = 0
		$TBUFFER = 0
		$PBUFFER = + 4294967295
	EndIf
	Local $IFMT = $AALIGN [ $IALIGN ]
	Local $IMASK = BitOR ( $HDI_WIDTH , $HDI_FORMAT )
	If $STEXT <> "" Then
		$IMASK = BitOR ( $IMASK , $HDI_TEXT )
		$IFMT = BitOR ( $IFMT , $HDF_STRING )
	EndIf
	If $IIMAGE <> + 4294967295 Then
		$IMASK = BitOR ( $IMASK , $HDI_IMAGE )
		$IFMT = BitOR ( $IFMT , $HDF_IMAGE )
	EndIf
	If $BONRIGHT Then $IFMT = BitOR ( $IFMT , $HDF_BITMAP_ON_RIGHT )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $IMASK )
	DllStructSetData ( $TITEM , "XY" , $IWIDTH )
	DllStructSetData ( $TITEM , "Fmt" , $IFMT )
	DllStructSetData ( $TITEM , "Image" , $IIMAGE )
	DllStructSetData ( $TITEM , "Text" , $PBUFFER )
	DllStructSetData ( $TITEM , "TextMax" , $IBUFFER )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM , $TBUFFER , False , + 4294967295 )
	Return $IRET
EndFunc
Func _GUICTRLHEADER_LAYOUT ( $HWND , ByRef $TRECT )
	Local $TLAYOUT = DllStructCreate ( $TAGHDLAYOUT )
	Local $TWINDOWPOS = DllStructCreate ( $TAGWINDOWPOS )
	If _WINAPI_INPROCESS ( $HWND , $__G_HGUICTRL_LASTWND ) Then
		DllStructSetData ( $TLAYOUT , "Rect" , DllStructGetPtr ( $TRECT ) )
		DllStructSetData ( $TLAYOUT , "WindowPos" , DllStructGetPtr ( $TWINDOWPOS ) )
		_SENDMESSAGE ( $HWND , $HDM_LAYOUT , 0 , $TLAYOUT , 0 , "wparam" , "struct*" )
	Else
		Local $ILAYOUT = DllStructGetSize ( $TLAYOUT )
		Local $IRECT = DllStructGetSize ( $TRECT )
		Local $IWINDOWPOS = DllStructGetSize ( $TWINDOWPOS )
		Local $TMEMMAP
		Local $PMEMORY = _MEMINIT ( $HWND , $ILAYOUT + $IRECT + $IWINDOWPOS , $TMEMMAP )
		DllStructSetData ( $TLAYOUT , "Rect" , $PMEMORY + $ILAYOUT )
		DllStructSetData ( $TLAYOUT , "WindowPos" , $PMEMORY + $ILAYOUT + $IRECT )
		_MEMWRITE ( $TMEMMAP , $TLAYOUT , $PMEMORY , $ILAYOUT )
		_MEMWRITE ( $TMEMMAP , $TRECT , $PMEMORY + $ILAYOUT , $IRECT )
		_SENDMESSAGE ( $HWND , $HDM_LAYOUT , 0 , $PMEMORY , 0 , "wparam" , "ptr" )
		_MEMREAD ( $TMEMMAP , $PMEMORY + $ILAYOUT + $IRECT , $TWINDOWPOS , $IWINDOWPOS )
		_MEMFREE ( $TMEMMAP )
	EndIf
	Return $TWINDOWPOS
EndFunc
Func _GUICTRLHEADER_ORDERTOINDEX ( $HWND , $IORDER )
	Return _SENDMESSAGE ( $HWND , $HDM_ORDERTOINDEX , $IORDER )
EndFunc
Func _GUICTRLHEADER_SETBITMAPMARGIN ( $HWND , $IWIDTH )
	Return _SENDMESSAGE ( $HWND , $HDM_SETBITMAPMARGIN , $IWIDTH )
EndFunc
Func _GUICTRLHEADER_SETFILTERCHANGETIMEOUT ( $HWND , $ITIMEOUT )
	Return _SENDMESSAGE ( $HWND , $HDM_SETFILTERCHANGETIMEOUT , 0 , $ITIMEOUT )
EndFunc
Func _GUICTRLHEADER_SETHOTDIVIDER ( $HWND , $IFLAG , $IINPUTVALUE )
	Return _SENDMESSAGE ( $HWND , $HDM_SETHOTDIVIDER , $IFLAG , $IINPUTVALUE )
EndFunc
Func _GUICTRLHEADER_SETIMAGELIST ( $HWND , $HIMAGE )
	Return _SENDMESSAGE ( $HWND , $HDM_SETIMAGELIST , 0 , $HIMAGE , 0 , "wparam" , "handle" , "handle" )
EndFunc
Func _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , ByRef $TITEM )
	Local $IMSG
	If _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $HDM_SETITEMW
	Else
		$IMSG = $HDM_SETITEMA
	EndIf
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM )
	Return $IRET <> 0
EndFunc
Func _GUICTRLHEADER_SETITEMALIGN ( $HWND , $IINDEX , $IALIGN )
	Local $AALIGN [ 3 ] = [ $HDF_LEFT , $HDF_RIGHT , $HDF_CENTER ]
	Local $IFORMAT = _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX )
	$IFORMAT = BitAND ( $IFORMAT , BitNOT ( $HDF_JUSTIFYMASK ) )
	$IFORMAT = BitOR ( $IFORMAT , $AALIGN [ $IALIGN ] )
	Return _GUICTRLHEADER_SETITEMFORMAT ( $HWND , $IINDEX , $IFORMAT )
EndFunc
Func _GUICTRLHEADER_SETITEMBITMAP ( $HWND , $IINDEX , $HBITMAP )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , BitOR ( $HDI_FORMAT , $HDI_BITMAP ) )
	DllStructSetData ( $TITEM , "Fmt" , $HDF_BITMAP )
	DllStructSetData ( $TITEM , "hBMP" , $HBITMAP )
	Return _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , $TITEM )
EndFunc
Func _GUICTRLHEADER_SETITEMDISPLAY ( $HWND , $IINDEX , $IDISPLAY )
	Local $IFORMAT = BitAND ( _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX ) , Not $HDF_DISPLAYMASK )
	If BitAND ( $IDISPLAY , 1 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_BITMAP )
	If BitAND ( $IDISPLAY , 2 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_BITMAP_ON_RIGHT )
	If BitAND ( $IDISPLAY , 4 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_OWNERDRAW )
	If BitAND ( $IDISPLAY , 8 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_STRING )
	Return _GUICTRLHEADER_SETITEMFORMAT ( $HWND , $IINDEX , $IFORMAT )
EndFunc
Func _GUICTRLHEADER_SETITEMFLAGS ( $HWND , $IINDEX , $IFLAGS )
	Local $IFORMAT = _GUICTRLHEADER_GETITEMFORMAT ( $HWND , $IINDEX )
	$IFORMAT = BitAND ( $IFORMAT , BitNOT ( $HDF_FLAGMASK ) )
	If BitAND ( $IFLAGS , 1 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_IMAGE )
	If BitAND ( $IFLAGS , 2 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_RTLREADING )
	If BitAND ( $IFLAGS , 4 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_SORTDOWN )
	If BitAND ( $IFLAGS , 8 ) <> 0 Then $IFORMAT = BitOR ( $IFORMAT , $HDF_SORTUP )
	Return _GUICTRLHEADER_SETITEMFORMAT ( $HWND , $IINDEX , $IFORMAT )
EndFunc
Func _GUICTRLHEADER_SETITEMFORMAT ( $HWND , $IINDEX , $IFORMAT )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_FORMAT )
	DllStructSetData ( $TITEM , "Fmt" , $IFORMAT )
	Return _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , $TITEM )
EndFunc
Func _GUICTRLHEADER_SETITEMIMAGE ( $HWND , $IINDEX , $IIMAGE )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_IMAGE )
	DllStructSetData ( $TITEM , "Image" , $IIMAGE )
	Return _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , $TITEM )
EndFunc
Func _GUICTRLHEADER_SETITEMORDER ( $HWND , $IINDEX , $IORDER )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_ORDER )
	DllStructSetData ( $TITEM , "Order" , $IORDER )
	Return _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , $TITEM )
EndFunc
Func _GUICTRLHEADER_SETITEMPARAM ( $HWND , $IINDEX , $IPARAM )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_PARAM )
	DllStructSetData ( $TITEM , "Param" , $IPARAM )
	Return _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , $TITEM )
EndFunc
Func _GUICTRLHEADER_SETITEMTEXT ( $HWND , $IINDEX , $STEXT )
	Local $TBUFFER , $IMSG
	If _GUICTRLHEADER_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_THEADERBUFFER
		$IMSG = $HDM_SETITEMW
	Else
		$TBUFFER = $__G_THEADERBUFFERANSI
		$IMSG = $HDM_SETITEMA
	EndIf
	Local $IBUFFER , $PBUFFER
	If $STEXT <> + 4294967295 Then
		$IBUFFER = StringLen ( $STEXT ) + 1
		DllStructSetData ( $TBUFFER , "Text" , $STEXT )
		$PBUFFER = DllStructGetPtr ( $TBUFFER )
	Else
		$IBUFFER = 0
		$TBUFFER = 0
		$PBUFFER = + 4294967295
	EndIf
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_TEXT )
	DllStructSetData ( $TITEM , "Text" , $PBUFFER )
	DllStructSetData ( $TITEM , "TextMax" , $IBUFFER )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM , $TBUFFER , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLHEADER_SETITEMWIDTH ( $HWND , $IINDEX , $IWIDTH )
	Local $TITEM = DllStructCreate ( $TAGHDITEM )
	DllStructSetData ( $TITEM , "Mask" , $HDI_WIDTH )
	DllStructSetData ( $TITEM , "XY" , $IWIDTH )
	Return _GUICTRLHEADER_SETITEM ( $HWND , $IINDEX , $TITEM )
EndFunc
Func _GUICTRLHEADER_SETORDERARRAY ( $HWND , ByRef $AORDER )
	Local $TBUFFER = DllStructCreate ( "int[" & $AORDER [ 0 ] & "]" )
	For $II = 1 To $AORDER [ 0 ]
		DllStructSetData ( $TBUFFER , 1 , $AORDER [ $II ] , $II )
	Next
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $HDM_SETORDERARRAY , $AORDER [ 0 ] , $TBUFFER )
	Return $IRET <> 0
EndFunc
Func _GUICTRLHEADER_SETUNICODEFORMAT ( $HWND , $BUNICODE )
	Return _SENDMESSAGE ( $HWND , $HDM_SETUNICODEFORMAT , $BUNICODE )
EndFunc
Global Const $FR_PRIVATE = 16
Global Const $FR_NOT_ENUM = 32
Global Const $COMPRESSION_BITMAP_PNG = 0
Global Const $COMPRESSION_BITMAP_JPEG = 1
Global Const $BS_DIBPATTERN = 5
Global Const $BS_DIBPATTERN8X8 = 8
Global Const $BS_DIBPATTERNPT = 6
Global Const $BS_HATCHED = 2
Global Const $BS_HOLLOW = 1
Global Const $BS_NULL = 1
Global Const $BS_PATTERN = 3
Global Const $BS_PATTERN8X8 = 7
Global Const $BS_SOLID = 0
Global Const $HS_BDIAGONAL = 3
Global Const $HS_CROSS = 4
Global Const $HS_DIAGCROSS = 5
Global Const $HS_FDIAGONAL = 2
Global Const $HS_HORIZONTAL = 0
Global Const $HS_VERTICAL = 1
Global Const $DIB_PAL_COLORS = 1
Global Const $DIB_RGB_COLORS = 0
Global Const $CA_NEGATIVE = 1
Global Const $CA_LOG_FILTER = 2
Global Const $ILLUMINANT_DEVICE_DEFAULT = 0
Global Const $ILLUMINANT_A = 1
Global Const $ILLUMINANT_B = 2
Global Const $ILLUMINANT_C = 3
Global Const $ILLUMINANT_D50 = 4
Global Const $ILLUMINANT_D55 = 5
Global Const $ILLUMINANT_D65 = 6
Global Const $ILLUMINANT_D75 = 7
Global Const $ILLUMINANT_F2 = 8
Global Const $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
Global Const $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
Global Const $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
Global Const $ILLUMINANT_NTSC = $ILLUMINANT_C
Global Const $BI_RGB = 0
Global Const $BI_RLE8 = 1
Global Const $BI_RLE4 = 2
Global Const $BI_BITFIELDS = 3
Global Const $BI_JPEG = 4
Global Const $BI_PNG = 5
Global Const $ALTERNATE = 1
Global Const $WINDING = 2
Global Const $DWMWA_NCRENDERING_ENABLED = 1
Global Const $DWMWA_NCRENDERING_POLICY = 2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 3
Global Const $DWMWA_ALLOW_NCPAINT = 4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
Global Const $DWMWA_FLIP3D_POLICY = 8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
Global Const $DWMWA_HAS_ICONIC_BITMAP = 10
Global Const $DWMWA_DISALLOW_PEEK = 11
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 12
Global Const $DWMNCRP_USEWINDOWSTYLE = 0
Global Const $DWMNCRP_DISABLED = 1
Global Const $DWMNCRP_ENABLED = 2
Global Const $DWMFLIP3D_DEFAULT = 0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 2
Global Const $DM_BITSPERPEL = 262144
Global Const $DM_COLLATE = 32768
Global Const $DM_COLOR = 2048
Global Const $DM_COPIES = 256
Global Const $DM_DEFAULTSOURCE = 512
Global Const $DM_DISPLAYFIXEDOUTPUT = 536870912
Global Const $DM_DISPLAYFLAGS = 2097152
Global Const $DM_DISPLAYFREQUENCY = 4194304
Global Const $DM_DISPLAYORIENTATION = 128
Global Const $DM_DITHERTYPE = 67108864
Global Const $DM_DUPLEX = 4096
Global Const $DM_FORMNAME = 65536
Global Const $DM_ICMINTENT = 16777216
Global Const $DM_ICMMETHOD = 8388608
Global Const $DM_LOGPIXELS = 131072
Global Const $DM_MEDIATYPE = 33554432
Global Const $DM_NUP = 64
Global Const $DM_ORIENTATION = 1
Global Const $DM_PANNINGHEIGHT = 268435456
Global Const $DM_PANNINGWIDTH = 134217728
Global Const $DM_PAPERLENGTH = 4
Global Const $DM_PAPERSIZE = 2
Global Const $DM_PAPERWIDTH = 8
Global Const $DM_PELSHEIGHT = 1048576
Global Const $DM_PELSWIDTH = 524288
Global Const $DM_POSITION = 32
Global Const $DM_PRINTQUALITY = 1024
Global Const $DM_SCALE = 16
Global Const $DM_TTOPTION = 16384
Global Const $DM_YRESOLUTION = 8192
Global Const $DMPAPER_LETTER = 1
Global Const $DMPAPER_LETTERSMALL = 2
Global Const $DMPAPER_TABLOID = 3
Global Const $DMPAPER_LEDGER = 4
Global Const $DMPAPER_LEGAL = 5
Global Const $DMPAPER_STATEMENT = 6
Global Const $DMPAPER_EXECUTIVE = 7
Global Const $DMPAPER_A3 = 8
Global Const $DMPAPER_A4 = 9
Global Const $DMPAPER_A4SMALL = 10
Global Const $DMPAPER_A5 = 11
Global Const $DMPAPER_B4 = 12
Global Const $DMPAPER_B5 = 13
Global Const $DMPAPER_FOLIO = 14
Global Const $DMPAPER_QUARTO = 15
Global Const $DMPAPER_10X14 = 16
Global Const $DMPAPER_11X17 = 17
Global Const $DMPAPER_NOTE = 18
Global Const $DMPAPER_ENV_9 = 19
Global Const $DMPAPER_ENV_10 = 20
Global Const $DMPAPER_ENV_11 = 21
Global Const $DMPAPER_ENV_12 = 22
Global Const $DMPAPER_ENV_14 = 23
Global Const $DMPAPER_CSHEET = 24
Global Const $DMPAPER_DSHEET = 25
Global Const $DMPAPER_ESHEET = 26
Global Const $DMPAPER_ENV_DL = 27
Global Const $DMPAPER_ENV_C5 = 28
Global Const $DMPAPER_ENV_C3 = 29
Global Const $DMPAPER_ENV_C4 = 30
Global Const $DMPAPER_ENV_C6 = 31
Global Const $DMPAPER_ENV_C65 = 32
Global Const $DMPAPER_ENV_B4 = 33
Global Const $DMPAPER_ENV_B5 = 34
Global Const $DMPAPER_ENV_B6 = 35
Global Const $DMPAPER_ENV_ITALY = 36
Global Const $DMPAPER_ENV_MONARCH = 37
Global Const $DMPAPER_ENV_PERSONAL = 38
Global Const $DMPAPER_FANFOLD_US = 39
Global Const $DMPAPER_FANFOLD_STD_GERMAN = 40
Global Const $DMPAPER_FANFOLD_LGL_GERMAN = 41
Global Const $DMPAPER_ISO_B4 = 42
Global Const $DMPAPER_JAPANESE_POSTCARD = 43
Global Const $DMPAPER_9X11 = 44
Global Const $DMPAPER_10X11 = 45
Global Const $DMPAPER_15X11 = 46
Global Const $DMPAPER_ENV_INVITE = 47
Global Const $DMPAPER_RESERVED_48 = 48
Global Const $DMPAPER_RESERVED_49 = 49
Global Const $DMPAPER_LETTER_EXTRA = 50
Global Const $DMPAPER_LEGAL_EXTRA = 51
Global Const $DMPAPER_TABLOID_EXTRA = 52
Global Const $DMPAPER_A4_EXTRA = 53
Global Const $DMPAPER_LETTER_TRANSVERSE = 54
Global Const $DMPAPER_A4_TRANSVERSE = 55
Global Const $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
Global Const $DMPAPER_A_PLUS = 57
Global Const $DMPAPER_B_PLUS = 58
Global Const $DMPAPER_LETTER_PLUS = 59
Global Const $DMPAPER_A4_PLUS = 60
Global Const $DMPAPER_A5_TRANSVERSE = 61
Global Const $DMPAPER_B5_TRANSVERSE = 62
Global Const $DMPAPER_A3_EXTRA = 63
Global Const $DMPAPER_A5_EXTRA = 64
Global Const $DMPAPER_B5_EXTRA = 65
Global Const $DMPAPER_A2 = 66
Global Const $DMPAPER_A3_TRANSVERSE = 67
Global Const $DMPAPER_A3_EXTRA_TRANSVERSE = 68
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD = 69
Global Const $DMPAPER_A6 = 70
Global Const $DMPAPER_JENV_KAKU2 = 71
Global Const $DMPAPER_JENV_KAKU3 = 72
Global Const $DMPAPER_JENV_CHOU3 = 73
Global Const $DMPAPER_JENV_CHOU4 = 74
Global Const $DMPAPER_LETTER_ROTATED = 75
Global Const $DMPAPER_A3_ROTATED = 76
Global Const $DMPAPER_A4_ROTATED = 77
Global Const $DMPAPER_A5_ROTATED = 78
Global Const $DMPAPER_B4_JIS_ROTATED = 79
Global Const $DMPAPER_B5_JIS_ROTATED = 80
Global Const $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
Global Const $DMPAPER_A6_ROTATED = 83
Global Const $DMPAPER_JENV_KAKU2_ROTATED = 84
Global Const $DMPAPER_JENV_KAKU3_ROTATED = 85
Global Const $DMPAPER_JENV_CHOU3_ROTATED = 86
Global Const $DMPAPER_JENV_CHOU4_ROTATED = 87
Global Const $DMPAPER_B6_JIS = 88
Global Const $DMPAPER_B6_JIS_ROTATED = 89
Global Const $DMPAPER_12X11 = 90
Global Const $DMPAPER_JENV_YOU4 = 91
Global Const $DMPAPER_JENV_YOU4_ROTATED = 92
Global Const $DMPAPER_P16K = 93
Global Const $DMPAPER_P32K = 94
Global Const $DMPAPER_P32KBIG = 95
Global Const $DMPAPER_PENV_1 = 96
Global Const $DMPAPER_PENV_2 = 97
Global Const $DMPAPER_PENV_3 = 98
Global Const $DMPAPER_PENV_4 = 99
Global Const $DMPAPER_PENV_5 = 100
Global Const $DMPAPER_PENV_6 = 101
Global Const $DMPAPER_PENV_7 = 102
Global Const $DMPAPER_PENV_8 = 103
Global Const $DMPAPER_PENV_9 = 104
Global Const $DMPAPER_PENV_10 = 105
Global Const $DMPAPER_P16K_ROTATED = 106
Global Const $DMPAPER_P32K_ROTATED = 107
Global Const $DMPAPER_P32KBIG_ROTATED = 108
Global Const $DMPAPER_PENV_1_ROTATED = 109
Global Const $DMPAPER_PENV_2_ROTATED = 110
Global Const $DMPAPER_PENV_3_ROTATED = 111
Global Const $DMPAPER_PENV_4_ROTATED = 112
Global Const $DMPAPER_PENV_5_ROTATED = 113
Global Const $DMPAPER_PENV_6_ROTATED = 114
Global Const $DMPAPER_PENV_7_ROTATED = 115
Global Const $DMPAPER_PENV_8_ROTATED = 116
Global Const $DMPAPER_PENV_9_ROTATED = 117
Global Const $DMPAPER_PENV_10_ROTATED = 118
Global Const $DMPAPER_USER = 256
Global Const $DMBIN_UPPER = 1
Global Const $DMBIN_LOWER = 2
Global Const $DMBIN_MIDDLE = 3
Global Const $DMBIN_MANUAL = 4
Global Const $DMBIN_ENVELOPE = 5
Global Const $DMBIN_ENVMANUAL = 6
Global Const $DMBIN_AUTO = 7
Global Const $DMBIN_TRACTOR = 8
Global Const $DMBIN_SMALLFMT = 9
Global Const $DMBIN_LARGEFMT = 10
Global Const $DMBIN_LARGECAPACITY = 11
Global Const $DMBIN_CASSETTE = 14
Global Const $DMBIN_FORMSOURCE = 15
Global Const $DMBIN_USER = 256
Global Const $DMRES_DRAFT = + 4294967295
Global Const $DMRES_LOW = + 4294967294
Global Const $DMRES_MEDIUM = + 4294967293
Global Const $DMRES_HIGH = + 4294967292
Global Const $DMDO_DEFAULT = 0
Global Const $DMDO_90 = 1
Global Const $DMDO_180 = 2
Global Const $DMDO_270 = 3
Global Const $DMDFO_DEFAULT = 0
Global Const $DMDFO_STRETCH = 1
Global Const $DMDFO_CENTER = 2
Global Const $DMCOLOR_MONOCHROME = 1
Global Const $DMCOLOR_COLOR = 2
Global Const $DMDUP_SIMPLEX = 1
Global Const $DMDUP_VERTICAL = 2
Global Const $DMDUP_HORIZONTAL = 3
Global Const $DMTT_BITMAP = 1
Global Const $DMTT_DOWNLOAD = 2
Global Const $DMTT_SUBDEV = 3
Global Const $DMTT_DOWNLOAD_OUTLINE = 4
Global Const $DMCOLLATE_FALSE = 0
Global Const $DMCOLLATE_TRUE = 1
Global Const $DM_GRAYSCALE = 1
Global Const $DM_INTERLACED = 2
Global Const $DMNUP_SYSTEM = 1
Global Const $DMNUP_ONEUP = 2
Global Const $DMICMMETHOD_NONE = 1
Global Const $DMICMMETHOD_SYSTEM = 2
Global Const $DMICMMETHOD_DRIVER = 3
Global Const $DMICMMETHOD_DEVICE = 4
Global Const $DMICMMETHOD_USER = 256
Global Const $DMICM_SATURATE = 1
Global Const $DMICM_CONTRAST = 2
Global Const $DMICM_COLORIMETRIC = 3
Global Const $DMICM_ABS_COLORIMETRIC = 4
Global Const $DMICM_USER = 256
Global Const $DMMEDIA_STANDARD = 1
Global Const $DMMEDIA_TRANSPARENCY = 2
Global Const $DMMEDIA_GLOSSY = 3
Global Const $DMMEDIA_USER = 256
Global Const $DMDITHER_NONE = 1
Global Const $DMDITHER_COARSE = 2
Global Const $DMDITHER_FINE = 3
Global Const $DMDITHER_LINEART = 4
Global Const $DMDITHER_ERRORDIFFUSION = 5
Global Const $DMDITHER_RESERVED6 = 6
Global Const $DMDITHER_RESERVED7 = 7
Global Const $DMDITHER_RESERVED8 = 8
Global Const $DMDITHER_RESERVED9 = 9
Global Const $DMDITHER_GRAYSCALE = 10
Global Const $DMDITHER_USER = 256
Global Const $ENUM_CURRENT_SETTINGS = + 4294967295
Global Const $ENUM_REGISTRY_SETTINGS = + 4294967294
Global Const $DEVICE_FONTTYPE = 2
Global Const $RASTER_FONTTYPE = 1
Global Const $TRUETYPE_FONTTYPE = 4
Global Const $NTM_BOLD = 32
Global Const $NTM_DSIG = 2097152
Global Const $NTM_ITALIC = 1
Global Const $NTM_MULTIPLEMASTER = 524288
Global Const $NTM_NONNEGATIVE_AC = 65536
Global Const $NTM_PS_OPENTYPE = 131072
Global Const $NTM_REGULAR = 64
Global Const $NTM_TT_OPENTYPE = 262144
Global Const $NTM_TYPE1 = 1048576
Global Const $FLOODFILLBORDER = 0
Global Const $FLOODFILLSURFACE = 1
Global Const $AD_COUNTERCLOCKWISE = 1
Global Const $AD_CLOCKWISE = 2
Global Const $DCB_ACCUMULATE = 2
Global Const $DCB_DISABLE = 8
Global Const $DCB_ENABLE = 4
Global Const $DCB_RESET = 1
Global Const $DCB_SET = BitOR ( $DCB_RESET , $DCB_ACCUMULATE )
Global Const $DCX_WINDOW = 1
Global Const $DCX_CACHE = 2
Global Const $DCX_PARENTCLIP = 32
Global Const $DCX_CLIPSIBLINGS = 16
Global Const $DCX_CLIPCHILDREN = 8
Global Const $DCX_NORESETATTRS = 4
Global Const $DCX_LOCKWINDOWUPDATE = 1024
Global Const $DCX_EXCLUDERGN = 64
Global Const $DCX_INTERSECTRGN = 128
Global Const $DCX_INTERSECTUPDATE = 512
Global Const $DCX_VALIDATE = 2097152
Global Const $GGO_BEZIER = 3
Global Const $GGO_BITMAP = 1
Global Const $GGO_GLYPH_INDEX = 128
Global Const $GGO_GRAY2_BITMAP = 4
Global Const $GGO_GRAY4_BITMAP = 5
Global Const $GGO_GRAY8_BITMAP = 6
Global Const $GGO_METRICS = 0
Global Const $GGO_NATIVE = 2
Global Const $GGO_UNHINTED = 256
Global Const $GM_COMPATIBLE = 1
Global Const $GM_ADVANCED = 2
Global Const $MM_ANISOTROPIC = 8
Global Const $MM_HIENGLISH = 5
Global Const $MM_HIMETRIC = 3
Global Const $MM_ISOTROPIC = 7
Global Const $MM_LOENGLISH = 4
Global Const $MM_LOMETRIC = 2
Global Const $MM_TEXT = 1
Global Const $MM_TWIPS = 6
Global Const $R2_BLACK = 1
Global Const $R2_COPYPEN = 13
Global Const $R2_LAST = 16
Global Const $R2_MASKNOTPEN = 3
Global Const $R2_MASKPEN = 9
Global Const $R2_MASKPENNOT = 5
Global Const $R2_MERGENOTPEN = 12
Global Const $R2_MERGEPEN = 15
Global Const $R2_MERGEPENNOT = 14
Global Const $R2_NOP = 11
Global Const $R2_NOT = 6
Global Const $R2_NOTCOPYPEN = 4
Global Const $R2_NOTMASKPEN = 8
Global Const $R2_NOTMERGEPEN = 2
Global Const $R2_NOTXORPEN = 10
Global Const $R2_WHITE = 16
Global Const $R2_XORPEN = 7
Global Const $BLACKONWHITE = 1
Global Const $COLORONCOLOR = 3
Global Const $HALFTONE = 4
Global Const $WHITEONBLACK = 2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK
Global Const $TA_BASELINE = 24
Global Const $TA_BOTTOM = 8
Global Const $TA_TOP = 0
Global Const $TA_CENTER = 6
Global Const $TA_LEFT = 0
Global Const $TA_RIGHT = 2
Global Const $TA_NOUPDATECP = 0
Global Const $TA_RTLREADING = 256
Global Const $TA_UPDATECP = 1
Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
Global Const $VTA_RIGHT = $TA_TOP
Global Const $UDF_BGR = 1
Global Const $UDF_RGB = 0
Global Const $MWT_IDENTITY = 1
Global Const $MWT_LEFTMULTIPLY = 2
Global Const $MWT_RIGHTMULTIPLY = 3
Global Const $MWT_SET = 4
Global Const $MONITOR_DEFAULTTONEAREST = 2
Global Const $MONITOR_DEFAULTTONULL = 0
Global Const $MONITOR_DEFAULTTOPRIMARY = 1
Global Const $PT_BEZIERTO = 4
Global Const $PT_LINETO = 2
Global Const $PT_MOVETO = 6
Global Const $PT_CLOSEFIGURE = 1
Global Const $COINIT_APARTMENTTHREADED = 2
Global Const $COINIT_DISABLE_OLE1DDE = 4
Global Const $COINIT_MULTITHREADED = 0
Global Const $COINIT_SPEED_OVER_MEMORY = 8
#Region Global Variables and Constants
Global Const $__TAGWINAPICOM_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CLSIDFROMPROGID ( $SPROGID )
	Local $TGUID = DllStructCreate ( $__TAGWINAPICOM_GUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromProgID" , "wstr" , $SPROGID , "struct*" , $TGUID )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	$ACALL = DllCall ( "ole32.dll" , "int" , "StringFromGUID2" , "struct*" , $TGUID , "wstr" , "" , "int" , 39 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_COINITIALIZE ( $IFLAGS = 0 )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CoInitializeEx" , "ptr" , 0 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_COTASKMEMALLOC ( $ISIZE )
	Local $ACALL = DllCall ( "ole32.dll" , "ptr" , "CoTaskMemAlloc" , "uint_ptr" , $ISIZE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COTASKMEMFREE ( $PMEMORY )
	DllCall ( "ole32.dll" , "none" , "CoTaskMemFree" , "ptr" , $PMEMORY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_COTASKMEMREALLOC ( $PMEMORY , $ISIZE )
	Local $ACALL = DllCall ( "ole32.dll" , "ptr" , "CoTaskMemRealloc" , "ptr" , $PMEMORY , "ulong_ptr" , $ISIZE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COUNINITIALIZE ( )
	DllCall ( "ole32.dll" , "none" , "CoUninitialize" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_CREATEGUID ( )
	Local $TGUID = DllStructCreate ( $__TAGWINAPICOM_GUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CoCreateGuid" , "struct*" , $TGUID )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	$ACALL = DllCall ( "ole32.dll" , "int" , "StringFromGUID2" , "struct*" , $TGUID , "wstr" , "" , "int" , 65536 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_CREATESTREAMONHGLOBAL ( $HGLOBAL = 0 , $BDELETEONRELEASE = True )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CreateStreamOnHGlobal" , "handle" , $HGLOBAL , "bool" , $BDELETEONRELEASE , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETHGLOBALFROMSTREAM ( $PSTREAM )
	Local $ACALL = DllCall ( "ole32.dll" , "uint" , "GetHGlobalFromStream" , "ptr" , $PSTREAM , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_PROGIDFROMCLSID ( $SCLSID )
	Local $TGUID = DllStructCreate ( $__TAGWINAPICOM_GUID )
	Local $ACALL = DllCall ( "ole32.dll" , "uint" , "CLSIDFromString" , "wstr" , $SCLSID , "struct*" , $TGUID )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	$ACALL = DllCall ( "ole32.dll" , "uint" , "ProgIDFromCLSID" , "struct*" , $TGUID , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Local $SID = _WINAPI_GETSTRING ( $ACALL [ 2 ] )
	_WINAPI_COTASKMEMFREE ( $ACALL [ 2 ] )
	Return $SID
EndFunc
Func _WINAPI_RELEASESTREAM ( $PSTREAM )
	Local $ACALL = DllCall ( "oleaut32.dll" , "long" , "DispCallFunc" , "ptr" , $PSTREAM , "ulong_ptr" , 8 * ( 1 + @AutoItX64 ) , "uint" , 4 , "ushort" , 23 , "uint" , 0 , "ptr" , 0 , "ptr" , 0 , "str" , "" )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global $__G_HHEAP = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CREATEBUFFER ( $ILENGTH , $PBUFFER = 0 , $BABORT = True )
	$PBUFFER = __HEAPREALLOC ( $PBUFFER , $ILENGTH , 0 , $BABORT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $PBUFFER
EndFunc
Func _WINAPI_CREATEBUFFERFROMSTRUCT ( $TSTRUCT , $PBUFFER = 0 , $BABORT = True )
	If Not IsDllStruct ( $TSTRUCT ) Then Return SetError ( 1 , 0 , 0 )
	$PBUFFER = __HEAPREALLOC ( $PBUFFER , DllStructGetSize ( $TSTRUCT ) , 0 , $BABORT )
	If @error Then Return SetError ( @error + 100 , @extended , 0 )
	_WINAPI_MOVEMEMORY ( $PBUFFER , $TSTRUCT , DllStructGetSize ( $TSTRUCT ) )
	Return $PBUFFER
EndFunc
Func _WINAPI_CREATESTRING ( $SSTRING , $PSTRING = 0 , $ILENGTH = + 4294967295 , $BUNICODE = True , $BABORT = True )
	$ILENGTH = Number ( $ILENGTH )
	If $ILENGTH >= 0 Then
		$SSTRING = StringLeft ( $SSTRING , $ILENGTH )
	Else
		$ILENGTH = StringLen ( $SSTRING )
	EndIf
	Local $ISIZE = $ILENGTH + 1
	If $BUNICODE Then
		$ISIZE *= 2
	EndIf
	$PSTRING = __HEAPREALLOC ( $PSTRING , $ISIZE , 0 , $BABORT )
	If @error Then Return SetError ( @error , @extended , 0 )
	DllStructSetData ( DllStructCreate ( ( $BUNICODE ? "wchar" : "char" ) & "[" & ( $ILENGTH + 1 ) & "]" , $PSTRING ) , 1 , $SSTRING )
	Return SetExtended ( $ILENGTH , $PSTRING )
EndFunc
Func _WINAPI_EQUALMEMORY ( $PSOURCE1 , $PSOURCE2 , $ILENGTH )
	If _WINAPI_ISBADREADPTR ( $PSOURCE1 , $ILENGTH ) Then Return SetError ( 11 , @extended , 0 )
	If _WINAPI_ISBADREADPTR ( $PSOURCE2 , $ILENGTH ) Then Return SetError ( 12 , @extended , 0 )
	Local $ACALL = DllCall ( "ntdll.dll" , "ulong_ptr" , "RtlCompareMemory" , "struct*" , $PSOURCE1 , "struct*" , $PSOURCE2 , "ulong_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return Number ( $ACALL [ 0 ] = $ILENGTH )
EndFunc
Func _WINAPI_FILLMEMORY ( $PMEMORY , $ILENGTH , $IVALUE = 0 )
	If _WINAPI_ISBADWRITEPTR ( $PMEMORY , $ILENGTH ) Then Return SetError ( 11 , @extended , 0 )
	DllCall ( "ntdll.dll" , "none" , "RtlFillMemory" , "struct*" , $PMEMORY , "ulong_ptr" , $ILENGTH , "byte" , $IVALUE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_FREEMEMORY ( $PMEMORY )
	If Not __HEAPFREE ( $PMEMORY , 1 ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_GETMEMORYSIZE ( $PMEMORY )
	Local $IRESULT = __HEAPSIZE ( $PMEMORY , 1 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $IRESULT
EndFunc
Func _WINAPI_GLOBALMEMORYSTATUS ( )
	Local Const $TAGMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
	Local $TMEM = DllStructCreate ( $TAGMEMORYSTATUSEX )
	DllStructSetData ( $TMEM , 1 , DllStructGetSize ( $TMEM ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GlobalMemoryStatusEx" , "struct*" , $TMEM )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AMEM [ 7 ]
	$AMEM [ 0 ] = DllStructGetData ( $TMEM , 2 )
	$AMEM [ 1 ] = DllStructGetData ( $TMEM , 3 )
	$AMEM [ 2 ] = DllStructGetData ( $TMEM , 4 )
	$AMEM [ 3 ] = DllStructGetData ( $TMEM , 5 )
	$AMEM [ 4 ] = DllStructGetData ( $TMEM , 6 )
	$AMEM [ 5 ] = DllStructGetData ( $TMEM , 7 )
	$AMEM [ 6 ] = DllStructGetData ( $TMEM , 8 )
	Return $AMEM
EndFunc
Func _WINAPI_ISBADCODEPTR ( $PADDRESS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsBadCodePtr" , "struct*" , $PADDRESS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISBADREADPTR ( $PADDRESS , $ILENGTH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsBadReadPtr" , "struct*" , $PADDRESS , "uint_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISBADSTRINGPTR ( $PADDRESS , $ILENGTH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsBadStringPtr" , "struct*" , $PADDRESS , "uint_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISBADWRITEPTR ( $PADDRESS , $ILENGTH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsBadWritePtr" , "struct*" , $PADDRESS , "uint_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISMEMORY ( $PMEMORY )
	Local $BRESULT = __HEAPVALIDATE ( $PMEMORY )
	Return SetError ( @error , @extended , $BRESULT )
EndFunc
Func _WINAPI_LOCALFREE ( $HMEMORY )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $HMEMORY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MOVEMEMORY ( $PDESTINATION , $PSOURCE , $ILENGTH )
	If _WINAPI_ISBADREADPTR ( $PSOURCE , $ILENGTH ) Then Return SetError ( 10 , @extended , 0 )
	If _WINAPI_ISBADWRITEPTR ( $PDESTINATION , $ILENGTH ) Then Return SetError ( 11 , @extended , 0 )
	DllCall ( "ntdll.dll" , "none" , "RtlMoveMemory" , "struct*" , $PDESTINATION , "struct*" , $PSOURCE , "ulong_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_READPROCESSMEMORY ( $HPROCESS , $PBASEADDRESS , $PBUFFER , $ISIZE , ByRef $IREAD )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , $PBASEADDRESS , "struct*" , $PBUFFER , "ulong_ptr" , $ISIZE , "ulong_ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	$IREAD = $ACALL [ 5 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WRITEPROCESSMEMORY ( $HPROCESS , $PBASEADDRESS , $PBUFFER , $ISIZE , ByRef $IWRITTEN , $SBUFFERTYPE = "ptr" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "WriteProcessMemory" , "handle" , $HPROCESS , "ptr" , $PBASEADDRESS , $SBUFFERTYPE , $PBUFFER , "ulong_ptr" , $ISIZE , "ulong_ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	$IWRITTEN = $ACALL [ 5 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ZEROMEMORY ( $PMEMORY , $ILENGTH )
	If _WINAPI_ISBADWRITEPTR ( $PMEMORY , $ILENGTH ) Then Return SetError ( 11 , @extended , 0 )
	DllCall ( "ntdll.dll" , "none" , "RtlZeroMemory" , "struct*" , $PMEMORY , "ulong_ptr" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __HEAPALLOC ( $ISIZE , $BABORT = False )
	Local $ACALL
	If Not $__G_HHEAP Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "HeapCreate" , "dword" , 0 , "ulong_ptr" , 0 , "ulong_ptr" , 0 )
		If @error Or Not $ACALL [ 0 ] Then __FATALEXIT ( 1 , "Error allocating memory." )
		$__G_HHEAP = $ACALL [ 0 ]
	EndIf
	$ACALL = DllCall ( "kernel32.dll" , "ptr" , "HeapAlloc" , "handle" , $__G_HHEAP , "dword" , 8 , "ulong_ptr" , $ISIZE )
	If @error Or Not $ACALL [ 0 ] Then
		If $BABORT Then __FATALEXIT ( 1 , "Error allocating memory." )
		Return SetError ( @error + 30 , @extended , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func __HEAPFREE ( ByRef $PMEMORY , $BCHECK = False , $ICURERR = @error , $ICUREXT = @extended )
	If $BCHECK And ( Not __HEAPVALIDATE ( $PMEMORY ) ) Then Return SetError ( @error , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "HeapFree" , "handle" , $__G_HHEAP , "dword" , 0 , "ptr" , $PMEMORY )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 40 , @extended , 0 )
	$PMEMORY = 0
	Return SetError ( $ICURERR , $ICUREXT , 1 )
EndFunc
Func __HEAPREALLOC ( $PMEMORY , $ISIZE , $BAMOUNT = False , $BABORT = False )
	Local $PRET
	If __HEAPVALIDATE ( $PMEMORY ) Then
		If $BAMOUNT And ( __HEAPSIZE ( $PMEMORY ) >= $ISIZE ) Then Return SetExtended ( 1 , Ptr ( $PMEMORY ) )
		Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "HeapReAlloc" , "handle" , $__G_HHEAP , "dword" , 8 , "ptr" , $PMEMORY , "ulong_ptr" , $ISIZE )
		If @error Or Not $ACALL [ 0 ] Then
			If $BABORT Then __FATALEXIT ( 1 , "Error allocating memory." )
			Return SetError ( @error + 20 , @extended , Ptr ( $PMEMORY ) )
		EndIf
		$PRET = $ACALL [ 0 ]
	Else
		$PRET = __HEAPALLOC ( $ISIZE , $BABORT )
		If @error Then Return SetError ( @error , @extended , 0 )
	EndIf
	Return $PRET
EndFunc
Func __HEAPSIZE ( $PMEMORY , $BCHECK = False )
	If $BCHECK And ( Not __HEAPVALIDATE ( $PMEMORY ) ) Then Return SetError ( @error , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "ulong_ptr" , "HeapSize" , "handle" , $__G_HHEAP , "dword" , 0 , "ptr" , $PMEMORY )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error + 50 , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func __HEAPVALIDATE ( $PMEMORY )
	If ( Not $__G_HHEAP ) Or ( Not Ptr ( $PMEMORY ) ) Then Return SetError ( 9 , 0 , False )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "HeapValidate" , "handle" , $__G_HHEAP , "dword" , 0 , "ptr" , $PMEMORY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Internal Functions
Global Const $SND_APPLICATION = 128
Global Const $SND_ALIAS = 65536
Global Const $SND_ALIAS_ID = 1114112
Global Const $SND_ASYNC = 1
Global Const $SND_FILENAME = 131072
Global Const $SND_LOOP = 8
Global Const $SND_MEMORY = 4
Global Const $SND_NODEFAULT = 2
Global Const $SND_NOSTOP = 16
Global Const $SND_NOWAIT = 8192
Global Const $SND_PURGE = 64
Global Const $SND_RESOURCE = 262148
Global Const $SND_SENTRY = 524288
Global Const $SND_SYNC = 0
Global Const $SND_SYSTEM = 2097152
Global Const $SND_SYSTEM_NOSTOP = 2097168
Global Const $SND_ALIAS_SYSTEMASTERISK = "SystemAsterisk"
Global Const $SND_ALIAS_SYSTEMDEFAULT = "SystemDefault"
Global Const $SND_ALIAS_SYSTEMEXCLAMATION = "SystemExclamation"
Global Const $SND_ALIAS_SYSTEMEXIT = "SystemExit"
Global Const $SND_ALIAS_SYSTEMHAND = "SystemHand"
Global Const $SND_ALIAS_SYSTEMQUESTION = "SystemQuestion"
Global Const $SND_ALIAS_SYSTEMSTART = "SystemStart"
Global Const $SND_ALIAS_SYSTEMWELCOME = "SystemWelcome"
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_ARRAYTOSTRUCT ( Const ByRef $ADATA , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $ADATA , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "wchar[" & ( StringLen ( $ADATA [ $I ] ) + 1 ) & "];"
	Next
	Local $TDATA = DllStructCreate ( $TAGSTRUCT & "wchar[1]" )
	Local $ICOUNT = 1
	For $I = $ISTART To $IEND
		DllStructSetData ( $TDATA , $ICOUNT , $ADATA [ $I ] )
		$ICOUNT += 1
	Next
	DllStructSetData ( $TDATA , $ICOUNT , ChrW ( 0 ) )
	Return $TDATA
EndFunc
Func _WINAPI_CREATEMARGINS ( $ILEFTWIDTH , $IRIGHTWIDTH , $ITOPHEIGHT , $IBOTTOMHEIGHT )
	Local $TMARGINS = DllStructCreate ( $TAGMARGINS )
	DllStructSetData ( $TMARGINS , 1 , $ILEFTWIDTH )
	DllStructSetData ( $TMARGINS , 2 , $IRIGHTWIDTH )
	DllStructSetData ( $TMARGINS , 3 , $ITOPHEIGHT )
	DllStructSetData ( $TMARGINS , 4 , $IBOTTOMHEIGHT )
	Return $TMARGINS
EndFunc
Func _WINAPI_CREATEPOINT ( $IX , $IY )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	DllStructSetData ( $TPOINT , 1 , $IX )
	DllStructSetData ( $TPOINT , 2 , $IY )
	Return $TPOINT
EndFunc
Func _WINAPI_CREATERECT ( $ILEFT , $ITOP , $IRIGHT , $IBOTTOM )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , 1 , $ILEFT )
	DllStructSetData ( $TRECT , 2 , $ITOP )
	DllStructSetData ( $TRECT , 3 , $IRIGHT )
	DllStructSetData ( $TRECT , 4 , $IBOTTOM )
	Return $TRECT
EndFunc
Func _WINAPI_CREATERECTEX ( $IX , $IY , $IWIDTH , $IHEIGHT )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , 1 , $IX )
	DllStructSetData ( $TRECT , 2 , $IY )
	DllStructSetData ( $TRECT , 3 , $IX + $IWIDTH )
	DllStructSetData ( $TRECT , 4 , $IY + $IHEIGHT )
	Return $TRECT
EndFunc
Func _WINAPI_CREATESIZE ( $IWIDTH , $IHEIGHT )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	DllStructSetData ( $TSIZE , 1 , $IWIDTH )
	DllStructSetData ( $TSIZE , 2 , $IHEIGHT )
	Return $TSIZE
EndFunc
Func _WINAPI_COPYSTRUCT ( $TSTRUCT , $SSTRUCT = "" )
	Local $ISIZE = DllStructGetSize ( $TSTRUCT )
	If Not $ISIZE Then Return SetError ( 1 , 0 , 0 )
	Local $TRESULT
	If Not StringStripWS ( $SSTRUCT , $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES ) Then
		$TRESULT = DllStructCreate ( "byte[" & $ISIZE & "]" )
	Else
		$TRESULT = DllStructCreate ( $SSTRUCT )
	EndIf
	If DllStructGetSize ( $TRESULT ) < $ISIZE Then Return SetError ( 2 , 0 , 0 )
	_WINAPI_MOVEMEMORY ( $TRESULT , $TSTRUCT , $ISIZE )
	Return $TRESULT
EndFunc
Func _WINAPI_GETEXTENDED ( )
	Return $__G_VEXT
EndFunc
Func _WINAPI_GETMOUSEPOS ( $BTOCLIENT = False , $HWND = 0 )
	Local $IMODE = Opt ( "MouseCoordMode" , 1 )
	Local $APOS = MouseGetPos ( )
	Opt ( "MouseCoordMode" , $IMODE )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	DllStructSetData ( $TPOINT , "X" , $APOS [ 0 ] )
	DllStructSetData ( $TPOINT , "Y" , $APOS [ 1 ] )
	If $BTOCLIENT And Not _WINAPI_SCREENTOCLIENT ( $HWND , $TPOINT ) Then Return SetError ( @error + 20 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_GETMOUSEPOSX ( $BTOCLIENT = False , $HWND = 0 )
	Local $TPOINT = _WINAPI_GETMOUSEPOS ( $BTOCLIENT , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TPOINT , "X" )
EndFunc
Func _WINAPI_GETMOUSEPOSY ( $BTOCLIENT = False , $HWND = 0 )
	Local $TPOINT = _WINAPI_GETMOUSEPOS ( $BTOCLIENT , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TPOINT , "Y" )
EndFunc
Func _WINAPI_MULDIV ( $INUMBER , $INUMERATOR , $IDENOMINATOR )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "MulDiv" , "int" , $INUMBER , "int" , $INUMERATOR , "int" , $IDENOMINATOR )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PLAYSOUND ( $SSOUND , $IFLAGS = $SND_SYSTEM_NOSTOP , $HINSTANCE = 0 )
	Local $STYPEOFSOUND = "ptr"
	If $SSOUND Then
		If IsString ( $SSOUND ) Then
			$STYPEOFSOUND = "wstr"
		EndIf
	Else
		$SSOUND = 0
		$IFLAGS = 0
	EndIf
	Local $ACALL = DllCall ( "winmm.dll" , "bool" , "PlaySoundW" , $STYPEOFSOUND , $SSOUND , "handle" , $HINSTANCE , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRINGLENA ( Const ByRef $TSTRING )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "lstrlenA" , "struct*" , $TSTRING )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRINGLENW ( Const ByRef $TSTRING )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "lstrlenW" , "struct*" , $TSTRING )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRUCTTOARRAY ( ByRef $TSTRUCT , $IITEMS = 0 )
	Local $ISIZE = 2 * Floor ( DllStructGetSize ( $TSTRUCT ) / 2 )
	Local $PSTRUCT = DllStructGetPtr ( $TSTRUCT )
	If Not $ISIZE Or Not $PSTRUCT Then Return SetError ( 1 , 0 , 0 )
	Local $TDATA , $ILENGTH , $IOFFSET = 0
	Local $ARET [ 101 ] = [ 0 ]
	While 1
		$ILENGTH = _WINAPI_STRLEN ( $PSTRUCT + $IOFFSET )
		If Not $ILENGTH Then
			ExitLoop
		EndIf
		If 2 * ( 1 + $ILENGTH ) + $IOFFSET > $ISIZE Then Return SetError ( 3 , 0 , 0 )
		$TDATA = DllStructCreate ( "wchar[" & ( 1 + $ILENGTH ) & "]" , $PSTRUCT + $IOFFSET )
		If @error Then Return SetError ( @error + 10 , 0 , 0 )
		__INC ( $ARET )
		$ARET [ $ARET [ 0 ] ] = DllStructGetData ( $TDATA , 1 )
		If $ARET [ 0 ] = $IITEMS Then
			ExitLoop
		EndIf
		$IOFFSET += 2 * ( 1 + $ILENGTH )
		If $IOFFSET >= $ISIZE Then Return SetError ( 3 , 0 , 0 )
	WEnd
	If Not $ARET [ 0 ] Then Return SetError ( 2 , 0 , 0 )
	__INC ( $ARET , + 4294967295 )
	Return $ARET
EndFunc
Func _WINAPI_UNIONSTRUCT ( $TSTRUCT1 , $TSTRUCT2 , $SSTRUCT = "" )
	Local $ASIZE [ 2 ] = [ DllStructGetSize ( $TSTRUCT1 ) , DllStructGetSize ( $TSTRUCT2 ) ]
	If Not $ASIZE [ 0 ] Or Not $ASIZE [ 1 ] Then Return SetError ( 1 , 0 , 0 )
	Local $TRESULT
	If Not StringStripWS ( $SSTRUCT , $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES ) Then
		$TRESULT = DllStructCreate ( "byte[" & ( $ASIZE [ 0 ] + $ASIZE [ 1 ] ) & "]" )
	Else
		$TRESULT = DllStructCreate ( $SSTRUCT )
	EndIf
	If DllStructGetSize ( $TRESULT ) < ( $ASIZE [ 0 ] + $ASIZE [ 1 ] ) Then Return SetError ( 2 , 0 , 0 )
	_WINAPI_MOVEMEMORY ( $TRESULT , $TSTRUCT1 , $ASIZE [ 0 ] )
	_WINAPI_MOVEMEMORY ( DllStructGetPtr ( $TRESULT ) + $ASIZE [ 0 ] , $TSTRUCT2 , $ASIZE [ 1 ] )
	Return $TRESULT
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global Const $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
Global Const $TAGBITMAPV5HEADER = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
Global Const $TAGDIBSECTION = $TAGBITMAP & ";" & $TAGBITMAPINFOHEADER & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
Global Const $TMPF_FIXED_PITCH = 1
Global Const $TMPF_VECTOR = 2
Global Const $TMPF_TRUETYPE = 4
Global Const $TMPF_DEVICE = 8
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_BITBLT ( $HDESTDC , $IXDEST , $IYDEST , $IWIDTH , $IHEIGHT , $HSRCDC , $IXSRC , $IYSRC , $IROP )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "BitBlt" , "handle" , $HDESTDC , "int" , $IXDEST , "int" , $IYDEST , "int" , $IWIDTH , "int" , $IHEIGHT , "handle" , $HSRCDC , "int" , $IXSRC , "int" , $IYSRC , "dword" , $IROP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COMBINERGN ( $HRGNDEST , $HRGNSRC1 , $HRGNSRC2 , $ICOMBINEMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "CombineRgn" , "handle" , $HRGNDEST , "handle" , $HRGNSRC1 , "handle" , $HRGNSRC2 , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COPYBITMAP ( $HBITMAP )
	$HBITMAP = _WINAPI_COPYIMAGE ( $HBITMAP , 0 , 0 , 0 , 8192 )
	Return SetError ( @error , @extended , $HBITMAP )
EndFunc
Func _WINAPI_COPYIMAGE ( $HIMAGE , $ITYPE = 0 , $IXDESIREDPIXELS = 0 , $IYDESIREDPIXELS = 0 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "CopyImage" , "handle" , $HIMAGE , "uint" , $ITYPE , "int" , $IXDESIREDPIXELS , "int" , $IYDESIREDPIXELS , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEANDBITMAP ( $HBITMAP )
	Local $IERROR = 0 , $HDIB = 0
	$HBITMAP = _WINAPI_COPYBITMAP ( $HBITMAP )
	If Not $HBITMAP Then Return SetError ( @error + 20 , @extended , 0 )
	Do
		Local $ATDIB [ 2 ]
		$ATDIB [ 0 ] = DllStructCreate ( $TAGDIBSECTION )
		If ( Not _WINAPI_GETOBJECT ( $HBITMAP , DllStructGetSize ( $ATDIB [ 0 ] ) , $ATDIB [ 0 ] ) ) Or ( DllStructGetData ( $ATDIB [ 0 ] , "bmBitsPixel" ) <> 32 ) Or ( DllStructGetData ( $ATDIB [ 0 ] , "biCompression" ) ) Then
			$IERROR = 10
			ExitLoop
		EndIf
		$ATDIB [ 1 ] = DllStructCreate ( $TAGBITMAP )
		$HDIB = _WINAPI_CREATEDIB ( DllStructGetData ( $ATDIB [ 0 ] , "bmWidth" ) , DllStructGetData ( $ATDIB [ 0 ] , "bmHeight" ) , 1 )
		If Not _WINAPI_GETOBJECT ( $HDIB , DllStructGetSize ( $ATDIB [ 1 ] ) , $ATDIB [ 1 ] ) Then
			$IERROR = 11
			ExitLoop
		EndIf
		Local $ACALL = DllCall ( "user32.dll" , "lresult" , "CallWindowProc" , "ptr" , __ANDPROC ( ) , "ptr" , 0 , "uint" , 0 , "wparam" , DllStructGetPtr ( $ATDIB [ 0 ] ) , "lparam" , DllStructGetPtr ( $ATDIB [ 1 ] ) )
		If @error Then
			$IERROR = @error
			ExitLoop
		EndIf
		If Not $ACALL [ 0 ] Then
			$IERROR = 12
			ExitLoop
		EndIf
		$IERROR = 0
	Until 1
	_WINAPI_DELETEOBJECT ( $HBITMAP )
	If $IERROR Then
		If $HDIB Then
			_WINAPI_DELETEOBJECT ( $HDIB )
		EndIf
		$HDIB = 0
	EndIf
	Return SetError ( $IERROR , 0 , $HDIB )
EndFunc
Func _WINAPI_CREATEBITMAP ( $IWIDTH , $IHEIGHT , $IPLANES = 1 , $IBITSPERPEL = 1 , $PBITS = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateBitmap" , "int" , $IWIDTH , "int" , $IHEIGHT , "uint" , $IPLANES , "uint" , $IBITSPERPEL , "struct*" , $PBITS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATECOMPATIBLEBITMAP ( $HDC , $IWIDTH , $IHEIGHT )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleBitmap" , "handle" , $HDC , "int" , $IWIDTH , "int" , $IHEIGHT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEDIB ( $IWIDTH , $IHEIGHT , $IBITSPERPEL = 32 , $TCOLORTABLE = 0 , $ICOLORCOUNT = 0 )
	Local $ARGBQ [ 2 ] , $ICOLORS , $TAGRGBQ
	Switch $IBITSPERPEL
	Case 1
		$ICOLORS = 2
	Case 4
		$ICOLORS = 16
	Case 8
		$ICOLORS = 256
Case Else
		$ICOLORS = 0
	EndSwitch
	If $ICOLORS Then
		If Not IsDllStruct ( $TCOLORTABLE ) Then
			Switch $IBITSPERPEL
			Case 1
				$ARGBQ [ 0 ] = 0
				$ARGBQ [ 1 ] = 16777215
				$TCOLORTABLE = _WINAPI_CREATEDIBCOLORTABLE ( $ARGBQ )
		Case Else
			EndSwitch
		Else
			If $ICOLORS > $ICOLORCOUNT Then
				$ICOLORS = $ICOLORCOUNT
			EndIf
			If ( Not $ICOLORS ) Or ( ( 4 * $ICOLORS ) > DllStructGetSize ( $TCOLORTABLE ) ) Then
				Return SetError ( 20 , 0 , 0 )
			EndIf
		EndIf
		$TAGRGBQ = ";dword aRGBQuad[" & $ICOLORS & "]"
	Else
		$TAGRGBQ = ""
	EndIf
	Local $TBITMAPINFO = DllStructCreate ( $TAGBITMAPINFOHEADER & $TAGRGBQ )
	DllStructSetData ( $TBITMAPINFO , "biSize" , 40 )
	DllStructSetData ( $TBITMAPINFO , "biWidth" , $IWIDTH )
	DllStructSetData ( $TBITMAPINFO , "biHeight" , $IHEIGHT )
	DllStructSetData ( $TBITMAPINFO , "biPlanes" , 1 )
	DllStructSetData ( $TBITMAPINFO , "biBitCount" , $IBITSPERPEL )
	DllStructSetData ( $TBITMAPINFO , "biCompression" , 0 )
	DllStructSetData ( $TBITMAPINFO , "biSizeImage" , 0 )
	DllStructSetData ( $TBITMAPINFO , "biXPelsPerMeter" , 0 )
	DllStructSetData ( $TBITMAPINFO , "biYPelsPerMeter" , 0 )
	DllStructSetData ( $TBITMAPINFO , "biClrUsed" , $ICOLORS )
	DllStructSetData ( $TBITMAPINFO , "biClrImportant" , 0 )
	If $ICOLORS Then
		If IsDllStruct ( $TCOLORTABLE ) Then
			_WINAPI_MOVEMEMORY ( DllStructGetPtr ( $TBITMAPINFO , "aRGBQuad" ) , $TCOLORTABLE , 4 * $ICOLORS )
		Else
			_WINAPI_ZEROMEMORY ( DllStructGetPtr ( $TBITMAPINFO , "aRGBQuad" ) , 4 * $ICOLORS )
		EndIf
	EndIf
	Local $HBITMAP = _WINAPI_CREATEDIBSECTION ( 0 , $TBITMAPINFO , 0 , $__G_VEXT )
	If Not $HBITMAP Then Return SetError ( @error , @extended , 0 )
	Return $HBITMAP
EndFunc
Func _WINAPI_CREATEDIBSECTION ( $HDC , $TBITMAPINFO , $IUSAGE , ByRef $PBITS , $HSECTION = 0 , $IOFFSET = 0 )
	$PBITS = 0
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateDIBSection" , "handle" , $HDC , "struct*" , $TBITMAPINFO , "uint" , $IUSAGE , "ptr*" , 0 , "handle" , $HSECTION , "dword" , $IOFFSET )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	$PBITS = $ACALL [ 4 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEDIBCOLORTABLE ( Const ByRef $ACOLORTABLE , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $ACOLORTABLE , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TCOLORTABLE = DllStructCreate ( "dword[" & ( $IEND - $ISTART + 1 ) & "]" )
	Local $ICOUNT = 1
	For $I = $ISTART To $IEND
		DllStructSetData ( $TCOLORTABLE , 1 , _WINAPI_SWITCHCOLOR ( __RGB ( $ACOLORTABLE [ $I ] ) ) , $ICOUNT )
		$ICOUNT += 1
	Next
	Return $TCOLORTABLE
EndFunc
Func _WINAPI_CREATEFONT ( $IHEIGHT , $IWIDTH , $IESCAPE = 0 , $IORIENTN = 0 , $IWEIGHT = $__WINAPICONSTANT_FW_NORMAL , $BITALIC = False , $BUNDERLINE = False , $BSTRIKEOUT = False , $ICHARSET = $__WINAPICONSTANT_DEFAULT_CHARSET , $IOUTPUTPREC = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS , $ICLIPPREC = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS , $IQUALITY = $__WINAPICONSTANT_DEFAULT_QUALITY , $IPITCH = 0 , $SFACE = "Arial" )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateFontW" , "int" , $IHEIGHT , "int" , $IWIDTH , "int" , $IESCAPE , "int" , $IORIENTN , "int" , $IWEIGHT , "dword" , $BITALIC , "dword" , $BUNDERLINE , "dword" , $BSTRIKEOUT , "dword" , $ICHARSET , "dword" , $IOUTPUTPREC , "dword" , $ICLIPPREC , "dword" , $IQUALITY , "dword" , $IPITCH , "wstr" , $SFACE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEFONTINDIRECT ( $TLOGFONT )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateFontIndirectW" , "struct*" , $TLOGFONT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATERECTRGN ( $ILEFTRECT , $ITOPRECT , $IRIGHTRECT , $IBOTTOMRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateRectRgn" , "int" , $ILEFTRECT , "int" , $ITOPRECT , "int" , $IRIGHTRECT , "int" , $IBOTTOMRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEROUNDRECTRGN ( $ILEFTRECT , $ITOPRECT , $IRIGHTRECT , $IBOTTOMRECT , $IWIDTHELLIPSE , $IHEIGHTELLIPSE )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateRoundRectRgn" , "int" , $ILEFTRECT , "int" , $ITOPRECT , "int" , $IRIGHTRECT , "int" , $IBOTTOMRECT , "int" , $IWIDTHELLIPSE , "int" , $IHEIGHTELLIPSE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATESOLIDBRUSH ( $ICOLOR )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateSolidBrush" , "INT" , $ICOLOR )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETBITMAPDIMENSION ( $HBITMAP )
	Local $TOBJ = DllStructCreate ( $TAGBITMAP )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetObject" , "handle" , $HBITMAP , "int" , DllStructGetSize ( $TOBJ ) , "struct*" , $TOBJ )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return _WINAPI_CREATESIZE ( DllStructGetData ( $TOBJ , "bmWidth" ) , DllStructGetData ( $TOBJ , "bmHeight" ) )
EndFunc
Func _WINAPI_GETSYSCOLORBRUSH ( $IINDEX )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetSysColorBrush" , "int" , $IINDEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTEXTEXTENTPOINT32 ( $HDC , $STEXT )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	Local $ISIZE = StringLen ( $STEXT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetTextExtentPoint32W" , "handle" , $HDC , "wstr" , $STEXT , "int" , $ISIZE , "struct*" , $TSIZE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TSIZE
EndFunc
Func _WINAPI_GETTEXTMETRICS ( $HDC )
	Local $TTEXTMETRIC = DllStructCreate ( $TAGTEXTMETRIC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetTextMetricsW" , "handle" , $HDC , "struct*" , $TTEXTMETRIC )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TTEXTMETRIC
EndFunc
Func _WINAPI_GETWINDOWRGN ( $HWND , $HRGN )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetWindowRgn" , "hwnd" , $HWND , "handle" , $HRGN )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISALPHABITMAP ( $HBITMAP )
	$HBITMAP = _WINAPI_COPYBITMAP ( $HBITMAP )
	If Not $HBITMAP Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL , $IERROR = 0
	Do
		Local $TDIB = DllStructCreate ( $TAGDIBSECTION )
		If ( Not _WINAPI_GETOBJECT ( $HBITMAP , DllStructGetSize ( $TDIB ) , $TDIB ) ) Or ( DllStructGetData ( $TDIB , "bmBitsPixel" ) <> 32 ) Or ( DllStructGetData ( $TDIB , "biCompression" ) ) Then
			$IERROR = 1
			ExitLoop
		EndIf
		$ACALL = DllCall ( "user32.dll" , "int" , "CallWindowProc" , "ptr" , __ALPHAPROC ( ) , "ptr" , 0 , "uint" , 0 , "struct*" , $TDIB , "ptr" , 0 )
		If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
	Until 1
	_WINAPI_DELETEOBJECT ( $HBITMAP )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PTINRECT ( ByRef $TRECT , ByRef $TPOINT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "PtInRect" , "struct*" , $TRECT , "struct" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REDRAWWINDOW ( $HWND , $TRECT = 0 , $HREGION = 0 , $IFLAGS = 5 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "RedrawWindow" , "hwnd" , $HWND , "struct*" , $TRECT , "handle" , $HREGION , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWRGN ( $HWND , $HRGN , $BREDRAW = True )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "SetWindowRgn" , "hwnd" , $HWND , "handle" , $HRGN , "bool" , $BREDRAW )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __ALPHAPROC ( )
	Static $PPROC = 0
	If Not $PPROC Then
		If @AutoItX64 Then
			$PPROC = __INIT ( Binary ( "0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3" ) )
		Else
			$PPROC = __INIT ( Binary ( "0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000" ) )
		EndIf
	EndIf
	Return $PPROC
EndFunc
Func __ANDPROC ( )
	Static $PPROC = 0
	If Not $PPROC Then
		If @AutoItX64 Then
			$PPROC = __INIT ( Binary ( "0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3" ) )
		Else
			$PPROC = __INIT ( Binary ( "0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000" ) )
		EndIf
	EndIf
	Return $PPROC
EndFunc
Func __XORPROC ( )
	Static $PPROC = 0
	If Not $PPROC Then
		If @AutoItX64 Then
			$PPROC = __INIT ( Binary ( "0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3" ) )
		Else
			$PPROC = __INIT ( Binary ( "0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000" ) )
		EndIf
	EndIf
	Return $PPROC
EndFunc
#EndRegion Embedded DLL Functions
#Region Internal Functions
Func __INIT ( $DDATA )
	Local $ILENGTH = BinaryLen ( $DDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "VirtualAlloc" , "ptr" , 0 , "ulong_ptr" , $ILENGTH , "dword" , 4096 , "dword" , 64 )
	If @error Or Not $ACALL [ 0 ] Then __FATALEXIT ( 1 , "Error allocating memory." )
	Local $TDATA = DllStructCreate ( "byte[" & $ILENGTH & "]" , $ACALL [ 0 ] )
	DllStructSetData ( $TDATA , 1 , $DDATA )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $DI_MASK = 1
Global Const $DI_IMAGE = 2
Global Const $DI_NORMAL = 3
Global Const $DI_COMPAT = 4
Global Const $DI_DEFAULTSIZE = 8
Global Const $DI_NOMIRROR = 16
Global Const $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 1
Global Const $DISPLAY_DEVICE_MULTI_DRIVER = 2
Global Const $DISPLAY_DEVICE_PRIMARY_DEVICE = 4
Global Const $DISPLAY_DEVICE_MIRRORING_DRIVER = 8
Global Const $DISPLAY_DEVICE_VGA_COMPATIBLE = 16
Global Const $DISPLAY_DEVICE_REMOVABLE = 32
Global Const $DISPLAY_DEVICE_DISCONNECT = 33554432
Global Const $DISPLAY_DEVICE_REMOTE = 67108864
Global Const $DISPLAY_DEVICE_MODESPRUNED = 134217728
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_CREATECOMPATIBLEDC ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleDC" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DELETEDC ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "DeleteDC" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWEDGE ( $HDC , $TRECT , $IEDGETYPE , $IFLAGS )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DrawEdge" , "handle" , $HDC , "struct*" , $TRECT , "uint" , $IEDGETYPE , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWFRAMECONTROL ( $HDC , $TRECT , $ITYPE , $ISTATE )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DrawFrameControl" , "handle" , $HDC , "struct*" , $TRECT , "uint" , $ITYPE , "uint" , $ISTATE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWICON ( $HDC , $IX , $IY , $HICON )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DrawIcon" , "handle" , $HDC , "int" , $IX , "int" , $IY , "handle" , $HICON )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWICONEX ( $HDC , $IX , $IY , $HICON , $IWIDTH = 0 , $IHEIGHT = 0 , $ISTEP = 0 , $HBRUSH = 0 , $IFLAGS = 3 )
	Local $IOPTIONS
	Switch $IFLAGS
	Case 1
		$IOPTIONS = $DI_MASK
	Case 2
		$IOPTIONS = $DI_IMAGE
	Case 3
		$IOPTIONS = $DI_NORMAL
	Case 4
		$IOPTIONS = $DI_COMPAT
	Case 5
		$IOPTIONS = $DI_DEFAULTSIZE
Case Else
		$IOPTIONS = $DI_NOMIRROR
	EndSwitch
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DrawIconEx" , "handle" , $HDC , "int" , $IX , "int" , $IY , "handle" , $HICON , "int" , $IWIDTH , "int" , $IHEIGHT , "uint" , $ISTEP , "handle" , $HBRUSH , "uint" , $IOPTIONS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWTEXT ( $HDC , $STEXT , ByRef $TRECT , $IFLAGS )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "DrawTextW" , "handle" , $HDC , "wstr" , $STEXT , "int" , + 4294967295 , "struct*" , $TRECT , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENUMDISPLAYDEVICES ( $SDEVICE , $IDEVNUM )
	Local $TNAME = 0 , $IFLAGS = 0 , $ADEVICE [ 5 ]
	If $SDEVICE <> "" Then
		$TNAME = DllStructCreate ( "wchar Text[" & StringLen ( $SDEVICE ) + 1 & "]" )
		DllStructSetData ( $TNAME , "Text" , $SDEVICE )
	EndIf
	Local Const $TAGDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
	Local $TDEVICE = DllStructCreate ( $TAGDISPLAY_DEVICE )
	Local $IDEVICE = DllStructGetSize ( $TDEVICE )
	DllStructSetData ( $TDEVICE , "Size" , $IDEVICE )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnumDisplayDevicesW" , "struct*" , $TNAME , "dword" , $IDEVNUM , "struct*" , $TDEVICE , "dword" , 1 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $IN = DllStructGetData ( $TDEVICE , "Flags" )
	If BitAND ( $IN , $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 1 )
	If BitAND ( $IN , $DISPLAY_DEVICE_PRIMARY_DEVICE ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 2 )
	If BitAND ( $IN , $DISPLAY_DEVICE_MIRRORING_DRIVER ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 4 )
	If BitAND ( $IN , $DISPLAY_DEVICE_VGA_COMPATIBLE ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 8 )
	If BitAND ( $IN , $DISPLAY_DEVICE_REMOVABLE ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 16 )
	If BitAND ( $IN , $DISPLAY_DEVICE_MODESPRUNED ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 32 )
	$ADEVICE [ 0 ] = True
	$ADEVICE [ 1 ] = DllStructGetData ( $TDEVICE , "Name" )
	$ADEVICE [ 2 ] = DllStructGetData ( $TDEVICE , "String" )
	$ADEVICE [ 3 ] = $IFLAGS
	$ADEVICE [ 4 ] = DllStructGetData ( $TDEVICE , "ID" )
	Return $ADEVICE
EndFunc
Func _WINAPI_FILLRECT ( $HDC , $TRECT , $HBRUSH )
	Local $ACALL
	If IsPtr ( $HBRUSH ) Then
		$ACALL = DllCall ( "user32.dll" , "int" , "FillRect" , "handle" , $HDC , "struct*" , $TRECT , "handle" , $HBRUSH )
	Else
		$ACALL = DllCall ( "user32.dll" , "int" , "FillRect" , "handle" , $HDC , "struct*" , $TRECT , "dword_ptr" , $HBRUSH )
	EndIf
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FRAMERECT ( $HDC , $TRECT , $HBRUSH )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "FrameRect" , "handle" , $HDC , "struct*" , $TRECT , "handle" , $HBRUSH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETBKMODE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetBkMode" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETDC ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetDC" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETDCEX ( $HWND , $HRGN , $IFLAGS )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetDCEx" , "hwnd" , $HWND , "handle" , $HRGN , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETDEVICECAPS ( $HDC , $IINDEX )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetDeviceCaps" , "handle" , $HDC , "int" , $IINDEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTEXTCOLOR ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "GetTextColor" , "handle" , $HDC )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_GETWINDOWDC ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetWindowDC" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PRINTWINDOW ( $HWND , $HDC , $BCLIENT = False )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "PrintWindow" , "hwnd" , $HWND , "handle" , $HDC , "uint" , $BCLIENT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RELEASEDC ( $HWND , $HDC )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "ReleaseDC" , "hwnd" , $HWND , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RESTOREDC ( $HDC , $IID )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "RestoreDC" , "handle" , $HDC , "int" , $IID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SAVEDC ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SaveDC" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETBKCOLOR ( $HDC , $ICOLOR )
	Local $ACALL = DllCall ( "gdi32.dll" , "INT" , "SetBkColor" , "handle" , $HDC , "INT" , $ICOLOR )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETBKMODE ( $HDC , $IBKMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetBkMode" , "handle" , $HDC , "int" , $IBKMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTEXTCOLOR ( $HDC , $ICOLOR )
	Local $ACALL = DllCall ( "gdi32.dll" , "INT" , "SetTextColor" , "handle" , $HDC , "INT" , $ICOLOR )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_TWIPSPERPIXELX ( )
	Local $HDC , $ITWIPSPERPIXELX
	$HDC = _WINAPI_GETDC ( 0 )
	Local Const $__WINAPICONSTANT_LOGPIXELSX = 88
	$ITWIPSPERPIXELX = 1440 / _WINAPI_GETDEVICECAPS ( $HDC , $__WINAPICONSTANT_LOGPIXELSX )
	_WINAPI_RELEASEDC ( 0 , $HDC )
	Return $ITWIPSPERPIXELX
EndFunc
Func _WINAPI_TWIPSPERPIXELY ( )
	Local $HDC , $ITWIPSPERPIXELY
	$HDC = _WINAPI_GETDC ( 0 )
	Local Const $__WINAPICONSTANT_LOGPIXELSY = 90
	$ITWIPSPERPIXELY = 1440 / _WINAPI_GETDEVICECAPS ( $HDC , $__WINAPICONSTANT_LOGPIXELSY )
	_WINAPI_RELEASEDC ( 0 , $HDC )
	Return $ITWIPSPERPIXELY
EndFunc
#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $IDC_UNKNOWN = 0
Global Const $IDC_APPSTARTING = 32650
Global Const $IDC_ARROW = 32512
Global Const $IDC_CROSS = 32515
Global Const $IDC_HAND = 32649
Global Const $IDC_HELP = 32651
Global Const $IDC_IBEAM = 32513
Global Const $IDC_NO = 32648
Global Const $IDC_SIZEALL = 32646
Global Const $IDC_SIZENESW = 32643
Global Const $IDC_SIZENS = 32645
Global Const $IDC_SIZENWSE = 32642
Global Const $IDC_SIZEWE = 32644
Global Const $IDC_UPARROW = 32516
Global Const $IDC_WAIT = 32514
Global Const $IDI_APPLICATION = 32512
Global Const $IDI_ASTERISK = 32516
Global Const $IDI_EXCLAMATION = 32515
Global Const $IDI_HAND = 32513
Global Const $IDI_QUESTION = 32514
Global Const $IDI_WINLOGO = 32517
Global Const $IDI_SHIELD = 32518
Global Const $IDI_ERROR = $IDI_HAND
Global Const $IDI_INFORMATION = $IDI_ASTERISK
Global Const $IDI_WARNING = $IDI_EXCLAMATION
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Global Const $TAGICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WINAPI_ADDICONTRANSPARENCY ( $HICON , $IPERCENT = 50 , $BDELETE = False )
	Local $TBITMAP , $HDIB = 0 , $HRESULT = 0
	Local $AHBITMAP [ 2 ]
	Local $TICONINFO = DllStructCreate ( $TAGICONINFO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfo" , "handle" , $HICON , "struct*" , $TICONINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	For $I = 0 To 1
		$AHBITMAP [ $I ] = DllStructGetData ( $TICONINFO , $I + 4 )
	Next
	Local $IERROR = 0
	Do
		$HDIB = _WINAPI_COPYBITMAP ( $AHBITMAP [ 1 ] )
		If Not $HDIB Then
			$IERROR = 20
			ExitLoop
		EndIf
		$TBITMAP = DllStructCreate ( $TAGBITMAP )
		If ( Not _WINAPI_GETOBJECT ( $HDIB , DllStructGetSize ( $TBITMAP ) , $TBITMAP ) ) Or ( DllStructGetData ( $TBITMAP , "bmBitsPixel" ) <> 32 ) Then
			$IERROR = 21
			ExitLoop
		EndIf
		$ACALL = DllCall ( "user32.dll" , "lresult" , "CallWindowProc" , "PTR" , __TRANSPARENCYPROC ( ) , "hwnd" , 0 , "uint" , $IPERCENT , "wparam" , DllStructGetPtr ( $TBITMAP ) , "lparam" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		If $ACALL [ 0 ] = + 4294967295 Then
			$HRESULT = _WINAPI_CREATEEMPTYICON ( DllStructGetData ( $TBITMAP , "bmWidth" ) , DllStructGetData ( $TBITMAP , "bmHeight" ) )
		Else
			$HRESULT = _WINAPI_CREATEICONINDIRECT ( $HDIB , $AHBITMAP [ 0 ] )
		EndIf
		If Not $HRESULT Then $IERROR = 22
	Until 1
	If $HDIB Then
		_WINAPI_DELETEOBJECT ( $HDIB )
	EndIf
	For $I = 0 To 1
		If $AHBITMAP [ $I ] Then
			_WINAPI_DELETEOBJECT ( $AHBITMAP [ $I ] )
		EndIf
	Next
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	If $BDELETE Then
		_WINAPI_DESTROYICON ( $HICON )
	EndIf
	Return $HRESULT
EndFunc
Func _WINAPI_COPYICON ( $HICON )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "CopyIcon" , "handle" , $HICON )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATE32BITHICON ( $HICON , $BDELETE = False )
	Local $AHBITMAP [ 2 ] , $HRESULT = 0
	Local $ADIB [ 2 ] [ 2 ] = [ [ 0 , 0 ] , [ 0 , 0 ] ]
	Local $TICONINFO = DllStructCreate ( $TAGICONINFO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfo" , "handle" , $HICON , "struct*" , $TICONINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	For $I = 0 To 1
		$AHBITMAP [ $I ] = DllStructGetData ( $TICONINFO , $I + 4 )
	Next
	If _WINAPI_ISALPHABITMAP ( $AHBITMAP [ 1 ] ) Then
		$ADIB [ 0 ] [ 0 ] = _WINAPI_CREATEANDBITMAP ( $AHBITMAP [ 1 ] )
		If Not @error Then
			$HRESULT = _WINAPI_CREATEICONINDIRECT ( $AHBITMAP [ 1 ] , $ADIB [ 0 ] [ 0 ] )
		EndIf
	Else
		Local $TSIZE = _WINAPI_GETBITMAPDIMENSION ( $AHBITMAP [ 1 ] )
		Local $ASIZE [ 2 ]
		For $I = 0 To 1
			$ASIZE [ $I ] = DllStructGetData ( $TSIZE , $I + 1 )
		Next
		Local $HSRCDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
		Local $HDSTDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
		Local $HSRCSV , $HDSTSV
		For $I = 0 To 1
			$ADIB [ $I ] [ 0 ] = _WINAPI_CREATEDIB ( $ASIZE [ 0 ] , $ASIZE [ 1 ] )
			$ADIB [ $I ] [ 1 ] = $__G_VEXT
			$HSRCSV = _WINAPI_SELECTOBJECT ( $HSRCDC , $AHBITMAP [ $I ] )
			$HDSTSV = _WINAPI_SELECTOBJECT ( $HDSTDC , $ADIB [ $I ] [ 0 ] )
			_WINAPI_BITBLT ( $HDSTDC , 0 , 0 , $ASIZE [ 0 ] , $ASIZE [ 1 ] , $HSRCDC , 0 , 0 , 12583114 )
			_WINAPI_SELECTOBJECT ( $HSRCDC , $HSRCSV )
			_WINAPI_SELECTOBJECT ( $HDSTDC , $HDSTSV )
		Next
		_WINAPI_DELETEDC ( $HSRCDC )
		_WINAPI_DELETEDC ( $HDSTDC )
		$ACALL = DllCall ( "user32.dll" , "lresult" , "CallWindowProc" , "ptr" , __XORPROC ( ) , "ptr" , 0 , "uint" , $ASIZE [ 0 ] * $ASIZE [ 1 ] * 4 , "wparam" , $ADIB [ 0 ] [ 1 ] , "lparam" , $ADIB [ 1 ] [ 1 ] )
		If Not @error And $ACALL [ 0 ] Then
			$HRESULT = _WINAPI_CREATEICONINDIRECT ( $ADIB [ 1 ] [ 0 ] , $AHBITMAP [ 0 ] )
		EndIf
	EndIf
	For $I = 0 To 1
		_WINAPI_DELETEOBJECT ( $AHBITMAP [ $I ] )
		If $ADIB [ $I ] [ 0 ] Then
			_WINAPI_DELETEOBJECT ( $ADIB [ $I ] [ 0 ] )
		EndIf
	Next
	If Not $HRESULT Then Return SetError ( 11 , 0 , 0 )
	If $BDELETE Then
		_WINAPI_DESTROYICON ( $HICON )
	EndIf
	Return $HRESULT
EndFunc
Func _WINAPI_CREATEEMPTYICON ( $IWIDTH , $IHEIGHT , $IBITSPERPEL = 32 )
	Local $HXOR = _WINAPI_CREATEDIB ( $IWIDTH , $IHEIGHT , $IBITSPERPEL )
	Local $HAND = _WINAPI_CREATEDIB ( $IWIDTH , $IHEIGHT , 1 )
	Local $HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $HSV = _WINAPI_SELECTOBJECT ( $HDC , $HAND )
	Local $HBRUSH = _WINAPI_CREATESOLIDBRUSH ( 16777215 )
	Local $TRECT = _WINAPI_CREATERECT ( 0 , 0 , $IWIDTH , $IHEIGHT )
	_WINAPI_FILLRECT ( $HDC , $TRECT , $HBRUSH )
	_WINAPI_DELETEOBJECT ( $HBRUSH )
	_WINAPI_SELECTOBJECT ( $HDC , $HSV )
	_WINAPI_DELETEDC ( $HDC )
	Local $HICON = _WINAPI_CREATEICONINDIRECT ( $HXOR , $HAND )
	Local $IERROR = @error
	If $HXOR Then
		_WINAPI_DELETEOBJECT ( $HXOR )
	EndIf
	If $HAND Then
		_WINAPI_DELETEOBJECT ( $HAND )
	EndIf
	If Not $HICON Then Return SetError ( $IERROR + 10 , 0 , 0 )
	Return $HICON
EndFunc
Func _WINAPI_CREATEICON ( $HINSTANCE , $IWIDTH , $IHEIGHT , $IPLANES , $IBITSPIXEL , $PANDBITS , $PXORBITS )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "CreateIcon" , "handle" , $HINSTANCE , "int" , $IWIDTH , "int" , $IHEIGHT , "byte" , $IPLANES , "byte" , $IBITSPIXEL , "struct*" , $PANDBITS , "struct*" , $PXORBITS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEICONFROMRESOURCEEX ( $PDATA , $ISIZE , $BICON = True , $IXDESIREDPIXELS = 0 , $IYDESIREDPIXELS = 0 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "CreateIconFromResourceEx" , "ptr" , $PDATA , "dword" , $ISIZE , "bool" , $BICON , "dword" , 196608 , "int" , $IXDESIREDPIXELS , "int" , $IYDESIREDPIXELS , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEICONINDIRECT ( $HBITMAP , $HMASK , $IXHOTSPOT = 0 , $IYHOTSPOT = 0 , $BICON = True )
	Local $TICONINFO = DllStructCreate ( $TAGICONINFO )
	DllStructSetData ( $TICONINFO , 1 , $BICON )
	DllStructSetData ( $TICONINFO , 2 , $IXHOTSPOT )
	DllStructSetData ( $TICONINFO , 3 , $IYHOTSPOT )
	DllStructSetData ( $TICONINFO , 4 , $HMASK )
	DllStructSetData ( $TICONINFO , 5 , $HBITMAP )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "CreateIconIndirect" , "struct*" , $TICONINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DESTROYICON ( $HICON )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DestroyIcon" , "handle" , $HICON )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EXTRACTICON ( $SICON , $IINDEX , $BSMALL = False )
	Local $PLARGE , $PSMALL , $TPTR = DllStructCreate ( "ptr" )
	If $BSMALL Then
		$PLARGE = 0
		$PSMALL = DllStructGetPtr ( $TPTR )
	Else
		$PLARGE = DllStructGetPtr ( $TPTR )
		$PSMALL = 0
	EndIf
	DllCall ( "shell32.dll" , "uint" , "ExtractIconExW" , "wstr" , $SICON , "int" , $IINDEX , "ptr" , $PLARGE , "ptr" , $PSMALL , "uint" , 1 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TPTR , 1 )
EndFunc
Func _WINAPI_EXTRACTICONEX ( $SFILEPATH , $IINDEX , $PALARGE , $PASMALL , $IICONS )
	Local $ACALL = DllCall ( "shell32.dll" , "uint" , "ExtractIconExW" , "wstr" , $SFILEPATH , "int" , $IINDEX , "struct*" , $PALARGE , "struct*" , $PASMALL , "uint" , $IICONS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FILEICONINIT ( $BRESTORE = True )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , 660 , "int" , $BRESTORE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_GETICONDIMENSION ( $HICON )
	Local $TICONINFO = DllStructCreate ( $TAGICONINFO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfo" , "handle" , $HICON , "struct*" , $TICONINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TSIZE = _WINAPI_GETBITMAPDIMENSION ( DllStructGetData ( $TICONINFO , 5 ) )
	For $I = 4 To 5
		_WINAPI_DELETEOBJECT ( DllStructGetData ( $TICONINFO , $I ) )
	Next
	If Not IsDllStruct ( $TSIZE ) Then Return SetError ( 20 , 0 , 0 )
	Return $TSIZE
EndFunc
Func _WINAPI_GETICONINFO ( $HICON )
	Local $TINFO = DllStructCreate ( $TAGICONINFO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfo" , "handle" , $HICON , "struct*" , $TINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AICON [ 6 ]
	$AICON [ 0 ] = True
	$AICON [ 1 ] = DllStructGetData ( $TINFO , "Icon" ) <> 0
	$AICON [ 2 ] = DllStructGetData ( $TINFO , "XHotSpot" )
	$AICON [ 3 ] = DllStructGetData ( $TINFO , "YHotSpot" )
	$AICON [ 4 ] = DllStructGetData ( $TINFO , "hMask" )
	$AICON [ 5 ] = DllStructGetData ( $TINFO , "hColor" )
	Return $AICON
EndFunc
Func _WINAPI_GETICONINFOEX ( $HICON )
	Local $TIIEX = DllStructCreate ( "dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]" )
	DllStructSetData ( $TIIEX , 1 , DllStructGetSize ( $TIIEX ) )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfoExW" , "handle" , $HICON , "struct*" , $TIIEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 8 ]
	For $I = 0 To 7
		$ARET [ $I ] = DllStructGetData ( $TIIEX , $I + 2 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_LOADICON ( $HINSTANCE , $SNAME )
	Local $STYPEOFNAME = "int"
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "LoadIconW" , "handle" , $HINSTANCE , $STYPEOFNAME , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADICONMETRIC ( $HINSTANCE , $SNAME , $IMETRIC )
	Local $STYPEOFNAME = "int"
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "comctl32.dll" , "long" , "LoadIconMetric" , "handle" , $HINSTANCE , $STYPEOFNAME , $SNAME , "int" , $IMETRIC , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _WINAPI_LOADICONWITHSCALEDOWN ( $HINSTANCE , $SNAME , $IWIDTH , $IHEIGHT )
	Local $STYPEOFNAME = "int"
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "comctl32.dll" , "long" , "LoadIconWithScaleDown" , "handle" , $HINSTANCE , $STYPEOFNAME , $SNAME , "int" , $IWIDTH , "int" , $IHEIGHT , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_LOADSHELL32ICON ( $IICONID )
	Local $TICONS = DllStructCreate ( "ptr Data" )
	Local $IICONS = _WINAPI_EXTRACTICONEX ( "shell32.dll" , $IICONID , 0 , $TICONS , 1 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $IICONS <= 0 Then Return SetError ( 10 , 0 , 0 )
	Return DllStructGetData ( $TICONS , "Data" )
EndFunc
Func _WINAPI_LOOKUPICONIDFROMDIRECTORYEX ( $PDATA , $BICON = True , $IXDESIREDPIXELS = 0 , $IYDESIREDPIXELS = 0 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "LookupIconIdFromDirectoryEx" , "ptr" , $PDATA , "bool" , $BICON , "int" , $IXDESIREDPIXELS , "int" , $IYDESIREDPIXELS , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MIRRORICON ( $HICON , $BDELETE = False )
	If Not $BDELETE Then
		$HICON = _WINAPI_COPYICON ( $HICON )
	EndIf
	Local $ACALL = DllCall ( "comctl32.dll" , "int" , 414 , "ptr" , 0 , "ptr*" , $HICON )
	If @error Or Not $ACALL [ 0 ] Then
		Local $IERROR = @error + 10
		If $HICON And Not $BDELETE Then
			_WINAPI_DESTROYICON ( $HICON )
		EndIf
		Return SetError ( $IERROR , 0 , 0 )
	EndIf
	Return $ACALL [ 2 ]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __TRANSPARENCYPROC ( )
	Static $PPROC = 0
	If Not $PPROC Then
		If @AutoItX64 Then
			$PPROC = __INIT ( Binary ( "0x48894C240848895424104C894424184C894C24205541574831C0505050505050" & "4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522" & "488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502" & "EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63" & "7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF" & "7D08C74424780000000048C74424280100000048C74424300000000048C74424" & "3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF" & "F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18" & "4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C" & "244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899" & "48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7" & "4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24" & "3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0" & "FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F" & "5DC3" ) )
		Else
			$PPROC = __INIT ( Binary ( "0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24" & "28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021" & "C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24" & "2421DB7D08C744242400000000C7042401000000C744240400000000C7442408" & "000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B" & "6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24" & "100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058" & "8845008B6C240C807D00007407C7042400000000C74424040100000083442408" & "047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF" & "FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000" ) )
		EndIf
	EndIf
	Return $PPROC
EndFunc
#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
Global Const $TAGBITMAPV4HEADER = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
Global Const $TAGCOLORADJUSTMENT = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint"
Global Const $TAGDEVMODE = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight"
Global Const $TAGDEVMODE_DISPLAY = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $TAGPOINT & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency"
Global Const $TAGDWM_COLORIZATION_PARAMETERS = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
Global Const $TAGENHMETAHEADER = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct"
Global Const $TAGEXTLOGPEN = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
Global Const $TAGFONTSIGNATURE = "dword fsUsb[4];dword fsCsb[2]"
Global Const $TAGGLYPHMETRICS = "uint BlackBoxX;uint BlackBoxY;" & $TAGPOINT & ";short CellIncX;short CellIncY"
Global Const $TAGLOGBRUSH = "uint Style;dword Color;ulong_ptr Hatch"
Global Const $TAGLOGPEN = "uint Style;dword Width;dword Color"
Global Const $TAGMAT2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
Global Const $TAGNEWTEXTMETRIC = $TAGTEXTMETRIC & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
Global Const $TAGNEWTEXTMETRICEX = $TAGNEWTEXTMETRIC & ";" & $TAGFONTSIGNATURE
Global Const $TAGPANOSE = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct"
Global Const $TAGOUTLINETEXTMETRIC = "struct;uint otmSize;" & $TAGTEXTMETRIC & ";byte otmFiller;" & $TAGPANOSE & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
Global Const $TAGPAINTSTRUCT = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
Global Const $TAGRGNDATAHEADER = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $TAGRECT & ";endstruct"
Global Const $TAGXFORM = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_ABORTPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "AbortPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ADDFONTMEMRESOURCEEX ( $PDATA , $ISIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "AddFontMemResourceEx" , "ptr" , $PDATA , "dword" , $ISIZE , "ptr" , 0 , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 4 ] , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_ADDFONTRESOURCEEX ( $SFONT , $IFLAG = 0 , $BNOTIFY = False )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "AddFontResourceExW" , "wstr" , $SFONT , "dword" , $IFLAG , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	If $BNOTIFY Then
		Local Const $WM_FONTCHANGE = 29
		Local Const $HWND_BROADCAST = 65535
		DllCall ( "user32.dll" , "lresult" , "SendMessage" , "hwnd" , $HWND_BROADCAST , "uint" , $WM_FONTCHANGE , "wparam" , 0 , "lparam" , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ADDICONOVERLAY ( $HICON , $HOVERLAY )
	Local $ACALL , $HRESULT = 0 , $IERROR = 0
	Local $AHDEV [ 2 ] = [ 0 , 0 ]
	Local $TSIZE = _WINAPI_GETICONDIMENSION ( $HICON )
	Local $HIL = DllCall ( "comctl32.dll" , "handle" , "ImageList_Create" , "int" , DllStructGetData ( $TSIZE , 1 ) , "int" , DllStructGetData ( $TSIZE , 2 ) , "uint" , 33 , "int" , 2 , "int" , 2 )
	If @error Or Not $HIL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Do
		$AHDEV [ 0 ] = _WINAPI_CREATE32BITHICON ( $HICON )
		If @error Then
			$IERROR = @error + 100
			ExitLoop
		EndIf
		$ACALL = DllCall ( "comctl32.dll" , "int" , "ImageList_ReplaceIcon" , "handle" , $HIL [ 0 ] , "int" , + 4294967295 , "handle" , $AHDEV [ 0 ] )
		If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then
			$IERROR = @error + 200
			ExitLoop
		EndIf
		$AHDEV [ 1 ] = _WINAPI_CREATE32BITHICON ( $HOVERLAY )
		If @error Then
			$IERROR = @error + 300
			ExitLoop
		EndIf
		$ACALL = DllCall ( "comctl32.dll" , "int" , "ImageList_ReplaceIcon" , "handle" , $HIL [ 0 ] , "int" , + 4294967295 , "handle" , $AHDEV [ 1 ] )
		If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then
			$IERROR = @error + 400
			ExitLoop
		EndIf
		$ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_SetOverlayImage" , "handle" , $HIL [ 0 ] , "int" , 1 , "int" , 1 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 500
			ExitLoop
		EndIf
		$ACALL = DllCall ( "comctl32.dll" , "handle" , "ImageList_GetIcon" , "handle" , $HIL [ 0 ] , "int" , 0 , "uint" , 256 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 600
			ExitLoop
		EndIf
		$HRESULT = $ACALL [ 0 ]
	Until 1
	DllCall ( "comctl32.dll" , "bool" , "ImageList_Destroy" , "handle" , $HIL [ 0 ] )
	For $I = 0 To 1
		If $AHDEV [ $I ] Then
			_WINAPI_DESTROYICON ( $AHDEV [ $I ] )
		EndIf
	Next
	If Not $HRESULT Then Return SetError ( $IERROR , 0 , 0 )
	Return $HRESULT
EndFunc
Func _WINAPI_ADJUSTBITMAP ( $HBITMAP , $IWIDTH , $IHEIGHT , $IMODE = 3 , $TADJUSTMENT = 0 )
	Local $TOBJ = DllStructCreate ( $TAGBITMAP )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetObject" , "handle" , $HBITMAP , "int" , DllStructGetSize ( $TOBJ ) , "struct*" , $TOBJ )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	If $IWIDTH = + 4294967295 Then
		$IWIDTH = DllStructGetData ( $TOBJ , "bmWidth" )
	EndIf
	If $IHEIGHT = + 4294967295 Then
		$IHEIGHT = DllStructGetData ( $TOBJ , "bmHeight" )
	EndIf
	$ACALL = DllCall ( "user32.dll" , "handle" , "GetDC" , "hwnd" , 0 )
	Local $HDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleDC" , "handle" , $HDC )
	Local $HDESTDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleBitmap" , "handle" , $HDC , "int" , $IWIDTH , "int" , $IHEIGHT )
	Local $HBMP = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDESTDC , "handle" , $HBMP )
	Local $HDESTSV = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleDC" , "handle" , $HDC )
	Local $HSRCDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HSRCDC , "handle" , $HBITMAP )
	Local $HSRCSV = $ACALL [ 0 ]
	If _WINAPI_SETSTRETCHBLTMODE ( $HDESTDC , $IMODE ) Then
		Switch $IMODE
		Case 4
			If IsDllStruct ( $TADJUSTMENT ) Then
				If Not _WINAPI_SETCOLORADJUSTMENT ( $HDESTDC , $TADJUSTMENT ) Then
				EndIf
			EndIf
	Case Else
		EndSwitch
	EndIf
	$ACALL = _WINAPI_STRETCHBLT ( $HDESTDC , 0 , 0 , $IWIDTH , $IHEIGHT , $HSRCDC , 0 , 0 , DllStructGetData ( $TOBJ , "bmWidth" ) , DllStructGetData ( $TOBJ , "bmHeight" ) , 13369376 )
	DllCall ( "user32.dll" , "int" , "ReleaseDC" , "hwnd" , 0 , "handle" , $HDC )
	DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDESTDC , "handle" , $HDESTSV )
	DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HSRCDC , "handle" , $HSRCSV )
	DllCall ( "gdi32.dll" , "bool" , "DeleteDC" , "handle" , $HDESTDC )
	DllCall ( "gdi32.dll" , "bool" , "DeleteDC" , "handle" , $HSRCDC )
	If Not $ACALL Then Return SetError ( 10 , 0 , 0 )
	Return $HBMP
EndFunc
Func _WINAPI_ALPHABLEND ( $HDESTDC , $IXDEST , $IYDEST , $IWIDTHDEST , $IHEIGHTDEST , $HSRCDC , $IXSRC , $IYSRC , $IWIDTHSRC , $IHEIGHTSRC , $IALPHA , $BALPHA = False )
	Local $IBLEND = BitOR ( BitShift ( Not ( $BALPHA = False ) , + 4294967272 ) , BitShift ( BitAND ( $IALPHA , 255 ) , + 4294967280 ) )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GdiAlphaBlend" , "handle" , $HDESTDC , "int" , $IXDEST , "int" , $IYDEST , "int" , $IWIDTHDEST , "int" , $IHEIGHTDEST , "handle" , $HSRCDC , "int" , $IXSRC , "int" , $IYSRC , "int" , $IWIDTHSRC , "int" , $IHEIGHTSRC , "dword" , $IBLEND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ANGLEARC ( $HDC , $IX , $IY , $IRADIUS , $NSTARTANGLE , $NSWEEPANGLE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "AngleArc" , "handle" , $HDC , "int" , $IX , "int" , $IY , "dword" , $IRADIUS , "float" , $NSTARTANGLE , "float" , $NSWEEPANGLE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ARC ( $HDC , $TRECT , $IXSTARTARC , $IYSTARTARC , $IXENDARC , $IYENDARC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "Arc" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) , "int" , $IXSTARTARC , "int" , $IYSTARTARC , "int" , $IXENDARC , "int" , $IYENDARC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ARCTO ( $HDC , $TRECT , $IXRADIAL1 , $IYRADIAL1 , $IXRADIAL2 , $IYRADIAL2 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "ArcTo" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) , "int" , $IXRADIAL1 , "int" , $IYRADIAL1 , "int" , $IXRADIAL2 , "int" , $IYRADIAL2 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BEGINPAINT ( $HWND , ByRef $TPAINTSTRUCT )
	$TPAINTSTRUCT = DllStructCreate ( $TAGPAINTSTRUCT )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "BeginPaint" , "hwnd" , $HWND , "struct*" , $TPAINTSTRUCT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BEGINPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "BeginPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CLOSEENHMETAFILE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CloseEnhMetaFile" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CLOSEFIGURE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "CloseFigure" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COLORADJUSTLUMA ( $IRGB , $IPERCENT , $BSCALE = True )
	If $IRGB = + 4294967295 Then Return SetError ( 10 , 0 , + 4294967295 )
	If $BSCALE Then
		$IPERCENT = Floor ( $IPERCENT * 10 )
	EndIf
	Local $ACALL = DllCall ( "shlwapi.dll" , "dword" , "ColorAdjustLuma" , "dword" , __RGB ( $IRGB ) , "int" , $IPERCENT , "bool" , $BSCALE )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_COLORHLSTORGB ( $IHUE , $ILUMINANCE , $ISATURATION )
	If Not $ISATURATION Then $IHUE = 160
	Local $ACALL = DllCall ( "shlwapi.dll" , "dword" , "ColorHLSToRGB" , "word" , $IHUE , "word" , $ILUMINANCE , "word" , $ISATURATION )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_COLORRGBTOHLS ( $IRGB , ByRef $IHUE , ByRef $ILUMINANCE , ByRef $ISATURATION )
	Local $ACALL = DllCall ( "shlwapi.dll" , "none" , "ColorRGBToHLS" , "dword" , __RGB ( $IRGB ) , "word*" , 0 , "word*" , 0 , "word*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	$IHUE = $ACALL [ 2 ]
	$ILUMINANCE = $ACALL [ 3 ]
	$ISATURATION = $ACALL [ 4 ]
	Return 1
EndFunc
Func _WINAPI_COMBINETRANSFORM ( $TXFORM1 , $TXFORM2 )
	Local $TXFORM = DllStructCreate ( $TAGXFORM )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "CombineTransform" , "struct*" , $TXFORM , "struct*" , $TXFORM1 , "struct*" , $TXFORM2 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TXFORM
EndFunc
Func _WINAPI_COMPRESSBITMAPBITS ( $HBITMAP , ByRef $PBUFFER , $ICOMPRESSION = 0 , $IQUALITY = 100 )
	If Not __DLL ( "gdiplus.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $ASIZE [ 2 ] , $ICOUNT , $IFORMAT , $ILENGTH , $SMIME , $ACALL , $HDC , $HSV , $HMEM , $TBITS , $TDATA , $PDATA , $IERROR = 1
	Local $HSOURCE = 0 , $HIMAGE = 0 , $HTOKEN = 0 , $PSTREAM = 0 , $TPARAM = 0
	Local $TDIB = DllStructCreate ( $TAGDIBSECTION )
	Do
		Switch $ICOMPRESSION
		Case 0
			$SMIME = "image/png"
		Case 1
			$SMIME = "image/jpeg"
	Case Else
			$IERROR = 10
			ExitLoop
		EndSwitch
		While $HBITMAP
			If Not _WINAPI_GETOBJECT ( $HBITMAP , DllStructGetSize ( $TDIB ) , $TDIB ) Then
				$IERROR = 11
				ExitLoop 2
			EndIf
			If ( DllStructGetData ( $TDIB , "bmBitsPixel" ) = 32 ) And ( Not DllStructGetData ( $TDIB , "biCompression" ) ) Then
				$IERROR = 12
				ExitLoop
			EndIf
			If $HSOURCE Then
				$IERROR = 13
				ExitLoop 2
			EndIf
			$HSOURCE = _WINAPI_CREATEDIB ( DllStructGetData ( $TDIB , "bmWidth" ) , DllStructGetData ( $TDIB , "bmHeight" ) )
			If Not $HSOURCE Then
				$IERROR = @error + 100
				ExitLoop 2
			EndIf
			$HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
			$HSV = _WINAPI_SELECTOBJECT ( $HDC , $HSOURCE )
			If _WINAPI_DRAWBITMAP ( $HDC , 0 , 0 , $HBITMAP ) Then
				$HBITMAP = $HSOURCE
			Else
				$IERROR = @error + 200
				$HBITMAP = 0
			EndIf
			_WINAPI_SELECTOBJECT ( $HDC , $HSV )
			_WINAPI_DELETEDC ( $HDC )
		WEnd
		If Not $HBITMAP Then
			ExitLoop
		EndIf
		For $I = 0 To 1
			$ASIZE [ $I ] = DllStructGetData ( $TDIB , $I + 2 )
		Next
		$TBITS = DllStructCreate ( "byte[" & ( $ASIZE [ 0 ] * $ASIZE [ 1 ] * 4 ) & "]" )
		If Not _WINAPI_GETBITMAPBITS ( $HBITMAP , DllStructGetSize ( $TBITS ) , $TBITS ) Then
			$IERROR = @error + 300
			ExitLoop
		EndIf
		$TDATA = DllStructCreate ( $TAGGDIPSTARTUPINPUT )
		DllStructSetData ( $TDATA , "Version" , 1 )
		$ACALL = DllCall ( "gdiplus.dll" , "int" , "GdiplusStartup" , "ulong_ptr*" , 0 , "struct*" , $TDATA , "ptr" , 0 )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 400
			ExitLoop
		EndIf
		If _WINAPI_ISALPHABITMAP ( $HBITMAP ) Then
			$IFORMAT = 2498570
		Else
			$IFORMAT = 139273
		EndIf
		$HTOKEN = $ACALL [ 1 ]
		$ACALL = DllCall ( "gdiplus.dll" , "int" , "GdipCreateBitmapFromScan0" , "int" , $ASIZE [ 0 ] , "int" , $ASIZE [ 1 ] , "uint" , $ASIZE [ 0 ] * 4 , "int" , $IFORMAT , "struct*" , $TBITS , "ptr*" , 0 )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 500
			ExitLoop
		EndIf
		$HIMAGE = $ACALL [ 6 ]
		$ACALL = DllCall ( "gdiplus.dll" , "int" , "GdipGetImageEncodersSize" , "uint*" , 0 , "uint*" , 0 )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 600
			ExitLoop
		EndIf
		$ICOUNT = $ACALL [ 1 ]
		$TDATA = DllStructCreate ( "byte[" & $ACALL [ 2 ] & "]" )
		If @error Then
			$IERROR = @error + 700
			ExitLoop
		EndIf
		$PDATA = DllStructGetPtr ( $TDATA )
		$ACALL = DllCall ( "gdiplus.dll" , "int" , "GdipGetImageEncoders" , "uint" , $ICOUNT , "uint" , $ACALL [ 2 ] , "struct*" , $TDATA )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 800
			ExitLoop
		EndIf
		Local $TCODEC , $PENCODER = 0
		For $I = 1 To $ICOUNT
			$TCODEC = DllStructCreate ( $TAGGDIPIMAGECODECINFO , $PDATA )
			If Not StringInStr ( _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "MimeType" ) ) , $SMIME ) Then
				$PDATA += DllStructGetSize ( $TAGGDIPIMAGECODECINFO )
			Else
				$PENCODER = $PDATA
				$IERROR = 0
				ExitLoop
			EndIf
		Next
		If Not $PENCODER Then
			$IERROR = 15
			ExitLoop
		EndIf
		Switch $ICOMPRESSION
		Case 0
		Case 1
			Local Const $TAGENCODERPARAMETER = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
			$TPARAM = DllStructCreate ( "dword Count;" & $TAGENCODERPARAMETER & ";ulong Quality" )
			DllStructSetData ( $TPARAM , "Count" , 1 )
			DllStructSetData ( $TPARAM , "NumberOfValues" , 1 )
			DllStructSetData ( $TPARAM , "Type" , 4 )
			DllStructSetData ( $TPARAM , "pValue" , DllStructGetPtr ( $TPARAM , "Quality" ) )
			DllStructSetData ( $TPARAM , "Quality" , $IQUALITY )
			$ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}" , "ptr" , DllStructGetPtr ( $TPARAM , 2 ) )
			If @error Or $ACALL [ 0 ] Then
				$TPARAM = 0
			EndIf
		EndSwitch
		$PSTREAM = _WINAPI_CREATESTREAMONHGLOBAL ( )
		$ACALL = DllCall ( "gdiplus.dll" , "int" , "GdipSaveImageToStream" , "handle" , $HIMAGE , "ptr" , $PSTREAM , "ptr" , $PENCODER , "struct*" , $TPARAM )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 900
			ExitLoop
		EndIf
		$HMEM = _WINAPI_GETHGLOBALFROMSTREAM ( $PSTREAM )
		$ACALL = DllCall ( "kernel32.dll" , "ulong_ptr" , "GlobalSize" , "handle" , $HMEM )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 1000
			ExitLoop
		EndIf
		$ILENGTH = $ACALL [ 0 ]
		$ACALL = DllCall ( "kernel32.dll" , "ptr" , "GlobalLock" , "handle" , $HMEM )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 1100
			ExitLoop
		EndIf
		$PBUFFER = __HEAPREALLOC ( $PBUFFER , $ILENGTH , 1 )
		If Not @error Then
			_WINAPI_MOVEMEMORY ( $PBUFFER , $ACALL [ 0 ] , $ILENGTH )
		Else
			$IERROR = @error + 1300
		EndIf
	Until 1
	If $PSTREAM Then
		_WINAPI_RELEASESTREAM ( $PSTREAM )
	EndIf
	If $HIMAGE Then
		DllCall ( "gdiplus.dll" , "int" , "GdipDisposeImage" , "handle" , $HIMAGE )
	EndIf
	If $HTOKEN Then
		DllCall ( "gdiplus.dll" , "none" , "GdiplusShutdown" , "ulong_ptr" , $HTOKEN )
	EndIf
	If $HSOURCE Then
		_WINAPI_DELETEOBJECT ( $HSOURCE )
	EndIf
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ILENGTH
EndFunc
Func _WINAPI_COPYENHMETAFILE ( $HEMF , $SFILEPATH = "" )
	If Not StringStripWS ( $SFILEPATH , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SFILEPATH = Null
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CopyEnhMetaFileW" , "handle" , $HEMF , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COPYRECT ( $TRECT )
	Local $TDATA = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "CopyRect" , "struct*" , $TDATA , "struct*" , $TRECT )
	If @error Or Not $ACALL [ 0 ] Then SetError ( @error + 10 , @extended , 0 )
	Return $TDATA
EndFunc
Func _WINAPI_CREATE32BITHBITMAP ( $HICON , $BDIB = False , $BDELETE = False )
	Local $HBITMAP = 0
	Local $ADIB [ 2 ] = [ 0 , 0 ]
	Local $HTEMP = _WINAPI_CREATE32BITHICON ( $HICON )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $IERROR = 0
	Do
		Local $TICONINFO = DllStructCreate ( $TAGICONINFO )
		Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfo" , "handle" , $HTEMP , "struct*" , $TICONINFO )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		For $I = 0 To 1
			$ADIB [ $I ] = DllStructGetData ( $TICONINFO , $I + 4 )
		Next
		Local $TBITMAP = DllStructCreate ( $TAGBITMAP )
		If Not _WINAPI_GETOBJECT ( $ADIB [ 0 ] , DllStructGetSize ( $TBITMAP ) , $TBITMAP ) Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
		If $BDIB Then
			$HBITMAP = _WINAPI_CREATEDIB ( DllStructGetData ( $TBITMAP , "bmWidth" ) , DllStructGetData ( $TBITMAP , "bmHeight" ) )
			Local $HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
			Local $HSV = _WINAPI_SELECTOBJECT ( $HDC , $HBITMAP )
			_WINAPI_DRAWICONEX ( $HDC , 0 , 0 , $HTEMP )
			_WINAPI_SELECTOBJECT ( $HDC , $HSV )
			_WINAPI_DELETEDC ( $HDC )
		Else
			$HBITMAP = $ADIB [ 1 ]
			$ADIB [ 1 ] = 0
		EndIf
	Until 1
	For $I = 0 To 1
		If $ADIB [ $I ] Then
			_WINAPI_DELETEOBJECT ( $ADIB [ $I ] )
		EndIf
	Next
	_WINAPI_DESTROYICON ( $HTEMP )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	If Not $HBITMAP Then Return SetError ( 12 , 0 , 0 )
	If $BDELETE Then
		_WINAPI_DESTROYICON ( $HICON )
	EndIf
	Return $HBITMAP
EndFunc
Func _WINAPI_CREATEBITMAPINDIRECT ( ByRef $TBITMAP )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateBitmapIndirect" , "struct*" , $TBITMAP )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEBRUSHINDIRECT ( $ISTYLE , $IRGB , $IHATCH = 0 )
	Local $TLOGBRUSH = DllStructCreate ( $TAGLOGBRUSH )
	DllStructSetData ( $TLOGBRUSH , 1 , $ISTYLE )
	DllStructSetData ( $TLOGBRUSH , 2 , __RGB ( $IRGB ) )
	DllStructSetData ( $TLOGBRUSH , 3 , $IHATCH )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateBrushIndirect" , "struct*" , $TLOGBRUSH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATECOLORADJUSTMENT ( $IFLAGS = 0 , $IILLUMINANT = 0 , $IGAMMAR = 10000 , $IGAMMAG = 10000 , $IGAMMAB = 10000 , $IBLACK = 0 , $IWHITE = 10000 , $ICONTRAST = 0 , $IBRIGHTNESS = 0 , $ICOLORFULNESS = 0 , $ITINT = 0 )
	Local $TCA = DllStructCreate ( $TAGCOLORADJUSTMENT )
	DllStructSetData ( $TCA , 1 , DllStructGetSize ( $TCA ) )
	DllStructSetData ( $TCA , 2 , $IFLAGS )
	DllStructSetData ( $TCA , 3 , $IILLUMINANT )
	DllStructSetData ( $TCA , 4 , $IGAMMAR )
	DllStructSetData ( $TCA , 5 , $IGAMMAG )
	DllStructSetData ( $TCA , 6 , $IGAMMAB )
	DllStructSetData ( $TCA , 7 , $IBLACK )
	DllStructSetData ( $TCA , 8 , $IWHITE )
	DllStructSetData ( $TCA , 9 , $ICONTRAST )
	DllStructSetData ( $TCA , 10 , $IBRIGHTNESS )
	DllStructSetData ( $TCA , 11 , $ICOLORFULNESS )
	DllStructSetData ( $TCA , 12 , $ITINT )
	Return $TCA
EndFunc
Func _WINAPI_CREATECOMPATIBLEBITMAPEX ( $HDC , $IWIDTH , $IHEIGHT , $IRGB )
	Local $HBRUSH = _WINAPI_CREATEBRUSHINDIRECT ( 0 , $IRGB )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleDC" , "handle" , $HDC )
	Local $HDESTDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleBitmap" , "handle" , $HDC , "int" , $IWIDTH , "int" , $IHEIGHT )
	Local $HBMP = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDESTDC , "handle" , $HBMP )
	Local $HDESTSV = $ACALL [ 0 ]
	Local $TRECT = _WINAPI_CREATERECTEX ( 0 , 0 , $IWIDTH , $IHEIGHT )
	Local $IERROR = 0
	$ACALL = DllCall ( "user32.dll" , "int" , "FillRect" , "handle" , $HDESTDC , "struct*" , $TRECT , "handle" , $HBRUSH )
	If @error Or Not $ACALL [ 0 ] Then
		$IERROR = @error + 10
		_WINAPI_DELETEOBJECT ( $HBMP )
	EndIf
	_WINAPI_DELETEOBJECT ( $HBRUSH )
	DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDESTDC , "handle" , $HDESTSV )
	DllCall ( "gdi32.dll" , "bool" , "DeleteDC" , "handle" , $HDESTDC )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $HBMP
EndFunc
Func _WINAPI_CREATEDIBITMAP ( $HDC , ByRef $TBITMAPINFO , $IUSAGE , $PBITS = 0 )
	Local $IINIT = 0
	If $PBITS Then
		$IINIT = 4
	EndIf
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateDIBitmap" , "handle" , $HDC , "struct*" , $TBITMAPINFO , "dword" , $IINIT , "struct*" , $PBITS , "struct*" , $TBITMAPINFO , "uint" , $IUSAGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEELLIPTICRGN ( $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateEllipticRgnIndirect" , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEENHMETAFILE ( $HDC = 0 , $TRECT = 0 , $BPIXELS = False , $SFILEPATH = "" , $SDESCRIPTION = "" )
	If Not StringStripWS ( $SFILEPATH , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SFILEPATH = Null
	Local $TDATA = 0 , $ADATA = StringSplit ( $SDESCRIPTION , "|" , $STR_NOCOUNT )
	If UBound ( $ADATA ) < 2 Then
		ReDim $ADATA [ 2 ]
		$ADATA [ 1 ] = ""
	EndIf
	For $I = 0 To 1
		$ADATA [ $I ] = StringStripWS ( $ADATA [ $I ] , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	Next
	If ( $ADATA [ 0 ] ) Or ( $ADATA [ 1 ] ) Then
		$TDATA = _WINAPI_ARRAYTOSTRUCT ( $ADATA )
	EndIf
	Local $IXP , $IYP , $IXM , $IYM , $HREF = 0
	If $BPIXELS And ( IsDllStruct ( $TRECT ) ) Then
		If Not $HDC Then
			$HREF = _WINAPI_GETDC ( 0 )
		EndIf
		$IXP = _WINAPI_GETDEVICECAPS ( $HREF , 8 )
		$IYP = _WINAPI_GETDEVICECAPS ( $HREF , 10 )
		$IXM = _WINAPI_GETDEVICECAPS ( $HREF , 4 )
		$IYM = _WINAPI_GETDEVICECAPS ( $HREF , 6 )
		If $HREF Then
			_WINAPI_RELEASEDC ( 0 , $HREF )
		EndIf
		For $I = 1 To 3 Step 2
			DllStructSetData ( $TRECT , $I , Round ( DllStructGetData ( $TRECT , $I ) * $IXM / $IXP * 100 ) )
		Next
		For $I = 2 To 4 Step 2
			DllStructSetData ( $TRECT , $I , Round ( DllStructGetData ( $TRECT , $I ) * $IYM / $IYP * 100 ) )
		Next
	EndIf
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateEnhMetaFileW" , "handle" , $HDC , "wstr" , $SFILEPATH , "struct*" , $TRECT , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEFONTEX ( $IHEIGHT , $IWIDTH = 0 , $IESCAPEMENT = 0 , $IORIENTATION = 0 , $IWEIGHT = 400 , $BITALIC = False , $BUNDERLINE = False , $BSTRIKEOUT = False , $ICHARSET = 1 , $IOUTPRECISION = 0 , $ICLIPPRECISION = 0 , $IQUALITY = 0 , $IPITCHANDFAMILY = 0 , $SFACENAME = "" , $ISTYLE = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateFontW" , "int" , $IHEIGHT , "int" , $IWIDTH , "int" , $IESCAPEMENT , "int" , $IORIENTATION , "int" , $IWEIGHT , "dword" , $BITALIC , "dword" , $BUNDERLINE , "dword" , $BSTRIKEOUT , "dword" , $ICHARSET , "dword" , $IOUTPRECISION , "dword" , $ICLIPPRECISION , "dword" , $IQUALITY , "dword" , $IPITCHANDFAMILY , "wstr" , _WINAPI_GETFONTNAME ( $SFACENAME , $ISTYLE , $ICHARSET ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATENULLRGN ( )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateRectRgn" , "int" , 0 , "int" , 0 , "int" , 0 , "int" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEPEN ( $IPENSTYLE , $IWIDTH , $ICOLOR )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreatePen" , "int" , $IPENSTYLE , "int" , $IWIDTH , "INT" , $ICOLOR )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEPOLYGONRGN ( Const ByRef $APOINT , $ISTART = 0 , $IEND = + 4294967295 , $IMODE = 1 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 , 2 ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "int[2];"
	Next
	Local $TDATA = DllStructCreate ( $TAGSTRUCT )
	Local $ICOUNT = 1
	For $I = $ISTART To $IEND
		For $J = 0 To 1
			DllStructSetData ( $TDATA , $ICOUNT , $APOINT [ $I ] [ $J ] , $J + 1 )
		Next
		$ICOUNT += 1
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreatePolygonRgn" , "struct*" , $TDATA , "int" , $ICOUNT + 4294967295 , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATERECTRGNINDIRECT ( $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateRectRgnIndirect" , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATESOLIDBITMAP ( $HWND , $ICOLOR , $IWIDTH , $IHEIGHT , $BRGB = 1 )
	Local $HDC = _WINAPI_GETDC ( $HWND )
	Local $HDESTDC = _WINAPI_CREATECOMPATIBLEDC ( $HDC )
	Local $HBITMAP = _WINAPI_CREATECOMPATIBLEBITMAP ( $HDC , $IWIDTH , $IHEIGHT )
	Local $HOLD = _WINAPI_SELECTOBJECT ( $HDESTDC , $HBITMAP )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , 1 , 0 )
	DllStructSetData ( $TRECT , 2 , 0 )
	DllStructSetData ( $TRECT , 3 , $IWIDTH )
	DllStructSetData ( $TRECT , 4 , $IHEIGHT )
	If $BRGB Then
		$ICOLOR = BitOR ( BitAND ( $ICOLOR , 65280 ) , BitShift ( BitAND ( $ICOLOR , 255 ) , + 4294967280 ) , BitShift ( BitAND ( $ICOLOR , 16711680 ) , 16 ) )
	EndIf
	Local $HBRUSH = _WINAPI_CREATESOLIDBRUSH ( $ICOLOR )
	If Not _WINAPI_FILLRECT ( $HDESTDC , $TRECT , $HBRUSH ) Then
		_WINAPI_DELETEOBJECT ( $HBITMAP )
		$HBITMAP = 0
	EndIf
	_WINAPI_DELETEOBJECT ( $HBRUSH )
	_WINAPI_RELEASEDC ( $HWND , $HDC )
	_WINAPI_SELECTOBJECT ( $HDESTDC , $HOLD )
	_WINAPI_DELETEDC ( $HDESTDC )
	If Not $HBITMAP Then Return SetError ( 1 , 0 , 0 )
	Return $HBITMAP
EndFunc
Func _WINAPI_CREATETRANSFORM ( $NM11 = 1 , $NM12 = 0 , $NM21 = 0 , $NM22 = 1 , $NDX = 0 , $NDY = 0 )
	Local $TXFORM = DllStructCreate ( $TAGXFORM )
	DllStructSetData ( $TXFORM , 1 , $NM11 )
	DllStructSetData ( $TXFORM , 2 , $NM12 )
	DllStructSetData ( $TXFORM , 3 , $NM21 )
	DllStructSetData ( $TXFORM , 4 , $NM22 )
	DllStructSetData ( $TXFORM , 5 , $NDX )
	DllStructSetData ( $TXFORM , 6 , $NDY )
	Return $TXFORM
EndFunc
Func _WINAPI_DELETEENHMETAFILE ( $HEMF )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "DeleteEnhMetaFile" , "handle" , $HEMF )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DPTOLP ( $HDC , ByRef $TPOINT , $ICOUNT = 1 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "DPtoLP" , "handle" , $HDC , "struct*" , $TPOINT , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWANIMATEDRECTS ( $HWND , $TRECTFROM , $TRECTTO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DrawAnimatedRects" , "hwnd" , $HWND , "int" , 3 , "struct*" , $TRECTFROM , "struct*" , $TRECTTO )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWBITMAP ( $HDC , $IX , $IY , $HBITMAP , $IROP = 13369376 )
	Local $TOBJ = DllStructCreate ( $TAGBITMAP )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetObject" , "handle" , $HBITMAP , "int" , DllStructGetSize ( $TOBJ ) , "struct*" , $TOBJ )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	$ACALL = DllCall ( "user32.dll" , "handle" , "GetDC" , "hwnd" , 0 )
	Local $_HDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleDC" , "handle" , $_HDC )
	Local $HSRCDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HSRCDC , "handle" , $HBITMAP )
	Local $HSRCSV = $ACALL [ 0 ]
	Local $IERROR = 0
	$ACALL = DllCall ( "gdi32.dll" , "int" , "BitBlt" , "hwnd" , $HDC , "int" , $IX , "int" , $IY , "int" , DllStructGetData ( $TOBJ , "bmWidth" ) , "int" , DllStructGetData ( $TOBJ , "bmHeight" ) , "hwnd" , $HSRCDC , "int" , 0 , "int" , 0 , "int" , $IROP )
	If @error Or Not $ACALL [ 0 ] Then
		$IERROR = @error + 1
	EndIf
	DllCall ( "user32.dll" , "int" , "ReleaseDC" , "hwnd" , 0 , "handle" , $_HDC )
	DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HSRCDC , "handle" , $HSRCSV )
	DllCall ( "gdi32.dll" , "bool" , "DeleteDC" , "handle" , $HSRCDC )
	If $IERROR Then Return SetError ( 10 , 0 , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWFOCUSRECT ( $HDC , $TRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DrawFocusRect" , "handle" , $HDC , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAWLINE ( $HDC , $IX1 , $IY1 , $IX2 , $IY2 )
	_WINAPI_MOVETO ( $HDC , $IX1 , $IY1 )
	If @error Then Return SetError ( @error , @extended , False )
	_WINAPI_LINETO ( $HDC , $IX2 , $IY2 )
	If @error Then Return SetError ( @error + 10 , @extended , False )
	Return True
EndFunc
Func _WINAPI_DRAWSHADOWTEXT ( $HDC , $STEXT , $IRGBTEXT , $IRGBSHADOW , $IXOFFSET = 0 , $IYOFFSET = 0 , $TRECT = 0 , $IFLAGS = 0 )
	Local $ACALL
	If Not IsDllStruct ( $TRECT ) Then
		$TRECT = DllStructCreate ( $TAGRECT )
		$ACALL = DllCall ( "user32.dll" , "bool" , "GetClientRect" , "hwnd" , _WINAPI_WINDOWFROMDC ( $HDC ) , "struct*" , $TRECT )
		If @error Then Return SetError ( @error + 10 , @extended , 0 )
		If Not $ACALL [ 0 ] Then Return SetError ( 10 , 0 , 0 )
	EndIf
	$ACALL = DllCall ( "comctl32.dll" , "int" , "DrawShadowText" , "handle" , $HDC , "wstr" , $STEXT , "uint" , + 4294967295 , "struct*" , $TRECT , "dword" , $IFLAGS , "int" , __RGB ( $IRGBTEXT ) , "int" , __RGB ( $IRGBSHADOW ) , "int" , $IXOFFSET , "int" , $IYOFFSET )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DWMDEFWINDOWPROC ( $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "dwmapi.dll" , "bool" , "DwmDefWindowProc" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM , "lresult*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_DWMENABLEBLURBEHINDWINDOW ( $HWND , $BENABLE = True , $BTRANSITION = False , $HRGN = 0 )
	Local $TBLURBEHIND = DllStructCreate ( "dword;bool;handle;bool" )
	Local $IFLAGS = 0
	If $HRGN Then
		$IFLAGS += 2
		DllStructSetData ( $TBLURBEHIND , 3 , $HRGN )
	EndIf
	DllStructSetData ( $TBLURBEHIND , 1 , BitOR ( $IFLAGS , 5 ) )
	DllStructSetData ( $TBLURBEHIND , 2 , $BENABLE )
	DllStructSetData ( $TBLURBEHIND , 4 , $BTRANSITION )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmEnableBlurBehindWindow" , "hwnd" , $HWND , "struct*" , $TBLURBEHIND )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMENABLECOMPOSITION ( $BENABLE )
	If $BENABLE Then $BENABLE = 1
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmEnableComposition" , "uint" , $BENABLE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMEXTENDFRAMEINTOCLIENTAREA ( $HWND , $TMARGINS = 0 )
	If Not IsDllStruct ( $TMARGINS ) Then
		$TMARGINS = _WINAPI_CREATEMARGINS ( + 4294967295 , + 4294967295 , + 4294967295 , + 4294967295 )
	EndIf
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmExtendFrameIntoClientArea" , "hwnd" , $HWND , "struct*" , $TMARGINS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMGETCOLORIZATIONCOLOR ( )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmGetColorizationColor" , "dword*" , 0 , "bool*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return SetExtended ( $ACALL [ 2 ] , $ACALL [ 1 ] )
EndFunc
Func _WINAPI_DWMGETCOLORIZATIONPARAMETERS ( )
	Local $TDWMCP = DllStructCreate ( $TAGDWM_COLORIZATION_PARAMETERS )
	Local $ACALL = DllCall ( "dwmapi.dll" , "uint" , 127 , "struct*" , $TDWMCP )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TDWMCP
EndFunc
Func _WINAPI_DWMGETWINDOWATTRIBUTE ( $HWND , $IATTRIBUTE )
	Local $TAGSTRUCT
	Switch $IATTRIBUTE
	Case 5 , 9
		$TAGSTRUCT = $TAGRECT
	Case 1
		$TAGSTRUCT = "uint"
Case Else
		Return SetError ( 11 , 0 , 0 )
	EndSwitch
	Local $TDATA = DllStructCreate ( $TAGSTRUCT )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmGetWindowAttribute" , "hwnd" , $HWND , "dword" , $IATTRIBUTE , "struct*" , $TDATA , "dword" , DllStructGetSize ( $TDATA ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Switch $IATTRIBUTE
	Case 1
		Return DllStructGetData ( $TDATA , 1 )
Case Else
		Return $TDATA
	EndSwitch
EndFunc
Func _WINAPI_DWMINVALIDATEICONICBITMAPS ( $HWND )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmInvalidateIconicBitmaps" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMISCOMPOSITIONENABLED ( )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmIsCompositionEnabled" , "bool*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE ( $HTHUMBNAIL )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmQueryThumbnailSourceSize" , "handle" , $HTHUMBNAIL , "struct*" , $TSIZE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TSIZE
EndFunc
Func _WINAPI_DWMREGISTERTHUMBNAIL ( $HDESTINATION , $HSOURCE )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmRegisterThumbnail" , "hwnd" , $HDESTINATION , "hwnd" , $HSOURCE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_DWMSETCOLORIZATIONPARAMETERS ( $TDWMCP )
	Local $ACALL = DllCall ( "dwmapi.dll" , "uint" , 131 , "struct*" , $TDWMCP , "uint" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMSETICONICLIVEPREVIEWBITMAP ( $HWND , $HBITMAP , $BFRAME = False , $TCLIENT = 0 )
	Local $IFLAGS
	If $BFRAME Then
		$IFLAGS = 1
	Else
		$IFLAGS = 0
	EndIf
	Local $ACALL = DllCall ( "dwmapi.dll" , "uint" , "DwmSetIconicLivePreviewBitmap" , "hwnd" , $HWND , "handle" , $HBITMAP , "struct*" , $TCLIENT , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMSETICONICTHUMBNAIL ( $HWND , $HBITMAP , $BFRAME = False )
	Local $IFLAGS
	If $BFRAME Then
		$IFLAGS = 1
	Else
		$IFLAGS = 0
	EndIf
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmSetIconicThumbnail" , "hwnd" , $HWND , "handle" , $HBITMAP , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMSETWINDOWATTRIBUTE ( $HWND , $IATTRIBUTE , $IDATA )
	Switch $IATTRIBUTE
	Case 2 , 3 , 4 , 6 , 7 , 8 , 10 , 11 , 12
Case Else
		Return SetError ( 1 , 0 , 0 )
	EndSwitch
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmSetWindowAttribute" , "hwnd" , $HWND , "dword" , $IATTRIBUTE , "dword*" , $IDATA , "dword" , 4 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMUNREGISTERTHUMBNAIL ( $HTHUMBNAIL )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmUnregisterThumbnail" , "handle" , $HTHUMBNAIL )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DWMUPDATETHUMBNAILPROPERTIES ( $HTHUMBNAIL , $BVISIBLE = True , $BCLIENTAREAONLY = False , $IOPACITY = 255 , $TRECTDEST = 0 , $TRECTSRC = 0 )
	Local Const $TAGDWM_THUMBNAIL_PROPERTIES = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
	Local $TTHUMBNAILPROPERTIES = DllStructCreate ( $TAGDWM_THUMBNAIL_PROPERTIES )
	Local $TSIZE , $IFLAGS = 0
	If Not IsDllStruct ( $TRECTDEST ) Then
		$TSIZE = _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE ( $HTHUMBNAIL )
		If @error Then
			Return SetError ( @error + 10 , @extended , 0 )
		EndIf
		$TRECTDEST = _WINAPI_CREATERECTEX ( 0 , 0 , DllStructGetData ( $TSIZE , 1 ) , DllStructGetData ( $TSIZE , 2 ) )
	EndIf
	For $I = 1 To 4
		DllStructSetData ( $TTHUMBNAILPROPERTIES , 2 , DllStructGetData ( $TRECTDEST , $I ) , $I )
	Next
	If IsDllStruct ( $TRECTSRC ) Then
		$IFLAGS += 2
		For $I = 1 To 4
			DllStructSetData ( $TTHUMBNAILPROPERTIES , 3 , DllStructGetData ( $TRECTSRC , $I ) , $I )
		Next
	EndIf
	DllStructSetData ( $TTHUMBNAILPROPERTIES , 1 , BitOR ( $IFLAGS , 29 ) )
	DllStructSetData ( $TTHUMBNAILPROPERTIES , 4 , $IOPACITY )
	DllStructSetData ( $TTHUMBNAILPROPERTIES , 5 , $BVISIBLE )
	DllStructSetData ( $TTHUMBNAILPROPERTIES , 6 , $BCLIENTAREAONLY )
	Local $ACALL = DllCall ( "dwmapi.dll" , "long" , "DwmUpdateThumbnailProperties" , "handle" , $HTHUMBNAIL , "struct*" , $TTHUMBNAILPROPERTIES )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_ELLIPSE ( $HDC , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "Ellipse" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENDPAINT ( $HWND , ByRef $TPAINTSTRUCT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EndPaint" , "hwnd" , $HWND , "struct*" , $TPAINTSTRUCT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENDPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "EndPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENUMDISPLAYMONITORS ( $HDC = 0 , $TRECT = 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumDisplayMonitorsProc" , "bool" , "handle;handle;ptr;lparam" )
	Dim $__G_VENUM [ 101 ] [ 2 ] = [ [ 0 ] ]
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnumDisplayMonitors" , "handle" , $HDC , "struct*" , $TRECT , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMDISPLAYSETTINGS ( $SDEVICE , $IMODE )
	If Not StringStripWS ( $SDEVICE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SDEVICE = Null
	Local $TDEVMODE = DllStructCreate ( $TAGDEVMODE_DISPLAY )
	DllStructSetData ( $TDEVMODE , "Size" , DllStructGetSize ( $TDEVMODE ) )
	DllStructSetData ( $TDEVMODE , "DriverExtra" , 0 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnumDisplaySettingsW" , "wstr" , $SDEVICE , "dword" , $IMODE , "struct*" , $TDEVMODE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 5 ]
	$ARET [ 0 ] = DllStructGetData ( $TDEVMODE , "PelsWidth" )
	$ARET [ 1 ] = DllStructGetData ( $TDEVMODE , "PelsHeight" )
	$ARET [ 2 ] = DllStructGetData ( $TDEVMODE , "BitsPerPel" )
	$ARET [ 3 ] = DllStructGetData ( $TDEVMODE , "DisplayFrequency" )
	$ARET [ 4 ] = DllStructGetData ( $TDEVMODE , "DisplayFlags" )
	Return $ARET
EndFunc
Func _WINAPI_ENUMFONTFAMILIES ( $HDC = 0 , $SFACENAME = "" , $ICHARSET = 1 , $IFONTTYPE = 7 , $SPATTERN = "" , $BEXCLUDE = False )
	Local $TLOGFONT = DllStructCreate ( $TAGLOGFONT )
	Local $TPATTERN = DllStructCreate ( "uint;uint;ptr;wchar[" & ( StringLen ( $SPATTERN ) + 1 ) & "]" )
	DllStructSetData ( $TPATTERN , 1 , $IFONTTYPE )
	If Not $SPATTERN Then
		DllStructSetData ( $TPATTERN , 2 , 0 )
		DllStructSetData ( $TPATTERN , 3 , 0 )
	Else
		DllStructSetData ( $TPATTERN , 2 , $BEXCLUDE )
		DllStructSetData ( $TPATTERN , 3 , DllStructGetPtr ( $TPATTERN , 4 ) )
		DllStructSetData ( $TPATTERN , 4 , $SPATTERN )
	EndIf
	DllStructSetData ( $TLOGFONT , 9 , $ICHARSET )
	DllStructSetData ( $TLOGFONT , 13 , 0 )
	DllStructSetData ( $TLOGFONT , 14 , StringLeft ( $SFACENAME , 31 ) )
	Local $HCDC
	If Not $HDC Then
		$HCDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Else
		$HCDC = $HDC
	EndIf
	Dim $__G_VENUM [ 101 ] [ 8 ] = [ [ 0 ] ]
	Local $HENUMPROC = DllCallbackRegister ( "__EnumFontFamiliesProc" , "int" , "ptr;ptr;dword;PTR" )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "EnumFontFamiliesExW" , "handle" , $HCDC , "struct*" , $TLOGFONT , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "struct*" , $TPATTERN , "dword" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If Not $HDC Then
		_WINAPI_DELETEDC ( $HCDC )
	EndIf
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_EQUALRECT ( $TRECT1 , $TRECT2 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EqualRect" , "struct*" , $TRECT1 , "struct*" , $TRECT2 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EQUALRGN ( $HRGN1 , $HRGN2 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "EqualRgn" , "handle" , $HRGN1 , "handle" , $HRGN2 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EXCLUDECLIPRECT ( $HDC , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "ExcludeClipRect" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EXTCREATEPEN ( $IPENSTYLE , $IWIDTH , $IBRUSHSTYLE , $IRGB , $IHATCH = 0 , $AUSERSTYLE = 0 , $ISTART = 0 , $IEND = + 4294967295 )
	Local $ICOUNT = 0 , $TSTYLE = 0
	If BitAND ( $IPENSTYLE , 255 ) = 7 Then
		If __CHECKERRORARRAYBOUNDS ( $AUSERSTYLE , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
		$TSTYLE = DllStructCreate ( "dword[" & ( $IEND - $ISTART + 1 ) & "]" )
		For $I = $ISTART To $IEND
			DllStructSetData ( $TSTYLE , 1 , $AUSERSTYLE [ $I ] , $ICOUNT + 1 )
			$ICOUNT += 1
		Next
	EndIf
	Local $TLOGBRUSH = DllStructCreate ( $TAGLOGBRUSH )
	DllStructSetData ( $TLOGBRUSH , 1 , $IBRUSHSTYLE )
	DllStructSetData ( $TLOGBRUSH , 2 , __RGB ( $IRGB ) )
	DllStructSetData ( $TLOGBRUSH , 3 , $IHATCH )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "ExtCreatePen" , "dword" , $IPENSTYLE , "dword" , $IWIDTH , "struct*" , $TLOGBRUSH , "dword" , $ICOUNT , "struct*" , $TSTYLE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EXTCREATEREGION ( $TRGNDATA , $TXFORM = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "ExtCreateRegion" , "struct*" , $TXFORM , "dword" , DllStructGetSize ( $TRGNDATA ) , "struct*" , $TRGNDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EXTFLOODFILL ( $HDC , $IX , $IY , $IRGB , $ITYPE = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "ExtFloodFill" , "handle" , $HDC , "int" , $IX , "int" , $IY , "dword" , __RGB ( $IRGB ) , "uint" , $ITYPE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_EXTSELECTCLIPRGN ( $HDC , $HRGN , $IMODE = 5 )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "ExtSelectClipRgn" , "handle" , $HDC , "handle" , $HRGN , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FILLPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "FillPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FILLRGN ( $HDC , $HRGN , $HBRUSH )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "FillRgn" , "handle" , $HDC , "handle" , $HRGN , "handle" , $HBRUSH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FLATTENPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "FlattenPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FRAMERGN ( $HDC , $HRGN , $HBRUSH , $IWIDTH , $IHEIGHT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "FrameRgn" , "handle" , $HDC , "handle" , $HRGN , "handle" , $HBRUSH , "int" , $IWIDTH , "int" , $IHEIGHT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GDICOMMENT ( $HDC , $PBUFFER , $ISIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GdiComment" , "handle" , $HDC , "uint" , $ISIZE , "struct*" , $PBUFFER )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETARCDIRECTION ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetArcDirection" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	If ( $ACALL [ 0 ] < 1 ) Or ( $ACALL [ 0 ] > 2 ) Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETBITMAPBITS ( $HBITMAP , $ISIZE , $PBITS )
	Local $ACALL = DllCall ( "gdi32.dll" , "long" , "GetBitmapBits" , "handle" , $HBITMAP , "long" , $ISIZE , "struct*" , $PBITS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETBITMAPDIMENSIONEX ( $HBITMAP )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetBitmapDimensionEx" , "handle" , $HBITMAP , "struct*" , $TSIZE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TSIZE
EndFunc
Func _WINAPI_GETBKCOLOR ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "GetBkColor" , "handle" , $HDC )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_GETBOUNDSRECT ( $HDC , $IFLAGS = 0 )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetBoundsRect" , "handle" , $HDC , "struct*" , $TRECT , "uint" , $IFLAGS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TRECT )
EndFunc
Func _WINAPI_GETBRUSHORG ( $HDC )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetBrushOrgEx" , "handle" , $HDC , "struct*" , $TPOINT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_GETBVALUE ( $IRGB )
	Return BitShift ( BitAND ( __RGB ( $IRGB ) , 16711680 ) , 16 )
EndFunc
Func _WINAPI_GETCLIPBOX ( $HDC , ByRef $TRECT )
	$TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetClipBox" , "handle" , $HDC , "struct*" , $TRECT )
	If @error Or Not $ACALL [ 0 ] Then
		$TRECT = 0
		Return SetError ( @error , @extended , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCLIPRGN ( $HDC )
	Local $HRGN = _WINAPI_CREATERECTRGN ( 0 , 0 , 0 , 0 )
	Local $IERROR = 0
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetClipRgn" , "handle" , $HDC , "handle" , $HRGN )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then $IERROR = @error + 10
	If $IERROR Or Not $ACALL [ 0 ] Then
		_WINAPI_DELETEOBJECT ( $HRGN )
		$HRGN = 0
	EndIf
	Return SetError ( $IERROR , 0 , $HRGN )
EndFunc
Func _WINAPI_GETCOLORADJUSTMENT ( $HDC )
	Local $TADJUSTMENT = DllStructCreate ( $TAGCOLORADJUSTMENT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetColorAdjustment" , "handle" , $HDC , "struct*" , $TADJUSTMENT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TADJUSTMENT
EndFunc
Func _WINAPI_GETCURRENTPOSITION ( $HDC )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetCurrentPositionEx" , "handle" , $HDC , "struct*" , $TPOINT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_GETDEVICEGAMMARAMP ( $HDC , ByRef $ARAMP )
	$ARAMP = 0
	Local $TDATA = DllStructCreate ( "word[256];word[256];word[256]" )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetDeviceGammaRamp" , "handle" , $HDC , "struct*" , $TDATA )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Dim $ARAMP [ 256 ] [ 3 ]
	For $I = 0 To 2
		For $J = 0 To 255
			$ARAMP [ $J ] [ $I ] = DllStructGetData ( $TDATA , $I + 1 , $J + 1 )
		Next
	Next
	Return 1
EndFunc
Func _WINAPI_GETDIBCOLORTABLE ( $HBITMAP )
	Local $HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $HSV = _WINAPI_SELECTOBJECT ( $HDC , $HBITMAP )
	Local $TPEAK = DllStructCreate ( "dword[256]" )
	Local $IERROR = 0
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetDIBColorTable" , "handle" , $HDC , "uint" , 0 , "uint" , 256 , "struct*" , $TPEAK )
	If @error Or Not $ACALL [ 0 ] Then $IERROR = @error + 10
	_WINAPI_SELECTOBJECT ( $HDC , $HSV )
	_WINAPI_DELETEDC ( $HDC )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Local $TDATA = DllStructCreate ( "dword[" & $ACALL [ 0 ] & "]" )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	_WINAPI_MOVEMEMORY ( $TDATA , $ACALL [ 4 ] , 4 * $ACALL [ 0 ] )
	Return SetExtended ( $ACALL [ 0 ] , $TDATA )
EndFunc
Func _WINAPI_GETDIBITS ( $HDC , $HBITMAP , $ISTARTSCAN , $ISCANLINES , $PBITS , $TBI , $IUSAGE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetDIBits" , "handle" , $HDC , "handle" , $HBITMAP , "uint" , $ISTARTSCAN , "uint" , $ISCANLINES , "struct*" , $PBITS , "struct*" , $TBI , "uint" , $IUSAGE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETENHMETAFILE ( $SFILEPATH )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "GetEnhMetaFileW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETENHMETAFILEBITS ( $HEMF , ByRef $PBUFFER )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetEnhMetaFileBits" , "handle" , $HEMF , "uint" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 50 , @extended , 0 )
	$PBUFFER = __HEAPREALLOC ( $PBUFFER , $ACALL [ 0 ] , 1 )
	If @error Then Return SetError ( @error , @extended , 0 )
	$ACALL = DllCall ( "gdi32.dll" , "uint" , "GetEnhMetaFileBits" , "handle" , $HEMF , "uint" , $ACALL [ 0 ] , "ptr" , $PBUFFER )
	If Not $ACALL [ 0 ] Then Return SetError ( 60 , 0 , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETENHMETAFILEDESCRIPTION ( $HEMF )
	Local $TDATA = DllStructCreate ( "wchar[4096]" )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetEnhMetaFileDescriptionW" , "handle" , $HEMF , "uint" , 4096 , "struct*" , $TDATA )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error + 20 , $ACALL [ 0 ] , 0 )
	If Not $ACALL [ 0 ] Then Return 0
	Local $ADATA = _WINAPI_STRUCTTOARRAY ( $TDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 2 ]
	For $I = 0 To 1
		If $ADATA [ 0 ] > $I Then
			$ARET [ $I ] = $ADATA [ $I + 1 ]
		Else
			$ARET [ $I ] = ""
		EndIf
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETENHMETAFILEDIMENSION ( $HEMF )
	Local $TENHMETAHEADER = _WINAPI_GETENHMETAFILEHEADER ( $HEMF )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	DllStructSetData ( $TSIZE , 1 , Round ( ( DllStructGetData ( $TENHMETAHEADER , "rcFrame" , 3 ) - DllStructGetData ( $TENHMETAHEADER , "rcFrame" , 1 ) ) * DllStructGetData ( $TENHMETAHEADER , "Device" , 1 ) / DllStructGetData ( $TENHMETAHEADER , "Millimeters" , 1 ) / 100 ) )
	DllStructSetData ( $TSIZE , 2 , Round ( ( DllStructGetData ( $TENHMETAHEADER , "rcFrame" , 4 ) - DllStructGetData ( $TENHMETAHEADER , "rcFrame" , 2 ) ) * DllStructGetData ( $TENHMETAHEADER , "Device" , 2 ) / DllStructGetData ( $TENHMETAHEADER , "Millimeters" , 2 ) / 100 ) )
	Return $TSIZE
EndFunc
Func _WINAPI_GETENHMETAFILEHEADER ( $HEMF )
	Local $TENHMETAHEADER = DllStructCreate ( $TAGENHMETAHEADER )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetEnhMetaFileHeader" , "handle" , $HEMF , "uint" , DllStructGetSize ( $TENHMETAHEADER ) , "struct*" , $TENHMETAHEADER )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TENHMETAHEADER )
EndFunc
Func _WINAPI_GETFONTNAME ( $SFACENAME , $ISTYLE = 0 , $ICHARSET = 1 )
	If Not $SFACENAME Then Return SetError ( 1 , 0 , "" )
	Local $IFLAGS = 0
	If BitAND ( $ISTYLE , 1 ) Then
		$IFLAGS += 32
	EndIf
	If BitAND ( $ISTYLE , 2 ) Then
		$IFLAGS += 1
	EndIf
	If Not $IFLAGS Then
		$IFLAGS = 64
	EndIf
	Local $TLOGFONT = DllStructCreate ( $TAGLOGFONT )
	DllStructSetData ( $TLOGFONT , 9 , $ICHARSET )
	DllStructSetData ( $TLOGFONT , 13 , 0 )
	DllStructSetData ( $TLOGFONT , 14 , StringLeft ( $SFACENAME , 31 ) )
	Local $TFN = DllStructCreate ( "dword;wchar[64]" )
	DllStructSetData ( $TFN , 1 , $IFLAGS )
	DllStructSetData ( $TFN , 2 , "" )
	Local $HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumFontStylesProc" , "int" , "ptr;ptr;dword;lparam" )
	Local $SRET = ""
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "EnumFontFamiliesExW" , "handle" , $HDC , "struct*" , $TLOGFONT , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "struct*" , $TFN , "dword" , 0 )
	If Not @error And Not $ACALL [ 0 ] Then $SRET = DllStructGetData ( $TFN , 2 )
	DllCallbackFree ( $HENUMPROC )
	_WINAPI_DELETEDC ( $HDC )
	If Not $SRET Then Return SetError ( 2 , 0 , "" )
	Return $SRET
EndFunc
Func _WINAPI_GETFONTRESOURCEINFO ( $SFONT , $BFORCE = False , $IFLAG = Default )
	If $IFLAG = Default Then
		If $BFORCE Then
			If Not _WINAPI_ADDFONTRESOURCEEX ( $SFONT , $FR_NOT_ENUM ) Then Return SetError ( @error + 20 , @extended , "" )
		EndIf
		Local $IERROR = 0
		Local $ARET = DllCall ( "gdi32.dll" , "bool" , "GetFontResourceInfoW" , "wstr" , $SFONT , "dword*" , 4096 , "wstr" , "" , "dword" , 1 )
		If @error Or Not $ARET [ 0 ] Then $IERROR = @error + 10
		If $BFORCE Then
			_WINAPI_REMOVEFONTRESOURCEEX ( $SFONT , $FR_NOT_ENUM )
		EndIf
		If $IERROR Then Return SetError ( $IERROR , 0 , "" )
		Return $ARET [ 3 ]
	Else
		If Not FileExists ( $SFONT ) Then
			$SFONT = RegRead ( "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" , "Fonts" ) & "\" & $SFONT
			If Not FileExists ( $SFONT ) Then Return SetError ( 31 , 0 , "" )
		EndIf
		Local Const $HFILE = _WINAPI_CREATEFILE ( $SFONT , 2 , 2 , 2 )
		If Not $HFILE Then Return SetError ( 32 , _WINAPI_GETLASTERROR ( ) , "" )
		Local Const $IFILE = FileGetSize ( $SFONT )
		Local Const $TBUFFER = DllStructCreate ( "byte[" & $IFILE + 1 & "]" )
		Local Const $PFILE = DllStructGetPtr ( $TBUFFER )
		Local $IREAD
		_WINAPI_READFILE ( $HFILE , $PFILE , $IFILE , $IREAD )
		_WINAPI_CLOSEHANDLE ( $HFILE )
		Local $STTFNAME = _WINAPI_GETFONTMEMORYRESOURCEINFO ( $PFILE , $IFLAG )
		If @error Then
			If @error = 1 Then
				$STTFNAME = _WINAPI_GETFONTRESOURCEINFO ( $SFONT , True )
				Return SetError ( @error , @extended , $STTFNAME )
			EndIf
			Return SetError ( 33 , @error , "" )
		EndIf
		Return $STTFNAME
	EndIf
EndFunc
Func _WINAPI_GETFONTMEMORYRESOURCEINFO ( $PMEMORY , $IFLAG = 1 )
	Local Const $TAGTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
	Local Const $TAGTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
	Local Const $TAGTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
	Local Const $TAGTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
	Local $TTTOFFSETTABLE = DllStructCreate ( $TAGTT_OFFSET_TABLE , $PMEMORY )
	Local $INUMOFTABLES = _WINAPI_SWAPWORD ( DllStructGetData ( $TTTOFFSETTABLE , "uNumOfTables" ) )
	If Not ( _WINAPI_SWAPWORD ( DllStructGetData ( $TTTOFFSETTABLE , "uMajorVersion" ) ) = 1 And _WINAPI_SWAPWORD ( DllStructGetData ( $TTTOFFSETTABLE , "uMinorVersion" ) ) = 0 ) Then Return SetError ( 1 , 0 , "" )
	Local $ITBLDIRSIZE = DllStructGetSize ( DllStructCreate ( $TAGTT_TABLE_DIRECTORY ) )
	Local $BFOUND = False , $IOFFSET , $TTBLDIR
	For $I = 0 To $INUMOFTABLES + 4294967295
		$TTBLDIR = DllStructCreate ( $TAGTT_TABLE_DIRECTORY , $PMEMORY + DllStructGetSize ( $TTTOFFSETTABLE ) + $I * $ITBLDIRSIZE )
		If StringLeft ( DllStructGetData ( $TTBLDIR , "szTag" ) , 4 ) = "name" Then
			$BFOUND = True
			$IOFFSET = _WINAPI_SWAPDWORD ( DllStructGetData ( $TTBLDIR , "uOffset" ) )
			ExitLoop
		EndIf
	Next
	If Not $BFOUND Then Return SetError ( 2 , 0 , "" )
	Local $TNTHEADER = DllStructCreate ( $TAGTT_NAME_TABLE_HEADER , $PMEMORY + $IOFFSET )
	Local $INTHEADERSIZE = DllStructGetSize ( $TNTHEADER )
	Local $INRCOUNT = _WINAPI_SWAPWORD ( DllStructGetData ( $TNTHEADER , "uNRCount" ) )
	Local $ISTORAGEOFFSET = _WINAPI_SWAPWORD ( DllStructGetData ( $TNTHEADER , "uStorageOffset" ) )
	Local $ITTRECORDSIZE = DllStructGetSize ( DllStructCreate ( $TAGTT_NAME_RECORD ) )
	Local $TRESULT , $SRESULT , $ISTRINGLENGTH = 0 , $ISTRINGOFFSET , $IENCODINGID , $TTTRECORD
	For $I = 0 To $INRCOUNT + 4294967295
		$TTTRECORD = DllStructCreate ( $TAGTT_NAME_RECORD , $PMEMORY + $IOFFSET + $INTHEADERSIZE + $I * $ITTRECORDSIZE )
		If @error Then ContinueLoop
		If _WINAPI_SWAPWORD ( $TTTRECORD .uNameID ) = $IFLAG Then
			$ISTRINGLENGTH = _WINAPI_SWAPWORD ( DllStructGetData ( $TTTRECORD , "uStringLength" ) )
			$ISTRINGOFFSET = _WINAPI_SWAPWORD ( DllStructGetData ( $TTTRECORD , "uStringOffset" ) )
			$IENCODINGID = _WINAPI_SWAPWORD ( DllStructGetData ( $TTTRECORD , "uEncodingID" ) )
			Local $SWCHAR = "char"
			If $IENCODINGID = 1 Then
				$SWCHAR = "word"
				$ISTRINGLENGTH /= 2
			EndIf
			If Not $ISTRINGLENGTH Then
				$SRESULT = ""
				ContinueLoop
			EndIf
			$TRESULT = DllStructCreate ( $SWCHAR & " szTTFName[" & $ISTRINGLENGTH & "]" , $PMEMORY + $IOFFSET + $ISTRINGOFFSET + $ISTORAGEOFFSET )
			If $IENCODINGID = 1 Then
				$SRESULT = ""
				For $J = 1 To $ISTRINGLENGTH
					$SRESULT &= ChrW ( _WINAPI_SWAPWORD ( DllStructGetData ( $TRESULT , 1 , $J ) ) )
				Next
			Else
				$SRESULT = $TRESULT .szTTFName
			EndIf
			If StringLen ( $SRESULT ) > 0 Then ExitLoop
		EndIf
	Next
	Return $SRESULT
EndFunc
Func _WINAPI_GETGLYPHOUTLINE ( $HDC , $SCHAR , $IFORMAT , ByRef $PBUFFER , $TMAT2 = 0 )
	Local $TGM = DllStructCreate ( $TAGGLYPHMETRICS )
	Local $ACALL , $ILENGTH = 0
	If Not IsDllStruct ( $TMAT2 ) Then
		$TMAT2 = DllStructCreate ( "short[8]" )
		DllStructSetData ( $TMAT2 , 1 , 1 , 2 )
		DllStructSetData ( $TMAT2 , 1 , 1 , 8 )
	EndIf
	If $IFORMAT Then
		$ACALL = DllCall ( "gdi32.dll" , "dword" , "GetGlyphOutlineW" , "handle" , $HDC , "uint" , AscW ( $SCHAR ) , "uint" , $IFORMAT , "struct*" , $TGM , "dword" , 0 , "ptr" , 0 , "struct*" , $TMAT2 )
		If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error + 10 , @extended , 0 )
		$ILENGTH = $ACALL [ 0 ]
		$PBUFFER = __HEAPREALLOC ( $PBUFFER , $ILENGTH , 1 )
		If @error Then Return SetError ( @error + 20 , @extended , 0 )
	EndIf
	$ACALL = DllCall ( "gdi32.dll" , "dword" , "GetGlyphOutlineW" , "handle" , $HDC , "uint" , AscW ( $SCHAR ) , "uint" , $IFORMAT , "struct*" , $TGM , "dword" , $ILENGTH , "ptr" , $PBUFFER , "struct*" , $TMAT2 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 4294967295 Then Return SetError ( 10 , + 4294967295 , 0 )
	Return SetExtended ( $ILENGTH , $TGM )
EndFunc
Func _WINAPI_GETGRAPHICSMODE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetGraphicsMode" , "handle" , $HDC )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETGVALUE ( $IRGB )
	Return BitShift ( BitAND ( __RGB ( $IRGB ) , 65280 ) , 8 )
EndFunc
Func _WINAPI_GETMAPMODE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetMapMode" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETMONITORINFO ( $HMONITOR )
	Local $TMIEX = DllStructCreate ( "dword;long[4];long[4];dword;wchar[32]" )
	DllStructSetData ( $TMIEX , 1 , DllStructGetSize ( $TMIEX ) )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetMonitorInfoW" , "handle" , $HMONITOR , "struct*" , $TMIEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 4 ]
	For $I = 0 To 1
		$ARET [ $I ] = DllStructCreate ( $TAGRECT )
		_WINAPI_MOVEMEMORY ( $ARET [ $I ] , DllStructGetPtr ( $TMIEX , $I + 2 ) , 16 )
	Next
	$ARET [ 3 ] = DllStructGetData ( $TMIEX , 5 )
	Switch DllStructGetData ( $TMIEX , 4 )
	Case 1
		$ARET [ 2 ] = 1
Case Else
		$ARET [ 2 ] = 0
	EndSwitch
	Return $ARET
EndFunc
Func _WINAPI_GETOUTLINETEXTMETRICS ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetOutlineTextMetricsW" , "handle" , $HDC , "uint" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TDATA = DllStructCreate ( "byte[" & $ACALL [ 0 ] & "]" )
	Local $TOLTM = DllStructCreate ( $TAGOUTLINETEXTMETRIC , DllStructGetPtr ( $TDATA ) )
	$ACALL = DllCall ( "gdi32.dll" , "uint" , "GetOutlineTextMetricsW" , "handle" , $HDC , "uint" , $ACALL [ 0 ] , "struct*" , $TDATA )
	If Not $ACALL [ 0 ] Then Return SetError ( 20 , 0 , 0 )
	Return $TOLTM
EndFunc
Func _WINAPI_GETPIXEL ( $HDC , $IX , $IY )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "GetPixel" , "handle" , $HDC , "int" , $IX , "int" , $IY )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_GETPOLYFILLMODE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetPolyFillMode" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPOSFROMRECT ( $TRECT )
	Local $ARET [ 4 ]
	For $I = 0 To 3
		$ARET [ $I ] = DllStructGetData ( $TRECT , $I + 1 )
		If @error Then Return SetError ( @error , @extended , 0 )
	Next
	For $I = 2 To 3
		$ARET [ $I ] -= $ARET [ $I + 4294967294 ]
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETREGIONDATA ( $HRGN , ByRef $TRGNDATA )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "GetRegionData" , "handle" , $HRGN , "dword" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then
		$TRGNDATA = 0
		Return SetError ( @error , @extended , False )
	EndIf
	$TRGNDATA = DllStructCreate ( $TAGRGNDATAHEADER )
	Local $IRECTSIZE = $ACALL [ 0 ] - DllStructGetSize ( $TRGNDATA )
	If $IRECTSIZE > 0 Then $TRGNDATA = DllStructCreate ( $TAGRGNDATAHEADER & ";byte[" & $IRECTSIZE & "]" )
	$ACALL = DllCall ( "gdi32.dll" , "dword" , "GetRegionData" , "handle" , $HRGN , "dword" , $ACALL [ 0 ] , "struct*" , $TRGNDATA )
	If Not $ACALL [ 0 ] Then $TRGNDATA = 0
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETRGNBOX ( $HRGN , ByRef $TRECT )
	$TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetRgnBox" , "handle" , $HRGN , "struct*" , $TRECT )
	If @error Or Not $ACALL [ 0 ] Then
		$TRECT = 0
		Return SetError ( @error , @extended , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETROP2 ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetROP2" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETRVALUE ( $IRGB )
	Return BitAND ( __RGB ( $IRGB ) , 255 )
EndFunc
Func _WINAPI_GETSTRETCHBLTMODE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetStretchBltMode" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTABBEDTEXTEXTENT ( $HDC , $STEXT , $ATAB = 0 , $ISTART = 0 , $IEND = + 4294967295 )
	Local $ITAB , $ICOUNT
	If Not IsArray ( $ATAB ) Then
		If $ATAB Then
			$ITAB = $ATAB
			Dim $ATAB [ 1 ] = [ $ITAB ]
			$ISTART = 0
			$IEND = 0
			$ICOUNT = 1
		Else
			$ICOUNT = 0
		EndIf
	Else
		$ICOUNT = 1
	EndIf
	Local $TTAB = 0
	If $ICOUNT Then
		If __CHECKERRORARRAYBOUNDS ( $ATAB , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
		$ICOUNT = $IEND - $ISTART + 1
		$TTAB = DllStructCreate ( "uint[" & $ICOUNT & "]" )
		$ITAB = 1
		For $I = $ISTART To $IEND
			DllStructSetData ( $TTAB , 1 , $ATAB [ $I ] , $ITAB )
			$ITAB += 1
		Next
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "GetTabbedTextExtentW" , "handle" , $HDC , "wstr" , $STEXT , "int" , StringLen ( $STEXT ) , "int" , $ICOUNT , "struct*" , $TTAB )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Return _WINAPI_CREATESIZE ( _WINAPI_LOWORD ( $ACALL [ 0 ] ) , _WINAPI_HIWORD ( $ACALL [ 0 ] ) )
EndFunc
Func _WINAPI_GETTEXTALIGN ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "GetTextAlign" , "handle" , $HDC )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTEXTCHARACTEREXTRA ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetTextCharacterExtra" , "handle" , $HDC )
	If @error Or ( $ACALL [ 0 ] = 134217728 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTEXTFACE ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetTextFaceW" , "handle" , $HDC , "int" , 2048 , "wstr" , "" )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETUDFCOLORMODE ( )
	Return Number ( $__G_IRGBMODE )
EndFunc
Func _WINAPI_GETUPDATERECT ( $HWND , $BERASE = True )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetUpdateRect" , "hwnd" , $HWND , "struct*" , $TRECT , "bool" , $BERASE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETUPDATERGN ( $HWND , $HRGN , $BERASE = True )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetUpdateRgn" , "hwnd" , $HWND , "handle" , $HRGN , "bool" , $BERASE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOWEXT ( $HDC )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetWindowExtEx" , "handle" , $HDC , "struct*" , $TSIZE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TSIZE
EndFunc
Func _WINAPI_GETWINDOWORG ( $HDC )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetWindowOrgEx" , "handle" , $HDC , "struct*" , $TPOINT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_GETWINDOWRGNBOX ( $HWND , ByRef $TRECT )
	$TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "GetWindowRgnBox" , "hwnd" , $HWND , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWORLDTRANSFORM ( $HDC )
	Local $TXFORM = DllStructCreate ( $TAGXFORM )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GetWorldTransform" , "handle" , $HDC , "struct*" , $TXFORM )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TXFORM
EndFunc
Func _WINAPI_GRADIENTFILL ( $HDC , Const ByRef $AVERTEX , $ISTART = 0 , $IEND = + 4294967295 , $BROTATE = False )
	If __CHECKERRORARRAYBOUNDS ( $AVERTEX , $ISTART , $IEND , 2 ) Then Return SetError ( @error + 10 , @extended , 0 )
	If UBound ( $AVERTEX , $UBOUND_COLUMNS ) < 3 Then Return SetError ( 13 , 0 , 0 )
	Local $IPOINT = $IEND - $ISTART + 1
	If $IPOINT > 3 Then
		$IEND = $ISTART + 2
		$IPOINT = 3
	EndIf
	Local $IMODE
	Switch $IPOINT
	Case 2
		$IMODE = Number ( Not $BROTATE )
	Case 3
		$IMODE = 2
Case Else
		Return SetError ( 15 , 0 , 0 )
	EndSwitch
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "ushort[8];"
	Next
	Local $TVERTEX = DllStructCreate ( $TAGSTRUCT )
	Local $ICOUNT = 1
	Local $TGRADIENT = DllStructCreate ( "ulong[" & $IPOINT & "]" )
	For $I = $ISTART To $IEND
		DllStructSetData ( $TGRADIENT , 1 , $ICOUNT + 4294967295 , $ICOUNT )
		DllStructSetData ( $TVERTEX , $ICOUNT , _WINAPI_LOWORD ( $AVERTEX [ $I ] [ 0 ] ) , 1 )
		DllStructSetData ( $TVERTEX , $ICOUNT , _WINAPI_HIWORD ( $AVERTEX [ $I ] [ 0 ] ) , 2 )
		DllStructSetData ( $TVERTEX , $ICOUNT , _WINAPI_LOWORD ( $AVERTEX [ $I ] [ 1 ] ) , 3 )
		DllStructSetData ( $TVERTEX , $ICOUNT , _WINAPI_HIWORD ( $AVERTEX [ $I ] [ 1 ] ) , 4 )
		DllStructSetData ( $TVERTEX , $ICOUNT , BitShift ( _WINAPI_GETRVALUE ( $AVERTEX [ $I ] [ 2 ] ) , + 4294967288 ) , 5 )
		DllStructSetData ( $TVERTEX , $ICOUNT , BitShift ( _WINAPI_GETGVALUE ( $AVERTEX [ $I ] [ 2 ] ) , + 4294967288 ) , 6 )
		DllStructSetData ( $TVERTEX , $ICOUNT , BitShift ( _WINAPI_GETBVALUE ( $AVERTEX [ $I ] [ 2 ] ) , + 4294967288 ) , 7 )
		DllStructSetData ( $TVERTEX , $ICOUNT , 0 , 8 )
		$ICOUNT += 1
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GdiGradientFill" , "handle" , $HDC , "struct*" , $TVERTEX , "ulong" , $IPOINT , "struct*" , $TGRADIENT , "ulong" , 1 , "ulong" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_INFLATERECT ( ByRef $TRECT , $IDX , $IDY )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "InflateRect" , "struct*" , $TRECT , "int" , $IDX , "int" , $IDY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_INTERSECTCLIPRECT ( $HDC , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "IntersectClipRect" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_INTERSECTRECT ( $TRECT1 , $TRECT2 )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IntersectRect" , "struct*" , $TRECT , "struct*" , $TRECT1 , "struct*" , $TRECT2 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_INVALIDATERGN ( $HWND , $HRGN = 0 , $BERASE = True )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "InvalidateRgn" , "hwnd" , $HWND , "handle" , $HRGN , "bool" , $BERASE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_INVERTANDBITMAP ( $HBITMAP , $BDELETE = False )
	Local $TBITMAP = DllStructCreate ( $TAGBITMAP )
	If Not _WINAPI_GETOBJECT ( $HBITMAP , DllStructGetSize ( $TBITMAP ) , $TBITMAP ) Or ( DllStructGetData ( $TBITMAP , "bmBitsPixel" ) <> 1 ) Then
		Return SetError ( @error + 10 , @extended , 0 )
	EndIf
	Local $HRESULT = _WINAPI_CREATEDIB ( DllStructGetData ( $TBITMAP , "bmWidth" ) , DllStructGetData ( $TBITMAP , "bmHeight" ) , 1 )
	If Not $HRESULT Then Return SetError ( @error , @extended , 0 )
	Local $HSRCDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $HSRCSV = _WINAPI_SELECTOBJECT ( $HSRCDC , $HBITMAP )
	Local $HDSTDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $HDSTSV = _WINAPI_SELECTOBJECT ( $HDSTDC , $HRESULT )
	_WINAPI_BITBLT ( $HDSTDC , 0 , 0 , DllStructGetData ( $TBITMAP , "bmWidth" ) , DllStructGetData ( $TBITMAP , "bmHeight" ) , $HSRCDC , 0 , 0 , 3342344 )
	_WINAPI_SELECTOBJECT ( $HSRCDC , $HSRCSV )
	_WINAPI_DELETEDC ( $HSRCDC )
	_WINAPI_SELECTOBJECT ( $HDSTDC , $HDSTSV )
	_WINAPI_DELETEDC ( $HDSTDC )
	If $BDELETE Then
		_WINAPI_DELETEOBJECT ( $HBITMAP )
	EndIf
	Return $HRESULT
EndFunc
Func _WINAPI_INVERTCOLOR ( $ICOLOR )
	If $ICOLOR = + 4294967295 Then Return 0
	Return 16777215 - BitAND ( $ICOLOR , 16777215 )
EndFunc
Func _WINAPI_INVERTRECT ( $HDC , ByRef $TRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "InvertRect" , "handle" , $HDC , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_INVERTRGN ( $HDC , $HRGN )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "InvertRgn" , "handle" , $HDC , "handle" , $HRGN )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISRECTEMPTY ( ByRef $TRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsRectEmpty" , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LINEDDA ( $IX1 , $IY1 , $IX2 , $IY2 , $PLINEPROC , $PDATA = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "LineDDA" , "int" , $IX1 , "int" , $IY1 , "int" , $IX2 , "int" , $IY2 , "ptr" , $PLINEPROC , "lparam" , $PDATA )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LINETO ( $HDC , $IX , $IY )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "LineTo" , "handle" , $HDC , "int" , $IX , "int" , $IY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOCKWINDOWUPDATE ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "LockWindowUpdate" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LPTODP ( $HDC , ByRef $TPOINT , $ICOUNT = 1 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "LPtoDP" , "handle" , $HDC , "struct*" , $TPOINT , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MASKBLT ( $HDESTDC , $IXDEST , $IYDEST , $IWIDTH , $IHEIGHT , $HSRCDC , $IXSRC , $IYSRC , $HMASK , $IXMASK , $IYMASK , $IROP )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "MaskBlt" , "handle" , $HDESTDC , "int" , $IXDEST , "int" , $IYDEST , "int" , $IWIDTH , "int" , $IHEIGHT , "hwnd" , $HSRCDC , "int" , $IXSRC , "int" , $IYSRC , "handle" , $HMASK , "int" , $IXMASK , "int" , $IYMASK , "dword" , $IROP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MODIFYWORLDTRANSFORM ( $HDC , ByRef $TXFORM , $IMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "ModifyWorldTransform" , "handle" , $HDC , "struct*" , $TXFORM , "dword" , $IMODE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MONITORFROMPOINT ( ByRef $TPOINT , $IFLAG = 1 )
	If DllStructGetSize ( $TPOINT ) <> 8 Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "MonitorFromPoint" , "struct" , $TPOINT , "dword" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MONITORFROMRECT ( ByRef $TRECT , $IFLAG = 1 )
	Local $ACALL = DllCall ( "user32.dll" , "ptr" , "MonitorFromRect" , "struct*" , $TRECT , "dword" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MONITORFROMWINDOW ( $HWND , $IFLAG = 1 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "MonitorFromWindow" , "hwnd" , $HWND , "dword" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MOVETO ( $HDC , $IX , $IY )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "MoveToEx" , "handle" , $HDC , "int" , $IX , "int" , $IY , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MOVETOEX ( $HDC , $IX , $IY )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "MoveToEx" , "handle" , $HDC , "int" , $IX , "int" , $IY , "struct*" , $TPOINT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_OFFSETCLIPRGN ( $HDC , $IXOFFSET , $IYOFFSET )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "OffsetClipRgn" , "handle" , $HDC , "int" , $IXOFFSET , "int" , $IYOFFSET )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OFFSETPOINTS ( ByRef $APOINT , $IXOFFSET , $IYOFFSET , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 ) Then Return SetError ( @error + 10 , @extended , 0 )
	If UBound ( $APOINT , $UBOUND_COLUMNS ) < 2 Then Return SetError ( 13 , 0 , 0 )
	For $I = $ISTART To $IEND
		$APOINT [ $I ] [ 0 ] += $IXOFFSET
		$APOINT [ $I ] [ 1 ] += $IYOFFSET
	Next
	Return 1
EndFunc
Func _WINAPI_OFFSETRECT ( ByRef $TRECT , $IDX , $IDY )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "OffsetRect" , "struct*" , $TRECT , "int" , $IDX , "int" , $IDY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OFFSETRGN ( $HRGN , $IXOFFSET , $IYOFFSET )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "OffsetRgn" , "handle" , $HRGN , "int" , $IXOFFSET , "int" , $IYOFFSET )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OFFSETWINDOWORG ( $HDC , $IXOFFSET , $IYOFFSET )
	$__G_VEXT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "OffsetWindowOrgEx" , "handle" , $HDC , "int" , $IXOFFSET , "int" , $IYOFFSET , "struct*" , $__G_VEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PAINTDESKTOP ( $HDC )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "PaintDesktop" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PAINTRGN ( $HDC , $HRGN )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PaintRgn" , "handle" , $HDC , "handle" , $HRGN )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATBLT ( $HDC , $IX , $IY , $IWIDTH , $IHEIGHT , $IROP )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PatBlt" , "handle" , $HDC , "int" , $IX , "int" , $IY , "int" , $IWIDTH , "int" , $IHEIGHT , "dword" , $IROP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHTOREGION ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "PathToRegion" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PLAYENHMETAFILE ( $HDC , $HEMF , ByRef $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PlayEnhMetaFile" , "handle" , $HDC , "handle" , $HEMF , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PLGBLT ( $HDESTDC , Const ByRef $APOINT , $HSRCDC , $IXSRC , $IYSRC , $IWIDTH , $IHEIGHT , $HMASK = 0 , $IXMASK = 0 , $IYMASK = 0 )
	If ( UBound ( $APOINT ) < 3 ) Or ( UBound ( $APOINT , $UBOUND_COLUMNS ) < 2 ) Then Return SetError ( 12 , 0 , False )
	Local $TPOINTS = DllStructCreate ( "long[2];long[2];long[2]" )
	For $I = 0 To 2
		For $J = 0 To 1
			DllStructSetData ( $TPOINTS , $I + 1 , $APOINT [ $I ] [ $J ] , $J + 1 )
		Next
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PlgBlt" , "handle" , $HDESTDC , "struct*" , $TPOINTS , "handle" , $HSRCDC , "int" , $IXSRC , "int" , $IYSRC , "int" , $IWIDTH , "int" , $IHEIGHT , "handle" , $HMASK , "int" , $IXMASK , "int" , $IYMASK )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_POLYBEZIER ( $HDC , Const ByRef $APOINT , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 , 2 ) Then Return SetError ( @error + 10 , @extended , False )
	Local $IPOINT = 1 + 3 * Floor ( ( $IEND - $ISTART ) / 3 )
	If $IPOINT < 1 Then Return SetError ( 15 , 0 , False )
	$IEND = $ISTART + $IPOINT + 4294967295
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "long[2];"
	Next
	Local $TPOINT = DllStructCreate ( $TAGSTRUCT )
	Local $ICOUNT = 0
	For $I = $ISTART To $IEND
		$ICOUNT += 1
		For $J = 0 To 1
			DllStructSetData ( $TPOINT , $ICOUNT , $APOINT [ $I ] [ $J ] , $J + 1 )
		Next
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PolyBezier" , "handle" , $HDC , "struct*" , $TPOINT , "dword" , $IPOINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_POLYBEZIERTO ( $HDC , Const ByRef $APOINT , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 , 2 ) Then Return SetError ( @error + 10 , @extended , False )
	Local $IPOINT = 3 * Floor ( ( $IEND - $ISTART + 1 ) / 3 )
	If $IPOINT < 3 Then Return SetError ( 15 , 0 , False )
	$IEND = $ISTART + $IPOINT + 4294967295
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "long[2];"
	Next
	Local $TPOINT = DllStructCreate ( $TAGSTRUCT )
	Local $ICOUNT = 0
	For $I = $ISTART To $IEND
		$ICOUNT += 1
		For $J = 0 To 1
			DllStructSetData ( $TPOINT , $ICOUNT , $APOINT [ $I ] [ $J ] , $J + 1 )
		Next
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PolyBezierTo" , "handle" , $HDC , "struct*" , $TPOINT , "dword" , $IPOINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_POLYDRAW ( $HDC , Const ByRef $APOINT , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 ) Then Return SetError ( @error + 10 , @extended , 0 )
	If UBound ( $APOINT , $UBOUND_COLUMNS ) < 3 Then Return SetError ( 13 , 0 , False )
	Local $IPOINT = $IEND - $ISTART + 1
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "long[2];"
	Next
	Local $TPOINT = DllStructCreate ( $TAGSTRUCT )
	Local $TTYPES = DllStructCreate ( "byte[" & $IPOINT & "]" )
	Local $ICOUNT = 0
	For $I = $ISTART To $IEND
		$ICOUNT += 1
		For $J = 0 To 1
			DllStructSetData ( $TPOINT , $ICOUNT , $APOINT [ $I ] [ $J ] , $J + 1 )
		Next
		DllStructSetData ( $TTYPES , 1 , $APOINT [ $I ] [ 2 ] , $ICOUNT )
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PolyDraw" , "handle" , $HDC , "struct*" , $TPOINT , "struct*" , $TTYPES , "dword" , $IPOINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_POLYGON ( $HDC , Const ByRef $APOINT , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 , 2 ) Then Return SetError ( @error + 10 , @extended , False )
	Local $TAGSTRUCT = ""
	For $I = $ISTART To $IEND
		$TAGSTRUCT &= "int[2];"
	Next
	Local $TDATA = DllStructCreate ( $TAGSTRUCT )
	Local $ICOUNT = 1
	For $I = $ISTART To $IEND
		For $J = 0 To 1
			DllStructSetData ( $TDATA , $ICOUNT , $APOINT [ $I ] [ $J ] , $J + 1 )
		Next
		$ICOUNT += 1
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "Polygon" , "handle" , $HDC , "struct*" , $TDATA , "int" , $ICOUNT + 4294967295 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PTINRECTEX ( $IX , $IY , $ILEFT , $ITOP , $IRIGHT , $IBOTTOM )
	Local $TRECT = _WINAPI_CREATERECT ( $ILEFT , $ITOP , $IRIGHT , $IBOTTOM )
	Local $TPOINT = _WINAPI_CREATEPOINT ( $IX , $IY )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "PtInRect" , "struct*" , $TRECT , "struct" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PTINREGION ( $HRGN , $IX , $IY )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PtInRegion" , "handle" , $HRGN , "int" , $IX , "int" , $IY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PTVISIBLE ( $HDC , $IX , $IY )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "PtVisible" , "handle" , $HDC , "int" , $IX , "int" , $IY )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	If $ACALL [ 0 ] = + 4294967295 Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RADIALGRADIENTFILL ( $HDC , $IX , $IY , $IRADIUS , $IRGB1 , $IRGB2 , $FANGLESTART = 0 , $FANGLEEND = 360 , $FSTEP = 5 )
	If Abs ( $FANGLESTART ) > 360 Then
		$FANGLESTART = Mod ( $FANGLESTART , 360 )
	EndIf
	If Abs ( $FANGLEEND ) > 360 Then
		$FANGLEEND = Mod ( $FANGLEEND , 360 )
	EndIf
	If ( $FANGLESTART < 0 ) Or ( $FANGLEEND < 0 ) Then
		$FANGLESTART += 360
		$FANGLEEND += 360
	EndIf
	If $FANGLESTART > $FANGLEEND Then
		Local $FVAL = $FANGLESTART
		$FANGLESTART = $FANGLEEND
		$FANGLEEND = $FVAL
	EndIf
	If $FSTEP < 1 Then
		$FSTEP = 1
	EndIf
	Local $FKI = ATan ( 1 ) / 45
	Local $IXP = Round ( $IX + $IRADIUS * Cos ( $FKI * $FANGLESTART ) )
	Local $IYP = Round ( $IY + $IRADIUS * Sin ( $FKI * $FANGLESTART ) )
	Local $IXN , $IYN , $FAN = $FANGLESTART
	Local $AVERTEX [ 3 ] [ 3 ]
	While $FAN < $FANGLEEND
		$FAN += $FSTEP
		If $FAN > $FANGLEEND Then
			$FAN = $FANGLEEND
		EndIf
		$IXN = Round ( $IX + $IRADIUS * Cos ( $FKI * $FAN ) )
		$IYN = Round ( $IY + $IRADIUS * Sin ( $FKI * $FAN ) )
		$AVERTEX [ 0 ] [ 0 ] = $IX
		$AVERTEX [ 0 ] [ 1 ] = $IY
		$AVERTEX [ 0 ] [ 2 ] = $IRGB1
		$AVERTEX [ 1 ] [ 0 ] = $IXP
		$AVERTEX [ 1 ] [ 1 ] = $IYP
		$AVERTEX [ 1 ] [ 2 ] = $IRGB2
		$AVERTEX [ 2 ] [ 0 ] = $IXN
		$AVERTEX [ 2 ] [ 1 ] = $IYN
		$AVERTEX [ 2 ] [ 2 ] = $IRGB2
		If Not _WINAPI_GRADIENTFILL ( $HDC , $AVERTEX , 0 , 2 ) Then
			Return SetError ( @error , @extended , 0 )
		EndIf
		$IXP = $IXN
		$IYP = $IYN
	WEnd
	Return 1
EndFunc
Func _WINAPI_RECTANGLE ( $HDC , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "Rectangle" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RECTINREGION ( $HRGN , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "RectInRegion" , "handle" , $HRGN , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RECTISEMPTY ( ByRef $TRECT )
	Return ( DllStructGetData ( $TRECT , "Left" ) = 0 ) And ( DllStructGetData ( $TRECT , "Top" ) = 0 ) And ( DllStructGetData ( $TRECT , "Right" ) = 0 ) And ( DllStructGetData ( $TRECT , "Bottom" ) = 0 )
EndFunc
Func _WINAPI_RECTVISIBLE ( $HDC , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "RectVisible" , "handle" , $HDC , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Switch $ACALL [ 0 ]
	Case 0 , 1 , 2
Case Else
		Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	EndSwitch
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REMOVEFONTMEMRESOURCEEX ( $HFONT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "RemoveFontMemResourceEx" , "handle" , $HFONT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REMOVEFONTRESOURCEEX ( $SFONT , $IFLAG = 0 , $BNOTIFY = False )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "RemoveFontResourceExW" , "wstr" , $SFONT , "dword" , $IFLAG , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	If $BNOTIFY Then
		Local Const $WM_FONTCHANGE = 29
		Local Const $HWND_BROADCAST = 65535
		DllCall ( "user32.dll" , "none" , "SendMessage" , "hwnd" , $HWND_BROADCAST , "uint" , $WM_FONTCHANGE , "wparam" , 0 , "lparam" , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RGB ( $IRED , $IGREEN , $IBLUE )
	Return __RGB ( BitOR ( BitShift ( $IBLUE , + 4294967280 ) , BitShift ( $IGREEN , + 4294967288 ) , $IRED ) )
EndFunc
Func _WINAPI_ROTATEPOINTS ( ByRef $APOINT , $IXC , $IYC , $FANGLE , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $APOINT , $ISTART , $IEND , 2 ) Then Return SetError ( @error + 10 , @extended , 0 )
	If UBound ( $APOINT , $UBOUND_COLUMNS ) < 2 Then Return SetError ( 13 , 0 , 0 )
	Local $FCOS = Cos ( ATan ( 1 ) / 45 * $FANGLE )
	Local $FSIN = Sin ( ATan ( 1 ) / 45 * $FANGLE )
	Local $IXN , $IYN
	For $I = $ISTART To $IEND
		$IXN = $APOINT [ $I ] [ 0 ] - $IXC
		$IYN = $APOINT [ $I ] [ 1 ] - $IYC
		$APOINT [ $I ] [ 0 ] = $IXC + Round ( $IXN * $FCOS - $IYN * $FSIN )
		$APOINT [ $I ] [ 1 ] = $IYC + Round ( $IXN * $FSIN + $IYN * $FCOS )
	Next
	Return 1
EndFunc
Func _WINAPI_ROUNDRECT ( $HDC , $TRECT , $IWIDTH , $IHEIGHT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "RoundRect" , "handle" , $HDC , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) , "int" , $IWIDTH , "int" , $IHEIGHT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SAVEHBITMAPTOFILE ( $SFILEPATH , $HBITMAP , $IXPELSPERMETER = Default , $IYPELSPERMETER = Default )
	Local $TBMP = DllStructCreate ( "align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset" )
	Local $TDIB = DllStructCreate ( $TAGDIBSECTION )
	Local $HDC , $HSV , $HSOURCE = 0
	While $HBITMAP
		If ( Not _WINAPI_GETOBJECT ( $HBITMAP , DllStructGetSize ( $TDIB ) , $TDIB ) ) Or ( DllStructGetData ( $TDIB , "biCompression" ) ) Then
			$HBITMAP = 0
		Else
			Switch DllStructGetData ( $TDIB , "bmBitsPixel" )
			Case 32
				If Not _WINAPI_ISALPHABITMAP ( $HBITMAP ) Then
					If Not $HSOURCE Then
						$HSOURCE = _WINAPI_CREATEDIB ( DllStructGetData ( $TDIB , "bmWidth" ) , DllStructGetData ( $TDIB , "bmHeight" ) , 24 )
						If Not $HSOURCE Then
							$HBITMAP = 0
						EndIf
						$HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
						$HSV = _WINAPI_SELECTOBJECT ( $HDC , $HSOURCE )
						If _WINAPI_DRAWBITMAP ( $HDC , 0 , 0 , $HBITMAP ) Then
							$HBITMAP = $HSOURCE
						Else
							$HBITMAP = 0
						EndIf
						_WINAPI_SELECTOBJECT ( $HDC , $HSV )
						_WINAPI_DELETEDC ( $HDC )
					Else
						$HBITMAP = 0
					EndIf
					ContinueLoop
				EndIf
		Case Else
			EndSwitch
			If ( Not DllStructGetData ( $TDIB , "bmBits" ) ) Or ( Not DllStructGetData ( $TDIB , "biSizeImage" ) ) Then
				If Not $HSOURCE Then
					$HBITMAP = _WINAPI_COPYBITMAP ( $HBITMAP )
					$HSOURCE = $HBITMAP
				Else
					$HBITMAP = 0
				EndIf
			Else
				ExitLoop
			EndIf
		EndIf
	WEnd
	Local $HFILE = 0 , $IERROR = 0 , $IRESULT = 0
	Do
		If Not $HBITMAP Then
			$IERROR = 1
			ExitLoop
		EndIf
		Local $ADATA [ 4 ] [ 2 ]
		$ADATA [ 0 ] [ 0 ] = DllStructGetPtr ( $TBMP )
		$ADATA [ 0 ] [ 1 ] = DllStructGetSize ( $TBMP )
		$ADATA [ 1 ] [ 0 ] = DllStructGetPtr ( $TDIB , "biSize" )
		$ADATA [ 1 ] [ 1 ] = 40
		$ADATA [ 2 ] [ 1 ] = DllStructGetData ( $TDIB , "biClrUsed" ) * 4
		Local $TTABLE = 0
		If $ADATA [ 2 ] [ 1 ] Then
			$TTABLE = _WINAPI_GETDIBCOLORTABLE ( $HBITMAP )
			If @error Or ( @extended <> $ADATA [ 2 ] [ 1 ] / 4 ) Then
				$IERROR = @error + 10
				ExitLoop
			EndIf
		EndIf
		$ADATA [ 2 ] [ 0 ] = DllStructGetPtr ( $TTABLE )
		$ADATA [ 3 ] [ 0 ] = DllStructGetData ( $TDIB , "bmBits" )
		$ADATA [ 3 ] [ 1 ] = DllStructGetData ( $TDIB , "biSizeImage" )
		DllStructSetData ( $TBMP , "bfType" , 19778 )
		DllStructSetData ( $TBMP , "bfSize" , $ADATA [ 0 ] [ 1 ] + $ADATA [ 1 ] [ 1 ] + $ADATA [ 2 ] [ 1 ] + $ADATA [ 3 ] [ 1 ] )
		DllStructSetData ( $TBMP , "bfReserved1" , 0 )
		DllStructSetData ( $TBMP , "bfReserved2" , 0 )
		DllStructSetData ( $TBMP , "bfOffset" , $ADATA [ 0 ] [ 1 ] + $ADATA [ 1 ] [ 1 ] + $ADATA [ 2 ] [ 1 ] )
		$HDC = _WINAPI_GETDC ( 0 )
		If $IXPELSPERMETER = Default Then
			If Not DllStructGetData ( $TDIB , "biXPelsPerMeter" ) Then
				DllStructSetData ( $TDIB , "biXPelsPerMeter" , _WINAPI_GETDEVICECAPS ( $HDC , 8 ) / _WINAPI_GETDEVICECAPS ( $HDC , 4 ) * 1000 )
			EndIf
		Else
			DllStructSetData ( $TDIB , "biXPelsPerMeter" , $IXPELSPERMETER )
		EndIf
		If $IYPELSPERMETER = Default Then
			If Not DllStructGetData ( $TDIB , "biYPelsPerMeter" ) Then
				DllStructSetData ( $TDIB , "biYPelsPerMeter" , _WINAPI_GETDEVICECAPS ( $HDC , 10 ) / _WINAPI_GETDEVICECAPS ( $HDC , 6 ) * 1000 )
			EndIf
		Else
			DllStructSetData ( $TDIB , "biYPelsPerMeter" , $IYPELSPERMETER )
		EndIf
		_WINAPI_RELEASEDC ( 0 , $HDC )
		$HFILE = _WINAPI_CREATEFILE ( $SFILEPATH , 1 , 4 )
		If @error Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
		Local $IBYTES
		For $I = 0 To 3
			If $ADATA [ $I ] [ 1 ] Then
				If Not _WINAPI_WRITEFILE ( $HFILE , $ADATA [ $I ] [ 0 ] , $ADATA [ $I ] [ 1 ] , $IBYTES ) Then
					$IERROR = @error + 30
					ExitLoop 2
				EndIf
			EndIf
		Next
		$IRESULT = 1
	Until 1
	If $HSOURCE Then
		_WINAPI_DELETEOBJECT ( $HSOURCE )
	EndIf
	_WINAPI_CLOSEHANDLE ( $HFILE )
	If Not $IRESULT Then
		FileDelete ( $SFILEPATH )
	EndIf
	Return SetError ( $IERROR , 0 , $IRESULT )
EndFunc
Func _WINAPI_SAVEHICONTOFILE ( $SFILEPATH , Const ByRef $VICON , $BCOMPRESS = 0 , $ISTART = 0 , $IEND = + 4294967295 )
	Local $AICON , $ATEMP , $ICOUNT = 1
	If Not IsArray ( $VICON ) Then
		Dim $AICON [ 1 ] = [ $VICON ]
		Dim $ATEMP [ 1 ] = [ 0 ]
	Else
		If __CHECKERRORARRAYBOUNDS ( $VICON , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
		$ICOUNT = $IEND - $ISTART + 1
		If $ICOUNT Then
			Dim $AICON [ $ICOUNT ]
			Dim $ATEMP [ $ICOUNT ]
			For $I = 0 To $ICOUNT + 4294967295
				$AICON [ $I ] = $VICON [ $ISTART + $I ]
				$ATEMP [ $I ] = 0
			Next
		EndIf
	EndIf
	Local $HFILE = _WINAPI_CREATEFILE ( $SFILEPATH , 1 , 4 )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TICO = DllStructCreate ( "align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & ( 16 * $ICOUNT ) & "]" )
	Local $ILENGTH = DllStructGetSize ( $TICO )
	Local $TBI = DllStructCreate ( $TAGBITMAPINFOHEADER )
	Local $TII = DllStructCreate ( $TAGICONINFO )
	Local $TDIB = DllStructCreate ( $TAGDIBSECTION )
	Local $IDIB = DllStructGetSize ( $TDIB )
	Local $PDIB = DllStructGetPtr ( $TDIB )
	Local $IOFFSET = $ILENGTH
	DllStructSetData ( $TBI , "biSize" , 40 )
	DllStructSetData ( $TBI , "biPlanes" , 1 )
	DllStructSetData ( $TBI , "biXPelsPerMeter" , 0 )
	DllStructSetData ( $TBI , "biYPelsPerMeter" , 0 )
	DllStructSetData ( $TBI , "biClrUsed" , 0 )
	DllStructSetData ( $TBI , "biClrImportant" , 0 )
	DllStructSetData ( $TICO , "Reserved" , 0 )
	DllStructSetData ( $TICO , "Type" , 1 )
	DllStructSetData ( $TICO , "Count" , $ICOUNT )
	Local $IRESULT = 0 , $IERROR = 0 , $IBYTES
	Local $AINFO [ 8 ] , $ACALL , $PDATA = 0 , $IINDEX = 0
	Local $ASIZE [ 2 ] , $TDATA = 0
	Do
		If Not _WINAPI_WRITEFILE ( $HFILE , $TICO , $ILENGTH , $IBYTES ) Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		While $ICOUNT > $IINDEX
			$ACALL = DllCall ( "user32.dll" , "bool" , "GetIconInfo" , "handle" , $AICON [ $IINDEX ] , "struct*" , $TII )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 40
				ExitLoop 2
			EndIf
			For $I = 4 To 5
				$AINFO [ $I ] = _WINAPI_COPYIMAGE ( DllStructGetData ( $TII , $I ) , 0 , 0 , 0 , 8200 )
				If _WINAPI_GETOBJECT ( $AINFO [ $I ] , $IDIB , $PDIB ) Then
					$AINFO [ $I + 4294967292 ] = DllStructGetData ( $TDIB , "biSizeImage" )
					$AINFO [ $I + 4294967294 ] = DllStructGetData ( $TDIB , "bmBits" )
				Else
					$IERROR = @error + 50
				EndIf
			Next
			$AINFO [ 6 ] = 40
			$AINFO [ 7 ] = DllStructGetData ( $TDIB , "bmBitsPixel" )
			Switch $AINFO [ 7 ]
			Case 16 , 24
			Case 32
				If Not _WINAPI_ISALPHABITMAP ( $AINFO [ 5 ] ) Then
					If Not $ATEMP [ $IINDEX ] Then
						$AICON [ $IINDEX ] = _WINAPI_CREATE32BITHICON ( $AICON [ $IINDEX ] )
						$ATEMP [ $IINDEX ] = $AICON [ $IINDEX ]
						If Not @error Then
							ContinueLoop
						Else
							ContinueCase
						EndIf
					EndIf
				Else
					If ( $AINFO [ 1 ] >= 256 * 256 * 4 ) And ( $BCOMPRESS ) Then
						$IBYTES = _WINAPI_COMPRESSBITMAPBITS ( $AINFO [ 5 ] , $PDATA )
						If Not @error Then
							$AINFO [ 0 ] = 0
							$AINFO [ 1 ] = $IBYTES
							$AINFO [ 2 ] = 0
							$AINFO [ 3 ] = $PDATA
							$AINFO [ 6 ] = 0
						EndIf
					EndIf
				EndIf
		Case Else
				$IERROR = 60
			EndSwitch
			If Not $IERROR Then
				$TDATA = DllStructCreate ( "byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset" , DllStructGetPtr ( $TICO ) + 6 + 16 * $IINDEX )
				DllStructSetData ( $TDATA , "ColorCount" , 0 )
				DllStructSetData ( $TDATA , "Reserved" , 0 )
				DllStructSetData ( $TDATA , "Planes" , 1 )
				DllStructSetData ( $TDATA , "BitCount" , $AINFO [ 7 ] )
				DllStructSetData ( $TDATA , "Size" , $AINFO [ 0 ] + $AINFO [ 1 ] + $AINFO [ 6 ] )
				DllStructSetData ( $TDATA , "Offset" , $IOFFSET )
				For $I = 0 To 1
					$ASIZE [ $I ] = DllStructGetData ( $TDIB , $I + 2 )
					If $ASIZE [ $I ] < 256 Then
						DllStructSetData ( $TDATA , $I + 1 , $ASIZE [ $I ] )
					Else
						DllStructSetData ( $TDATA , $I + 1 , 0 )
					EndIf
				Next
				DllStructSetData ( $TBI , "biWidth" , $ASIZE [ 0 ] )
				DllStructSetData ( $TBI , "biHeight" , 2 * $ASIZE [ 1 ] )
				DllStructSetData ( $TBI , "biBitCount" , $AINFO [ 7 ] )
				DllStructSetData ( $TBI , "biCompression" , 0 )
				DllStructSetData ( $TBI , "biSizeImage" , $AINFO [ 0 ] + $AINFO [ 1 ] )
				$IOFFSET += $AINFO [ 0 ] + $AINFO [ 1 ] + $AINFO [ 6 ]
				Do
					If $AINFO [ 6 ] Then
						If Not _WINAPI_WRITEFILE ( $HFILE , $TBI , $AINFO [ 6 ] , $IBYTES ) Then
							$IERROR = @error + 70
							ExitLoop
						EndIf
						For $I = 1 To 0 Step + 4294967295
							If Not _WINAPI_WRITEFILE ( $HFILE , $AINFO [ $I + 2 ] , $AINFO [ $I ] , $IBYTES ) Then
								$IERROR = @error + 80
								ExitLoop 2
							EndIf
						Next
					Else
						If Not _WINAPI_WRITEFILE ( $HFILE , $AINFO [ 3 ] , $AINFO [ 1 ] , $IBYTES ) Then
							$IERROR = @error + 90
							ExitLoop
						EndIf
					EndIf
				Until 1
			EndIf
			For $I = 4 To 5
				_WINAPI_DELETEOBJECT ( $AINFO [ $I ] )
			Next
			If $IERROR Then
				ExitLoop 2
			EndIf
			$IINDEX += 1
		WEnd
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "SetFilePointerEx" , "handle" , $HFILE , "int64" , 0 , "int64*" , 0 , "dword" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 100
			ExitLoop
		EndIf
		If Not _WINAPI_WRITEFILE ( $HFILE , $TICO , $ILENGTH , $IBYTES ) Then
			$IERROR = @error + 110
			ExitLoop
		EndIf
		$IRESULT = 1
	Until 1
	For $I = 0 To $ICOUNT + 4294967295
		If $ATEMP [ $I ] Then
			_WINAPI_DESTROYICON ( $ATEMP [ $I ] )
		EndIf
	Next
	If $PDATA Then
		__HEAPFREE ( $PDATA )
	EndIf
	_WINAPI_CLOSEHANDLE ( $HFILE )
	If Not $IRESULT Then
		FileDelete ( $SFILEPATH )
	EndIf
	Return SetError ( $IERROR , 0 , $IRESULT )
EndFunc
Func _WINAPI_SCALEWINDOWEXT ( $HDC , $IXNUM , $IXDENOM , $IYNUM , $IYDENOM )
	$__G_VEXT = DllStructCreate ( $TAGSIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "ScaleWindowExtEx" , "handle" , $HDC , "int" , $IXNUM , "int" , $IXDENOM , "int" , $IYNUM , "int" , $IYDENOM , "struct*" , $__G_VEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SELECTCLIPPATH ( $HDC , $IMODE = 5 )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SelectClipPath" , "handle" , $HDC , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SELECTCLIPRGN ( $HDC , $HRGN )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SelectClipRgn" , "handle" , $HDC , "handle" , $HRGN )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETARCDIRECTION ( $HDC , $IDIRECTION )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetArcDirection" , "handle" , $HDC , "int" , $IDIRECTION )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETBITMAPBITS ( $HBITMAP , $ISIZE , $PBITS )
	Local $ACALL = DllCall ( "gdi32.dll" , "long" , "SetBitmapBits" , "handle" , $HBITMAP , "dword" , $ISIZE , "struct*" , $PBITS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETBITMAPDIMENSIONEX ( $HBITMAP , $IWIDTH , $IHEIGHT )
	$__G_VEXT = DllStructCreate ( $TAGSIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetBitmapDimensionEx" , "handle" , $HBITMAP , "int" , $IWIDTH , "int" , $IHEIGHT , "struct*" , $__G_VEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETBOUNDSRECT ( $HDC , $IFLAGS , $TRECT = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "SetBoundsRect" , "handle" , $HDC , "struct*" , $TRECT , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETBRUSHORG ( $HDC , $IX , $IY )
	$__G_VEXT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetBrushOrgEx" , "handle" , $HDC , "int" , $IX , "int" , $IY , "struct*" , $__G_VEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETCOLORADJUSTMENT ( $HDC , $TADJUSTMENT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetColorAdjustment" , "handle" , $HDC , "struct*" , $TADJUSTMENT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETDCBRUSHCOLOR ( $HDC , $IRGB )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "SetDCBrushColor" , "handle" , $HDC , "dword" , __RGB ( $IRGB ) )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_SETDCPENCOLOR ( $HDC , $IRGB )
	Local $ACALL = DllCall ( "gdi32.dll" , "dword" , "SetDCPenColor" , "handle" , $HDC , "dword" , __RGB ( $IRGB ) )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return __RGB ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_SETDEVICEGAMMARAMP ( $HDC , Const ByRef $ARAMP )
	If ( UBound ( $ARAMP , $UBOUND_DIMENSIONS ) <> 2 ) Or ( UBound ( $ARAMP , $UBOUND_ROWS ) <> 256 ) Or ( UBound ( $ARAMP , $UBOUND_COLUMNS ) <> 3 ) Then
		Return SetError ( 12 , 0 , 0 )
	EndIf
	Local $TDATA = DllStructCreate ( "ushort[256];ushort[256];ushort[256]" )
	For $I = 0 To 2
		For $J = 0 To 255
			DllStructSetData ( $TDATA , $I + 1 , $ARAMP [ $J ] [ $I ] , $J + 1 )
		Next
	Next
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetDeviceGammaRamp" , "handle" , $HDC , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETDIBCOLORTABLE ( $HBITMAP , $TCOLORTABLE , $ICOLORCOUNT )
	If $ICOLORCOUNT > DllStructGetSize ( $TCOLORTABLE ) / 4 Then Return SetError ( 1 , 0 , 0 )
	Local $HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $HSV = _WINAPI_SELECTOBJECT ( $HDC , $HBITMAP )
	Local $IERROR = 0
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "SetDIBColorTable" , "handle" , $HDC , "uint" , 0 , "uint" , $ICOLORCOUNT , "struct*" , $TCOLORTABLE )
	If @error Then $IERROR = @error
	_WINAPI_SELECTOBJECT ( $HDC , $HSV )
	_WINAPI_DELETEDC ( $HDC )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETDIBITS ( $HDC , $HBITMAP , $ISTARTSCAN , $ISCANLINES , $PBITS , $TBMI , $ICOLORUSE = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetDIBits" , "handle" , $HDC , "handle" , $HBITMAP , "uint" , $ISTARTSCAN , "uint" , $ISCANLINES , "struct*" , $PBITS , "struct*" , $TBMI , "INT" , $ICOLORUSE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETDIBITSTODEVICE ( $HDC , $IXDEST , $IYDEST , $IWIDTH , $IHEIGHT , $IXSRC , $IYSRC , $ISTARTSCAN , $ISCANLINES , $TBITMAPINFO , $IUSAGE , $PBITS )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetDIBitsToDevice" , "handle" , $HDC , "int" , $IXDEST , "int" , $IYDEST , "dword" , $IWIDTH , "dword" , $IHEIGHT , "int" , $IXSRC , "int" , $IYSRC , "uint" , $ISTARTSCAN , "uint" , $ISCANLINES , "struct*" , $PBITS , "struct*" , $TBITMAPINFO , "uint" , $IUSAGE )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then Return SetError ( @error + 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETENHMETAFILEBITS ( $PDATA , $ILENGTH )
	Local $ACALL = DllCall ( "gdi32.dll" , "handle" , "SetEnhMetaFileBits" , "uint" , $ILENGTH , "struct*" , $PDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETGRAPHICSMODE ( $HDC , $IMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetGraphicsMode" , "handle" , $HDC , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETMAPMODE ( $HDC , $IMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetMapMode" , "handle" , $HDC , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETPIXEL ( $HDC , $IX , $IY , $IRGB )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetPixelV" , "handle" , $HDC , "int" , $IX , "int" , $IY , "dword" , __RGB ( $IRGB ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETPOLYFILLMODE ( $HDC , $IMODE = 1 )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetPolyFillMode" , "handle" , $HDC , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETRECTRGN ( $HRGN , $TRECT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetRectRgn" , "handle" , $HRGN , "int" , DllStructGetData ( $TRECT , 1 ) , "int" , DllStructGetData ( $TRECT , 2 ) , "int" , DllStructGetData ( $TRECT , 3 ) , "int" , DllStructGetData ( $TRECT , 4 ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETROP2 ( $HDC , $IMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetROP2" , "handle" , $HDC , "int" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETSTRETCHBLTMODE ( $HDC , $IMODE )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetStretchBltMode" , "handle" , $HDC , "int" , $IMODE )
	If @error Or Not $ACALL [ 0 ] Or ( $ACALL [ 0 ] = 87 ) Then Return SetError ( @error + 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTEXTALIGN ( $HDC , $IMODE = 0 )
	Local $ACALL = DllCall ( "gdi32.dll" , "uint" , "SetTextAlign" , "handle" , $HDC , "uint" , $IMODE )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTEXTCHARACTEREXTRA ( $HDC , $ICHAREXTRA )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "SetTextCharacterExtra" , "handle" , $HDC , "int" , $ICHAREXTRA )
	If @error Or ( $ACALL [ 0 ] = 2147483648 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTEXTJUSTIFICATION ( $HDC , $IBREAKEXTRA , $IBREAKCOUNT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetTextJustification" , "handle" , $HDC , "int" , $IBREAKEXTRA , "int" , $IBREAKCOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETUDFCOLORMODE ( $IMODE )
	$__G_IRGBMODE = Not ( $IMODE = 0 )
EndFunc
Func _WINAPI_SETWINDOWEXT ( $HDC , $IXEXTENT , $IYEXTENT )
	$__G_VEXT = DllStructCreate ( $TAGSIZE )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetWindowExtEx" , "handle" , $HDC , "int" , $IXEXTENT , "int" , $IYEXTENT , "struct*" , $__G_VEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWORG ( $HDC , $IX , $IY )
	$__G_VEXT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetWindowOrgEx" , "handle" , $HDC , "int" , $IX , "int" , $IY , "struct*" , $__G_VEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWORLDTRANSFORM ( $HDC , ByRef $TXFORM )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "SetWorldTransform" , "handle" , $HDC , "struct*" , $TXFORM )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRETCHBLT ( $HDESTDC , $IXDEST , $IYDEST , $IWIDTHDEST , $IHEIGHTDEST , $HSRCDC , $IXSRC , $IYSRC , $IWIDTHSRC , $IHEIGHTSRC , $IROP )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "StretchBlt" , "handle" , $HDESTDC , "int" , $IXDEST , "int" , $IYDEST , "int" , $IWIDTHDEST , "int" , $IHEIGHTDEST , "hwnd" , $HSRCDC , "int" , $IXSRC , "int" , $IYSRC , "int" , $IWIDTHSRC , "int" , $IHEIGHTSRC , "dword" , $IROP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STRETCHDIBITS ( $HDESTDC , $IXDEST , $IYDEST , $IWIDTHDEST , $IHEIGHTDEST , $IXSRC , $IYSRC , $IWIDTHSRC , $IHEIGHTSRC , $TBITMAPINFO , $IUSAGE , $PBITS , $IROP )
	Local $ACALL = DllCall ( "gdi32.dll" , "int" , "StretchDIBits" , "handle" , $HDESTDC , "int" , $IXDEST , "int" , $IYDEST , "int" , $IWIDTHDEST , "int" , $IHEIGHTDEST , "int" , $IXSRC , "int" , $IYSRC , "int" , $IWIDTHSRC , "int" , $IHEIGHTSRC , "struct*" , $PBITS , "struct*" , $TBITMAPINFO , "uint" , $IUSAGE , "dword" , $IROP )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then Return SetError ( @error + 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STROKEANDFILLPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "StrokeAndFillPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_STROKEPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "StrokePath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SUBTRACTRECT ( ByRef $TRECT1 , ByRef $TRECT2 )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SubtractRect" , "struct*" , $TRECT , "struct*" , $TRECT1 , "struct*" , $TRECT2 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_TABBEDTEXTOUT ( $HDC , $IX , $IY , $STEXT , $ATAB = 0 , $ISTART = 0 , $IEND = + 4294967295 , $IORIGIN = 0 )
	Local $ITAB , $ICOUNT
	If Not IsArray ( $ATAB ) Then
		If $ATAB Then
			$ITAB = $ATAB
			Dim $ATAB [ 1 ] = [ $ITAB ]
			$ISTART = 0
			$IEND = 0
			$ICOUNT = 1
		Else
			$ICOUNT = 0
		EndIf
	Else
		$ICOUNT = 1
	EndIf
	Local $TTAB = 0
	If $ICOUNT Then
		If __CHECKERRORARRAYBOUNDS ( $ATAB , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
		$ICOUNT = $IEND - $ISTART + 1
		$TTAB = DllStructCreate ( "uint[" & $ICOUNT & "]" )
		$ITAB = 1
		For $I = $ISTART To $IEND
			DllStructSetData ( $TTAB , 1 , $ATAB [ $I ] , $ITAB )
			$ITAB += 1
		Next
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "long" , "TabbedTextOutW" , "handle" , $HDC , "int" , $IX , "int" , $IY , "wstr" , $STEXT , "int" , StringLen ( $STEXT ) , "int" , $ICOUNT , "struct*" , $TTAB , "int" , $IORIGIN )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	$__G_VEXT = _WINAPI_CREATESIZE ( _WINAPI_LOWORD ( $ACALL [ 0 ] ) , _WINAPI_HIWORD ( $ACALL [ 0 ] ) )
	Return 1
EndFunc
Func _WINAPI_TEXTOUT ( $HDC , $IX , $IY , $STEXT )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "TextOutW" , "handle" , $HDC , "int" , $IX , "int" , $IY , "wstr" , $STEXT , "int" , StringLen ( $STEXT ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_TRANSPARENTBLT ( $HDESTDC , $IXDEST , $IYDEST , $IWIDTHDEST , $IHEIGHTDEST , $HSRCDC , $IXSRC , $IYSRC , $IWIDTHSRC , $IHEIGHTSRC , $IRGB )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "GdiTransparentBlt" , "handle" , $HDESTDC , "int" , $IXDEST , "int" , $IYDEST , "int" , $IWIDTHDEST , "int" , $IHEIGHTDEST , "hwnd" , $HSRCDC , "int" , $IXSRC , "int" , $IYSRC , "int" , $IWIDTHSRC , "int" , $IHEIGHTSRC , "dword" , __RGB ( $IRGB ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNIONRECT ( ByRef $TRECT1 , ByRef $TRECT2 )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnionRect" , "struct*" , $TRECT , "struct*" , $TRECT1 , "struct*" , $TRECT2 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , 0 , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_VALIDATERECT ( $HWND , $TRECT = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ValidateRect" , "hwnd" , $HWND , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_VALIDATERGN ( $HWND , $HRGN = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ValidateRgn" , "hwnd" , $HWND , "handle" , $HRGN )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WIDENPATH ( $HDC )
	Local $ACALL = DllCall ( "gdi32.dll" , "bool" , "WidenPath" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WINDOWFROMDC ( $HDC )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "WindowFromDC" , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __ENUMDISPLAYMONITORSPROC ( $HMONITOR , $HDC , $PRECT , $LPARAM )
	#forceref $hDC, $lParam
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = $HMONITOR
	If Not $PRECT Then
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] = 0
	Else
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] = DllStructCreate ( $TAGRECT )
		If Not _WINAPI_MOVEMEMORY ( DllStructGetPtr ( $__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] ) , $PRECT , 16 ) Then Return 0
	EndIf
	Return 1
EndFunc
Func __ENUMFONTFAMILIESPROC ( $PELFEX , $PNTMEX , $IFONTTYPE , $PPATTERN )
	Local $TELFEX = DllStructCreate ( $TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]" , $PELFEX )
	Local $TNTMEX = DllStructCreate ( $TAGNEWTEXTMETRICEX , $PNTMEX )
	Local $TPATTERN = DllStructCreate ( "uint;uint;ptr" , $PPATTERN )
	If $IFONTTYPE And Not BitAND ( $IFONTTYPE , DllStructGetData ( $TPATTERN , 1 ) ) Then
		Return 1
	EndIf
	If DllStructGetData ( $TPATTERN , 3 ) Then
		Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathMatchSpecW" , "ptr" , DllStructGetPtr ( $TELFEX , 14 ) , "ptr" , DllStructGetData ( $TPATTERN , 3 ) )
		If Not @error Then
			If DllStructGetData ( $TPATTERN , 2 ) Then
				If $ACALL [ 0 ] Then
					Return 1
				Else
				EndIf
			Else
				If $ACALL [ 0 ] Then
				Else
					Return 1
				EndIf
			EndIf
		EndIf
	EndIf
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TELFEX , 14 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( $TELFEX , 16 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 2 ] = DllStructGetData ( $TELFEX , 15 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 3 ] = DllStructGetData ( $TELFEX , 17 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 4 ] = $IFONTTYPE
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 5 ] = DllStructGetData ( $TNTMEX , 19 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 6 ] = DllStructGetData ( $TNTMEX , 20 )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 7 ] = DllStructGetData ( $TNTMEX , 21 )
	Return 1
EndFunc
Func __ENUMFONTSTYLESPROC ( $PELFEX , $PNTMEX , $IFONTTYPE , $PFN )
	#forceref $iFontType
	Local $TELFEX = DllStructCreate ( $TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]" , $PELFEX )
	Local $TNTMEX = DllStructCreate ( $TAGNEWTEXTMETRICEX , $PNTMEX )
	Local $TFN = DllStructCreate ( "dword;wchar[64]" , $PFN )
	If BitAND ( DllStructGetData ( $TNTMEX , "ntmFlags" ) , 97 ) = DllStructGetData ( $TFN , 1 ) Then
		DllStructSetData ( $TFN , 2 , DllStructGetData ( $TELFEX , "FullName" ) )
		Return 0
	Else
		Return 1
	EndIf
EndFunc
#EndRegion Internal Functions
Global Const $LINGUISTIC_IGNORECASE = 16
Global Const $LINGUISTIC_IGNOREDIACRITIC = 32
Global Const $NORM_IGNORECASE = 1
Global Const $NORM_IGNOREKANATYPE = 65536
Global Const $NORM_IGNORENONSPACE = 2
Global Const $NORM_IGNORESYMBOLS = 4
Global Const $NORM_IGNOREWIDTH = 131072
Global Const $NORM_LINGUISTIC_CASING = 134217728
Global Const $SORT_DIGITSASNUMBERS = 8
Global Const $SORT_STRINGSORT = 4096
Global Const $CSTR_LESS_THAN = 1
Global Const $CSTR_EQUAL = 2
Global Const $CSTR_GREATER_THAN = 3
Global Const $MUI_LANGUAGE_ID = 4
Global Const $MUI_LANGUAGE_NAME = 8
Global Const $DATE_AUTOLAYOUT = 64
Global Const $DATE_LONGDATE = 2
Global Const $DATE_LTRREADING = 16
Global Const $DATE_SHORTDATE = 1
Global Const $DATE_RTLREADING = 32
Global Const $DATE_USE_ALT_CALENDAR = 4
Global Const $DATE_YEARMONTH = 8
Global Const $GEO_NATION = 1
Global Const $GEO_LATITUDE = 2
Global Const $GEO_LONGITUDE = 3
Global Const $GEO_ISO2 = 4
Global Const $GEO_ISO3 = 5
Global Const $GEO_RFC1766 = 6
Global Const $GEO_LCID = 7
Global Const $GEO_FRIENDLYNAME = 8
Global Const $GEO_OFFICIALNAME = 9
Global Const $GEO_TIMEZONES = 10
Global Const $GEO_OFFICIALLANGUAGES = 11
Global Const $GEO_ISO_UN_NUMBER = 12
Global Const $GEO_PARENT = 13
Global Const $LOCALE_ILANGUAGE = 1
Global Const $LOCALE_SLANGUAGE = 2
Global Const $LOCALE_SENGLANGUAGE = 4097
Global Const $LOCALE_SABBREVLANGNAME = 3
Global Const $LOCALE_SNATIVELANGNAME = 4
Global Const $LOCALE_ICOUNTRY = 5
Global Const $LOCALE_SCOUNTRY = 6
Global Const $LOCALE_SENGCOUNTRY = 4098
Global Const $LOCALE_SABBREVCTRYNAME = 7
Global Const $LOCALE_SNATIVECTRYNAME = 8
Global Const $LOCALE_IDEFAULTLANGUAGE = 9
Global Const $LOCALE_IDEFAULTCOUNTRY = 10
Global Const $LOCALE_IDEFAULTCODEPAGE = 11
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 4100
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 4113
Global Const $LOCALE_SLIST = 12
Global Const $LOCALE_IMEASURE = 13
Global Const $LOCALE_SDECIMAL = 14
Global Const $LOCALE_STHOUSAND = 15
Global Const $LOCALE_SGROUPING = 16
Global Const $LOCALE_IDIGITS = 17
Global Const $LOCALE_ILZERO = 18
Global Const $LOCALE_INEGNUMBER = 4112
Global Const $LOCALE_SNATIVEDIGITS = 19
Global Const $LOCALE_SCURRENCY = 20
Global Const $LOCALE_SINTLSYMBOL = 21
Global Const $LOCALE_SMONDECIMALSEP = 22
Global Const $LOCALE_SMONTHOUSANDSEP = 23
Global Const $LOCALE_SMONGROUPING = 24
Global Const $LOCALE_ICURRDIGITS = 25
Global Const $LOCALE_IINTLCURRDIGITS = 26
Global Const $LOCALE_ICURRENCY = 27
Global Const $LOCALE_INEGCURR = 28
Global Const $LOCALE_SDATE = 29
Global Const $LOCALE_STIME = 30
Global Const $LOCALE_SSHORTDATE = 31
Global Const $LOCALE_SLONGDATE = 32
Global Const $LOCALE_STIMEFORMAT = 4099
Global Const $LOCALE_IDATE = 33
Global Const $LOCALE_ILDATE = 34
Global Const $LOCALE_ITIME = 35
Global Const $LOCALE_ITIMEMARKPOSN = 4101
Global Const $LOCALE_ICENTURY = 36
Global Const $LOCALE_ITLZERO = 37
Global Const $LOCALE_IDAYLZERO = 38
Global Const $LOCALE_IMONLZERO = 39
Global Const $LOCALE_S1159 = 40
Global Const $LOCALE_S2359 = 41
Global Const $LOCALE_ICALENDARTYPE = 4105
Global Const $LOCALE_IOPTIONALCALENDAR = 4107
Global Const $LOCALE_IFIRSTDAYOFWEEK = 4108
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 4109
Global Const $LOCALE_SDAYNAME1 = 42
Global Const $LOCALE_SDAYNAME2 = 43
Global Const $LOCALE_SDAYNAME3 = 44
Global Const $LOCALE_SDAYNAME4 = 45
Global Const $LOCALE_SDAYNAME5 = 46
Global Const $LOCALE_SDAYNAME6 = 47
Global Const $LOCALE_SDAYNAME7 = 48
Global Const $LOCALE_SABBREVDAYNAME1 = 49
Global Const $LOCALE_SABBREVDAYNAME2 = 50
Global Const $LOCALE_SABBREVDAYNAME3 = 51
Global Const $LOCALE_SABBREVDAYNAME4 = 52
Global Const $LOCALE_SABBREVDAYNAME5 = 53
Global Const $LOCALE_SABBREVDAYNAME6 = 54
Global Const $LOCALE_SABBREVDAYNAME7 = 55
Global Const $LOCALE_SMONTHNAME1 = 56
Global Const $LOCALE_SMONTHNAME2 = 57
Global Const $LOCALE_SMONTHNAME3 = 58
Global Const $LOCALE_SMONTHNAME4 = 59
Global Const $LOCALE_SMONTHNAME5 = 60
Global Const $LOCALE_SMONTHNAME6 = 61
Global Const $LOCALE_SMONTHNAME7 = 62
Global Const $LOCALE_SMONTHNAME8 = 63
Global Const $LOCALE_SMONTHNAME9 = 64
Global Const $LOCALE_SMONTHNAME10 = 65
Global Const $LOCALE_SMONTHNAME11 = 66
Global Const $LOCALE_SMONTHNAME12 = 67
Global Const $LOCALE_SMONTHNAME13 = 4110
Global Const $LOCALE_SABBREVMONTHNAME1 = 68
Global Const $LOCALE_SABBREVMONTHNAME2 = 69
Global Const $LOCALE_SABBREVMONTHNAME3 = 70
Global Const $LOCALE_SABBREVMONTHNAME4 = 71
Global Const $LOCALE_SABBREVMONTHNAME5 = 72
Global Const $LOCALE_SABBREVMONTHNAME6 = 73
Global Const $LOCALE_SABBREVMONTHNAME7 = 74
Global Const $LOCALE_SABBREVMONTHNAME8 = 75
Global Const $LOCALE_SABBREVMONTHNAME9 = 76
Global Const $LOCALE_SABBREVMONTHNAME10 = 77
Global Const $LOCALE_SABBREVMONTHNAME11 = 78
Global Const $LOCALE_SABBREVMONTHNAME12 = 79
Global Const $LOCALE_SABBREVMONTHNAME13 = 4111
Global Const $LOCALE_SPOSITIVESIGN = 80
Global Const $LOCALE_SNEGATIVESIGN = 81
Global Const $LOCALE_IPOSSIGNPOSN = 82
Global Const $LOCALE_INEGSIGNPOSN = 83
Global Const $LOCALE_IPOSSYMPRECEDES = 84
Global Const $LOCALE_IPOSSEPBYSPACE = 85
Global Const $LOCALE_INEGSYMPRECEDES = 86
Global Const $LOCALE_INEGSEPBYSPACE = 87
Global Const $LOCALE_FONTSIGNATURE = 88
Global Const $LOCALE_SISO639LANGNAME = 89
Global Const $LOCALE_SISO3166CTRYNAME = 90
Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 4114
Global Const $LOCALE_IPAPERSIZE = 4106
Global Const $LOCALE_SENGCURRNAME = 4103
Global Const $LOCALE_SNATIVECURRNAME = 4104
Global Const $LOCALE_SYEARMONTH = 4102
Global Const $LOCALE_SSORTNAME = 4115
Global Const $LOCALE_IDIGITSUBSTITUTION = 4116
Global Const $LOCALE_CUSTOM_DEFAULT = 3072
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 5120
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 4096
Global Const $LOCALE_INVARIANT = 127
Global Const $LOCALE_SYSTEM_DEFAULT = 2048
Global Const $LOCALE_USER_DEFAULT = 1024
Global Const $TIME_FORCE24HOURFORMAT = 8
Global Const $TIME_NOMINUTESORSECONDS = 1
Global Const $TIME_NOSECONDS = 2
Global Const $TIME_NOTIMEMARKER = 4
Global Const $LCID_INSTALLED = 1
Global Const $LCID_SUPPORTED = 2
Global Const $RT_ACCELERATOR = 9
Global Const $RT_ANICURSOR = 21
Global Const $RT_ANIICON = 22
Global Const $RT_BITMAP = 2
Global Const $RT_CURSOR = 1
Global Const $RT_DIALOG = 5
Global Const $RT_DLGINCLUDE = 17
Global Const $RT_FONT = 8
Global Const $RT_FONTDIR = 7
Global Const $RT_GROUP_CURSOR = 12
Global Const $RT_GROUP_ICON = 14
Global Const $RT_HTML = 23
Global Const $RT_ICON = 3
Global Const $RT_MANIFEST = 24
Global Const $RT_MENU = 4
Global Const $RT_MESSAGETABLE = 11
Global Const $RT_PLUGPLAY = 19
Global Const $RT_RCDATA = 10
Global Const $RT_STRING = 6
Global Const $RT_VERSION = 16
Global Const $RT_VXD = 20
Global Const $FILE_VER_GET_LOCALISED = 1
Global Const $FILE_VER_GET_NEUTRAL = 2
Global Const $FILE_VER_GET_PREFETCHED = 4
Global Const $OBM_TRTYPE = 32732
Global Const $OBM_LFARROWI = 32734
Global Const $OBM_RGARROWI = 32735
Global Const $OBM_DNARROWI = 32736
Global Const $OBM_UPARROWI = 32737
Global Const $OBM_COMBO = 32738
Global Const $OBM_MNARROW = 32739
Global Const $OBM_LFARROWD = 32740
Global Const $OBM_RGARROWD = 32741
Global Const $OBM_DNARROWD = 32742
Global Const $OBM_UPARROWD = 32743
Global Const $OBM_RESTORED = 32744
Global Const $OBM_ZOOMD = 32745
Global Const $OBM_REDUCED = 32746
Global Const $OBM_RESTORE = 32747
Global Const $OBM_ZOOM = 32748
Global Const $OBM_REDUCE = 32749
Global Const $OBM_LFARROW = 32750
Global Const $OBM_RGARROW = 32751
Global Const $OBM_DNARROW = 32752
Global Const $OBM_UPARROW = 32753
Global Const $OBM_CLOSE = 32754
Global Const $OBM_OLD_RESTORE = 32755
Global Const $OBM_OLD_ZOOM = 32756
Global Const $OBM_OLD_REDUCE = 32757
Global Const $OBM_BTNCORNERS = 32758
Global Const $OBM_CHECKBOXES = 32759
Global Const $OBM_CHECK = 32760
Global Const $OBM_BTSIZE = 32761
Global Const $OBM_OLD_LFARROW = 32762
Global Const $OBM_OLD_RGARROW = 32763
Global Const $OBM_OLD_DNARROW = 32764
Global Const $OBM_OLD_UPARROW = 32765
Global Const $OBM_SIZE = 32766
Global Const $OBM_OLD_CLOSE = 32767
Global Const $OIC_SAMPLE = 32512
Global Const $OIC_HAND = 32513
Global Const $OIC_QUES = 32514
Global Const $OIC_BANG = 32515
Global Const $OIC_NOTE = 32516
Global Const $OIC_WINLOGO = 32517
Global Const $OIC_WARNING = $OIC_BANG
Global Const $OIC_ERROR = $OIC_HAND
Global Const $OIC_INFORMATION = $OIC_NOTE
Global Const $DONT_RESOLVE_DLL_REFERENCES = 1
Global Const $LOAD_LIBRARY_AS_DATAFILE = 2
Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 8
Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 16
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 64
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 32
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 512
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 4096
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 256
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 2048
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 1024
Global Const $OCR_NORMAL = 32512
Global Const $OCR_IBEAM = 32513
Global Const $OCR_WAIT = 32514
Global Const $OCR_CROSS = 32515
Global Const $OCR_UP = 32516
Global Const $OCR_SIZE = 32640
Global Const $OCR_ICON = 32641
Global Const $OCR_SIZENWSE = 32642
Global Const $OCR_SIZENESW = 32643
Global Const $OCR_SIZEWE = 32644
Global Const $OCR_SIZENS = 32645
Global Const $OCR_SIZEALL = 32646
Global Const $OCR_ICOCUR = 32647
Global Const $OCR_NO = 32648
Global Const $OCR_HAND = 32649
Global Const $OCR_APPSTARTING = 32650
Global Const $OCR_HELP = 32651
Global Const $VS_FF_DEBUG = 1
Global Const $VS_FF_INFOINFERRED = 16
Global Const $VS_FF_PATCHED = 4
Global Const $VS_FF_PRERELEASE = 2
Global Const $VS_FF_PRIVATEBUILD = 8
Global Const $VS_FF_SPECIALBUILD = 32
Global Const $VOS_DOS = 65536
Global Const $VOS_NT = 262144
Global Const $VOS__WINDOWS16 = 1
Global Const $VOS__WINDOWS32 = 4
Global Const $VOS_OS216 = 131072
Global Const $VOS_OS232 = 196608
Global Const $VOS__PM16 = 2
Global Const $VOS__PM32 = 3
Global Const $VOS_UNKNOWN = 0
Global Const $VOS_DOS_WINDOWS16 = 65537
Global Const $VOS_DOS_WINDOWS32 = 65540
Global Const $VOS_NT_WINDOWS32 = 262148
Global Const $VOS_OS216_PM16 = 131074
Global Const $VOS_OS232_PM32 = 196611
Global Const $VFT_APP = 1
Global Const $VFT_DLL = 2
Global Const $VFT_DRV = 3
Global Const $VFT_FONT = 4
Global Const $VFT_STATIC_LIB = 7
Global Const $VFT_UNKNOWN = 0
Global Const $VFT_VXD = 5
Global Const $VFT2_DRV_COMM = 10
Global Const $VFT2_DRV_DISPLAY = 4
Global Const $VFT2_DRV_INSTALLABLE = 8
Global Const $VFT2_DRV_KEYBOARD = 2
Global Const $VFT2_DRV_LANGUAGE = 3
Global Const $VFT2_DRV_MOUSE = 5
Global Const $VFT2_DRV_NETWORK = 6
Global Const $VFT2_DRV_PRINTER = 1
Global Const $VFT2_DRV_SOUND = 9
Global Const $VFT2_DRV_SYSTEM = 7
Global Const $VFT2_DRV_VERSIONED_PRINTER = 12
Global Const $VFT2_UNKNOWN = 0
Global Const $VFT2_FONT_RASTER = 1
Global Const $VFT2_FONT_TRUETYPE = 3
Global Const $VFT2_FONT_VECTOR = 2
#Region Global Variables and Constants
Global $__G_VVAL
Global Const $TAGVS_FIXEDFILEINFO = "dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_BEGINUPDATERESOURCE ( $SFILEPATH , $BDELETE = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "BeginUpdateResourceW" , "wstr" , $SFILEPATH , "bool" , $BDELETE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CLIPCURSOR ( $TRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ClipCursor" , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COPYCURSOR ( $HCURSOR )
	Return _WINAPI_COPYICON ( $HCURSOR )
EndFunc
Func _WINAPI_CREATECARET ( $HWND , $HBITMAP , $IWIDTH = 0 , $IHEIGHT = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "CreateCaret" , "hwnd" , $HWND , "handle" , $HBITMAP , "int" , $IWIDTH , "int" , $IHEIGHT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DESTROYCARET ( )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DestroyCaret" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DESTROYCURSOR ( $HCURSOR )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DestroyCursor" , "handle" , $HCURSOR )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENDUPDATERESOURCE ( $HUPDATE , $BDISCARD = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EndUpdateResourceW" , "handle" , $HUPDATE , "bool" , $BDISCARD )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENUMRESOURCELANGUAGES ( $HMODULE , $STYPE , $SNAME )
	Local $ILIBRARY = 0 , $STYPEOFTYPE = "int" , $STYPEOFNAME = "int"
	If IsString ( $HMODULE ) Then
		If StringStripWS ( $HMODULE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
			$HMODULE = _WINAPI_LOADLIBRARYEX ( $HMODULE , BitOR ( $DONT_RESOLVE_DLL_REFERENCES , $LOAD_LIBRARY_AS_DATAFILE ) )
			If Not $HMODULE Then Return SetError ( 1 , 0 , 0 )
			$ILIBRARY = 1
		Else
			$HMODULE = 0
		EndIf
	EndIf
	If IsString ( $STYPE ) Then
		$STYPEOFTYPE = "wstr"
	EndIf
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $HENUMPROC = DllCallbackRegister ( "__EnumResLanguagesProc" , "bool" , "handle;ptr;ptr;word;long_ptr" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumResourceLanguagesW" , "handle" , $HMODULE , $STYPEOFTYPE , $STYPE , $STYPEOFNAME , $SNAME , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "long_ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	If $ILIBRARY Then
		_WINAPI_FREELIBRARY ( $HMODULE )
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMRESOURCENAMES ( $HMODULE , $STYPE )
	Local $ACALL , $HENUMPROC , $ILIBRARY = 0 , $STYPEOFTYPE = "int"
	If IsString ( $HMODULE ) Then
		If StringStripWS ( $HMODULE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
			$HMODULE = _WINAPI_LOADLIBRARYEX ( $HMODULE , BitOR ( $DONT_RESOLVE_DLL_REFERENCES , $LOAD_LIBRARY_AS_DATAFILE ) )
			If Not $HMODULE Then Return SetError ( 1 , 0 , 0 )
			$ILIBRARY = 1
		Else
			$HMODULE = 0
		EndIf
	EndIf
	If IsString ( $STYPE ) Then
		$STYPEOFTYPE = "wstr"
	EndIf
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	$HENUMPROC = DllCallbackRegister ( "__EnumResNamesProc" , "bool" , "handle;ptr;ptr;long_ptr" )
	$ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumResourceNamesW" , "handle" , $HMODULE , $STYPEOFTYPE , $STYPE , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "long_ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Or ( Not $__G_VENUM [ 0 ] ) Then
		$__G_VENUM = @error + 10
	EndIf
	If $ILIBRARY Then
		_WINAPI_FREELIBRARY ( $HMODULE )
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMRESOURCETYPES ( $HMODULE )
	Local $ILIBRARY = 0
	If IsString ( $HMODULE ) Then
		If StringStripWS ( $HMODULE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
			$HMODULE = _WINAPI_LOADLIBRARYEX ( $HMODULE , BitOR ( $DONT_RESOLVE_DLL_REFERENCES , $LOAD_LIBRARY_AS_DATAFILE ) )
			If Not $HMODULE Then Return SetError ( 1 , 0 , 0 )
			$ILIBRARY = 1
		Else
			$HMODULE = 0
		EndIf
	EndIf
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $HENUMPROC = DllCallbackRegister ( "__EnumResTypesProc" , "bool" , "handle;ptr;long_ptr" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumResourceTypesW" , "handle" , $HMODULE , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "long_ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Or ( Not $__G_VENUM [ 0 ] ) Then
		$__G_VENUM = @error + 10
	EndIf
	If $ILIBRARY Then
		_WINAPI_FREELIBRARY ( $HMODULE )
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_FINDRESOURCE ( $HINSTANCE , $STYPE , $SNAME )
	Local $STYPEOFTYPE = "int" , $STYPEOFNAME = "int"
	If IsString ( $STYPE ) Then
		$STYPEOFTYPE = "wstr"
	EndIf
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindResourceW" , "handle" , $HINSTANCE , $STYPEOFNAME , $SNAME , $STYPEOFTYPE , $STYPE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDRESOURCEEX ( $HINSTANCE , $STYPE , $SNAME , $ILANGUAGE )
	Local $STYPEOFTYPE = "int" , $STYPEOFNAME = "int"
	If IsString ( $STYPE ) Then
		$STYPEOFTYPE = "wstr"
	EndIf
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindResourceExW" , "handle" , $HINSTANCE , $STYPEOFTYPE , $STYPE , $STYPEOFNAME , $SNAME , "ushort" , $ILANGUAGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FREERESOURCE ( $HDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FreeResource" , "handle" , $HDATA )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCARETBLINKTIME ( )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetCaretBlinkTime" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCARETPOS ( )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetCaretPos" , "struct*" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Local $ARET [ 2 ]
	For $I = 0 To 1
		$ARET [ $I ] = DllStructGetData ( $TPOINT , $I + 1 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETCLIPCURSOR ( )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetClipCursor" , "struct*" , $TRECT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETCURSOR ( )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetCursor" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETFILEVERSIONINFO ( $SFILEPATH , ByRef $PBUFFER , $IFLAGS = 0 )
	Local $ACALL
	If _WINAPI_GETVERSION ( ) >= 6.0 Then
		$ACALL = DllCall ( "version.dll" , "dword" , "GetFileVersionInfoSizeExW" , "dword" , BitAND ( $IFLAGS , 3 ) , "wstr" , $SFILEPATH , "ptr" , 0 )
	Else
		$ACALL = DllCall ( "version.dll" , "dword" , "GetFileVersionInfoSizeW" , "wstr" , $SFILEPATH , "ptr" , 0 )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	$PBUFFER = __HEAPREALLOC ( $PBUFFER , $ACALL [ 0 ] , 1 )
	If @error Then Return SetError ( @error + 100 , @extended , 0 )
	Local $INBBYTE = $ACALL [ 0 ]
	If _WINAPI_GETVERSION ( ) >= 6.0 Then
		$ACALL = DllCall ( "version.dll" , "bool" , "GetFileVersionInfoExW" , "dword" , BitAND ( $IFLAGS , 7 ) , "wstr" , $SFILEPATH , "dword" , 0 , "dword" , $INBBYTE , "ptr" , $PBUFFER )
	Else
		$ACALL = DllCall ( "version.dll" , "bool" , "GetFileVersionInfoW" , "wstr" , $SFILEPATH , "dword" , 0 , "dword" , $INBBYTE , "ptr" , $PBUFFER )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $INBBYTE
EndFunc
Func _WINAPI_HIDECARET ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "HideCaret" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADBITMAP ( $HINSTANCE , $SBITMAP )
	Local $SBITMAPTYPE = "int"
	If IsString ( $SBITMAP ) Then $SBITMAPTYPE = "wstr"
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "LoadBitmapW" , "handle" , $HINSTANCE , $SBITMAPTYPE , $SBITMAP )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADCURSOR ( $HINSTANCE , $SNAME )
	Local $STYPEOFNAME = "int"
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "LoadCursorW" , "handle" , $HINSTANCE , $STYPEOFNAME , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADCURSORFROMFILE ( $SFILEPATH )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "LoadCursorFromFileW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADINDIRECTSTRING ( $SSTRIN )
	Local $ACALL = DllCall ( "shlwapi.dll" , "uint" , "SHLoadIndirectString" , "wstr" , $SSTRIN , "wstr" , "" , "uint" , 4096 , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_LOADSTRING ( $HINSTANCE , $ISTRINGID )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "LoadStringW" , "handle" , $HINSTANCE , "uint" , $ISTRINGID , "wstr" , "" , "int" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 3 ] )
EndFunc
Func _WINAPI_LOADLIBRARYEX ( $SFILENAME , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "LoadLibraryExW" , "wstr" , $SFILENAME , "ptr" , 0 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADRESOURCE ( $HINSTANCE , $HRESOURCE )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "LoadResource" , "handle" , $HINSTANCE , "handle" , $HRESOURCE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADSTRINGEX ( $HMODULE , $IID , $ILANGUAGE = $LOCALE_USER_DEFAULT )
	Local $ILIBRARY = 0
	If IsString ( $HMODULE ) Then
		If StringStripWS ( $HMODULE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
			$HMODULE = _WINAPI_LOADLIBRARYEX ( $HMODULE , BitOR ( $DONT_RESOLVE_DLL_REFERENCES , $LOAD_LIBRARY_AS_DATAFILE ) )
			If Not $HMODULE Then Return SetError ( @error + 20 , @extended , "" )
			$ILIBRARY = 1
		Else
			$HMODULE = 0
		EndIf
	EndIf
	Local $SRESULT = ""
	Local $PDATA = __RESLOAD ( $HMODULE , 6 , Floor ( $IID / 16 ) + 1 , $ILANGUAGE )
	If Not @error Then
		Local $IOFFSET = 0
		For $I = 0 To Mod ( $IID , 16 ) + 4294967295
			$IOFFSET += 2 * ( DllStructGetData ( DllStructCreate ( "ushort" , $PDATA + $IOFFSET ) , 1 ) + 1 )
		Next
		$SRESULT = DllStructGetData ( DllStructCreate ( "ushort;wchar[" & DllStructGetData ( DllStructCreate ( "ushort" , $PDATA + $IOFFSET ) , 1 ) & "]" , $PDATA + $IOFFSET ) , 2 )
		If @error Then $SRESULT = ""
	Else
		Return SetError ( 10 , 0 , "" )
	EndIf
	If $ILIBRARY Then
		_WINAPI_FREELIBRARY ( $HMODULE )
	EndIf
	Return SetError ( Number ( Not $SRESULT ) , 0 , $SRESULT )
EndFunc
Func _WINAPI_LOCKRESOURCE ( $HDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "LockResource" , "handle" , $HDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETCARETBLINKTIME ( $IDURATION )
	Local $IPREV = _WINAPI_GETCARETBLINKTIME ( )
	If Not $IPREV Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetCaretBlinkTime" , "uint" , $IDURATION )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $IPREV
EndFunc
Func _WINAPI_SETCARETPOS ( $IX , $IY )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "SetCaretPos" , "int" , $IX , "int" , $IY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETCURSOR ( $HCURSOR )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "SetCursor" , "handle" , $HCURSOR )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETSYSTEMCURSOR ( $HCURSOR , $IID , $BCOPY = False )
	If $BCOPY Then
		$HCURSOR = _WINAPI_COPYCURSOR ( $HCURSOR )
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetSystemCursor" , "handle" , $HCURSOR , "dword" , $IID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHOWCARET ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ShowCaret" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHOWCURSOR ( $BSHOW )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "ShowCursor" , "bool" , $BSHOW )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SIZEOFRESOURCE ( $HINSTANCE , $HRESOURCE )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "SizeofResource" , "handle" , $HINSTANCE , "handle" , $HRESOURCE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UPDATERESOURCE ( $HUPDATE , $STYPE , $SNAME , $ILANGUAGE , $PDATA , $ISIZE )
	Local $STYPEOFTYPE = "int" , $STYPEOFNAME = "int"
	If IsString ( $STYPE ) Then
		$STYPEOFTYPE = "wstr"
	EndIf
	If IsString ( $SNAME ) Then
		$STYPEOFNAME = "wstr"
	EndIf
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "UpdateResourceW" , "handle" , $HUPDATE , $STYPEOFTYPE , $STYPE , $STYPEOFNAME , $SNAME , "word" , $ILANGUAGE , "ptr" , $PDATA , "dword" , $ISIZE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_VERQUERYROOT ( $PDATA )
	Local $ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\" , "ptr*" , 0 , "uint*" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $ACALL [ 4 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TVFFI = DllStructCreate ( $TAGVS_FIXEDFILEINFO )
	If Not _WINAPI_MOVEMEMORY ( $TVFFI , $ACALL [ 3 ] , $ACALL [ 4 ] ) Then Return SetError ( @error + 20 , @extended , 0 )
	Return $TVFFI
EndFunc
Func _WINAPI_VERQUERYVALUE ( $PDATA , $SVALUES = "" )
	$SVALUES = StringRegExpReplace ( $SVALUES , "\A[\s\|]*|[\s\|]*\Z" , "" )
	If Not $SVALUES Then
		$SVALUES = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
	EndIf
	$SVALUES = StringSplit ( $SVALUES , "|" , $STR_NOCOUNT )
	Local $ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\VarFileInfo\Translation" , "ptr*" , 0 , "uint*" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $ACALL [ 4 ] Then Return SetError ( @error + 10 , 0 , 0 )
	Local $ILENGTH = Floor ( $ACALL [ 4 ] / 4 )
	Local $TLANG = DllStructCreate ( "dword[" & $ILENGTH & "]" , $ACALL [ 3 ] )
	If @error Then Return SetError ( @error + 20 , 0 , 0 )
	Local $SCP , $AINFO [ 101 ] [ UBound ( $SVALUES ) + 1 ] = [ [ 0 ] ]
	For $I = 1 To $ILENGTH
		__INC ( $AINFO )
		$AINFO [ $AINFO [ 0 ] [ 0 ] ] [ 0 ] = _WINAPI_LOWORD ( DllStructGetData ( $TLANG , 1 , $I ) )
		$SCP = Hex ( _WINAPI_MAKELONG ( _WINAPI_HIWORD ( DllStructGetData ( $TLANG , 1 , $I ) ) , _WINAPI_LOWORD ( DllStructGetData ( $TLANG , 1 , $I ) ) ) , 8 )
		For $J = 0 To UBound ( $SVALUES ) + 4294967295
			$ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\StringFileInfo\" & $SCP & "\" & $SVALUES [ $J ] , "ptr*" , 0 , "uint*" , 0 )
			If Not @error And $ACALL [ 0 ] And $ACALL [ 4 ] Then
				$AINFO [ $AINFO [ 0 ] [ 0 ] ] [ $J + 1 ] = DllStructGetData ( DllStructCreate ( "wchar[" & $ACALL [ 4 ] & "]" , $ACALL [ 3 ] ) , 1 )
			Else
				$AINFO [ $AINFO [ 0 ] [ 0 ] ] [ $J + 1 ] = ""
			EndIf
		Next
	Next
	__INC ( $AINFO , + 4294967295 )
	Return $AINFO
EndFunc
Func _WINAPI_VERQUERYVALUEEX ( $HMODULE , $SVALUES = "" , $ILANGUAGE = 1024 )
	$__G_VVAL = StringRegExpReplace ( $SVALUES , "\A[\s\|]*|[\s\|]*\Z" , "" )
	If Not $__G_VVAL Then
		$__G_VVAL = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
	EndIf
	$__G_VVAL = StringSplit ( $__G_VVAL , "|" )
	If Not IsArray ( $__G_VVAL ) Then Return SetError ( 1 , 0 , 0 )
	Local $ILIBRARY = 0
	If IsString ( $HMODULE ) Then
		If StringStripWS ( $HMODULE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
			$HMODULE = _WINAPI_LOADLIBRARYEX ( $HMODULE , BitOR ( $DONT_RESOLVE_DLL_REFERENCES , $LOAD_LIBRARY_AS_DATAFILE ) )
			If Not $HMODULE Then
				Return SetError ( @error + 10 , @extended , 0 )
			EndIf
			$ILIBRARY = 1
		Else
			$HMODULE = 0
		EndIf
	EndIf
	Dim $__G_VENUM [ 101 ] [ $__G_VVAL [ 0 ] + 1 ] = [ [ 0 ] ]
	Local $HENUMPROC = DllCallbackRegister ( "__EnumVerValuesProc" , "bool" , "ptr;ptr;ptr;word;long_ptr" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumResourceLanguagesW" , "handle" , $HMODULE , "int" , 16 , "int" , 1 , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "long_ptr" , $ILANGUAGE )
	Do
		If @error Then
			$__G_VENUM = @error + 20
		Else
			If Not $ACALL [ 0 ] Then
				Switch _WINAPI_GETLASTERROR ( )
				Case 0 , 15106
					ExitLoop
			Case Else
					$__G_VENUM = 20
				EndSwitch
			Else
				ExitLoop
			EndIf
		EndIf
	Until 1
	If $ILIBRARY Then
		_WINAPI_FREELIBRARY ( $HMODULE )
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If Not $__G_VENUM [ 0 ] [ 0 ] Then $__G_VENUM = 230
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __ENUMRESLANGUAGESPROC ( $HMODULE , $ITYPE , $INAME , $ILANGUAGE , $LPARAM )
	#forceref $hModule, $iType, $iName, $lParam
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] ] = $ILANGUAGE
	Return 1
EndFunc
Func __ENUMRESNAMESPROC ( $HMODULE , $ITYPE , $INAME , $LPARAM )
	#forceref $hModule, $iType, $lParam
	Local $ILENGTH = _WINAPI_STRLEN ( $INAME )
	__INC ( $__G_VENUM )
	If $ILENGTH Then
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = DllStructGetData ( DllStructCreate ( "wchar[" & ( $ILENGTH + 1 ) & "]" , $INAME ) , 1 )
	Else
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = Number ( $INAME )
	EndIf
	Return 1
EndFunc
Func __ENUMRESTYPESPROC ( $HMODULE , $ITYPE , $LPARAM )
	#forceref $hModule, $lParam
	Local $ILENGTH = _WINAPI_STRLEN ( $ITYPE )
	__INC ( $__G_VENUM )
	If $ILENGTH Then
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = DllStructGetData ( DllStructCreate ( "wchar[" & ( $ILENGTH + 1 ) & "]" , $ITYPE ) , 1 )
	Else
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = Number ( $ITYPE )
	EndIf
	Return 1
EndFunc
Func __ENUMVERVALUESPROC ( $HMODULE , $ITYPE , $INAME , $ILANGUAGE , $IDEFAULT )
	Local $ACALL , $IENUM = 1 , $IERROR = 0
	Switch $IDEFAULT
	Case + 4294967295
	Case 1024
		$ILANGUAGE = 1024
		$IENUM = 0
Case Else
		If $ILANGUAGE <> $IDEFAULT Then
			Return 1
		EndIf
		$IENUM = 0
	EndSwitch
	Do
		Local $PDATA = __RESLOAD ( $HMODULE , $ITYPE , $INAME , $ILANGUAGE )
		If @error Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\VarFileInfo\Translation" , "ptr*" , 0 , "uint*" , 0 )
		If @error Or Not $ACALL [ 0 ] Or Not $ACALL [ 4 ] Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
		Local $TDATA = DllStructCreate ( "ushort;ushort" , $ACALL [ 3 ] )
		If @error Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
	Until 1
	If Not $IERROR Then
		__INC ( $__G_VENUM )
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TDATA , 1 )
		Local $SCP = Hex ( _WINAPI_MAKELONG ( DllStructGetData ( $TDATA , 2 ) , DllStructGetData ( $TDATA , 1 ) ) , 8 )
		For $I = 1 To $__G_VVAL [ 0 ]
			$ACALL = DllCall ( "version.dll" , "bool" , "VerQueryValueW" , "ptr" , $PDATA , "wstr" , "\StringFileInfo\" & $SCP & "\" & $__G_VVAL [ $I ] , "ptr*" , 0 , "uint*" , 0 )
			If Not @error And $ACALL [ 0 ] And $ACALL [ 4 ] Then
				$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ $I ] = DllStructGetData ( DllStructCreate ( "wchar[" & $ACALL [ 4 ] & "]" , $ACALL [ 3 ] ) , 1 )
			Else
				$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ $I ] = ""
			EndIf
		Next
	Else
		$__G_VENUM = @error + 40
	EndIf
	If $__G_VENUM Then Return SetError ( $IERROR , 0 , 0 )
	Return $IENUM
EndFunc
Func __RESLOAD ( $HINSTANCE , $STYPE , $SNAME , $ILANGUAGE )
	Local $HINFO = _WINAPI_FINDRESOURCEEX ( $HINSTANCE , $STYPE , $SNAME , $ILANGUAGE )
	If Not $HINFO Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ISIZE = _WINAPI_SIZEOFRESOURCE ( $HINSTANCE , $HINFO )
	If Not $ISIZE Then Return SetError ( @error + 20 , @extended , 0 )
	Local $HDATA = _WINAPI_LOADRESOURCE ( $HINSTANCE , $HINFO )
	If Not $HDATA Then Return SetError ( @error + 30 , @extended , 0 )
	Local $PDATA = _WINAPI_LOCKRESOURCE ( $HDATA )
	If Not $PDATA Then Return SetError ( @error + 40 , @extended , 0 )
	Return SetExtended ( $ISIZE , $PDATA )
EndFunc
#EndRegion Internal Functions
Global Const $__LISTVIEWCONSTANT_SORTINFOSIZE = 11
Global $__G_ALISTVIEWSORTINFO [ 1 ] [ $__LISTVIEWCONSTANT_SORTINFOSIZE ]
Global $__G_TLISTVIEWBUFFER , $__G_TLISTVIEWBUFFERANSI
Global $__G_TLISTVIEWITEM = DllStructCreate ( $TAGLVITEM )
Global Const $__LISTVIEWCONSTANT_CLASSNAME = "SysListView32"
Global Const $__LISTVIEWCONSTANT_WM_SETREDRAW = 11
Global Const $__LISTVIEWCONSTANT_WM_SETFONT = 48
Global Const $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__LISTVIEWCONSTANT_ILD_TRANSPARENT = 1
Global Const $__LISTVIEWCONSTANT_ILD_BLEND25 = 2
Global Const $__LISTVIEWCONSTANT_ILD_BLEND50 = 4
Global Const $__LISTVIEWCONSTANT_ILD_MASK = 16
Global Const $__LISTVIEWCONSTANT_VK_DOWN = 40
Global Const $__LISTVIEWCONSTANT_VK_END = 35
Global Const $__LISTVIEWCONSTANT_VK_HOME = 36
Global Const $__LISTVIEWCONSTANT_VK_LEFT = 37
Global Const $__LISTVIEWCONSTANT_VK_NEXT = 34
Global Const $__LISTVIEWCONSTANT_VK_PRIOR = 33
Global Const $__LISTVIEWCONSTANT_VK_RIGHT = 39
Global Const $__LISTVIEWCONSTANT_VK_UP = 38
Global Const $TAGLVBKIMAGE = "ulong Flags;hwnd hBmp;ptr Image;uint ImageMax;int XOffPercent;int YOffPercent"
Global Const $TAGLVCOLUMN = "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal"
Global Const $TAGLVGROUP = "uint Size;uint Mask;ptr Header;int HeaderMax;ptr Footer;int FooterMax;int GroupID;uint StateMask;uint State;uint Align;" & "ptr  pszSubtitle;uint cchSubtitle;ptr pszTask;uint cchTask;ptr pszDescriptionTop;uint cchDescriptionTop;ptr pszDescriptionBottom;" & "uint cchDescriptionBottom;int iTitleImage;int iExtendedImage;int iFirstItem;uint cItems;ptr pszSubsetTitle;uint cchSubsetTitle"
Global Const $TAGLVINSERTMARK = "uint Size;dword Flags;int Item;dword Reserved"
Global Const $TAGLVSETINFOTIP = "uint Size;dword Flags;ptr Text;int Item;int SubItem"
Func _GUICTRLLISTVIEW_ADDARRAY ( $HWND , ByRef $AITEMS )
	Local $TBUFFER , $IMSG , $IMSGSET
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_INSERTITEMW
		$IMSGSET = $LVM_SETITEMW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_INSERTITEMA
		$IMSGSET = $LVM_SETITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_TEXT )
	Local $ILASTITEM = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND )
	_GUICTRLLISTVIEW_BEGINUPDATE ( $HWND )
	Local $PSENDMSG = __GUICTRL_SENDMSG_INIT ( $HWND , $IMSG , 0 , $TITEM , $TBUFFER , False , 6 )
	For $II = 0 To UBound ( $AITEMS ) + 4294967295
		DllStructSetData ( $TITEM , "Item" , $II + $ILASTITEM )
		DllStructSetData ( $TITEM , "SubItem" , 0 )
		DllStructSetData ( $TBUFFER , 1 , $AITEMS [ $II ] [ 0 ] )
		$PSENDMSG ( $HWND , $IMSG , 0 , $TITEM , $TBUFFER , False , 6 )
		For $IJ = 1 To UBound ( $AITEMS , $UBOUND_COLUMNS ) + 4294967295
			DllStructSetData ( $TITEM , "SubItem" , $IJ )
			DllStructSetData ( $TBUFFER , 1 , $AITEMS [ $II ] [ $IJ ] )
			$PSENDMSG ( $HWND , $IMSGSET , 0 , $TITEM , $TBUFFER , False , 6 )
		Next
	Next
	_GUICTRLLISTVIEW_ENDUPDATE ( $HWND )
EndFunc
Func _GUICTRLLISTVIEW_ADDCOLUMN ( $HWND , $STEXT , $IWIDTH = 50 , $IALIGN = + 4294967295 , $IIMAGE = + 4294967295 , $BONRIGHT = False )
	Return _GUICTRLLISTVIEW_INSERTCOLUMN ( $HWND , _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND ) , $STEXT , $IWIDTH , $IALIGN , $IIMAGE , $BONRIGHT )
EndFunc
Func _GUICTRLLISTVIEW_ADDITEM ( $HWND , $STEXT , $IIMAGE = + 4294967295 , $IPARAM = 0 )
	Return _GUICTRLLISTVIEW_INSERTITEM ( $HWND , $STEXT , + 4294967295 , $IIMAGE , $IPARAM )
EndFunc
Func _GUICTRLLISTVIEW_ADDSUBITEM ( $HWND , $IINDEX , $STEXT , $ISUBITEM , $IIMAGE = + 4294967295 )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_SETITEMW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_SETITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	Local $IMASK = $LVIF_TEXT
	If $IIMAGE <> + 4294967295 Then $IMASK = BitOR ( $IMASK , $LVIF_IMAGE )
	DllStructSetData ( $TBUFFER , 1 , $STEXT )
	DllStructSetData ( $TITEM , "Mask" , $IMASK )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	DllStructSetData ( $TITEM , "Image" , $IIMAGE )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , $TBUFFER , False , 6 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_APPROXIMATEVIEWHEIGHT ( $HWND , $ICOUNT = + 4294967295 , $ICX = + 4294967295 , $ICY = + 4294967295 )
	If IsHWnd ( $HWND ) Then
		Return BitShift ( ( _SENDMESSAGE ( $HWND , $LVM_APPROXIMATEVIEWRECT , $ICOUNT , _WINAPI_MAKELONG ( $ICX , $ICY ) ) ) , 16 )
	Else
		Return BitShift ( ( GUICtrlSendMsg ( $HWND , $LVM_APPROXIMATEVIEWRECT , $ICOUNT , _WINAPI_MAKELONG ( $ICX , $ICY ) ) ) , 16 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_APPROXIMATEVIEWRECT ( $HWND , $ICOUNT = + 4294967295 , $ICX = + 4294967295 , $ICY = + 4294967295 )
	Local $IVIEW
	If IsHWnd ( $HWND ) Then
		$IVIEW = _SENDMESSAGE ( $HWND , $LVM_APPROXIMATEVIEWRECT , $ICOUNT , _WINAPI_MAKELONG ( $ICX , $ICY ) )
	Else
		$IVIEW = GUICtrlSendMsg ( $HWND , $LVM_APPROXIMATEVIEWRECT , $ICOUNT , _WINAPI_MAKELONG ( $ICX , $ICY ) )
	EndIf
	Local $AVIEW [ 2 ]
	$AVIEW [ 0 ] = BitAND ( $IVIEW , 65535 )
	$AVIEW [ 1 ] = BitShift ( $IVIEW , 16 )
	Return $AVIEW
EndFunc
Func _GUICTRLLISTVIEW_APPROXIMATEVIEWWIDTH ( $HWND , $ICOUNT = + 4294967295 , $ICX = + 4294967295 , $ICY = + 4294967295 )
	If IsHWnd ( $HWND ) Then
		Return BitAND ( ( _SENDMESSAGE ( $HWND , $LVM_APPROXIMATEVIEWRECT , $ICOUNT , _WINAPI_MAKELONG ( $ICX , $ICY ) ) ) , 65535 )
	Else
		Return BitAND ( ( GUICtrlSendMsg ( $HWND , $LVM_APPROXIMATEVIEWRECT , $ICOUNT , _WINAPI_MAKELONG ( $ICX , $ICY ) ) ) , 65535 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_ARRANGE ( $HWND , $IARRANGE = 0 )
	Local $AARRANGE [ 4 ] = [ $LVA_DEFAULT , $LVA_ALIGNLEFT , $LVA_ALIGNTOP , $LVA_SNAPTOGRID ]
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_ARRANGE , $AARRANGE [ $IARRANGE ] ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_ARRANGE , $AARRANGE [ $IARRANGE ] , 0 ) <> 0
	EndIf
EndFunc
Func __GUICTRLLISTVIEW_ARRAYDELETE ( ByRef $AVARRAY , $IELEMENT )
	If Not IsArray ( $AVARRAY ) Then Return SetError ( 1 , 0 , "" )
	Local $IUPPER = UBound ( $AVARRAY )
	If $IUPPER = 1 Then
		SetError ( 2 )
		Return ""
	EndIf
	Local $AVNEWARRAY [ $IUPPER + 4294967295 ] [ $__LISTVIEWCONSTANT_SORTINFOSIZE ]
	$AVNEWARRAY [ 0 ] [ 0 ] = $AVARRAY [ 0 ] [ 0 ]
	If $IELEMENT < 0 Then
		$IELEMENT = 0
	EndIf
	If $IELEMENT > ( $IUPPER + 4294967295 ) Then
		$IELEMENT = ( $IUPPER + 4294967295 )
	EndIf
	If $IELEMENT > 0 Then
		For $ICNTR = 0 To $IELEMENT + 4294967295
			For $X = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE + 4294967295
				$AVNEWARRAY [ $ICNTR ] [ $X ] = $AVARRAY [ $ICNTR ] [ $X ]
			Next
		Next
	EndIf
	If $IELEMENT < ( $IUPPER + 4294967295 ) Then
		For $ICNTR = ( $IELEMENT + 1 ) To ( $IUPPER + 4294967295 )
			For $X = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE + 4294967295
				$AVNEWARRAY [ $ICNTR + 4294967295 ] [ $X ] = $AVARRAY [ $ICNTR ] [ $X ]
			Next
		Next
	EndIf
	$AVARRAY = $AVNEWARRAY
	SetError ( 0 )
	Return 1
EndFunc
Func _GUICTRLLISTVIEW_BEGINUPDATE ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $__LISTVIEWCONSTANT_WM_SETREDRAW , False ) = 0
	Else
		Return GUICtrlSendMsg ( $HWND , $__LISTVIEWCONSTANT_WM_SETREDRAW , False , 0 ) = 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_CANCELEDITLABEL ( $HWND )
	If IsHWnd ( $HWND ) Then
		_SENDMESSAGE ( $HWND , $LVM_CANCELEDITLABEL )
	Else
		GUICtrlSendMsg ( $HWND , $LVM_CANCELEDITLABEL , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_CLICKITEM ( $HWND , $IINDEX , $SBUTTON = "left" , $BMOVE = False , $ICLICKS = 1 , $ISPEED = 1 )
	_GUICTRLLISTVIEW_ENSUREVISIBLE ( $HWND , $IINDEX , False )
	Local $TRECT = _GUICTRLLISTVIEW_GETITEMRECTEX ( $HWND , $IINDEX , $LVIR_LABEL )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Local $TPOINT = _WINAPI_POINTFROMRECT ( $TRECT , True )
	$TPOINT = _WINAPI_CLIENTTOSCREEN ( $HWND , $TPOINT )
	Local $IX , $IY
	_WINAPI_GETXYFROMPOINT ( $TPOINT , $IX , $IY )
	Local $IXPLUS = DllStructGetData ( $TRECT , "Left" ) < 0 ? DllStructGetData ( $TRECT , "Left" ) * + 4294967295 : 0
	Local $IMODE = Opt ( "MouseCoordMode" , 1 )
	If Not $BMOVE Then
		Local $APOS = MouseGetPos ( )
		_WINAPI_SHOWCURSOR ( False )
		MouseClick ( $SBUTTON , $IX + $IXPLUS , $IY , $ICLICKS , $ISPEED )
		MouseMove ( $APOS [ 0 ] , $APOS [ 1 ] , 0 )
		_WINAPI_SHOWCURSOR ( True )
	Else
		MouseClick ( $SBUTTON , $IX + $IXPLUS , $IY , $ICLICKS , $ISPEED )
	EndIf
	Opt ( "MouseCoordMode" , $IMODE )
EndFunc
Func _GUICTRLLISTVIEW_COPYITEMS ( $HWND_SOURCE , $HWND_DESTINATION , $BDELFLAG = False )
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND_SOURCE ) Then
		$IMSG = $LVM_GETITEMW
	Else
		$IMSG = $LVM_GETITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	Local $A_INDICES , $IINDEX
	Local $ICOLS = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND_SOURCE )
	Local $IITEMS = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND_SOURCE )
	_GUICTRLLISTVIEW_BEGINUPDATE ( $HWND_SOURCE )
	_GUICTRLLISTVIEW_BEGINUPDATE ( $HWND_DESTINATION )
	If BitAND ( _GUICTRLLISTVIEW_GETEXTENDEDLISTVIEWSTYLE ( $HWND_SOURCE ) , $LVS_EX_CHECKBOXES ) == $LVS_EX_CHECKBOXES Then
		For $I = 0 To $IITEMS + 4294967295
			If ( _GUICTRLLISTVIEW_GETITEMCHECKED ( $HWND_SOURCE , $I ) ) Then
				If IsArray ( $A_INDICES ) Then
					ReDim $A_INDICES [ UBound ( $A_INDICES ) + 1 ]
				Else
					Local $A_INDICES [ 2 ]
				EndIf
				$A_INDICES [ 0 ] = $A_INDICES [ 0 ] + 1
				$A_INDICES [ UBound ( $A_INDICES ) + 4294967295 ] = $I
			EndIf
		Next
		If ( IsArray ( $A_INDICES ) ) Then
			For $I = 1 To $A_INDICES [ 0 ]
				DllStructSetData ( $TITEM , "Mask" , BitOR ( $LVIF_GROUPID , $LVIF_IMAGE , $LVIF_INDENT , $LVIF_PARAM , $LVIF_STATE ) )
				DllStructSetData ( $TITEM , "Item" , $A_INDICES [ $I ] )
				DllStructSetData ( $TITEM , "SubItem" , 0 )
				DllStructSetData ( $TITEM , "StateMask" , + 4294967295 )
				__GUICTRL_SENDMSG ( $HWND_SOURCE , $IMSG , 0 , $TITEM , 0 , True , + 4294967295 )
				$IINDEX = _GUICTRLLISTVIEW_ADDITEM ( $HWND_DESTINATION , _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND_SOURCE , $A_INDICES [ $I ] , 0 ) , DllStructGetData ( $TITEM , "Image" ) )
				_GUICTRLLISTVIEW_SETITEMCHECKED ( $HWND_DESTINATION , $IINDEX )
				For $X = 1 To $ICOLS + 4294967295
					DllStructSetData ( $TITEM , "Item" , $A_INDICES [ $I ] )
					DllStructSetData ( $TITEM , "SubItem" , $X )
					__GUICTRL_SENDMSG ( $HWND_SOURCE , $IMSG , 0 , $TITEM , 0 , True , + 4294967295 )
					_GUICTRLLISTVIEW_ADDSUBITEM ( $HWND_DESTINATION , $IINDEX , _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND_SOURCE , $A_INDICES [ $I ] , $X ) , $X , DllStructGetData ( $TITEM , "Image" ) )
				Next
			Next
			If $BDELFLAG Then
				For $I = $A_INDICES [ 0 ] To 1 Step + 4294967295
					_GUICTRLLISTVIEW_DELETEITEM ( $HWND_SOURCE , $A_INDICES [ $I ] )
				Next
			EndIf
		EndIf
	EndIf
	If ( _GUICTRLLISTVIEW_GETSELECTEDCOUNT ( $HWND_SOURCE ) ) Then
		$A_INDICES = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HWND_SOURCE , 1 )
		For $I = 1 To $A_INDICES [ 0 ]
			DllStructSetData ( $TITEM , "Mask" , BitOR ( $LVIF_GROUPID , $LVIF_IMAGE , $LVIF_INDENT , $LVIF_PARAM , $LVIF_STATE ) )
			DllStructSetData ( $TITEM , "Item" , $A_INDICES [ $I ] )
			DllStructSetData ( $TITEM , "SubItem" , 0 )
			DllStructSetData ( $TITEM , "StateMask" , + 4294967295 )
			__GUICTRL_SENDMSG ( $HWND_SOURCE , $IMSG , 0 , $TITEM , 0 , True , + 4294967295 )
			$IINDEX = _GUICTRLLISTVIEW_ADDITEM ( $HWND_DESTINATION , _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND_SOURCE , $A_INDICES [ $I ] , 0 ) , DllStructGetData ( $TITEM , "Image" ) )
			For $X = 1 To $ICOLS + 4294967295
				DllStructSetData ( $TITEM , "Item" , $A_INDICES [ $I ] )
				DllStructSetData ( $TITEM , "SubItem" , $X )
				__GUICTRL_SENDMSG ( $HWND_SOURCE , $IMSG , 0 , $TITEM , 0 , True , + 4294967295 )
				_GUICTRLLISTVIEW_ADDSUBITEM ( $HWND_DESTINATION , $IINDEX , _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND_SOURCE , $A_INDICES [ $I ] , $X ) , $X , DllStructGetData ( $TITEM , "Image" ) )
			Next
		Next
		_GUICTRLLISTVIEW_SETITEMSELECTED ( $HWND_SOURCE , + 4294967295 , False )
		If $BDELFLAG Then
			For $I = $A_INDICES [ 0 ] To 1 Step + 4294967295
				_GUICTRLLISTVIEW_DELETEITEM ( $HWND_SOURCE , $A_INDICES [ $I ] )
			Next
		EndIf
	EndIf
	_GUICTRLLISTVIEW_ENDUPDATE ( $HWND_SOURCE )
	_GUICTRLLISTVIEW_ENDUPDATE ( $HWND_DESTINATION )
EndFunc
Func _GUICTRLLISTVIEW_CREATE ( $HWND , $SHEADERTEXT , $IX , $IY , $IWIDTH = 150 , $IHEIGHT = 150 , $ISTYLE = 13 , $IEXSTYLE = 0 , $BCOINIT = False )
	If Not IsHWnd ( $HWND ) Then Return SetError ( 1 , 0 , 0 )
	If Not IsString ( $SHEADERTEXT ) Then Return SetError ( 2 , 0 , 0 )
	If $IWIDTH = + 4294967295 Then $IWIDTH = 150
	If $IHEIGHT = + 4294967295 Then $IHEIGHT = 150
	If $ISTYLE = + 4294967295 Then $ISTYLE = $LVS_DEFAULT
	If $IEXSTYLE = + 4294967295 Then $IEXSTYLE = 0
	Local Const $S_OK = 0
	Local Const $S_FALSE = 1
	Local Const $RPC_E_CHANGED_MODE = 2147549446
	Local Const $E_INVALIDARG = 2147942487
	Local Const $E_OUTOFMEMORY = 2147942414
	Local Const $E_UNEXPECTED = 2147549183
	Local $SSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" )
	Local Const $COINIT_APARTMENTTHREADED = 2
	Local $ISTR_LEN = StringLen ( $SHEADERTEXT )
	If $ISTR_LEN Then $SHEADERTEXT = StringSplit ( $SHEADERTEXT , $SSEPARATORCHAR )
	$ISTYLE = BitOR ( $__UDFGUICONSTANT_WS_CHILD , $__UDFGUICONSTANT_WS_VISIBLE , $ISTYLE )
	If $BCOINIT Then
		Local $ACALL = DllCall ( "ole32.dll" , "long" , "CoInitializeEx" , "ptr" , 0 , "dword" , $COINIT_APARTMENTTHREADED )
		If @error Then Return SetError ( @error , @extended , 0 )
		Switch $ACALL [ 0 ]
		Case $S_OK
		Case $S_FALSE
		Case $RPC_E_CHANGED_MODE
		Case $E_INVALIDARG
		Case $E_OUTOFMEMORY
		Case $E_UNEXPECTED
		EndSwitch
	EndIf
	Local $NCTRLID = __UDF_GETNEXTGLOBALID ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $HLIST = _WINAPI_CREATEWINDOWEX ( $IEXSTYLE , $__LISTVIEWCONSTANT_CLASSNAME , "" , $ISTYLE , $IX , $IY , $IWIDTH , $IHEIGHT , $HWND , $NCTRLID )
	_SENDMESSAGE ( $HLIST , $__LISTVIEWCONSTANT_WM_SETFONT , _WINAPI_GETSTOCKOBJECT ( $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT ) , True )
	If $ISTR_LEN Then
		For $X = 1 To $SHEADERTEXT [ 0 ]
			_GUICTRLLISTVIEW_INSERTCOLUMN ( $HLIST , $X + 4294967295 , $SHEADERTEXT [ $X ] , 75 )
		Next
	EndIf
	Return $HLIST
EndFunc
Func _GUICTRLLISTVIEW_CREATEDRAGIMAGE ( $HWND , $IINDEX )
	Local $ADRAG [ 3 ]
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	$ADRAG [ 0 ] = Ptr ( __GUICTRL_SENDMSG ( $HWND , $LVM_CREATEDRAGIMAGE , $IINDEX , $TPOINT , 0 , True , + 4294967295 ) )
	$ADRAG [ 1 ] = DllStructGetData ( $TPOINT , "X" )
	$ADRAG [ 2 ] = DllStructGetData ( $TPOINT , "Y" )
	Return $ADRAG
EndFunc
Func _GUICTRLLISTVIEW_CREATESOLIDBITMAP ( $HWND , $ICOLOR , $IWIDTH , $IHEIGHT )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	Return _WINAPI_CREATESOLIDBITMAP ( $HWND , $ICOLOR , $IWIDTH , $IHEIGHT )
EndFunc
Func _GUICTRLLISTVIEW_DELETEALLITEMS ( $HWND )
	If _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND ) = 0 Then Return True
	Local $VCID = 0
	If IsHWnd ( $HWND ) Then
		$VCID = _WINAPI_GETDLGCTRLID ( $HWND )
	Else
		$VCID = $HWND
		$HWND = GUICtrlGetHandle ( $HWND )
	EndIf
	If $VCID < $_UDF_STARTID Then
		Local $IPARAM = 0
		For $IINDEX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND ) + 4294967295 To 0 Step + 4294967295
			$IPARAM = _GUICTRLLISTVIEW_GETITEMPARAM ( $HWND , $IINDEX )
			If GUICtrlGetState ( $IPARAM ) > 0 And GUICtrlGetHandle ( $IPARAM ) = 0 Then
				GUICtrlDelete ( $IPARAM )
			EndIf
		Next
		If _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND ) = 0 Then Return True
	EndIf
	Return _SENDMESSAGE ( $HWND , $LVM_DELETEALLITEMS ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_DELETECOLUMN ( $HWND , $ICOL )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_DELETECOLUMN , $ICOL ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_DELETECOLUMN , $ICOL , 0 ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_DELETEITEM ( $HWND , $IINDEX )
	Local $VCID = 0
	If IsHWnd ( $HWND ) Then
		$VCID = _WINAPI_GETDLGCTRLID ( $HWND )
	Else
		$VCID = $HWND
		$HWND = GUICtrlGetHandle ( $HWND )
	EndIf
	If $VCID < $_UDF_STARTID Then
		Local $IPARAM = _GUICTRLLISTVIEW_GETITEMPARAM ( $HWND , $IINDEX )
		If GUICtrlGetState ( $IPARAM ) > 0 And GUICtrlGetHandle ( $IPARAM ) = 0 Then
			If GUICtrlDelete ( $IPARAM ) Then
				Return True
			EndIf
		EndIf
	EndIf
	Return _SENDMESSAGE ( $HWND , $LVM_DELETEITEM , $IINDEX ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_DELETEITEMSSELECTED ( $HWND )
	Local $IITEMCOUNT = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND )
	If _GUICTRLLISTVIEW_GETSELECTEDCOUNT ( $HWND ) = $IITEMCOUNT Then
		Return _GUICTRLLISTVIEW_DELETEALLITEMS ( $HWND )
	Else
		Local $ASELECTED = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HWND , True )
		If Not IsArray ( $ASELECTED ) Then Return SetError ( $LV_ERR , $LV_ERR , 0 )
		_GUICTRLLISTVIEW_SETITEMSELECTED ( $HWND , + 4294967295 , False )
		Local $VCID = 0 , $INATIVE_DELETE , $IUDF_DELETE
		If IsHWnd ( $HWND ) Then
			$VCID = _WINAPI_GETDLGCTRLID ( $HWND )
		Else
			$VCID = $HWND
			$HWND = GUICtrlGetHandle ( $HWND )
		EndIf
		For $IINDEX = $ASELECTED [ 0 ] To 1 Step + 4294967295
			If $VCID < $_UDF_STARTID Then
				Local $IPARAM = _GUICTRLLISTVIEW_GETITEMPARAM ( $HWND , $ASELECTED [ $IINDEX ] )
				If GUICtrlGetState ( $IPARAM ) > 0 And GUICtrlGetHandle ( $IPARAM ) = 0 Then
					$INATIVE_DELETE = GUICtrlDelete ( $IPARAM )
					If $INATIVE_DELETE Then ContinueLoop
				EndIf
			EndIf
			$IUDF_DELETE = _SENDMESSAGE ( $HWND , $LVM_DELETEITEM , $ASELECTED [ $IINDEX ] )
			If $INATIVE_DELETE + $IUDF_DELETE = 0 Then
				ExitLoop
			EndIf
		Next
		Return Not $IINDEX
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_DESTROY ( ByRef $HWND )
	If Not _WINAPI_ISCLASSNAME ( $HWND , $__LISTVIEWCONSTANT_CLASSNAME ) Then Return SetError ( 2 , 2 , False )
	Local $IDESTROYED = 0
	If IsHWnd ( $HWND ) Then
		If _WINAPI_INPROCESS ( $HWND , $__G_HGUICTRL_LASTWND ) Then
			Local $NCTRLID = _WINAPI_GETDLGCTRLID ( $HWND )
			Local $HPARENT = _WINAPI_GETPARENT ( $HWND )
			$IDESTROYED = _WINAPI_DESTROYWINDOW ( $HWND )
			Local $IRET = __UDF_FREEGLOBALID ( $HPARENT , $NCTRLID )
			If Not $IRET Then
			EndIf
		Else
			Return SetError ( 1 , 1 , False )
		EndIf
	Else
		$IDESTROYED = GUICtrlDelete ( $HWND )
	EndIf
	If $IDESTROYED Then $HWND = 0
	Return $IDESTROYED <> 0
EndFunc
Func __GUICTRLLISTVIEW_DRAW ( $HWND , $IINDEX , $HDC , $IX , $IY , $ISTYLE = 0 )
	Local $IFLAGS = 0
	If BitAND ( $ISTYLE , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $__LISTVIEWCONSTANT_ILD_TRANSPARENT )
	If BitAND ( $ISTYLE , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $__LISTVIEWCONSTANT_ILD_BLEND25 )
	If BitAND ( $ISTYLE , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $__LISTVIEWCONSTANT_ILD_BLEND50 )
	If BitAND ( $ISTYLE , 8 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $__LISTVIEWCONSTANT_ILD_MASK )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Draw" , "handle" , $HWND , "int" , $IINDEX , "handle" , $HDC , "int" , $IX , "int" , $IY , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _GUICTRLLISTVIEW_DRAWDRAGIMAGE ( ByRef $HWND , ByRef $ADRAG )
	Local $HDC = _WINAPI_GETWINDOWDC ( $HWND )
	Local $TPOINT = _WINAPI_GETMOUSEPOS ( True , $HWND )
	_WINAPI_INVALIDATERECT ( $HWND )
	__GUICTRLLISTVIEW_DRAW ( $ADRAG [ 0 ] , 0 , $HDC , DllStructGetData ( $TPOINT , "X" ) , DllStructGetData ( $TPOINT , "Y" ) )
	_WINAPI_RELEASEDC ( $HWND , $HDC )
EndFunc
Func _GUICTRLLISTVIEW_EDITLABEL ( $HWND , $IINDEX )
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $LVM_EDITLABELW
	Else
		$IMSG = $LVM_EDITLABEL
	EndIf
	Local $ACALL
	If IsHWnd ( $HWND ) Then
		$ACALL = DllCall ( "user32.dll" , "hwnd" , "SetFocus" , "hwnd" , $HWND )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $ACALL [ 0 ] = 0 Then Return 0
		Return _SENDMESSAGE ( $HWND , $IMSG , $IINDEX , 0 , 0 , "wparam" , "lparam" , "hwnd" )
	Else
		$ACALL = DllCall ( "user32.dll" , "hwnd" , "SetFocus" , "hwnd" , GUICtrlGetHandle ( $HWND ) )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $ACALL [ 0 ] = 0 Then Return 0
		Return Ptr ( GUICtrlSendMsg ( $HWND , $IMSG , $IINDEX , 0 ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_ENABLEGROUPVIEW ( $HWND , $BENABLE = True )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_ENABLEGROUPVIEW , $BENABLE )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_ENABLEGROUPVIEW , $BENABLE , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_ENDUPDATE ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $__LISTVIEWCONSTANT_WM_SETREDRAW , True ) = 0
	Else
		Return GUICtrlSendMsg ( $HWND , $__LISTVIEWCONSTANT_WM_SETREDRAW , True , 0 ) = 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_ENSUREVISIBLE ( $HWND , $IINDEX , $BPARTIALOK = False )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_ENSUREVISIBLE , $IINDEX , $BPARTIALOK )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_ENSUREVISIBLE , $IINDEX , $BPARTIALOK )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_FINDINTEXT ( $HWND , $STEXT , $ISTART = + 4294967295 , $BWRAPOK = True , $BREVERSE = False )
	Local $ICOUNT = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND )
	Local $ICOLUMNS = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND )
	If $ICOLUMNS = 0 Then $ICOLUMNS = 1
	If $BREVERSE And $ISTART = + 4294967295 Then Return + 4294967295
	Local $SLIST
	If $BREVERSE Then
		For $II = $ISTART + 4294967295 To 0 Step + 4294967295
			For $IJ = 0 To $ICOLUMNS + 4294967295
				$SLIST = _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $II , $IJ )
				If StringInStr ( $SLIST , $STEXT ) Then Return $II
			Next
		Next
	Else
		For $II = $ISTART + 1 To $ICOUNT + 4294967295
			For $IJ = 0 To $ICOLUMNS + 4294967295
				$SLIST = _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $II , $IJ )
				If StringInStr ( $SLIST , $STEXT ) Then Return $II
			Next
		Next
	EndIf
	If ( ( $ISTART = + 4294967295 ) Or Not $BWRAPOK ) And Not $BREVERSE Then Return + 4294967295
	If $BREVERSE And $BWRAPOK Then
		For $II = $ICOUNT + 4294967295 To $ISTART + 1 Step + 4294967295
			For $IJ = 0 To $ICOLUMNS + 4294967295
				$SLIST = _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $II , $IJ )
				If StringInStr ( $SLIST , $STEXT ) Then Return $II
			Next
		Next
	Else
		For $II = 0 To $ISTART + 4294967295
			For $IJ = 0 To $ICOLUMNS + 4294967295
				$SLIST = _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $II , $IJ )
				If StringInStr ( $SLIST , $STEXT ) Then Return $II
			Next
		Next
	EndIf
	Return + 4294967295
EndFunc
Func _GUICTRLLISTVIEW_FINDITEM ( $HWND , $ISTART , ByRef $TFINDINFO , $STEXT = "" )
	Local $IBUFFER = StringLen ( $STEXT ) + 1
	Local $TBUFFER = DllStructCreate ( "char Text[" & $IBUFFER & "]" )
	DllStructSetData ( $TBUFFER , 1 , $STEXT )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_FINDITEM , $ISTART , $TFINDINFO , $TBUFFER , False , 2 , False , + 4294967295 )
	Return $IRET
EndFunc
Func _GUICTRLLISTVIEW_FINDNEAREST ( $HWND , $IX , $IY , $IDIR = 0 , $ISTART = + 4294967295 , $BWRAPOK = True )
	Local $ADIR [ 8 ] = [ $__LISTVIEWCONSTANT_VK_LEFT , $__LISTVIEWCONSTANT_VK_RIGHT , $__LISTVIEWCONSTANT_VK_UP , $__LISTVIEWCONSTANT_VK_DOWN , $__LISTVIEWCONSTANT_VK_HOME , $__LISTVIEWCONSTANT_VK_END , $__LISTVIEWCONSTANT_VK_PRIOR , $__LISTVIEWCONSTANT_VK_NEXT ]
	Local $TFINDINFO = DllStructCreate ( $TAGLVFINDINFO )
	Local $IFLAGS = $LVFI_NEARESTXY
	If $BWRAPOK Then $IFLAGS = BitOR ( $IFLAGS , $LVFI_WRAP )
	DllStructSetData ( $TFINDINFO , "Flags" , $IFLAGS )
	DllStructSetData ( $TFINDINFO , "X" , $IX )
	DllStructSetData ( $TFINDINFO , "Y" , $IY )
	DllStructSetData ( $TFINDINFO , "Direction" , $ADIR [ $IDIR ] )
	Return _GUICTRLLISTVIEW_FINDITEM ( $HWND , $ISTART , $TFINDINFO )
EndFunc
Func _GUICTRLLISTVIEW_FINDPARAM ( $HWND , $IPARAM , $ISTART = + 4294967295 )
	Local $TFINDINFO = DllStructCreate ( $TAGLVFINDINFO )
	DllStructSetData ( $TFINDINFO , "Flags" , $LVFI_PARAM )
	DllStructSetData ( $TFINDINFO , "Param" , $IPARAM )
	Return _GUICTRLLISTVIEW_FINDITEM ( $HWND , $ISTART , $TFINDINFO )
EndFunc
Func _GUICTRLLISTVIEW_FINDTEXT ( $HWND , $STEXT , $ISTART = + 4294967295 , $BPARTIALOK = True , $BWRAPOK = True )
	Local $TFINDINFO = DllStructCreate ( $TAGLVFINDINFO )
	Local $IFLAGS = $LVFI_STRING
	If $BPARTIALOK Then $IFLAGS = BitOR ( $IFLAGS , $LVFI_PARTIAL )
	If $BWRAPOK Then $IFLAGS = BitOR ( $IFLAGS , $LVFI_WRAP )
	DllStructSetData ( $TFINDINFO , "Flags" , $IFLAGS )
	Return _GUICTRLLISTVIEW_FINDITEM ( $HWND , $ISTART , $TFINDINFO , $STEXT )
EndFunc
Func _GUICTRLLISTVIEW_GETBKCOLOR ( $HWND )
	Local $I_COLOR
	If IsHWnd ( $HWND ) Then
		$I_COLOR = _SENDMESSAGE ( $HWND , $LVM_GETBKCOLOR )
	Else
		$I_COLOR = GUICtrlSendMsg ( $HWND , $LVM_GETBKCOLOR , 0 , 0 )
	EndIf
	Return __GUICTRLLISTVIEW_REVERSECOLORORDER ( $I_COLOR )
EndFunc
Func _GUICTRLLISTVIEW_GETBKIMAGE ( $HWND )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_GETBKIMAGEW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_GETBKIMAGEA
	EndIf
	Local $TIMAGE = DllStructCreate ( $TAGLVBKIMAGE )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TIMAGE , $TBUFFER , True , 3 , True )
	Local $AIMAGE [ 4 ]
	Switch BitAND ( DllStructGetData ( $TIMAGE , "Flags" ) , $LVBKIF_SOURCE_MASK )
	Case $LVBKIF_SOURCE_HBITMAP
		$AIMAGE [ 0 ] = 1
	Case $LVBKIF_SOURCE_URL
		$AIMAGE [ 0 ] = 2
	EndSwitch
	$AIMAGE [ 1 ] = DllStructGetData ( $TBUFFER , 1 )
	$AIMAGE [ 2 ] = DllStructGetData ( $TIMAGE , "XOffPercent" )
	$AIMAGE [ 3 ] = DllStructGetData ( $TIMAGE , "YOffPercent" )
	Return SetError ( $IRET <> 0 , 0 , $AIMAGE )
EndFunc
Func _GUICTRLLISTVIEW_GETCALLBACKMASK ( $HWND )
	Local $IFLAGS = 0
	Local $IMASK = _SENDMESSAGE ( $HWND , $LVM_GETCALLBACKMASK )
	If BitAND ( $IMASK , $LVIS_CUT ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 1 )
	If BitAND ( $IMASK , $LVIS_DROPHILITED ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 2 )
	If BitAND ( $IMASK , $LVIS_FOCUSED ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 4 )
	If BitAND ( $IMASK , $LVIS_SELECTED ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 8 )
	If BitAND ( $IMASK , $LVIS_OVERLAYMASK ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 16 )
	If BitAND ( $IMASK , $LVIS_STATEIMAGEMASK ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , 32 )
	Return $IFLAGS
EndFunc
Func _GUICTRLLISTVIEW_GETCOLUMN ( $HWND , $IINDEX )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_GETCOLUMNW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_GETCOLUMNA
	EndIf
	Local $TCOLUMN = DllStructCreate ( $TAGLVCOLUMN )
	DllStructSetData ( $TCOLUMN , "Mask" , $LVCF_ALLDATA )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TCOLUMN , $TBUFFER , True , 4 , True )
	Local $ACOLUMN [ 9 ]
	Switch BitAND ( DllStructGetData ( $TCOLUMN , "Fmt" ) , $LVCFMT_JUSTIFYMASK )
	Case $LVCFMT_RIGHT
		$ACOLUMN [ 0 ] = 1
	Case $LVCFMT_CENTER
		$ACOLUMN [ 0 ] = 2
Case Else
		$ACOLUMN [ 0 ] = 0
	EndSwitch
	$ACOLUMN [ 1 ] = BitAND ( DllStructGetData ( $TCOLUMN , "Fmt" ) , $LVCFMT_IMAGE ) <> 0
	$ACOLUMN [ 2 ] = BitAND ( DllStructGetData ( $TCOLUMN , "Fmt" ) , $LVCFMT_BITMAP_ON_RIGHT ) <> 0
	$ACOLUMN [ 3 ] = BitAND ( DllStructGetData ( $TCOLUMN , "Fmt" ) , $LVCFMT_COL_HAS_IMAGES ) <> 0
	$ACOLUMN [ 4 ] = DllStructGetData ( $TCOLUMN , "CX" )
	$ACOLUMN [ 5 ] = DllStructGetData ( $TBUFFER , 1 )
	$ACOLUMN [ 6 ] = DllStructGetData ( $TCOLUMN , "SubItem" )
	$ACOLUMN [ 7 ] = DllStructGetData ( $TCOLUMN , "Image" )
	$ACOLUMN [ 8 ] = DllStructGetData ( $TCOLUMN , "Order" )
	Return SetError ( $IRET = 0 , 0 , $ACOLUMN )
EndFunc
Func _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND )
	Return _SENDMESSAGE ( _GUICTRLLISTVIEW_GETHEADER ( $HWND ) , 4608 )
EndFunc
Func _GUICTRLLISTVIEW_GETCOLUMNORDER ( $HWND )
	Local $A_COLS = _GUICTRLLISTVIEW_GETCOLUMNORDERARRAY ( $HWND ) , $S_COLS = ""
	Local $SSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" )
	For $I = 1 To $A_COLS [ 0 ]
		$S_COLS &= $A_COLS [ $I ] & $SSEPARATORCHAR
	Next
	$S_COLS = StringTrimRight ( $S_COLS , 1 )
	Return $S_COLS
EndFunc
Func _GUICTRLLISTVIEW_GETCOLUMNORDERARRAY ( $HWND )
	Local $ICOLUMNS = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND )
	Local $TCOLUMNS = DllStructCreate ( "int[" & $ICOLUMNS & "]" )
	__GUICTRL_SENDMSG ( $HWND , $LVM_GETCOLUMNORDERARRAY , $ICOLUMNS , $TCOLUMNS , 0 , True , + 4294967295 )
	Local $ABUFFER [ $ICOLUMNS + 1 ]
	$ABUFFER [ 0 ] = $ICOLUMNS
	For $II = 1 To $ICOLUMNS
		$ABUFFER [ $II ] = DllStructGetData ( $TCOLUMNS , 1 , $II )
	Next
	Return $ABUFFER
EndFunc
Func _GUICTRLLISTVIEW_GETCOLUMNWIDTH ( $HWND , $ICOL )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETCOLUMNWIDTH , $ICOL )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETCOLUMNWIDTH , $ICOL , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETCOUNTERPAGE ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETCOUNTPERPAGE )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETCOUNTPERPAGE , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETEDITCONTROL ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return HWnd ( _SENDMESSAGE ( $HWND , $LVM_GETEDITCONTROL ) )
	Else
		Return HWnd ( GUICtrlSendMsg ( $HWND , $LVM_GETEDITCONTROL , 0 , 0 ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETEMPTYTEXT ( $HWND )
	Local $TTEXT = DllStructCreate ( "wchar[4096]" )
	Local $ITEXT = DllStructGetSize ( $TTEXT )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETEMPTYTEXT , $ITEXT , $TTEXT , 0 , True , + 4294967295 )
	Return $IRET ? DllStructGetData ( $TTEXT , 1 ) : ""
EndFunc
Func _GUICTRLLISTVIEW_GETEXTENDEDLISTVIEWSTYLE ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETEXTENDEDLISTVIEWSTYLE )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETEXTENDEDLISTVIEWSTYLE , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETFOCUSEDGROUP ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETFOCUSEDGROUP )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETFOCUSEDGROUP , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETGROUPCOUNT ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETGROUPCOUNT )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETGROUPCOUNT , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETGROUPINFO ( $HWND , $IGROUPID )
	Local $TGROUP = __GUICTRLLISTVIEW_GETGROUPINFOEX ( $HWND , $IGROUPID , BitOR ( $LVGF_HEADER , $LVGF_ALIGN ) )
	Local $IERR = @error
	Local $AGROUP [ 2 ]
	$AGROUP [ 0 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TGROUP , "Header" ) )
	Select
	Case BitAND ( DllStructGetData ( $TGROUP , "Align" ) , $LVGA_HEADER_CENTER ) <> 0
		$AGROUP [ 1 ] = 1
	Case BitAND ( DllStructGetData ( $TGROUP , "Align" ) , $LVGA_HEADER_RIGHT ) <> 0
		$AGROUP [ 1 ] = 2
Case Else
		$AGROUP [ 1 ] = 0
	EndSelect
	Return SetError ( $IERR , 0 , $AGROUP )
EndFunc
Func __GUICTRLLISTVIEW_GETGROUPINFOEX ( $HWND , $IGROUPID , $IMASK )
	Local $TGROUP = DllStructCreate ( $TAGLVGROUP )
	Local $IGROUP = DllStructGetSize ( $TGROUP )
	DllStructSetData ( $TGROUP , "Size" , $IGROUP )
	DllStructSetData ( $TGROUP , "Mask" , $IMASK )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETGROUPINFO , $IGROUPID , $TGROUP , 0 , True , + 4294967295 )
	Return SetError ( $IRET <> $IGROUPID , 0 , $TGROUP )
EndFunc
Func _GUICTRLLISTVIEW_GETGROUPINFOBYINDEX ( $HWND , $IINDEX )
	Local $TGROUP = DllStructCreate ( $TAGLVGROUP )
	Local $IGROUP = DllStructGetSize ( $TGROUP )
	DllStructSetData ( $TGROUP , "Size" , $IGROUP )
	DllStructSetData ( $TGROUP , "Mask" , BitOR ( $LVGF_HEADER , $LVGF_ALIGN , $LVGF_GROUPID ) )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETGROUPINFOBYINDEX , $IINDEX , $TGROUP , 0 , True , + 4294967295 )
	Local $AGROUP [ 3 ]
	$AGROUP [ 0 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TGROUP , "Header" ) )
	Select
	Case BitAND ( DllStructGetData ( $TGROUP , "Align" ) , $LVGA_HEADER_CENTER ) <> 0
		$AGROUP [ 1 ] = 1
	Case BitAND ( DllStructGetData ( $TGROUP , "Align" ) , $LVGA_HEADER_RIGHT ) <> 0
		$AGROUP [ 1 ] = 2
Case Else
		$AGROUP [ 1 ] = 0
	EndSelect
	$AGROUP [ 2 ] = DllStructGetData ( $TGROUP , "GroupID" )
	Return SetError ( $IRET = 0 , 0 , $AGROUP )
EndFunc
Func _GUICTRLLISTVIEW_GETGROUPRECT ( $HWND , $IGROUPID , $IGET = $LVGGR_GROUP )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , "Top" , $IGET )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETGROUPRECT , $IGROUPID , $TRECT , 0 , True , + 4294967295 )
	Local $ARECT [ 4 ]
	For $X = 0 To 3
		$ARECT [ $X ] = DllStructGetData ( $TRECT , $X + 1 )
	Next
	Return SetError ( $IRET = 0 , 0 , $ARECT )
EndFunc
Func _GUICTRLLISTVIEW_GETGROUPSTATE ( $HWND , $IGROUPID , $IMASK )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETGROUPSTATE , $IGROUPID , $IMASK )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETGROUPSTATE , $IGROUPID , $IMASK )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETGROUPVIEWENABLED ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_ISGROUPVIEWENABLED ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_ISGROUPVIEWENABLED , 0 , 0 ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETHEADER ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return HWnd ( _SENDMESSAGE ( $HWND , $LVM_GETHEADER ) )
	Else
		Return HWnd ( GUICtrlSendMsg ( $HWND , $LVM_GETHEADER , 0 , 0 ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETHOTCURSOR ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETHOTCURSOR , 0 , 0 , 0 , "wparam" , "lparam" , "handle" )
	Else
		Return Ptr ( GUICtrlSendMsg ( $HWND , $LVM_GETHOTCURSOR , 0 , 0 ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETHOTITEM ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETHOTITEM )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETHOTITEM , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETHOVERTIME ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETHOVERTIME )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETHOVERTIME , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETIMAGELIST ( $HWND , $IIMAGELIST )
	Local $AIMAGELIST [ 3 ] = [ $LVSIL_NORMAL , $LVSIL_SMALL , $LVSIL_STATE ]
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETIMAGELIST , $AIMAGELIST [ $IIMAGELIST ] , 0 , 0 , "wparam" , "lparam" , "handle" )
	Else
		Return Ptr ( GUICtrlSendMsg ( $HWND , $LVM_GETIMAGELIST , $AIMAGELIST [ $IIMAGELIST ] , 0 ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETINSERTMARK ( $HWND )
	Local $TMARK = DllStructCreate ( $TAGLVINSERTMARK )
	Local $IMARK = DllStructGetSize ( $TMARK )
	DllStructSetData ( $TMARK , "Size" , $IMARK )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETINSERTMARK , 0 , $TMARK , 0 , True , + 4294967295 )
	Local $AMARK [ 2 ]
	$AMARK [ 0 ] = DllStructGetData ( $TMARK , "Flags" ) = $LVIM_AFTER
	$AMARK [ 1 ] = DllStructGetData ( $TMARK , "Item" )
	Return SetError ( $IRET = 0 , 0 , $AMARK )
EndFunc
Func _GUICTRLLISTVIEW_GETINSERTMARKCOLOR ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETINSERTMARKCOLOR , $LVSIL_STATE )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETINSERTMARKCOLOR , $LVSIL_STATE , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETINSERTMARKRECT ( $HWND )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ARECT [ 5 ]
	$ARECT [ 0 ] = __GUICTRL_SENDMSG ( $HWND , $LVM_GETINSERTMARKRECT , 0 , $TRECT , 0 , True , + 4294967295 )
	$ARECT [ 1 ] = DllStructGetData ( $TRECT , "Left" )
	$ARECT [ 2 ] = DllStructGetData ( $TRECT , "Top" )
	$ARECT [ 3 ] = DllStructGetData ( $TRECT , "Right" )
	$ARECT [ 4 ] = DllStructGetData ( $TRECT , "Bottom" )
	Return $ARECT
EndFunc
Func _GUICTRLLISTVIEW_GETISEARCHSTRING ( $HWND )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_GETISEARCHSTRINGW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_GETISEARCHSTRINGA
	EndIf
	Local $IBUFFER
	If IsHWnd ( $HWND ) Then
		$IBUFFER = _SENDMESSAGE ( $HWND , $IMSG ) + 1
	Else
		$IBUFFER = GUICtrlSendMsg ( $HWND , $IMSG , 0 , 0 ) + 1
	EndIf
	If $IBUFFER = 1 Then Return ""
	__GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TBUFFER , 0 , True , + 4294967295 )
	Return DllStructGetData ( $TBUFFER , 1 )
EndFunc
Func _GUICTRLLISTVIEW_GETITEM ( $HWND , $IINDEX , $ISUBITEM = 0 )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , BitOR ( $LVIF_GROUPID , $LVIF_IMAGE , $LVIF_INDENT , $LVIF_PARAM , $LVIF_STATE ) )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	DllStructSetData ( $TITEM , "StateMask" , + 4294967295 )
	_GUICTRLLISTVIEW_GETITEMEX ( $HWND , $TITEM )
	Local $ISTATE = DllStructGetData ( $TITEM , "State" )
	Local $AITEM [ 8 ]
	If BitAND ( $ISTATE , $LVIS_CUT ) <> 0 Then $AITEM [ 0 ] = BitOR ( $AITEM [ 0 ] , 1 )
	If BitAND ( $ISTATE , $LVIS_DROPHILITED ) <> 0 Then $AITEM [ 0 ] = BitOR ( $AITEM [ 0 ] , 2 )
	If BitAND ( $ISTATE , $LVIS_FOCUSED ) <> 0 Then $AITEM [ 0 ] = BitOR ( $AITEM [ 0 ] , 4 )
	If BitAND ( $ISTATE , $LVIS_SELECTED ) <> 0 Then $AITEM [ 0 ] = BitOR ( $AITEM [ 0 ] , 8 )
	$AITEM [ 1 ] = __GUICTRLLISTVIEW_OVERLAYIMAGEMASKTOINDEX ( $ISTATE )
	$AITEM [ 2 ] = __GUICTRLLISTVIEW_STATEIMAGEMASKTOINDEX ( $ISTATE )
	$AITEM [ 3 ] = _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $IINDEX , $ISUBITEM )
	$AITEM [ 4 ] = DllStructGetData ( $TITEM , "Image" )
	$AITEM [ 5 ] = DllStructGetData ( $TITEM , "Param" )
	$AITEM [ 6 ] = DllStructGetData ( $TITEM , "Indent" )
	$AITEM [ 7 ] = DllStructGetData ( $TITEM , "GroupID" )
	Return $AITEM
EndFunc
Func _GUICTRLLISTVIEW_GETITEMCHECKED ( $HWND , $IINDEX )
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $LVM_GETITEMW
	Else
		$IMSG = $LVM_GETITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_STATE )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "StateMask" , 65535 )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , 0 , True , + 4294967295 )
	If Not $IRET Then Return SetError ( $LV_ERR , $LV_ERR , False )
	Return BitAND ( DllStructGetData ( $TITEM , "State" ) , 8192 ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETITEMCOUNT )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETITEMCOUNT , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETITEMCUT ( $HWND , $IINDEX )
	Return _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $LVIS_CUT ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_GETITEMDROPHILITED ( $HWND , $IINDEX )
	Return _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $LVIS_DROPHILITED ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_GETITEMEX ( $HWND , ByRef $TITEM )
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $LVM_GETITEMW
	Else
		$IMSG = $LVM_GETITEMA
	EndIf
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , 0 , True , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_GETITEMFOCUSED ( $HWND , $IINDEX )
	Return _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $LVIS_FOCUSED ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_GETITEMGROUPID ( $HWND , $IINDEX )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_GROUPID )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	_GUICTRLLISTVIEW_GETITEMEX ( $HWND , $TITEM )
	Return DllStructGetData ( $TITEM , "GroupID" )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMIMAGE ( $HWND , $IINDEX , $ISUBITEM = 0 )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_IMAGE )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	_GUICTRLLISTVIEW_GETITEMEX ( $HWND , $TITEM )
	Return DllStructGetData ( $TITEM , "Image" )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMINDENT ( $HWND , $IINDEX )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_INDENT )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	_GUICTRLLISTVIEW_GETITEMEX ( $HWND , $TITEM )
	Return DllStructGetData ( $TITEM , "Indent" )
EndFunc
Func __GUICTRLLISTVIEW_GETITEMOVERLAYIMAGE ( $HWND , $IINDEX )
	Return BitShift ( _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $LVIS_OVERLAYMASK ) , 8 )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMPARAM ( $HWND , $IINDEX )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_PARAM )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	_GUICTRLLISTVIEW_GETITEMEX ( $HWND , $TITEM )
	Return DllStructGetData ( $TITEM , "Param" )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMPOSITION ( $HWND , $IINDEX )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETITEMPOSITION , $IINDEX , $TPOINT , 0 , True , + 4294967295 )
	Local $APOINT [ 2 ]
	If Not $IRET Then Return $APOINT
	$APOINT [ 0 ] = DllStructGetData ( $TPOINT , "X" )
	$APOINT [ 1 ] = DllStructGetData ( $TPOINT , "Y" )
	Return $APOINT
EndFunc
Func _GUICTRLLISTVIEW_GETITEMPOSITIONX ( $HWND , $IINDEX )
	Local $APOINT = _GUICTRLLISTVIEW_GETITEMPOSITION ( $HWND , $IINDEX )
	Return $APOINT [ 0 ]
EndFunc
Func _GUICTRLLISTVIEW_GETITEMPOSITIONY ( $HWND , $IINDEX )
	Local $APOINT = _GUICTRLLISTVIEW_GETITEMPOSITION ( $HWND , $IINDEX )
	Return $APOINT [ 1 ]
EndFunc
Func _GUICTRLLISTVIEW_GETITEMRECT ( $HWND , $IINDEX , $IPART = 3 )
	Local $TRECT = _GUICTRLLISTVIEW_GETITEMRECTEX ( $HWND , $IINDEX , $IPART )
	Local $ARECT [ 4 ]
	$ARECT [ 0 ] = DllStructGetData ( $TRECT , "Left" )
	$ARECT [ 1 ] = DllStructGetData ( $TRECT , "Top" )
	$ARECT [ 2 ] = DllStructGetData ( $TRECT , "Right" )
	$ARECT [ 3 ] = DllStructGetData ( $TRECT , "Bottom" )
	Return $ARECT
EndFunc
Func _GUICTRLLISTVIEW_GETITEMRECTEX ( $HWND , $IINDEX , $IPART = 3 )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , "Left" , $IPART )
	__GUICTRL_SENDMSG ( $HWND , $LVM_GETITEMRECT , $IINDEX , $TRECT , 0 , True , + 4294967295 )
	Return $TRECT
EndFunc
Func _GUICTRLLISTVIEW_GETITEMSELECTED ( $HWND , $IINDEX )
	Return _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $LVIS_SELECTED ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_GETITEMSPACING ( $HWND , $BSMALL = False )
	Local $ISPACE
	If IsHWnd ( $HWND ) Then
		$ISPACE = _SENDMESSAGE ( $HWND , $LVM_GETITEMSPACING , $BSMALL )
	Else
		$ISPACE = GUICtrlSendMsg ( $HWND , $LVM_GETITEMSPACING , $BSMALL , 0 )
	EndIf
	Local $ASPACE [ 2 ]
	$ASPACE [ 0 ] = BitAND ( $ISPACE , 65535 )
	$ASPACE [ 1 ] = BitShift ( $ISPACE , 16 )
	Return $ASPACE
EndFunc
Func _GUICTRLLISTVIEW_GETITEMSPACINGX ( $HWND , $BSMALL = False )
	If IsHWnd ( $HWND ) Then
		Return BitAND ( _SENDMESSAGE ( $HWND , $LVM_GETITEMSPACING , $BSMALL , 0 ) , 65535 )
	Else
		Return BitAND ( GUICtrlSendMsg ( $HWND , $LVM_GETITEMSPACING , $BSMALL , 0 ) , 65535 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETITEMSPACINGY ( $HWND , $BSMALL = False )
	If IsHWnd ( $HWND ) Then
		Return BitShift ( _SENDMESSAGE ( $HWND , $LVM_GETITEMSPACING , $BSMALL , 0 ) , 16 )
	Else
		Return BitShift ( GUICtrlSendMsg ( $HWND , $LVM_GETITEMSPACING , $BSMALL , 0 ) , 16 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $IMASK )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETITEMSTATE , $IINDEX , $IMASK )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETITEMSTATE , $IINDEX , $IMASK )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETITEMSTATEIMAGE ( $HWND , $IINDEX )
	Return BitShift ( _GUICTRLLISTVIEW_GETITEMSTATE ( $HWND , $IINDEX , $LVIS_STATEIMAGEMASK ) , 12 )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $IINDEX , $ISUBITEM = 0 )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_GETITEMTEXTW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_GETITEMTEXTA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TBUFFER , 1 , "" )
	DllStructSetData ( $TITEM , "Mask" , $LVIF_TEXT )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	__GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TITEM , $TBUFFER , False , 6 , True )
	Return DllStructGetData ( $TBUFFER , 1 )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMTEXTARRAY ( $HWND , $IITEM = + 4294967295 )
	Local $SITEMS = _GUICTRLLISTVIEW_GETITEMTEXTSTRING ( $HWND , $IITEM )
	If $SITEMS = "" Then
		Local $AITEMS [ 1 ] = [ 0 ]
		Return SetError ( $LV_ERR , $LV_ERR , $AITEMS )
	EndIf
	Return StringSplit ( $SITEMS , Opt ( "GUIDataSeparatorChar" ) )
EndFunc
Func _GUICTRLLISTVIEW_GETITEMTEXTSTRING ( $HWND , $IITEM = + 4294967295 )
	Local $SROW = "" , $SSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" ) , $ISELECTED
	If $IITEM = + 4294967295 Then
		$ISELECTED = _GUICTRLLISTVIEW_GETNEXTITEM ( $HWND )
	Else
		$ISELECTED = $IITEM
	EndIf
	If $ISELECTED < 0 Or $ISELECTED > _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND ) + 4294967295 Then Return SetError ( 1 , 0 , 0 )
	For $X = 0 To _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND ) + 4294967295
		$SROW &= _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $ISELECTED , $X ) & $SSEPARATORCHAR
	Next
	Return StringTrimRight ( $SROW , 1 )
EndFunc
Func _GUICTRLLISTVIEW_GETNEXTITEM ( $HWND , $ISTART = + 4294967295 , $ISEARCH = 0 , $ISTATE = 8 )
	Local $ASEARCH [ 5 ] = [ $LVNI_ALL , $LVNI_ABOVE , $LVNI_BELOW , $LVNI_TOLEFT , $LVNI_TORIGHT ]
	Local $IFLAGS = $ASEARCH [ $ISEARCH ]
	If BitAND ( $ISTATE , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVNI_CUT )
	If BitAND ( $ISTATE , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVNI_DROPHILITED )
	If BitAND ( $ISTATE , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVNI_FOCUSED )
	If BitAND ( $ISTATE , 8 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVNI_SELECTED )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETNEXTITEM , $ISTART , $IFLAGS )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETNEXTITEM , $ISTART , $IFLAGS )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETNUMBEROFWORKAREAS ( $HWND )
	Local $TDATA = DllStructCreate ( "int Data" )
	__GUICTRL_SENDMSG ( $HWND , $LVM_GETNUMBEROFWORKAREAS , 0 , $TDATA , 0 , True , + 4294967295 )
	Return DllStructGetData ( $TDATA , "Data" )
EndFunc
Func _GUICTRLLISTVIEW_GETORIGIN ( $HWND )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_GETORIGIN , 0 , $TPOINT , 0 , True , + 4294967295 )
	Local $AORIGIN [ 2 ]
	$AORIGIN [ 0 ] = DllStructGetData ( $TPOINT , "X" )
	$AORIGIN [ 1 ] = DllStructGetData ( $TPOINT , "Y" )
	Return SetError ( @error , $IRET = 1 , $AORIGIN )
EndFunc
Func _GUICTRLLISTVIEW_GETORIGINX ( $HWND )
	Local $AORIGIN = _GUICTRLLISTVIEW_GETORIGIN ( $HWND )
	Return $AORIGIN [ 0 ]
EndFunc
Func _GUICTRLLISTVIEW_GETORIGINY ( $HWND )
	Local $AORIGIN = _GUICTRLLISTVIEW_GETORIGIN ( $HWND )
	Return $AORIGIN [ 1 ]
EndFunc
Func _GUICTRLLISTVIEW_GETOUTLINECOLOR ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETOUTLINECOLOR )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETOUTLINECOLOR , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETSELECTEDCOLUMN ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETSELECTEDCOLUMN )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETSELECTEDCOLUMN , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETSELECTEDCOUNT ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETSELECTEDCOUNT )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETSELECTEDCOUNT , 0 , 0 )
	EndIf
EndFunc
Func __GUICTRLLISTVIEW_GETCHECKEDINDICES ( $HWND )
	Local $ICOUNT = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND )
	Local $ASELECTED [ $ICOUNT + 1 ] = [ 0 ]
	For $I = 0 To $ICOUNT + 4294967295
		If _GUICTRLLISTVIEW_GETITEMCHECKED ( $HWND , $I ) Then
			$ASELECTED [ 0 ] += 1
			$ASELECTED [ $ASELECTED [ 0 ] ] = $I
		EndIf
	Next
	ReDim $ASELECTED [ $ASELECTED [ 0 ] + 1 ]
	Return $ASELECTED
EndFunc
Func _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HWND , $BARRAY = False )
	Local $SINDICES , $AINDICES [ 1 ] = [ 0 ]
	Local $ISELECTEDCOUNT = _GUICTRLLISTVIEW_GETSELECTEDCOUNT ( $HWND )
	If $ISELECTEDCOUNT Then
		Local $ISELECTED , $ISTART = + 4294967295
		For $I = 1 To $ISELECTEDCOUNT
			If IsHWnd ( $HWND ) Then
				$ISELECTED = _SENDMESSAGE ( $HWND , $LVM_GETNEXTITEM , $ISTART , $LVNI_SELECTED )
			Else
				$ISELECTED = GUICtrlSendMsg ( $HWND , $LVM_GETNEXTITEM , $ISTART , $LVNI_SELECTED )
			EndIf
			If ( Not $BARRAY ) Then
				If StringLen ( $SINDICES ) Then
					$SINDICES &= "|" & $ISELECTED
				Else
					$SINDICES = $ISELECTED
				EndIf
			Else
				ReDim $AINDICES [ UBound ( $AINDICES ) + 1 ]
				$AINDICES [ 0 ] = UBound ( $AINDICES ) + 4294967295
				$AINDICES [ UBound ( $AINDICES ) + 4294967295 ] = $ISELECTED
			EndIf
			$ISTART = $ISELECTED
		Next
	EndIf
	If ( Not $BARRAY ) Then
		Return String ( $SINDICES )
	Else
		Return $AINDICES
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETSELECTIONMARK ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETSELECTIONMARK )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETSELECTIONMARK , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETSTRINGWIDTH ( $HWND , $SSTRING )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_GETSTRINGWIDTHW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_GETSTRINGWIDTHA
	EndIf
	DllStructSetData ( $TBUFFER , 1 , $SSTRING )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TBUFFER , 0 , True , + 4294967295 )
	Return $IRET
EndFunc
Func _GUICTRLLISTVIEW_GETSUBITEMRECT ( $HWND , $IINDEX , $ISUBITEM , $IPART = 0 )
	Local $APART [ 2 ] = [ $LVIR_BOUNDS , $LVIR_ICON ]
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , "Top" , $ISUBITEM )
	DllStructSetData ( $TRECT , "Left" , $APART [ $IPART ] )
	__GUICTRL_SENDMSG ( $HWND , $LVM_GETSUBITEMRECT , $IINDEX , $TRECT , 0 , True , + 4294967295 )
	Local $ARECT [ 4 ]
	$ARECT [ 0 ] = DllStructGetData ( $TRECT , "Left" )
	$ARECT [ 1 ] = DllStructGetData ( $TRECT , "Top" )
	$ARECT [ 2 ] = DllStructGetData ( $TRECT , "Right" )
	$ARECT [ 3 ] = DllStructGetData ( $TRECT , "Bottom" )
	Return $ARECT
EndFunc
Func _GUICTRLLISTVIEW_GETTEXTBKCOLOR ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETTEXTBKCOLOR )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETTEXTBKCOLOR , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETTEXTCOLOR ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETTEXTCOLOR )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETTEXTCOLOR , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETTOOLTIPS ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return HWnd ( _SENDMESSAGE ( $HWND , $LVM_GETTOOLTIPS ) )
	Else
		Return HWnd ( GUICtrlSendMsg ( $HWND , $LVM_GETTOOLTIPS , 0 , 0 ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETTOPINDEX ( $HWND )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETTOPINDEX )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETTOPINDEX , 0 , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND )
	If Not IsDllStruct ( $__G_TLISTVIEWBUFFER ) Then
		$__G_TLISTVIEWBUFFER = DllStructCreate ( "wchar Text[4096]" )
		$__G_TLISTVIEWBUFFERANSI = DllStructCreate ( "char Text[4096]" , DllStructGetPtr ( $__G_TLISTVIEWBUFFER ) )
	EndIf
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_GETUNICODEFORMAT ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_GETUNICODEFORMAT , 0 , 0 ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_GETVIEW ( $HWND )
	Local $IVIEW
	If IsHWnd ( $HWND ) Then
		$IVIEW = _SENDMESSAGE ( $HWND , $LVM_GETVIEW )
	Else
		$IVIEW = GUICtrlSendMsg ( $HWND , $LVM_GETVIEW , 0 , 0 )
	EndIf
	Switch $IVIEW
	Case $LV_VIEW_ICON
		Return Int ( $LV_VIEW_ICON )
	Case $LV_VIEW_DETAILS
		Return Int ( $LV_VIEW_DETAILS )
	Case $LV_VIEW_LIST
		Return Int ( $LV_VIEW_LIST )
	Case $LV_VIEW_SMALLICON
		Return Int ( $LV_VIEW_SMALLICON )
	Case $LV_VIEW_TILE
		Return Int ( $LV_VIEW_TILE )
Case Else
		Return + 4294967295
	EndSwitch
EndFunc
Func _GUICTRLLISTVIEW_GETVIEWDETAILS ( $HWND )
	Return _GUICTRLLISTVIEW_GETVIEW ( $HWND ) = $LV_VIEW_DETAILS
EndFunc
Func _GUICTRLLISTVIEW_GETVIEWLARGE ( $HWND )
	Return _GUICTRLLISTVIEW_GETVIEW ( $HWND ) = $LV_VIEW_ICON
EndFunc
Func _GUICTRLLISTVIEW_GETVIEWLIST ( $HWND )
	Return _GUICTRLLISTVIEW_GETVIEW ( $HWND ) = $LV_VIEW_LIST
EndFunc
Func _GUICTRLLISTVIEW_GETVIEWSMALL ( $HWND )
	Return _GUICTRLLISTVIEW_GETVIEW ( $HWND ) = $LV_VIEW_SMALLICON
EndFunc
Func _GUICTRLLISTVIEW_GETVIEWTILE ( $HWND )
	Return _GUICTRLLISTVIEW_GETVIEW ( $HWND ) = $LV_VIEW_TILE
EndFunc
Func _GUICTRLLISTVIEW_GETVIEWRECT ( $HWND )
	Local $ARECT [ 4 ] = [ 0 , 0 , 0 , 0 ]
	Local $IVIEW = _GUICTRLLISTVIEW_GETVIEW ( $HWND )
	If ( $IVIEW < 0 ) And ( $IVIEW > 4 ) Then Return $ARECT
	Local $TRECT = DllStructCreate ( $TAGRECT )
	__GUICTRL_SENDMSG ( $HWND , $LVM_GETVIEWRECT , 0 , $TRECT , 0 , True , + 4294967295 )
	$ARECT [ 0 ] = DllStructGetData ( $TRECT , "Left" )
	$ARECT [ 1 ] = DllStructGetData ( $TRECT , "Top" )
	$ARECT [ 2 ] = DllStructGetData ( $TRECT , "Right" )
	$ARECT [ 3 ] = DllStructGetData ( $TRECT , "Bottom" )
	Return $ARECT
EndFunc
Func _GUICTRLLISTVIEW_HIDECOLUMN ( $HWND , $ICOL )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETCOLUMNWIDTH , $ICOL ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETCOLUMNWIDTH , $ICOL , 0 ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_HITTEST ( $HWND , $IX = + 4294967295 , $IY = + 4294967295 )
	Local $IMODE = Opt ( "MouseCoordMode" , 1 )
	Local $APOS = MouseGetPos ( )
	Opt ( "MouseCoordMode" , $IMODE )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	DllStructSetData ( $TPOINT , "X" , $APOS [ 0 ] )
	DllStructSetData ( $TPOINT , "Y" , $APOS [ 1 ] )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ScreenToClient" , "hwnd" , $HWND , "struct*" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 0 Then Return 0
	If $IX = + 4294967295 Then $IX = DllStructGetData ( $TPOINT , "X" )
	If $IY = + 4294967295 Then $IY = DllStructGetData ( $TPOINT , "Y" )
	Local $TTEST = DllStructCreate ( $TAGLVHITTESTINFO )
	DllStructSetData ( $TTEST , "X" , $IX )
	DllStructSetData ( $TTEST , "Y" , $IY )
	Local $ATEST [ 10 ]
	$ATEST [ 0 ] = __GUICTRL_SENDMSG ( $HWND , $LVM_HITTEST , 0 , $TTEST , 0 , True , + 4294967295 )
	Local $IFLAGS = DllStructGetData ( $TTEST , "Flags" )
	$ATEST [ 1 ] = BitAND ( $IFLAGS , $LVHT_NOWHERE ) <> 0
	$ATEST [ 2 ] = BitAND ( $IFLAGS , $LVHT_ONITEMICON ) <> 0
	$ATEST [ 3 ] = BitAND ( $IFLAGS , $LVHT_ONITEMLABEL ) <> 0
	$ATEST [ 4 ] = BitAND ( $IFLAGS , $LVHT_ONITEMSTATEICON ) <> 0
	$ATEST [ 5 ] = BitAND ( $IFLAGS , $LVHT_ONITEM ) <> 0
	$ATEST [ 6 ] = BitAND ( $IFLAGS , $LVHT_ABOVE ) <> 0
	$ATEST [ 7 ] = BitAND ( $IFLAGS , $LVHT_BELOW ) <> 0
	$ATEST [ 8 ] = BitAND ( $IFLAGS , $LVHT_TOLEFT ) <> 0
	$ATEST [ 9 ] = BitAND ( $IFLAGS , $LVHT_TORIGHT ) <> 0
	Return $ATEST
EndFunc
Func __GUICTRLLISTVIEW_INDEXTOOVERLAYIMAGEMASK ( $IINDEX )
	Return BitShift ( $IINDEX , + 4294967288 )
EndFunc
Func __GUICTRLLISTVIEW_INDEXTOSTATEIMAGEMASK ( $IINDEX )
	Return BitShift ( $IINDEX , + 4294967284 )
EndFunc
Func _GUICTRLLISTVIEW_INSERTCOLUMN ( $HWND , $IINDEX , $STEXT , $IWIDTH = 50 , $IALIGN = + 4294967295 , $IIMAGE = + 4294967295 , $BONRIGHT = False )
	Local $AALIGN [ 3 ] = [ $LVCFMT_LEFT , $LVCFMT_RIGHT , $LVCFMT_CENTER ]
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_INSERTCOLUMNW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_INSERTCOLUMNA
	EndIf
	Local $TCOLUMN = DllStructCreate ( $TAGLVCOLUMN )
	Local $IMASK = BitOR ( $LVCF_FMT , $LVCF_WIDTH , $LVCF_TEXT )
	If $IALIGN < 0 Or $IALIGN > 2 Then $IALIGN = 0
	Local $IFMT = $AALIGN [ $IALIGN ]
	If $IIMAGE <> + 4294967295 Then
		$IMASK = BitOR ( $IMASK , $LVCF_IMAGE )
		$IFMT = BitOR ( $IFMT , $LVCFMT_COL_HAS_IMAGES , $LVCFMT_IMAGE )
	EndIf
	If $BONRIGHT Then $IFMT = BitOR ( $IFMT , $LVCFMT_BITMAP_ON_RIGHT )
	DllStructSetData ( $TBUFFER , 1 , $STEXT )
	DllStructSetData ( $TCOLUMN , "Mask" , $IMASK )
	DllStructSetData ( $TCOLUMN , "Fmt" , $IFMT )
	DllStructSetData ( $TCOLUMN , "CX" , $IWIDTH )
	DllStructSetData ( $TCOLUMN , "Image" , $IIMAGE )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TCOLUMN , $TBUFFER , False , 4 )
	If $IALIGN > 0 Then _GUICTRLLISTVIEW_SETCOLUMN ( $HWND , $IRET , $STEXT , $IWIDTH , $IALIGN , $IIMAGE , $BONRIGHT )
	Return $IRET
EndFunc
Func _GUICTRLLISTVIEW_INSERTGROUP ( $HWND , $IINDEX , $IGROUPID , $SHEADER , $IALIGN = 0 )
	Local $AALIGN [ 3 ] = [ $LVGA_HEADER_LEFT , $LVGA_HEADER_CENTER , $LVGA_HEADER_RIGHT ]
	If $IALIGN < 0 Or $IALIGN > 2 Then $IALIGN = 0
	Local $THEADER = _WINAPI_MULTIBYTETOWIDECHAR ( $SHEADER )
	Local $TGROUP = DllStructCreate ( $TAGLVGROUP )
	Local $IMASK = BitOR ( $LVGF_HEADER , $LVGF_ALIGN , $LVGF_GROUPID )
	DllStructSetData ( $TGROUP , "Size" , DllStructGetSize ( $TGROUP ) )
	DllStructSetData ( $TGROUP , "Mask" , $IMASK )
	DllStructSetData ( $TGROUP , "GroupID" , $IGROUPID )
	DllStructSetData ( $TGROUP , "Align" , $AALIGN [ $IALIGN ] )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_INSERTGROUP , $IINDEX , $TGROUP , $THEADER , False , 3 )
	Return $IRET
EndFunc
Func _GUICTRLLISTVIEW_INSERTITEM ( $HWND , $STEXT , $IINDEX = + 4294967295 , $IIMAGE = + 4294967295 , $IPARAM = 0 )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_INSERTITEMW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_INSERTITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	If $IINDEX = + 4294967295 Then $IINDEX = 999999999
	DllStructSetData ( $TBUFFER , 1 , $STEXT )
	Local $IMASK = BitOR ( $LVIF_TEXT , $LVIF_PARAM )
	If $IIMAGE >= 0 Then $IMASK = BitOR ( $IMASK , $LVIF_IMAGE )
	DllStructSetData ( $TITEM , "Mask" , $IMASK )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "Image" , $IIMAGE )
	DllStructSetData ( $TITEM , "Param" , $IPARAM )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , $TBUFFER , False , 6 )
	Return $IRET
EndFunc
Func _GUICTRLLISTVIEW_INSERTMARKHITTEST ( $HWND , $IX = + 4294967295 , $IY = + 4294967295 )
	Local $IMODE = Opt ( "MouseCoordMode" , 1 )
	Local $APOS = MouseGetPos ( )
	Opt ( "MouseCoordMode" , $IMODE )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	DllStructSetData ( $TPOINT , "X" , $APOS [ 0 ] )
	DllStructSetData ( $TPOINT , "Y" , $APOS [ 1 ] )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ScreenToClient" , "hwnd" , $HWND , "struct*" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 0 Then Return 0
	If $IX = + 4294967295 Then $IX = DllStructGetData ( $TPOINT , "X" )
	If $IY = + 4294967295 Then $IY = DllStructGetData ( $TPOINT , "Y" )
	Local $TMARK = DllStructCreate ( $TAGLVINSERTMARK )
	DllStructSetData ( $TPOINT , "X" , $IX )
	DllStructSetData ( $TPOINT , "Y" , $IY )
	DllStructSetData ( $TMARK , "Size" , DllStructGetSize ( $TMARK ) )
	__GUICTRL_SENDMSG ( $HWND , $LVM_INSERTMARKHITTEST , DllStructGetPtr ( $TPOINT ) , $TMARK , $TPOINT , True , + 4294967295 , False , 0 )
	Local $ATEST [ 2 ]
	$ATEST [ 0 ] = DllStructGetData ( $TMARK , "Flags" ) = $LVIM_AFTER
	$ATEST [ 1 ] = DllStructGetData ( $TMARK , "Item" )
	Return $ATEST
EndFunc
Func _GUICTRLLISTVIEW_ISITEMVISIBLE ( $HWND , $IINDEX )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_ISITEMVISIBLE , $IINDEX ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_ISITEMVISIBLE , $IINDEX , 0 ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_JUSTIFYCOLUMN ( $HWND , $IINDEX , $IALIGN = + 4294967295 )
	Local $AALIGN [ 3 ] = [ $LVCFMT_LEFT , $LVCFMT_RIGHT , $LVCFMT_CENTER ]
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $LVM_SETCOLUMNW
	Else
		$IMSG = $LVM_SETCOLUMNA
	EndIf
	Local $TCOLUMN = DllStructCreate ( $TAGLVCOLUMN )
	If $IALIGN < 0 Or $IALIGN > 2 Then $IALIGN = 0
	Local $IMASK = $LVCF_FMT
	Local $IFMT = $AALIGN [ $IALIGN ]
	DllStructSetData ( $TCOLUMN , "Mask" , $IMASK )
	DllStructSetData ( $TCOLUMN , "Fmt" , $IFMT )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TCOLUMN , 0 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_MAPIDTOINDEX ( $HWND , $IID )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_MAPIDTOINDEX , $IID )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_MAPIDTOINDEX , $IID , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_MAPINDEXTOID ( $HWND , $IINDEX )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_MAPINDEXTOID , $IINDEX )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_MAPINDEXTOID , $IINDEX , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_MOVEGROUP ( $HWND , $IGROUPID , $IINDEX = + 4294967295 )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_MOVEGROUP , $IGROUPID , $IINDEX )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_MOVEGROUP , $IGROUPID , $IINDEX )
	EndIf
EndFunc
Func __GUICTRLLISTVIEW_OVERLAYIMAGEMASKTOINDEX ( $IMASK )
	Return BitShift ( BitAND ( $LVIS_OVERLAYMASK , $IMASK ) , 8 )
EndFunc
Func _GUICTRLLISTVIEW_REDRAWITEMS ( $HWND , $IFIRST , $ILAST )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_REDRAWITEMS , $IFIRST , $ILAST ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_REDRAWITEMS , $IFIRST , $ILAST ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_REGISTERSORTCALLBACK ( $HWND , $VCOMPARETYPE = 1 , $BARROWS = True , $SPRIVATECALLBACK = "__GUICtrlListView_Sort" )
	#Au3Stripper_Ignore_Funcs=$sPrivateCallBack
	If IsBool ( $VCOMPARETYPE ) Then $VCOMPARETYPE = ( $VCOMPARETYPE ) ? 1 : 0
	Local $HHEADER = _GUICTRLLISTVIEW_GETHEADER ( $HWND )
	ReDim $__G_ALISTVIEWSORTINFO [ UBound ( $__G_ALISTVIEWSORTINFO ) + 1 ] [ $__LISTVIEWCONSTANT_SORTINFOSIZE ]
	$__G_ALISTVIEWSORTINFO [ 0 ] [ 0 ] = UBound ( $__G_ALISTVIEWSORTINFO ) + 4294967295
	Local $IINDEX = $__G_ALISTVIEWSORTINFO [ 0 ] [ 0 ]
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 0 ] = _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 1 ] = $HWND
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 2 ] = DllCallbackRegister ( $SPRIVATECALLBACK , "int" , "int;int;hwnd" )
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 3 ] = + 4294967295
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 4 ] = + 4294967295
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 5 ] = 1
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 6 ] = + 4294967295
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 7 ] = 0
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 8 ] = $VCOMPARETYPE
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 9 ] = $BARROWS
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 10 ] = $HHEADER
	Return $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 2 ] <> 0
EndFunc
Func _GUICTRLLISTVIEW_REMOVEALLGROUPS ( $HWND )
	_GUICTRLLISTVIEW_BEGINUPDATE ( $HWND )
	Local $IGROUPID
	For $X = _GUICTRLLISTVIEW_GETGROUPCOUNT ( $HWND ) + 4294967295 To 0 Step + 4294967295
		$IGROUPID = _GUICTRLLISTVIEW_GETGROUPINFOBYINDEX ( $HWND , $X ) [ 2 ]
		_GUICTRLLISTVIEW_REMOVEGROUP ( $HWND , $IGROUPID )
	Next
	_GUICTRLLISTVIEW_ENDUPDATE ( $HWND )
EndFunc
Func _GUICTRLLISTVIEW_REMOVEGROUP ( $HWND , $IGROUPID )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_REMOVEGROUP , $IGROUPID )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_REMOVEGROUP , $IGROUPID , 0 )
	EndIf
EndFunc
Func __GUICTRLLISTVIEW_REVERSECOLORORDER ( $ICOLOR )
	Local $SH = Hex ( String ( $ICOLOR ) , 6 )
	Return "0x" & StringMid ( $SH , 5 , 2 ) & StringMid ( $SH , 3 , 2 ) & StringMid ( $SH , 1 , 2 )
EndFunc
Func _GUICTRLLISTVIEW_SCROLL ( $HWND , $IDX , $IDY )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SCROLL , $IDX , $IDY ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SCROLL , $IDX , $IDY ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETBKCOLOR ( $HWND , $ICOLOR )
	Local $IRET
	If IsHWnd ( $HWND ) Then
		$IRET = _SENDMESSAGE ( $HWND , $LVM_SETBKCOLOR , 0 , $ICOLOR )
	Else
		$IRET = GUICtrlSendMsg ( $HWND , $LVM_SETBKCOLOR , 0 , $ICOLOR )
	EndIf
	_WINAPI_INVALIDATERECT ( $HWND )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETBKHBITMAP ( $HWND , $HBITMAP , $ISTYLE = 0 , $IXOFFSET = 0 , $IYOFFSET = 0 , $BDELETEBITMAP = False )
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $LVM_SETBKIMAGEW
	Else
		$IMSG = $LVM_SETBKIMAGEA
	EndIf
	Local $IFLAGS = BitOR ( $LVBKIF_STYLE_TILE , $LVBKIF_FLAG_TILEOFFSET )
	If $IXOFFSET = Default Then $IXOFFSET = 0
	If $IYOFFSET = Default Then $IYOFFSET = 0
	If IsPtr ( $HBITMAP ) Then
		If ( Not $ISTYLE ) Or ( $ISTYLE = Default ) Then
			$IFLAGS = $LVBKIF_STYLE_NORMAL
		Else
			$IXOFFSET *= + 4294967295
			$IYOFFSET *= + 4294967295
		EndIf
		$IFLAGS = BitOR ( $IFLAGS , $LVBKIF_SOURCE_HBITMAP )
	Else
		$IFLAGS = $LVBKIF_SOURCE_NONE
	EndIf
	Local $TLVBKIMAGE = DllStructCreate ( $TAGLVBKIMAGE )
	Local $PLVBKIMAGE = DllStructGetPtr ( $TLVBKIMAGE )
	DllStructSetData ( $TLVBKIMAGE , "Flags" , $IFLAGS )
	DllStructSetData ( $TLVBKIMAGE , "hBmp" , $HBITMAP )
	DllStructSetData ( $TLVBKIMAGE , "XOffPercent" , $IXOFFSET )
	DllStructSetData ( $TLVBKIMAGE , "YOffPercent" , $IYOFFSET )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $PLVBKIMAGE )
	If $BDELETEBITMAP And $IRET Then DllCall ( "gdi32.dll" , "bool" , "DeleteObject" , "handle" , $HBITMAP )
	If $IFLAGS = $LVBKIF_SOURCE_NONE Then Return True
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETBKIMAGE ( $HWND , $SURL = "" , $ISTYLE = 0 , $IXOFFSET = 0 , $IYOFFSET = 0 )
	Local $ASTYLE [ 2 ] = [ $LVBKIF_STYLE_NORMAL , $LVBKIF_STYLE_TILE ]
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_SETBKIMAGEW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_SETBKIMAGEA
	EndIf
	Local $TIMAGE = DllStructCreate ( $TAGLVBKIMAGE )
	Local $IFLAGS = 0
	If $SURL <> "" Then $IFLAGS = $LVBKIF_SOURCE_URL
	$IFLAGS = BitOR ( $IFLAGS , $ASTYLE [ $ISTYLE ] )
	DllStructSetData ( $TBUFFER , 1 , $SURL )
	DllStructSetData ( $TIMAGE , "Flags" , $IFLAGS )
	DllStructSetData ( $TIMAGE , "XOffPercent" , $IXOFFSET )
	DllStructSetData ( $TIMAGE , "YOffPercent" , $IYOFFSET )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TIMAGE , $TBUFFER , False , 3 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETCALLBACKMASK ( $HWND , $IMASK )
	Local $IFLAGS = 0
	If BitAND ( $IMASK , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVIS_CUT )
	If BitAND ( $IMASK , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVIS_DROPHILITED )
	If BitAND ( $IMASK , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVIS_FOCUSED )
	If BitAND ( $IMASK , 8 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVIS_SELECTED )
	If BitAND ( $IMASK , 16 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVIS_OVERLAYMASK )
	If BitAND ( $IMASK , 32 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $LVIS_STATEIMAGEMASK )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETCALLBACKMASK , $IFLAGS ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETCALLBACKMASK , $IFLAGS , 0 ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETCOLUMN ( $HWND , $IINDEX , $STEXT , $IWIDTH = + 4294967295 , $IALIGN = + 4294967295 , $IIMAGE = + 4294967295 , $BONRIGHT = False )
	Local $AALIGN [ 3 ] = [ $LVCFMT_LEFT , $LVCFMT_RIGHT , $LVCFMT_CENTER ]
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_SETCOLUMNW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_SETCOLUMNA
	EndIf
	Local $TCOLUMN = DllStructCreate ( $TAGLVCOLUMN )
	Local $IMASK = $LVCF_TEXT
	If $IALIGN < 0 Or $IALIGN > 2 Then $IALIGN = 0
	$IMASK = BitOR ( $IMASK , $LVCF_FMT )
	Local $IFMT = $AALIGN [ $IALIGN ]
	If $IWIDTH <> + 4294967295 Then $IMASK = BitOR ( $IMASK , $LVCF_WIDTH )
	If $IIMAGE <> + 4294967295 Then
		$IMASK = BitOR ( $IMASK , $LVCF_IMAGE )
		$IFMT = BitOR ( $IFMT , $LVCFMT_COL_HAS_IMAGES , $LVCFMT_IMAGE )
	Else
		$IIMAGE = 0
	EndIf
	If $BONRIGHT Then $IFMT = BitOR ( $IFMT , $LVCFMT_BITMAP_ON_RIGHT )
	DllStructSetData ( $TBUFFER , 1 , $STEXT )
	DllStructSetData ( $TCOLUMN , "Mask" , $IMASK )
	DllStructSetData ( $TCOLUMN , "Fmt" , $IFMT )
	DllStructSetData ( $TCOLUMN , "CX" , $IWIDTH )
	DllStructSetData ( $TCOLUMN , "Image" , $IIMAGE )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , $IINDEX , $TCOLUMN , $TBUFFER , False , 4 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETCOLUMNORDER ( $HWND , $SORDER )
	Local $SSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" )
	Return _GUICTRLLISTVIEW_SETCOLUMNORDERARRAY ( $HWND , StringSplit ( $SORDER , $SSEPARATORCHAR ) )
EndFunc
Func _GUICTRLLISTVIEW_SETCOLUMNORDERARRAY ( $HWND , $AORDER )
	Local $TORDERS = DllStructCreate ( "int[" & $AORDER [ 0 ] & "]" )
	For $II = 1 To $AORDER [ 0 ]
		DllStructSetData ( $TORDERS , 1 , $AORDER [ $II ] , $II )
	Next
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_SETCOLUMNORDERARRAY , $AORDER [ 0 ] , $TORDERS , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETCOLUMNWIDTH ( $HWND , $ICOL , $IWIDTH )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETCOLUMNWIDTH , $ICOL , $IWIDTH )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETCOLUMNWIDTH , $ICOL , $IWIDTH )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETEXTENDEDLISTVIEWSTYLE ( $HWND , $IEXSTYLE , $IEXMASK = 0 )
	Local $IRET
	If IsHWnd ( $HWND ) Then
		$IRET = _SENDMESSAGE ( $HWND , $LVM_SETEXTENDEDLISTVIEWSTYLE , $IEXMASK , $IEXSTYLE )
	Else
		$IRET = GUICtrlSendMsg ( $HWND , $LVM_SETEXTENDEDLISTVIEWSTYLE , $IEXMASK , $IEXSTYLE )
	EndIf
	_WINAPI_INVALIDATERECT ( $HWND )
	Return $IRET
EndFunc
Func _GUICTRLLISTVIEW_SETGROUPINFO ( $HWND , $IGROUPID , $SHEADER , $IALIGN = 0 , $ISTATE = $LVGS_NORMAL )
	Local $TGROUP = 0
	If BitAND ( $ISTATE , $LVGS_SELECTED ) Then
		$TGROUP = __GUICTRLLISTVIEW_GETGROUPINFOEX ( $HWND , $IGROUPID , BitOR ( $LVGF_GROUPID , $LVGF_ITEMS ) )
		If @error Or DllStructGetData ( $TGROUP , "cItems" ) = 0 Then Return False
	EndIf
	Local $AALIGN [ 3 ] = [ $LVGA_HEADER_LEFT , $LVGA_HEADER_CENTER , $LVGA_HEADER_RIGHT ]
	If $IALIGN < 0 Or $IALIGN > 2 Then $IALIGN = 0
	Local $THEADER = _WINAPI_MULTIBYTETOWIDECHAR ( $SHEADER )
	$TGROUP = DllStructCreate ( $TAGLVGROUP )
	Local $IMASK = BitOR ( $LVGF_HEADER , $LVGF_ALIGN , $LVGF_STATE )
	DllStructSetData ( $TGROUP , "Size" , DllStructGetSize ( $TGROUP ) )
	DllStructSetData ( $TGROUP , "Mask" , $IMASK )
	DllStructSetData ( $TGROUP , "Align" , $AALIGN [ $IALIGN ] )
	DllStructSetData ( $TGROUP , "State" , $ISTATE )
	DllStructSetData ( $TGROUP , "StateMask" , $ISTATE )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_SETGROUPINFO , $IGROUPID , $TGROUP , $THEADER , False , 3 )
	DllStructSetData ( $TGROUP , "Mask" , $LVGF_GROUPID )
	DllStructSetData ( $TGROUP , "GroupID" , $IGROUPID )
	__GUICTRL_SENDMSG ( $HWND , $LVM_SETGROUPINFO , 0 , $TGROUP , 0 , False , + 4294967295 )
	_WINAPI_INVALIDATERECT ( $HWND )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETHOTCURSOR ( $HWND , $HCURSOR )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETHOTCURSOR , 0 , $HCURSOR , 0 , "wparam" , "handle" , "handle" )
	Else
		Return Ptr ( GUICtrlSendMsg ( $HWND , $LVM_SETHOTCURSOR , 0 , $HCURSOR ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETHOTITEM ( $HWND , $IINDEX )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETHOTITEM , $IINDEX )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETHOTITEM , $IINDEX , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETHOVERTIME ( $HWND , $ITIME )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETHOVERTIME , 0 , $ITIME )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETHOVERTIME , 0 , $ITIME )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETICONSPACING ( $HWND , $ICX , $ICY )
	Local $IRET , $APADDING [ 2 ]
	If IsHWnd ( $HWND ) Then
		$IRET = _SENDMESSAGE ( $HWND , $LVM_SETICONSPACING , 0 , _WINAPI_MAKELONG ( $ICX , $ICY ) )
	Else
		$IRET = GUICtrlSendMsg ( $HWND , $LVM_SETICONSPACING , 0 , _WINAPI_MAKELONG ( $ICX , $ICY ) )
	EndIf
	_WINAPI_INVALIDATERECT ( $HWND )
	$APADDING [ 0 ] = BitAND ( $IRET , 65535 )
	$APADDING [ 1 ] = BitShift ( $IRET , 16 )
	Return $APADDING
EndFunc
Func _GUICTRLLISTVIEW_SETIMAGELIST ( $HWND , $HHANDLE , $ITYPE = 0 )
	$ITYPE = Int ( $ITYPE )
	If $ITYPE < 0 Or $ITYPE > 2 Then
		$ITYPE = 0
	EndIf
	Local $ATYPE [ 3 ] = [ $LVSIL_NORMAL , $LVSIL_SMALL , $LVSIL_STATE ]
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETIMAGELIST , $ATYPE [ $ITYPE ] , $HHANDLE , 0 , "wparam" , "handle" , "handle" )
	Else
		Return Ptr ( GUICtrlSendMsg ( $HWND , $LVM_SETIMAGELIST , $ATYPE [ $ITYPE ] , $HHANDLE ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETINFOTIP ( $HWND , $IINDEX , $STEXT , $ISUBITEM = 0 )
	Local $TBUFFER = _WINAPI_MULTIBYTETOWIDECHAR ( $STEXT )
	Local $TINFO = DllStructCreate ( $TAGLVSETINFOTIP )
	DllStructSetData ( $TINFO , "Size" , DllStructGetSize ( $TINFO ) )
	DllStructSetData ( $TINFO , "Item" , $IINDEX )
	DllStructSetData ( $TINFO , "SubItem" , $ISUBITEM )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_SETINFOTIP , 0 , $TINFO , $TBUFFER , False , 3 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETINSERTMARK ( $HWND , $IINDEX , $BAFTER = False )
	Local $TMARK = DllStructCreate ( $TAGLVINSERTMARK )
	DllStructSetData ( $TMARK , "Size" , DllStructGetSize ( $TMARK ) )
	If $BAFTER Then DllStructSetData ( $TMARK , "Flags" , $LVIM_AFTER )
	DllStructSetData ( $TMARK , "Item" , $IINDEX )
	DllStructSetData ( $TMARK , "Reserved" , 0 )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_SETINSERTMARK , 0 , $TMARK , 0 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETINSERTMARKCOLOR ( $HWND , $ICOLOR )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETINSERTMARKCOLOR , 0 , $ICOLOR )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETINSERTMARKCOLOR , 0 , $ICOLOR )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETITEM ( $HWND , $STEXT , $IINDEX = 0 , $ISUBITEM = 0 , $IIMAGE = + 4294967295 , $IPARAM = + 4294967295 , $IINDENT = + 4294967295 )
	Local $PBUFFER , $IBUFFER
	If $STEXT <> + 4294967295 Then
		Local $TBUFFER
		If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
			$TBUFFER = $__G_TLISTVIEWBUFFER
		Else
			$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		EndIf
		$PBUFFER = DllStructGetPtr ( $TBUFFER )
		$IBUFFER = DllStructGetSize ( $TBUFFER )
		DllStructSetData ( $TBUFFER , "Text" , $STEXT )
	Else
		$PBUFFER = + 4294967295
		$IBUFFER = 0
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	Local $IMASK = $LVIF_TEXT
	If $IIMAGE <> + 4294967295 Then $IMASK = BitOR ( $IMASK , $LVIF_IMAGE )
	If $IPARAM <> + 4294967295 Then $IMASK = BitOR ( $IMASK , $LVIF_PARAM )
	If $IINDENT <> + 4294967295 Then $IMASK = BitOR ( $IMASK , $LVIF_INDENT )
	DllStructSetData ( $TITEM , "Mask" , $IMASK )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	DllStructSetData ( $TITEM , "Text" , $PBUFFER )
	DllStructSetData ( $TITEM , "TextMax" , $IBUFFER )
	DllStructSetData ( $TITEM , "Image" , $IIMAGE )
	DllStructSetData ( $TITEM , "Param" , $IPARAM )
	DllStructSetData ( $TITEM , "Indent" , $IINDENT )
	Return _GUICTRLLISTVIEW_SETITEMEX ( $HWND , $TITEM )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMCHECKED ( $HWND , $IINDEX , $BCHECK = True )
	Local $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$IMSG = $LVM_SETITEMW
	Else
		$IMSG = $LVM_SETITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	If ( $BCHECK ) Then
		DllStructSetData ( $TITEM , "State" , 8192 )
	Else
		DllStructSetData ( $TITEM , "State" , 4096 )
	EndIf
	DllStructSetData ( $TITEM , "StateMask" , 61440 )
	DllStructSetData ( $TITEM , "Mask" , $LVIF_STATE )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	Local $IINDEXMAX = $IINDEX
	If $IINDEX = + 4294967295 Then
		$IINDEX = 0
		$IINDEXMAX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND ) + 4294967295
	EndIf
	Local $IRET
	For $X = $IINDEX To $IINDEXMAX
		DllStructSetData ( $TITEM , "Item" , $X )
		$IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , 0 , False , + 4294967295 )
		If $IRET = 0 Then ExitLoop
	Next
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETITEMCOUNT ( $HWND , $IITEMS )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETITEMCOUNT , $IITEMS , BitOR ( $LVSICF_NOINVALIDATEALL , $LVSICF_NOSCROLL ) ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETITEMCOUNT , $IITEMS , BitOR ( $LVSICF_NOINVALIDATEALL , $LVSICF_NOSCROLL ) ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETITEMCUT ( $HWND , $IINDEX , $BENABLED = True )
	Local $ISTATE = 0
	If $BENABLED Then $ISTATE = $LVIS_CUT
	Return _GUICTRLLISTVIEW_SETITEMSTATE ( $HWND , $IINDEX , $ISTATE , $LVIS_CUT )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMDROPHILITED ( $HWND , $IINDEX , $BENABLED = True )
	Local $ISTATE = 0
	If $BENABLED Then $ISTATE = $LVIS_DROPHILITED
	Return _GUICTRLLISTVIEW_SETITEMSTATE ( $HWND , $IINDEX , $ISTATE , $LVIS_DROPHILITED )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMEX ( $HWND , ByRef $TITEM , $INESTED = 0 )
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_SETITEMW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_SETITEMA
	EndIf
	Local $IBUFFER = 0
	If $INESTED Then
		$TBUFFER = 0
		DllStructSetData ( $TITEM , "Text" , 0 )
	Else
		If DllStructGetData ( $TITEM , "Text" ) <> + 4294967295 Then
			$IBUFFER = DllStructGetSize ( $TBUFFER )
		Else
		EndIf
	EndIf
	DllStructSetData ( $TITEM , "TextMax" , $IBUFFER )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , $TBUFFER , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETITEMFOCUSED ( $HWND , $IINDEX , $BENABLED = True )
	Local $ISTATE = 0
	If $BENABLED Then $ISTATE = $LVIS_FOCUSED
	Return _GUICTRLLISTVIEW_SETITEMSTATE ( $HWND , $IINDEX , $ISTATE , $LVIS_FOCUSED )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMGROUPID ( $HWND , $IINDEX , $IGROUPID )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_GROUPID )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "GroupID" , $IGROUPID )
	Return _GUICTRLLISTVIEW_SETITEMEX ( $HWND , $TITEM , 1 )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMIMAGE ( $HWND , $IINDEX , $IIMAGE , $ISUBITEM = 0 )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_IMAGE )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	DllStructSetData ( $TITEM , "Image" , $IIMAGE )
	Return _GUICTRLLISTVIEW_SETITEMEX ( $HWND , $TITEM , 1 )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMINDENT ( $HWND , $IINDEX , $IINDENT )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_INDENT )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "Indent" , $IINDENT )
	Local $IRET = _GUICTRLLISTVIEW_SETITEMEX ( $HWND , $TITEM , 1 )
	_WINAPI_INVALIDATERECT ( $HWND )
	Return $IRET
EndFunc
Func __GUICTRLLISTVIEW_SETITEMOVERLAYIMAGE ( $HWND , $IINDEX , $IIMAGE )
	Return _GUICTRLLISTVIEW_SETITEMSTATE ( $HWND , $IINDEX , __GUICTRLLISTVIEW_INDEXTOOVERLAYIMAGEMASK ( $IIMAGE ) , $LVIS_OVERLAYMASK )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMPARAM ( $HWND , $IINDEX , $IPARAM )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_PARAM )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "Param" , $IPARAM )
	Return _GUICTRLLISTVIEW_SETITEMEX ( $HWND , $TITEM , 1 )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMPOSITION ( $HWND , $IINDEX , $ICX , $ICY )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETITEMPOSITION , $IINDEX , _WINAPI_MAKELONG ( $ICX , $ICY ) ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETITEMPOSITION , $IINDEX , _WINAPI_MAKELONG ( $ICX , $ICY ) ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETITEMPOSITION32 ( $HWND , $IINDEX , $ICX , $ICY )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	DllStructSetData ( $TPOINT , "X" , $ICX )
	DllStructSetData ( $TPOINT , "Y" , $ICY )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_SETITEMPOSITION32 , $IINDEX , $TPOINT , 0 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETITEMSELECTED ( $HWND , $IINDEX , $BSELECTED = True , $BFOCUSED = False )
	Local $TITEM = $__G_TLISTVIEWITEM
	Local $ISELECTED = 0 , $IFOCUSED = 0
	If ( $BSELECTED = True ) Then $ISELECTED = $LVIS_SELECTED
	If ( $BFOCUSED = True And $IINDEX <> + 4294967295 ) Then $IFOCUSED = $LVIS_FOCUSED
	DllStructSetData ( $TITEM , "Mask" , $LVIF_STATE )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "State" , BitOR ( $ISELECTED , $IFOCUSED ) )
	DllStructSetData ( $TITEM , "StateMask" , BitOR ( $LVIS_SELECTED , $IFOCUSED ) )
	Local $IRET = __GUICTRL_SENDMSG ( $HWND , $LVM_SETITEMSTATE , $IINDEX , $TITEM , 0 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETITEMSTATE ( $HWND , $IINDEX , $ISTATE , $ISTATEMASK )
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TITEM , "Mask" , $LVIF_STATE )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , 0 )
	DllStructSetData ( $TITEM , "State" , $ISTATE )
	DllStructSetData ( $TITEM , "StateMask" , $ISTATEMASK )
	Return _GUICTRLLISTVIEW_SETITEMEX ( $HWND , $TITEM , 1 ) <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETITEMSTATEIMAGE ( $HWND , $IINDEX , $IIMAGE )
	Return _GUICTRLLISTVIEW_SETITEMSTATE ( $HWND , $IINDEX , BitShift ( $IIMAGE , + 4294967284 ) , $LVIS_STATEIMAGEMASK )
EndFunc
Func _GUICTRLLISTVIEW_SETITEMTEXT ( $HWND , $IINDEX , $STEXT , $ISUBITEM = 0 )
	Local $IRET
	If $ISUBITEM = + 4294967295 Then
		Local $SSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" )
		Local $I_COLS = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND )
		Local $A_TEXT = StringSplit ( $STEXT , $SSEPARATORCHAR )
		If $I_COLS > $A_TEXT [ 0 ] Then $I_COLS = $A_TEXT [ 0 ]
		For $I = 1 To $I_COLS
			$IRET = _GUICTRLLISTVIEW_SETITEMTEXT ( $HWND , $IINDEX , $A_TEXT [ $I ] , $I + 4294967295 )
			If Not $IRET Then ExitLoop
		Next
		Return $IRET
	EndIf
	Local $TBUFFER , $IMSG
	If _GUICTRLLISTVIEW_GETUNICODEFORMAT ( $HWND ) Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_SETITEMW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_SETITEMA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	DllStructSetData ( $TBUFFER , 1 , $STEXT )
	DllStructSetData ( $TITEM , "Mask" , $LVIF_TEXT )
	DllStructSetData ( $TITEM , "Item" , $IINDEX )
	DllStructSetData ( $TITEM , "SubItem" , $ISUBITEM )
	$IRET = __GUICTRL_SENDMSG ( $HWND , $IMSG , 0 , $TITEM , $TBUFFER , False , 6 , False , + 4294967295 )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETOUTLINECOLOR ( $HWND , $ICOLOR )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETOUTLINECOLOR , 0 , $ICOLOR )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETOUTLINECOLOR , 0 , $ICOLOR )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETSELECTEDCOLUMN ( $HWND , $ICOL )
	If IsHWnd ( $HWND ) Then
		_SENDMESSAGE ( $HWND , $LVM_SETSELECTEDCOLUMN , $ICOL )
	Else
		GUICtrlSendMsg ( $HWND , $LVM_SETSELECTEDCOLUMN , $ICOL , 0 )
	EndIf
	_WINAPI_INVALIDATERECT ( $HWND )
EndFunc
Func _GUICTRLLISTVIEW_SETSELECTIONMARK ( $HWND , $IINDEX )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETSELECTIONMARK , 0 , $IINDEX )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETSELECTIONMARK , 0 , $IINDEX )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETTEXTBKCOLOR ( $HWND , $ICOLOR )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETTEXTBKCOLOR , 0 , $ICOLOR ) <> 0
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETTEXTBKCOLOR , 0 , $ICOLOR ) <> 0
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETTEXTCOLOR ( $HWND , $ICOLOR )
	Local $IRET
	If IsHWnd ( $HWND ) Then
		$IRET = _SENDMESSAGE ( $HWND , $LVM_SETTEXTCOLOR , 0 , $ICOLOR )
	Else
		$IRET = GUICtrlSendMsg ( $HWND , $LVM_SETTEXTCOLOR , 0 , $ICOLOR )
	EndIf
	_WINAPI_INVALIDATERECT ( $HWND )
	Return $IRET <> 0
EndFunc
Func _GUICTRLLISTVIEW_SETTOOLTIPS ( $HWND , $HTOOLTIP )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETTOOLTIPS , 0 , $HTOOLTIP , 0 , "wparam" , "hwnd" , "hwnd" )
	Else
		Return HWnd ( GUICtrlSendMsg ( $HWND , $LVM_SETTOOLTIPS , 0 , $HTOOLTIP ) )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETUNICODEFORMAT ( $HWND , $BUNICODE )
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETUNICODEFORMAT , $BUNICODE )
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETUNICODEFORMAT , $BUNICODE , 0 )
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETVIEW ( $HWND , $IVIEW )
	Local $AVIEW [ 5 ] = [ $LV_VIEW_ICON , $LV_VIEW_DETAILS , $LV_VIEW_LIST , $LV_VIEW_SMALLICON , $LV_VIEW_TILE ]
	If ( $IVIEW < 0 ) Or ( $IVIEW > 4 ) Then Return False
	If IsHWnd ( $HWND ) Then
		Return _SENDMESSAGE ( $HWND , $LVM_SETVIEW , $AVIEW [ $IVIEW ] ) <> + 4294967295
	Else
		Return GUICtrlSendMsg ( $HWND , $LVM_SETVIEW , $AVIEW [ $IVIEW ] , 0 ) <> + 4294967295
	EndIf
EndFunc
Func _GUICTRLLISTVIEW_SETWORKAREAS ( $HWND , $ILEFT , $ITOP , $IRIGHT , $IBOTTOM )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , "Left" , $ILEFT )
	DllStructSetData ( $TRECT , "Top" , $ITOP )
	DllStructSetData ( $TRECT , "Right" , $IRIGHT )
	DllStructSetData ( $TRECT , "Bottom" , $IBOTTOM )
	__GUICTRL_SENDMSG ( $HWND , $LVM_SETWORKAREAS , 1 , $TRECT , 0 , False , + 4294967295 )
EndFunc
Func _GUICTRLLISTVIEW_SIMPLESORT ( $HWND , ByRef $VSORTSENSE , $ICOL , $BTOGGLESENSE = True )
	Local $IITEMCOUNT = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HWND )
	If $IITEMCOUNT Then
		Local $IDESCENDING = 0
		If UBound ( $VSORTSENSE ) Then
			$IDESCENDING = $VSORTSENSE [ $ICOL ]
		Else
			$IDESCENDING = $VSORTSENSE
		EndIf
		Local $VSEPARATORCHAR = Opt ( "GUIDataSeparatorChar" )
		Local $ICOLUMNCOUNT = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HWND )
		Local Enum $IINDEXVALUE = $ICOLUMNCOUNT , $IITEMPARAM
		Local $ALISTVIEWITEMS [ $IITEMCOUNT ] [ $ICOLUMNCOUNT + 2 ]
		Local $SSELECTEDITEMS = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HWND )
		Local $ASELECTEDITEMS [ 1 ] = [ 0 ]
		If Not $SSELECTEDITEMS = "" Then $ASELECTEDITEMS = StringSplit ( $SSELECTEDITEMS , $VSEPARATORCHAR )
		Local $ACHECKEDITEMS = __GUICTRLLISTVIEW_GETCHECKEDINDICES ( $HWND )
		Local $SITEMTEXT , $IFOCUSED = + 4294967295
		For $I = 0 To $IITEMCOUNT + 4294967295
			If $IFOCUSED = + 4294967295 Then
				If _GUICTRLLISTVIEW_GETITEMFOCUSED ( $HWND , $I ) Then $IFOCUSED = $I
			EndIf
			_GUICTRLLISTVIEW_SETITEMSELECTED ( $HWND , $I , False )
			_GUICTRLLISTVIEW_SETITEMCHECKED ( $HWND , $I , False )
			For $J = 0 To $ICOLUMNCOUNT + 4294967295
				$SITEMTEXT = StringStripWS ( _GUICTRLLISTVIEW_GETITEMTEXT ( $HWND , $I , $J ) , $STR_STRIPTRAILING )
				If ( StringIsFloat ( $SITEMTEXT ) Or StringIsInt ( $SITEMTEXT ) ) Then
					$ALISTVIEWITEMS [ $I ] [ $J ] = Number ( $SITEMTEXT )
				Else
					$ALISTVIEWITEMS [ $I ] [ $J ] = $SITEMTEXT
				EndIf
			Next
			$ALISTVIEWITEMS [ $I ] [ $IINDEXVALUE ] = $I
			$ALISTVIEWITEMS [ $I ] [ $IITEMPARAM ] = _GUICTRLLISTVIEW_GETITEMPARAM ( $HWND , $I )
		Next
		_ARRAYSORT ( $ALISTVIEWITEMS , $IDESCENDING , 0 , 0 , $ICOL )
		For $I = 0 To $IITEMCOUNT + 4294967295
			For $J = 0 To $ICOLUMNCOUNT + 4294967295
				_GUICTRLLISTVIEW_SETITEMTEXT ( $HWND , $I , $ALISTVIEWITEMS [ $I ] [ $J ] , $J )
			Next
			_GUICTRLLISTVIEW_SETITEMPARAM ( $HWND , $I , $ALISTVIEWITEMS [ $I ] [ $IITEMPARAM ] )
			For $J = 1 To $ASELECTEDITEMS [ 0 ]
				If $ALISTVIEWITEMS [ $I ] [ $IINDEXVALUE ] = $ASELECTEDITEMS [ $J ] Then
					If $ALISTVIEWITEMS [ $I ] [ $IINDEXVALUE ] = $IFOCUSED Then
						_GUICTRLLISTVIEW_SETITEMSELECTED ( $HWND , $I , True , True )
					Else
						_GUICTRLLISTVIEW_SETITEMSELECTED ( $HWND , $I , True )
					EndIf
					ExitLoop
				EndIf
			Next
			For $J = 1 To $ACHECKEDITEMS [ 0 ]
				If $ALISTVIEWITEMS [ $I ] [ $IINDEXVALUE ] = $ACHECKEDITEMS [ $J ] Then
					_GUICTRLLISTVIEW_SETITEMCHECKED ( $HWND , $I , True )
					ExitLoop
				EndIf
			Next
		Next
		If $BTOGGLESENSE Then
			If UBound ( $VSORTSENSE ) Then
				$VSORTSENSE [ $ICOL ] = Not $IDESCENDING
			Else
				$VSORTSENSE = Not $IDESCENDING
			EndIf
		EndIf
	EndIf
EndFunc
#Au3Stripper_Ignore_Funcs=__GUICtrlListView_Sort
Func __GUICTRLLISTVIEW_SORT ( $NITEM1 , $NITEM2 , $HWND )
	Local $IINDEX , $SVAL1 , $SVAL2 , $NRESULT
	Local $TBUFFER , $IMSG
	If $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 0 ] Then
		$TBUFFER = $__G_TLISTVIEWBUFFER
		$IMSG = $LVM_GETITEMTEXTW
	Else
		$TBUFFER = $__G_TLISTVIEWBUFFERANSI
		$IMSG = $LVM_GETITEMTEXTA
	EndIf
	Local $TITEM = $__G_TLISTVIEWITEM
	For $X = 1 To $__G_ALISTVIEWSORTINFO [ 0 ] [ 0 ]
		If $HWND = $__G_ALISTVIEWSORTINFO [ $X ] [ 1 ] Then
			$IINDEX = $X
			ExitLoop
		EndIf
	Next
	If $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 3 ] = $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 4 ] Then
		If Not $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 7 ] Then
			$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 5 ] *= + 4294967295
			$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 7 ] = 1
		EndIf
	Else
		$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 7 ] = 1
	EndIf
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 6 ] = $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 3 ]
	DllStructSetData ( $TITEM , "Mask" , $LVIF_TEXT )
	DllStructSetData ( $TITEM , "SubItem" , $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 3 ] )
	__GUICTRL_SENDMSG ( $HWND , $IMSG , $NITEM1 , $TITEM , $TBUFFER , False , 6 , True )
	$SVAL1 = DllStructGetData ( $TBUFFER , 1 )
	__GUICTRL_SENDMSG ( $HWND , $IMSG , $NITEM2 , $TITEM , $TBUFFER , False , 6 , True )
	$SVAL2 = DllStructGetData ( $TBUFFER , 1 )
	If $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 8 ] = 1 Then
		If ( StringIsFloat ( $SVAL1 ) Or StringIsInt ( $SVAL1 ) ) Then $SVAL1 = Number ( $SVAL1 )
		If ( StringIsFloat ( $SVAL2 ) Or StringIsInt ( $SVAL2 ) ) Then $SVAL2 = Number ( $SVAL2 )
	EndIf
	If $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 8 ] < 2 Then
		$NRESULT = 0
		If $SVAL1 < $SVAL2 Then
			$NRESULT = + 4294967295
		ElseIf $SVAL1 > $SVAL2 Then
			$NRESULT = 1
		EndIf
	Else
		$NRESULT = DllCall ( "shlwapi.dll" , "int" , "StrCmpLogicalW" , "wstr" , $SVAL1 , "wstr" , $SVAL2 ) [ 0 ]
	EndIf
	$NRESULT = $NRESULT * $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 5 ]
	Return $NRESULT
EndFunc
Func _GUICTRLLISTVIEW_SORTITEMS ( $HWND , $ICOL )
	Local $IRET , $IINDEX , $PFUNCTION , $HHEADER , $IFORMAT
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	For $X = 1 To $__G_ALISTVIEWSORTINFO [ 0 ] [ 0 ]
		If $HWND = $__G_ALISTVIEWSORTINFO [ $X ] [ 1 ] Then
			$IINDEX = $X
			ExitLoop
		EndIf
	Next
	$PFUNCTION = DllCallbackGetPtr ( $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 2 ] )
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 3 ] = $ICOL
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 7 ] = 0
	$__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 4 ] = $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 6 ]
	$IRET = _SENDMESSAGE ( $HWND , $LVM_SORTITEMSEX , $HWND , $PFUNCTION , 0 , "hwnd" , "ptr" )
	If $IRET <> 0 Then
		If $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 9 ] Then
			$HHEADER = $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 10 ]
			For $X = 0 To _GUICTRLHEADER_GETITEMCOUNT ( $HHEADER ) + 4294967295
				$IFORMAT = _GUICTRLHEADER_GETITEMFORMAT ( $HHEADER , $X )
				If BitAND ( $IFORMAT , $HDF_SORTDOWN ) Then
					_GUICTRLHEADER_SETITEMFORMAT ( $HHEADER , $X , BitXOR ( $IFORMAT , $HDF_SORTDOWN ) )
				ElseIf BitAND ( $IFORMAT , $HDF_SORTUP ) Then
					_GUICTRLHEADER_SETITEMFORMAT ( $HHEADER , $X , BitXOR ( $IFORMAT , $HDF_SORTUP ) )
				EndIf
			Next
			$IFORMAT = _GUICTRLHEADER_GETITEMFORMAT ( $HHEADER , $ICOL )
			If $__G_ALISTVIEWSORTINFO [ $IINDEX ] [ 5 ] = 1 Then
				_GUICTRLHEADER_SETITEMFORMAT ( $HHEADER , $ICOL , BitOR ( $IFORMAT , $HDF_SORTUP ) )
			Else
				_GUICTRLHEADER_SETITEMFORMAT ( $HHEADER , $ICOL , BitOR ( $IFORMAT , $HDF_SORTDOWN ) )
			EndIf
		EndIf
	EndIf
	Return $IRET <> 0
EndFunc
Func __GUICTRLLISTVIEW_STATEIMAGEMASKTOINDEX ( $IMASK )
	Return BitShift ( BitAND ( $IMASK , $LVIS_STATEIMAGEMASK ) , 12 )
EndFunc
Func _GUICTRLLISTVIEW_SUBITEMHITTEST ( $HWND , $IX = + 4294967295 , $IY = + 4294967295 )
	If $IX = + 4294967295 Then $IX = _WINAPI_GETMOUSEPOSX ( True , $HWND )
	If $IY = + 4294967295 Then $IY = _WINAPI_GETMOUSEPOSY ( True , $HWND )
	Local $TTEST = DllStructCreate ( $TAGLVHITTESTINFO )
	DllStructSetData ( $TTEST , "X" , $IX )
	DllStructSetData ( $TTEST , "Y" , $IY )
	__GUICTRL_SENDMSG ( $HWND , $LVM_SUBITEMHITTEST , 0 , $TTEST , 0 , True , + 4294967295 )
	Local $IFLAGS = DllStructGetData ( $TTEST , "Flags" )
	Local $ATEST [ 11 ]
	$ATEST [ 0 ] = DllStructGetData ( $TTEST , "Item" )
	$ATEST [ 1 ] = DllStructGetData ( $TTEST , "SubItem" )
	$ATEST [ 2 ] = BitAND ( $IFLAGS , $LVHT_NOWHERE ) <> 0
	$ATEST [ 3 ] = BitAND ( $IFLAGS , $LVHT_ONITEMICON ) <> 0
	$ATEST [ 4 ] = BitAND ( $IFLAGS , $LVHT_ONITEMLABEL ) <> 0
	$ATEST [ 5 ] = BitAND ( $IFLAGS , $LVHT_ONITEMSTATEICON ) <> 0
	$ATEST [ 6 ] = BitAND ( $IFLAGS , $LVHT_ONITEM ) <> 0
	$ATEST [ 7 ] = BitAND ( $IFLAGS , $LVHT_ABOVE ) <> 0
	$ATEST [ 8 ] = BitAND ( $IFLAGS , $LVHT_BELOW ) <> 0
	$ATEST [ 9 ] = BitAND ( $IFLAGS , $LVHT_TOLEFT ) <> 0
	$ATEST [ 10 ] = BitAND ( $IFLAGS , $LVHT_TORIGHT ) <> 0
	Return $ATEST
EndFunc
Func _GUICTRLLISTVIEW_UNREGISTERSORTCALLBACK ( $HWND )
	If Not IsHWnd ( $HWND ) Then $HWND = GUICtrlGetHandle ( $HWND )
	For $X = 1 To $__G_ALISTVIEWSORTINFO [ 0 ] [ 0 ]
		If $HWND = $__G_ALISTVIEWSORTINFO [ $X ] [ 1 ] Then
			DllCallbackFree ( $__G_ALISTVIEWSORTINFO [ $X ] [ 2 ] )
			__GUICTRLLISTVIEW_ARRAYDELETE ( $__G_ALISTVIEWSORTINFO , $X )
			$__G_ALISTVIEWSORTINFO [ 0 ] [ 0 ] -= 1
			ExitLoop
		EndIf
	Next
EndFunc
Global Const $COLOR_ALICEBLUE = 15792383
Global Const $COLOR_ANTIQUEWHITE = 16444375
Global Const $COLOR_AQUA = 65535
Global Const $COLOR_AQUAMARINE = 8388564
Global Const $COLOR_AZURE = 15794175
Global Const $COLOR_BEIGE = 16119260
Global Const $COLOR_BISQUE = 16770244
Global Const $COLOR_BLACK = 0
Global Const $COLOR_BLANCHEDALMOND = 16772045
Global Const $COLOR_BLUE = 255
Global Const $COLOR_BLUEVIOLET = 9055202
Global Const $COLOR_BROWN = 10824234
Global Const $COLOR_BURLYWOOD = 14596231
Global Const $COLOR_CADETBLUE = 6266528
Global Const $COLOR_CHARTREUSE = 8388352
Global Const $COLOR_CHOCOLATE = 13789470
Global Const $COLOR_CORAL = 16744272
Global Const $COLOR_CORNFLOWERBLUE = 6591981
Global Const $COLOR_CORNSILK = 16775388
Global Const $COLOR_CRIMSON = 14423100
Global Const $COLOR_CYAN = 65535
Global Const $COLOR_DARKBLUE = 139
Global Const $COLOR_DARKCYAN = 35723
Global Const $COLOR_DARKGOLDENROD = 12092939
Global Const $COLOR_DARKGRAY = 11119017
Global Const $COLOR_DARKGREEN = 25600
Global Const $COLOR_DARKKHAKI = 12433259
Global Const $COLOR_DARKMAGENTA = 9109643
Global Const $COLOR_DARKOLIVEGREEN = 5597999
Global Const $COLOR_DARKORANGE = 16747520
Global Const $COLOR_DARKORCHID = 10040012
Global Const $COLOR_DARKRED = 9109504
Global Const $COLOR_DARKSALMON = 15308410
Global Const $COLOR_DARKSEAGREEN = 9419919
Global Const $COLOR_DARKSLATEBLUE = 4734347
Global Const $COLOR_DARKSLATEGRAY = 3100495
Global Const $COLOR_DARKTURQUOISE = 52945
Global Const $COLOR_DARKVIOLET = 9699539
Global Const $COLOR_DEEPPINK = 16716947
Global Const $COLOR_DEEPSKYBLUE = 49151
Global Const $COLOR_DIMGRAY = 6908265
Global Const $COLOR_DODGERBLUE = 2003199
Global Const $COLOR_FIREBRICK = 11674146
Global Const $COLOR_FLORALWHITE = 16775920
Global Const $COLOR_FORESTGREEN = 2263842
Global Const $COLOR_FUCHSIA = 16711935
Global Const $COLOR_GAINSBORO = 14474460
Global Const $COLOR_GHOSTWHITE = 16316671
Global Const $COLOR_GOLD = 16766720
Global Const $COLOR_GOLDENROD = 14329120
Global Const $COLOR_GRAY = 8421504
Global Const $COLOR_GREEN = 32768
Global Const $COLOR_GREENYELLOW = 11403055
Global Const $COLOR_HONEYDEW = 15794160
Global Const $COLOR_HOTPINK = 16738740
Global Const $COLOR_INDIANRED = 13458524
Global Const $COLOR_INDIGO = 4915330
Global Const $COLOR_IVORY = 16777200
Global Const $COLOR_KHAKI = 15787660
Global Const $COLOR_LAVENDER = 15132410
Global Const $COLOR_LAVENDERBLUSH = 16773365
Global Const $COLOR_LAWNGREEN = 8190976
Global Const $COLOR_LEMONCHIFFON = 16775885
Global Const $COLOR_LIGHTBLUE = 11393254
Global Const $COLOR_LIGHTCORAL = 15761536
Global Const $COLOR_LIGHTCYAN = 14745599
Global Const $COLOR_LIGHTGOLDENRODYELLOW = 16448210
Global Const $COLOR_LIGHTGRAY = 13882323
Global Const $COLOR_LIGHTGREEN = 9498256
Global Const $COLOR_LIGHTPINK = 16758465
Global Const $COLOR_LIGHTSALMON = 16752762
Global Const $COLOR_LIGHTSEAGREEN = 2142890
Global Const $COLOR_LIGHTSKYBLUE = 8900346
Global Const $COLOR_LIGHTSLATEGRAY = 7833753
Global Const $COLOR_LIGHTSTEELBLUE = 11584734
Global Const $COLOR_LIGHTYELLOW = 16777184
Global Const $COLOR_LIME = 65280
Global Const $COLOR_LIMEGREEN = 3329330
Global Const $COLOR_LINEN = 16445670
Global Const $COLOR_MAGENTA = 16711935
Global Const $COLOR_MAROON = 8388608
Global Const $COLOR_MEDIUMAQUAMARINE = 6737322
Global Const $COLOR_MEDIUMBLUE = 205
Global Const $COLOR_MEDIUMORCHID = 12211667
Global Const $COLOR_MEDIUMPURPLE = 9662683
Global Const $COLOR_MEDIUMSEAGREEN = 3978097
Global Const $COLOR_MEDIUMSLATEBLUE = 8087790
Global Const $COLOR_MEDIUMSPRINGGREEN = 64154
Global Const $COLOR_MEDIUMTURQUOISE = 4772300
Global Const $COLOR_MEDIUMVIOLETRED = 13047173
Global Const $COLOR_MIDNIGHTBLUE = 1644912
Global Const $COLOR_MINTCREAM = 16121850
Global Const $COLOR_MISTYROSE = 16770273
Global Const $COLOR_MOCCASIN = 16770229
Global Const $COLOR_NAVAJOWHITE = 16768685
Global Const $COLOR_NAVY = 128
Global Const $COLOR_OLDLACE = 16643558
Global Const $COLOR_OLIVE = 8421376
Global Const $COLOR_OLIVEDRAB = 7048739
Global Const $COLOR_ORANGE = 16753920
Global Const $COLOR_ORANGERED = 16729344
Global Const $COLOR_ORCHID = 14315734
Global Const $COLOR_PALEGOLDENROD = 15657130
Global Const $COLOR_PALEGREEN = 10025880
Global Const $COLOR_PALETURQUOISE = 11529966
Global Const $COLOR_PALEVIOLETRED = 14381203
Global Const $COLOR_PAPAYAWHIP = 16773077
Global Const $COLOR_PEACHPUFF = 16767673
Global Const $COLOR_PERU = 13468991
Global Const $COLOR_PINK = 16761035
Global Const $COLOR_PLUM = 14524637
Global Const $COLOR_POWDERBLUE = 11591910
Global Const $COLOR_PURPLE = 8388736
Global Const $COLOR_RED = 16711680
Global Const $COLOR_ROSYBROWN = 12357519
Global Const $COLOR_ROYALBLUE = 4286945
Global Const $COLOR_SADDLEBROWN = 9127187
Global Const $COLOR_SALMON = 16416882
Global Const $COLOR_SANDYBROWN = 16032864
Global Const $COLOR_SEAGREEN = 3050327
Global Const $COLOR_SEASHELL = 16774638
Global Const $COLOR_SIENNA = 10506797
Global Const $COLOR_SILVER = 12632256
Global Const $COLOR_SKYBLUE = 8900331
Global Const $COLOR_SLATEBLUE = 6970061
Global Const $COLOR_SLATEGRAY = 7372944
Global Const $COLOR_SNOW = 16775930
Global Const $COLOR_SPRINGGREEN = 65407
Global Const $COLOR_STEELBLUE = 4620980
Global Const $COLOR_TAN = 13808780
Global Const $COLOR_TEAL = 32896
Global Const $COLOR_THISTLE = 14204888
Global Const $COLOR_TOMATO = 16737095
Global Const $COLOR_TURQUOISE = 4251856
Global Const $COLOR_VIOLET = 15631086
Global Const $COLOR_WHEAT = 16113331
Global Const $COLOR_WHITE = 16777215
Global Const $COLOR_WHITESMOKE = 16119285
Global Const $COLOR_YELLOW = 16776960
Global Const $COLOR_YELLOWGREEN = 10145074
Global Const $CLR_NONE = 4294967295
Global Const $CLR_DEFAULT = 4278190080
Global Const $CLR_ALICEBLUE = 16775408
Global Const $CLR_ANTIQUEWHITE = 14150650
Global Const $CLR_AQUA = 16776960
Global Const $CLR_AQUAMARINE = 13959039
Global Const $CLR_AZURE = 16777200
Global Const $CLR_BEIGE = 14480885
Global Const $CLR_BISQUE = 12903679
Global Const $CLR_BLACK = 0
Global Const $CLR_BLANCHEDALMOND = 13495295
Global Const $CLR_BLUE = 16711680
Global Const $CLR_BLUEVIOLET = 14822282
Global Const $CLR_BROWN = 2763429
Global Const $CLR_BURLYWOOD = 8894686
Global Const $CLR_CADETBLUE = 10526303
Global Const $CLR_CHARTREUSE = 65407
Global Const $CLR_CHOCOLATE = 1993170
Global Const $CLR_CORAL = 5275647
Global Const $CLR_CORNFLOWERBLUE = 15570276
Global Const $CLR_CORNSILK = 14481663
Global Const $CLR_CRIMSON = 3937500
Global Const $CLR_CYAN = 16776960
Global Const $CLR_DARKBLUE = 9109504
Global Const $CLR_DARKCYAN = 9145088
Global Const $CLR_DARKGOLDENROD = 755384
Global Const $CLR_DARKGRAY = 11119017
Global Const $CLR_DARKGREEN = 25600
Global Const $CLR_DARKKHAKI = 7059389
Global Const $CLR_DARKMAGENTA = 9109643
Global Const $CLR_DARKOLIVEGREEN = 3107669
Global Const $CLR_DARKORANGE = 36095
Global Const $CLR_DARKORCHID = 13382297
Global Const $CLR_DARKRED = 139
Global Const $CLR_DARKSALMON = 8034025
Global Const $CLR_DARKSEAGREEN = 9419919
Global Const $CLR_DARKSLATEBLUE = 9125192
Global Const $CLR_DARKSLATEGRAY = 5197615
Global Const $CLR_DARKTURQUOISE = 13749760
Global Const $CLR_DARKVIOLET = 13828244
Global Const $CLR_DEEPPINK = 9639167
Global Const $CLR_DEEPSKYBLUE = 16760576
Global Const $CLR_DIMGRAY = 6908265
Global Const $CLR_DODGERBLUE = 16748574
Global Const $CLR_FIREBRICK = 2237106
Global Const $CLR_FLORALWHITE = 15792895
Global Const $CLR_FORESTGREEN = 2263842
Global Const $CLR_FUCHSIA = 16711935
Global Const $CLR_GAINSBORO = 14474460
Global Const $CLR_GHOSTWHITE = 16775416
Global Const $CLR_GOLD = 55295
Global Const $CLR_GOLDENROD = 2139610
Global Const $CLR_GRAY = 8421504
Global Const $CLR_GREEN = 32768
Global Const $CLR_GREENYELLOW = 3145645
Global Const $CLR_HONEYDEW = 15794160
Global Const $CLR_HOTPINK = 11823615
Global Const $CLR_INDIANRED = 6053069
Global Const $CLR_INDIGO = 8519755
Global Const $CLR_IVORY = 15794175
Global Const $CLR_KHAKI = 9234160
Global Const $CLR_LAVENDER = 16443110
Global Const $CLR_LAVENDERBLUSH = 16118015
Global Const $CLR_LAWNGREEN = 64636
Global Const $CLR_LEMONCHIFFON = 13499135
Global Const $CLR_LIGHTBLUE = 15128749
Global Const $CLR_LIGHTCORAL = 8421616
Global Const $CLR_LIGHTCYAN = 16777184
Global Const $CLR_LIGHTGOLDENRODYELLOW = 13826810
Global Const $CLR_LIGHTGRAY = 13882323
Global Const $CLR_LIGHTGREEN = 9498256
Global Const $CLR_LIGHTPINK = 12695295
Global Const $CLR_LIGHTSALMON = 8036607
Global Const $CLR_LIGHTSEAGREEN = 11186720
Global Const $CLR_LIGHTSKYBLUE = 16436871
Global Const $CLR_LIGHTSLATEGRAY = 10061943
Global Const $CLR_LIGHTSTEELBLUE = 14599344
Global Const $CLR_LIGHTYELLOW = 14745599
Global Const $CLR_LIME = 65280
Global Const $CLR_LIMEGREEN = 3329330
Global Const $CLR_LINEN = 15134970
Global Const $CLR_MAGENTA = 16711935
Global Const $CLR_MAROON = 128
Global Const $CLR_MEDIUMAQUAMARINE = 11193702
Global Const $CLR_MEDIUMBLUE = 13434880
Global Const $CLR_MEDIUMORCHID = 13850042
Global Const $CLR_MEDIUMPURPLE = 14381203
Global Const $CLR_MEDIUMSEAGREEN = 7451452
Global Const $CLR_MEDIUMSLATEBLUE = 15624315
Global Const $CLR_MEDIUMSPRINGGREEN = 10156544
Global Const $CLR_MEDIUMTURQUOISE = 13422920
Global Const $CLR_MEDIUMVIOLETRED = 8721863
Global Const $CLR_MIDNIGHTBLUE = 7346457
Global Const $CLR_MINTCREAM = 16449525
Global Const $CLR_MISTYROSE = 14804223
Global Const $CLR_MOCCASIN = 11920639
Global Const $CLR_NAVAJOWHITE = 11394815
Global Const $CLR_NAVY = 8388608
Global Const $CLR_OLDLACE = 15136253
Global Const $CLR_OLIVE = 32896
Global Const $CLR_OLIVEDRAB = 2330219
Global Const $CLR_ORANGE = 42495
Global Const $CLR_ORANGERED = 17919
Global Const $CLR_ORCHID = 14053594
Global Const $CLR_PALEGOLDENROD = 11200750
Global Const $CLR_PALEGREEN = 10025880
Global Const $CLR_PALETURQUOISE = 15658671
Global Const $CLR_PALEVIOLETRED = 9662683
Global Const $CLR_PAPAYAWHIP = 14020607
Global Const $CLR_PEACHPUFF = 12180223
Global Const $CLR_PERU = 4163021
Global Const $CLR_PINK = 13353215
Global Const $CLR_PLUM = 14524637
Global Const $CLR_POWDERBLUE = 15130800
Global Const $CLR_PURPLE = 8388736
Global Const $CLR_RED = 255
Global Const $CLR_ROSYBROWN = 9408444
Global Const $CLR_ROYALBLUE = 14772545
Global Const $CLR_SADDLEBROWN = 1262987
Global Const $CLR_SALMON = 7504122
Global Const $CLR_SANDYBROWN = 6333684
Global Const $CLR_SEAGREEN = 5737262
Global Const $CLR_SEASHELL = 15660543
Global Const $CLR_SIENNA = 2970272
Global Const $CLR_SILVER = 12632256
Global Const $CLR_SKYBLUE = 15453831
Global Const $CLR_SLATEBLUE = 13458026
Global Const $CLR_SLATEGRAY = 9470064
Global Const $CLR_SNOW = 16448255
Global Const $CLR_SPRINGGREEN = 8388352
Global Const $CLR_STEELBLUE = 11829830
Global Const $CLR_TAN = 9221330
Global Const $CLR_TEAL = 8421376
Global Const $CLR_THISTLE = 14204888
Global Const $CLR_TOMATO = 4678655
Global Const $CLR_TURQUOISE = 13688896
Global Const $CLR_VIOLET = 15631086
Global Const $CLR_WHEAT = 11788021
Global Const $CLR_WHITE = 16777215
Global Const $CLR_WHITESMOKE = 16119285
Global Const $CLR_YELLOW = 65535
Global Const $CLR_YELLOWGREEN = 3329434
Global Const $CC_ANYCOLOR = 256
Global Const $CC_FULLOPEN = 2
Global Const $CC_RGBINIT = 1
Global Const $ILC_MASK = 1
Global Const $ILC_COLOR = 0
Global Const $ILC_COLORDDB = 254
Global Const $ILC_COLOR4 = 4
Global Const $ILC_COLOR8 = 8
Global Const $ILC_COLOR16 = 16
Global Const $ILC_COLOR24 = 24
Global Const $ILC_COLOR32 = 32
Global Const $ILC_PALETTE = 2048
Global Const $ILC_MIRROR = 8192
Global Const $ILC_PERITEMMIRROR = 32768
Global Const $ILCF_MOVE = 0
Global Const $ILCF_SWAP = 1
Global Const $ILD_NORMAL = 0
Global Const $ILD_TRANSPARENT = 1
Global Const $ILD_BLEND25 = 2
Global Const $ILD_BLEND50 = 4
Global Const $ILD_MASK = 16
Global Const $ILD_IMAGE = 32
Global Const $ILD_ROP = 64
Global Const $ILD_OVERLAYMASK = 3840
Global Const $ILS_NORMAL = 0
Global Const $ILS_GLOW = 1
Global Const $ILS_SHADOW = 2
Global Const $ILS_SATURATE = 4
Global Const $ILS_ALPHA = 8
Global Const $HGDI_ERROR = Ptr ( + 4294967295 )
Global Const $INVALID_HANDLE_VALUE = Ptr ( + 4294967295 )
Global Const $CLR_INVALID = + 4294967295
Global Const $MB_PRECOMPOSED = 1
Global Const $MB_COMPOSITE = 2
Global Const $MB_USEGLYPHCHARS = 4
Global Const $ULW_ALPHA = 2
Global Const $ULW_COLORKEY = 1
Global Const $ULW_OPAQUE = 4
Global Const $ULW_EX_NORESIZE = 8
Global Const $WH_CALLWNDPROC = 4
Global Const $WH_CALLWNDPROCRET = 12
Global Const $WH_CBT = 5
Global Const $WH_DEBUG = 9
Global Const $WH_FOREGROUNDIDLE = 11
Global Const $WH_GETMESSAGE = 3
Global Const $WH_JOURNALPLAYBACK = 1
Global Const $WH_JOURNALRECORD = 0
Global Const $WH_KEYBOARD = 2
Global Const $WH_KEYBOARD_LL = 13
Global Const $WH_MOUSE = 7
Global Const $WH_MOUSE_LL = 14
Global Const $WH_MSGFILTER = + 4294967295
Global Const $WH_SHELL = 10
Global Const $WH_SYSMSGFILTER = 6
Global Const $WPF_ASYNCWINDOWPLACEMENT = 4
Global Const $WPF_RESTORETOMAXIMIZED = 2
Global Const $WPF_SETMINPOSITION = 1
Global Const $KF_EXTENDED = 256
Global Const $KF_ALTDOWN = 8192
Global Const $KF_UP = 32768
Global Const $LLKHF_EXTENDED = BitShift ( $KF_EXTENDED , 8 )
Global Const $LLKHF_LOWER_IL_INJECTED = 2
Global Const $LLKHF_INJECTED = 16
Global Const $LLKHF_ALTDOWN = BitShift ( $KF_ALTDOWN , 8 )
Global Const $LLKHF_UP = BitShift ( $KF_UP , 8 )
Global Const $LVKF_ALT = 1
Global Const $LVKF_CONTROL = 2
Global Const $LVKF_SHIFT = 4
Global Const $OFN_ALLOWMULTISELECT = 512
Global Const $OFN_CREATEPROMPT = 8192
Global Const $OFN_DONTADDTORECENT = 33554432
Global Const $OFN_ENABLEHOOK = 32
Global Const $OFN_ENABLEINCLUDENOTIFY = 4194304
Global Const $OFN_ENABLESIZING = 8388608
Global Const $OFN_ENABLETEMPLATE = 64
Global Const $OFN_ENABLETEMPLATEHANDLE = 128
Global Const $OFN_EXPLORER = 524288
Global Const $OFN_EXTENSIONDIFFERENT = 1024
Global Const $OFN_FILEMUSTEXIST = 4096
Global Const $OFN_FORCESHOWHIDDEN = 268435456
Global Const $OFN_HIDEREADONLY = 4
Global Const $OFN_LONGNAMES = 2097152
Global Const $OFN_NOCHANGEDIR = 8
Global Const $OFN_NODEREFERENCELINKS = 1048576
Global Const $OFN_NOLONGNAMES = 262144
Global Const $OFN_NONETWORKBUTTON = 131072
Global Const $OFN_NOREADONLYRETURN = 32768
Global Const $OFN_NOTESTFILECREATE = 65536
Global Const $OFN_NOVALIDATE = 256
Global Const $OFN_OVERWRITEPROMPT = 2
Global Const $OFN_PATHMUSTEXIST = 2048
Global Const $OFN_READONLY = 1
Global Const $OFN_SHAREAWARE = 16384
Global Const $OFN_SHOWHELP = 16
Global Const $OFN_EX_NOPLACESBAR = 1
Global Const $STD_CUT = 0
Global Const $STD_COPY = 1
Global Const $STD_PASTE = 2
Global Const $STD_UNDO = 3
Global Const $STD_REDOW = 4
Global Const $STD_DELETE = 5
Global Const $STD_FILENEW = 6
Global Const $STD_FILEOPEN = 7
Global Const $STD_FILESAVE = 8
Global Const $STD_PRINTPRE = 9
Global Const $STD_PROPERTIES = 10
Global Const $STD_HELP = 11
Global Const $STD_FIND = 12
Global Const $STD_REPLACE = 13
Global Const $STD_PRINT = 14
Global Const $KB_SENDSPECIAL = 0
Global Const $KB_SENDRAW = 1
Global Const $KB_CAPSOFF = 0
Global Const $KB_CAPSON = 1
Global Const $S_OK = 0
Global Const $E_ABORT = 2147500036
Global Const $E_ACCESSDENIED = 2147942405
Global Const $E_FAIL = 2147500037
Global Const $E_HANDLE = 2147942406
Global Const $E_INVALIDARG = 2147942487
Global Const $E_NOINTERFACE = 2147500034
Global Const $E_NOTIMPL = 2147500033
Global Const $E_OUTOFMEMORY = 2147942414
Global Const $E_POINTER = 2147500035
Global Const $E_UNEXPECTED = 2147549183
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIIMAGELIST_ADD ( $HWND , $HIMAGE , $HMASK = 0 )
	Local $ACALL = DllCall ( "comctl32.dll" , "int" , "ImageList_Add" , "handle" , $HWND , "handle" , $HIMAGE , "handle" , $HMASK )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_ADDMASKED ( $HWND , $HIMAGE , $IMASK = 0 )
	Local $ACALL = DllCall ( "comctl32.dll" , "int" , "ImageList_AddMasked" , "handle" , $HWND , "handle" , $HIMAGE , "dword" , $IMASK )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_ADDBITMAP ( $HWND , $SIMAGE , $SMASK = "" )
	Local $ASIZE = _GUIIMAGELIST_GETICONSIZE ( $HWND )
	Local $HIMAGE = _WINAPI_LOADIMAGE ( 0 , $SIMAGE , $__IMAGELISTCONSTANT_IMAGE_BITMAP , $ASIZE [ 0 ] , $ASIZE [ 1 ] , $LR_LOADFROMFILE )
	If $HIMAGE = 0 Then Return SetError ( _WINAPI_GETLASTERROR ( ) , 1 , + 4294967295 )
	Local $HMASK = 0
	If $SMASK <> "" Then
		$HMASK = _WINAPI_LOADIMAGE ( 0 , $SMASK , $__IMAGELISTCONSTANT_IMAGE_BITMAP , $ASIZE [ 0 ] , $ASIZE [ 1 ] , $LR_LOADFROMFILE )
		If $HMASK = 0 Then Return SetError ( _WINAPI_GETLASTERROR ( ) , 2 , + 4294967295 )
	EndIf
	Local $IRET = _GUIIMAGELIST_ADD ( $HWND , $HIMAGE , $HMASK )
	_WINAPI_DELETEOBJECT ( $HIMAGE )
	If $HMASK <> 0 Then _WINAPI_DELETEOBJECT ( $HMASK )
	Return $IRET
EndFunc
Func _GUIIMAGELIST_ADDICON ( $HWND , $SFILEPATH , $IINDEX = 0 , $BLARGE = False )
	Local $IRET , $TICON = DllStructCreate ( "handle Handle" )
	If $BLARGE Then
		$IRET = _WINAPI_EXTRACTICONEX ( $SFILEPATH , $IINDEX , $TICON , 0 , 1 )
	Else
		$IRET = _WINAPI_EXTRACTICONEX ( $SFILEPATH , $IINDEX , 0 , $TICON , 1 )
	EndIf
	If $IRET <= 0 Then Return SetError ( + 4294967295 , $IRET , + 4294967295 )
	Local $HICON = DllStructGetData ( $TICON , "Handle" )
	$IRET = _GUIIMAGELIST_REPLACEICON ( $HWND , + 4294967295 , $HICON )
	_WINAPI_DESTROYICON ( $HICON )
	If $IRET = + 4294967295 Then Return SetError ( + 4294967294 , $IRET , + 4294967295 )
	Return $IRET
EndFunc
Func _GUIIMAGELIST_BEGINDRAG ( $HWND , $ITRACK , $IXHOTSPOT , $IYHOTSPOT )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_BeginDrag" , "handle" , $HWND , "int" , $ITRACK , "int" , $IXHOTSPOT , "int" , $IYHOTSPOT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_COPY ( $HWND , $ISOURCE , $IDESTINATION )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Copy" , "handle" , $HWND , "int" , $IDESTINATION , "handle" , $HWND , "int" , $ISOURCE , "uint" , $ILCF_MOVE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_CREATE ( $ICX = 16 , $ICY = 16 , $ICOLOR = 4 , $IOPTIONS = 0 , $IINITIAL = 4 , $IGROW = 4 )
	Local Const $ACOLOR [ 7 ] = [ $ILC_COLOR , $ILC_COLOR4 , $ILC_COLOR8 , $ILC_COLOR16 , $ILC_COLOR24 , $ILC_COLOR32 , $ILC_COLORDDB ]
	Local $IFLAGS = 0
	If BitAND ( $IOPTIONS , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILC_MASK )
	If BitAND ( $IOPTIONS , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILC_MIRROR )
	If BitAND ( $IOPTIONS , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILC_PERITEMMIRROR )
	$IFLAGS = BitOR ( $IFLAGS , $ACOLOR [ $ICOLOR ] )
	Local $ACALL = DllCall ( "comctl32.dll" , "handle" , "ImageList_Create" , "int" , $ICX , "int" , $ICY , "uint" , $IFLAGS , "int" , $IINITIAL , "int" , $IGROW )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_DESTROY ( $HWND )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Destroy" , "handle" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DESTROYICON ( $HICON )
	Return _WINAPI_DESTROYICON ( $HICON )
EndFunc
Func _GUIIMAGELIST_DRAGENTER ( $HWND , $IX , $IY )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_DragEnter" , "hwnd" , $HWND , "int" , $IX , "int" , $IY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DRAGLEAVE ( $HWND )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_DragLeave" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DRAGMOVE ( $IX , $IY )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_DragMove" , "int" , $IX , "int" , $IY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DRAGSHOWNOLOCK ( $BSHOW )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_DragShowNolock" , "bool" , $BSHOW )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DRAW ( $HWND , $IINDEX , $HDC , $IX , $IY , $ISTYLE = 0 )
	Local $IFLAGS = 0
	If BitAND ( $ISTYLE , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_TRANSPARENT )
	If BitAND ( $ISTYLE , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_BLEND25 )
	If BitAND ( $ISTYLE , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_BLEND50 )
	If BitAND ( $ISTYLE , 8 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_MASK )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Draw" , "handle" , $HWND , "int" , $IINDEX , "handle" , $HDC , "int" , $IX , "int" , $IY , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DRAWEX ( $HWND , $IINDEX , $HDC , $IX , $IY , $IDX = 0 , $IDY = 0 , $IRGBBK = 4294967295 , $IRGBFG = 4294967295 , $ISTYLE = 0 )
	If $IDX = + 4294967295 Then $IDX = 0
	If $IDY = + 4294967295 Then $IDY = 0
	If $IRGBBK = + 4294967295 Then $IRGBBK = 4294967295
	If $IRGBFG = + 4294967295 Then $IRGBFG = 4294967295
	Local $IFLAGS = 0
	If BitAND ( $ISTYLE , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_TRANSPARENT )
	If BitAND ( $ISTYLE , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_BLEND25 )
	If BitAND ( $ISTYLE , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_BLEND50 )
	If BitAND ( $ISTYLE , 8 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_MASK )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_DrawEx" , "handle" , $HWND , "int" , $IINDEX , "handle" , $HDC , "int" , $IX , "int" , $IY , "int" , $IDX , "int" , $IDY , "dword" , $IRGBBK , "dword" , $IRGBFG , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_DUPLICATE ( $HWND )
	Local $ACALL = DllCall ( "comctl32.dll" , "handle" , "ImageList_Duplicate" , "handle" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_ENDDRAG ( )
	DllCall ( "comctl32.dll" , "none" , "ImageList_EndDrag" )
	If @error Then Return SetError ( @error , @extended )
EndFunc
Func _GUIIMAGELIST_GETBKCOLOR ( $HWND )
	Local $ACALL = DllCall ( "comctl32.dll" , "dword" , "ImageList_GetBkColor" , "handle" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_GETICON ( $HWND , $IINDEX , $ISTYLE = 0 )
	Local $IFLAGS = 0
	If BitAND ( $ISTYLE , 1 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_TRANSPARENT )
	If BitAND ( $ISTYLE , 2 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_BLEND25 )
	If BitAND ( $ISTYLE , 4 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_BLEND50 )
	If BitAND ( $ISTYLE , 8 ) <> 0 Then $IFLAGS = BitOR ( $IFLAGS , $ILD_MASK )
	Local $ACALL = DllCall ( "comctl32.dll" , "handle" , "ImageList_GetIcon" , "handle" , $HWND , "int" , $IINDEX , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_GETICONHEIGHT ( $HWND )
	Local $ASIZE = _GUIIMAGELIST_GETICONSIZE ( $HWND )
	Return $ASIZE [ 1 ]
EndFunc
Func _GUIIMAGELIST_GETICONSIZE ( $HWND )
	Local $ASIZE [ 2 ]
	Local $TPOINT = _GUIIMAGELIST_GETICONSIZEEX ( $HWND )
	$ASIZE [ 0 ] = DllStructGetData ( $TPOINT , "X" )
	$ASIZE [ 1 ] = DllStructGetData ( $TPOINT , "Y" )
	Return $ASIZE
EndFunc
Func _GUIIMAGELIST_GETICONSIZEEX ( $HWND )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $PPOINTX = DllStructGetPtr ( $TPOINT , "X" )
	Local $PPOINTY = DllStructGetPtr ( $TPOINT , "Y" )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_GetIconSize" , "hwnd" , $HWND , "struct*" , $PPOINTX , "struct*" , $PPOINTY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TPOINT )
EndFunc
Func _GUIIMAGELIST_GETICONWIDTH ( $HWND )
	Local $ASIZE = _GUIIMAGELIST_GETICONSIZE ( $HWND )
	Return $ASIZE [ 0 ]
EndFunc
Func _GUIIMAGELIST_GETIMAGECOUNT ( $HWND )
	Local $ACALL = DllCall ( "comctl32.dll" , "int" , "ImageList_GetImageCount" , "handle" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_GETIMAGEINFOEX ( $HWND , $IINDEX )
	Local $TIMAGE = DllStructCreate ( $TAGIMAGEINFO )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_GetImageInfo" , "handle" , $HWND , "int" , $IINDEX , "struct*" , $TIMAGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TIMAGE )
EndFunc
Func _GUIIMAGELIST_MERGE ( $HWND1 , $IINDEX1 , $HWND2 , $IINDEX2 , $IDX , $IDY )
	Local $ACALL = DllCall ( "comctl32.dll" , "handle" , "ImageList_Merge" , "handle" , $HWND1 , "int" , $IINDEX1 , "handle" , $HWND2 , "int" , $IINDEX2 , "int" , $IDX , "int" , $IDY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_REMOVE ( $HWND , $IINDEX = + 4294967295 )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Remove" , "handle" , $HWND , "int" , $IINDEX )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_REPLACE ( $HWND , $IINDEX , $HIMAGE , $HMASK = 0 )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Replace" , "handle" , $HWND , "int" , $IINDEX , "handle" , $HIMAGE , "handle" , $HMASK )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_REPLACEICON ( $HWND , $IINDEX , $HICON )
	Local $ACALL = DllCall ( "comctl32.dll" , "int" , "ImageList_ReplaceIcon" , "handle" , $HWND , "int" , $IINDEX , "handle" , $HICON )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_SETBKCOLOR ( $HWND , $ICLRBK )
	Local $ACALL = DllCall ( "comctl32.dll" , "dword" , "ImageList_SetBkColor" , "handle" , $HWND , "dword" , $ICLRBK )
	If @error Then Return SetError ( @error , @extended , $CLR_NONE )
	Return $ACALL [ 0 ]
EndFunc
Func _GUIIMAGELIST_SETDRAGCURSORIMAGE ( $HWND , $IDRAG , $IDXHOTSPOT , $IDYHOTSPOT )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_SetDragCursorImage" , "handle" , $HWND , "int" , $IDRAG , "int" , $IDXHOTSPOT , "int" , $IDYHOTSPOT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_SETICONSIZE ( $HWND , $ICX , $ICY )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_SetIconSize" , "handle" , $HWND , "int" , $ICX , "int" , $ICY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_SETIMAGECOUNT ( $HWND , $INEWCOUNT )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_SetImageCount" , "handle" , $HWND , "uint" , $INEWCOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_SETOVERLAYIMAGE ( $HWND , $IIMAGE , $IOVERLAY )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_SetOverlayImage" , "handle" , $HWND , "int" , $IIMAGE , "int" , $IOVERLAY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Func _GUIIMAGELIST_SWAP ( $HWND , $ISOURCE , $IDESTINATION )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "ImageList_Copy" , "handle" , $HWND , "int" , $IDESTINATION , "handle" , $HWND , "int" , $ISOURCE , "uint" , $ILCF_SWAP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ] <> 0
EndFunc
Global Const $KLF_ACTIVATE = 1
Global Const $KLF_NOTELLSHELL = 128
Global Const $KLF_REORDER = 8
Global Const $KLF_REPLACELANG = 16
Global Const $KLF_RESET = 1073741824
Global Const $KLF_SETFORPROCESS = 256
Global Const $KLF_SHIFTLOCK = 65536
Global Const $KLF_SUBSTITUTE_OK = 2
Global Const $HKL_NEXT = 1
Global Const $HKL_PREV = 0
Global Const $AW_ACTIVATE = 131072
Global Const $AW_BLEND = 524288
Global Const $AW_CENTER = 16
Global Const $AW_HIDE = 65536
Global Const $AW_HOR_NEGATIVE = 2
Global Const $AW_HOR_POSITIVE = 1
Global Const $AW_SLIDE = 262144
Global Const $AW_VER_NEGATIVE = 8
Global Const $AW_VER_POSITIVE = 4
Global Const $BSF_ALLOWSFW = 128
Global Const $BSF_FLUSHDISK = 4
Global Const $BSF_FORCEIFHUNG = 32
Global Const $BSF_IGNORECURRENTTASK = 2
Global Const $BSF_NOHANG = 8
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 64
Global Const $BSF_POSTMESSAGE = 16
Global Const $BSF_QUERY = 1
Global Const $BSF_SENDNOTIFYMESSAGE = 256
Global Const $BSM_ALLCOMPONENTS = 0
Global Const $BSM_ALLDESKTOPS = 8
Global Const $BSM_APPLICATIONS = 16
Global Const $BSM_INSTALLABLEDRIVERS = 4
Global Const $BSM_NETDRIVER = 2
Global Const $BSM_VXDS = 1
Global Const $MDITILE_HORIZONTAL = 1
Global Const $MDITILE_SKIPDISABLED = 2
Global Const $MDITILE_VERTICAL = 0
Global Const $MDITILE_ZORDER = 4
Global Const $MSGFLT_ALLOW = 1
Global Const $MSGFLT_DISALLOW = 2
Global Const $MSGFLT_RESET = 0
Global Const $MSGFLTINFO_ALLOWED_HIGHER = 3
Global Const $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
Global Const $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
Global Const $MSGFLTINFO_NONE = 0
Global Const $CWP_ALL = 0
Global Const $CWP_SKIPINVISIBLE = 1
Global Const $CWP_SKIPDISABLED = 2
Global Const $CWP_SKIPTRANSPARENT = 4
Global Const $COMPRESSION_FORMAT_NONE = 0
Global Const $COMPRESSION_FORMAT_DEFAULT = 1
Global Const $COMPRESSION_FORMAT_LZNT1 = 2
Global Const $COMPRESSION_FORMAT_XPRESS = 3
Global Const $COMPRESSION_FORMAT_XPRESS_HUFF = 4
Global Const $COMPRESSION_ENGINE_STANDARD = 0
Global Const $COMPRESSION_ENGINE_MAXIMUM = 256
Global Const $COMPRESSION_ENGINE_HIBER = 512
Global Const $WINSTA_ACCESSCLIPBOARD = 4
Global Const $WINSTA_ACCESSGLOBALATOMS = 32
Global Const $WINSTA_CREATEDESKTOP = 8
Global Const $WINSTA_ENUMDESKTOPS = 1
Global Const $WINSTA_ENUMERATE = 256
Global Const $WINSTA_EXITWINDOWS = 64
Global Const $WINSTA_READATTRIBUTES = 2
Global Const $WINSTA_READSCREEN = 512
Global Const $WINSTA_WRITEATTRIBUTES = 16
Global Const $WINSTA_ALL_ACCESS = BitOR ( $WINSTA_ACCESSCLIPBOARD , $WINSTA_ACCESSGLOBALATOMS , $WINSTA_CREATEDESKTOP , $WINSTA_ENUMDESKTOPS , $WINSTA_ENUMERATE , $WINSTA_EXITWINDOWS , $WINSTA_READATTRIBUTES , $WINSTA_READSCREEN , $WINSTA_WRITEATTRIBUTES )
Global Const $CWF_CREATE_ONLY = 1
Global Const $GCL_CBCLSEXTRA = + 4294967276
Global Const $GCL_CBWNDEXTRA = + 4294967278
Global Const $GCL_HBRBACKGROUND = + 4294967286
Global Const $GCL_HCURSOR = + 4294967284
Global Const $GCL_HICON = + 4294967282
Global Const $GCL_HICONSM = + 4294967262
Global Const $GCL_HMODULE = + 4294967280
Global Const $GCL_MENUNAME = + 4294967288
Global Const $GCL_STYLE = + 4294967270
Global Const $GCL_WNDPROC = + 4294967272
Global Const $DOCKINFO_DOCKED = 2
Global Const $DOCKINFO_UNDOCKED = 1
Global Const $DOCKINFO_USER_SUPPLIED = 4
Global Const $DOCKINFO_USER_DOCKED = 5
Global Const $DOCKINFO_USER_UNDOCKED = 6
Global Const $GUI_CARETBLINKING = 1
Global Const $GUI_INMENUMODE = 4
Global Const $GUI_INMOVESIZE = 2
Global Const $GUI_POPUPMENUMODE = 16
Global Const $GUI_SYSTEMMENUMODE = 8
Global Const $HANDLE_FLAG_INHERIT = 1
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 2
Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 4
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 1
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 2
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0
Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 65535
Global Const $PROCESSOR_INTEL_386 = 386
Global Const $PROCESSOR_INTEL_486 = 486
Global Const $PROCESSOR_INTEL_PENTIUM = 586
Global Const $PROCESSOR_INTEL_IA64 = 2200
Global Const $PROCESSOR_AMD_X8664 = 8664
Global Const $UOI_FLAGS = 1
Global Const $UOI_HEAPSIZE = 5
Global Const $UOI_IO = 6
Global Const $UOI_NAME = 2
Global Const $UOI_TYPE = 3
Global Const $UOI_USER_SID = 4
Global Const $DF_ALLOWOTHERACCOUNTHOOK = 1
Global Const $WSF_VISIBLE = 1
Global Const $VER_SUITE_BACKOFFICE = 4
Global Const $VER_SUITE_BLADE = 1024
Global Const $VER_SUITE_COMPUTE_SERVER = 16384
Global Const $VER_SUITE_DATACENTER = 128
Global Const $VER_SUITE_ENTERPRISE = 2
Global Const $VER_SUITE_EMBEDDEDNT = 64
Global Const $VER_SUITE_PERSONAL = 512
Global Const $VER_SUITE_SINGLEUSERTS = 256
Global Const $VER_SUITE_SMALLBUSINESS = 1
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 32
Global Const $VER_SUITE_STORAGE_SERVER = 8192
Global Const $VER_SUITE_TERMINAL = 16
Global Const $VER_SUITE_WH_SERVER = 32768
Global Const $VER_NT_DOMAIN_CONTROLLER = 2
Global Const $VER_NT_SERVER = 3
Global Const $VER_NT_WORKSTATION = 1
Global Const $WDA_MONITOR = 1
Global Const $WDA_NONE = 0
Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
Global Const $PF_CHANNELS_ENABLED = 16
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 2
Global Const $PF_COMPARE_EXCHANGE128 = 14
Global Const $PF_COMPARE64_EXCHANGE128 = 15
Global Const $PF_FLOATING_POINT_EMULATED = 1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
Global Const $PF_NX_ENABLED = 12
Global Const $PF_PAE_ENABLED = 9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
Global Const $PF_XSAVE_ENABLED = 17
Global Const $KEYEVENTF_EXTENDEDKEY = 1
Global Const $KEYEVENTF_KEYUP = 2
Global Const $LIM_SMALL = 0
Global Const $LIM_LARGE = 1
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $MAPVK_VK_TO_VSC = 0
Global Const $MAPVK_VK_TO_VSC_EX = 4
Global Const $MAPVK_VSC_TO_VK = 1
Global Const $MAPVK_VSC_TO_VK_EX = 3
Global Const $MOD_ALT = 1
Global Const $MOD_CONTROL = 2
Global Const $MOD_NOREPEAT = 16384
Global Const $MOD_SHIFT = 4
Global Const $MOD_WIN = 8
Global Const $GUID_ACDC_POWER_SOURCE = "{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}"
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = "{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}"
Global Const $GUID_IDLE_BACKGROUND_TASK = "{515C31D8-F734-163D-A0FD-11A08C91E8F1}"
Global Const $GUID_MONITOR_POWER_ON = "{02731015-4510-4526-99E6-E5A17EBD1AEA}"
Global Const $GUID_POWERSCHEME_PERSONALITY = "{245D8541-3943-4422-B025-13A784F679B7}"
Global Const $GUID_SYSTEM_AWAYMODE = "{98A7F580-01F7-48AA-9C0F-44352C29E5C0}"
Global Const $GUID_MIN_POWER_SAVINGS = "{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}"
Global Const $GUID_MAX_POWER_SAVINGS = "{A1841308-3541-4FAB-BC81-F71556F20B4A}"
Global Const $GUID_TYPICAL_POWER_SAVINGS = "{381B4222-F694-41F0-9685-FF5BB260DF2E}"
Global Const $HSHELL_WINDOWCREATED = 1
Global Const $HSHELL_WINDOWDESTROYED = 2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 3
Global Const $HSHELL_WINDOWACTIVATED = 4
Global Const $HSHELL_GETMINRECT = 5
Global Const $HSHELL_REDRAW = 6
Global Const $HSHELL_TASKMAN = 7
Global Const $HSHELL_LANGUAGE = 8
Global Const $HSHELL_SYSMENU = 9
Global Const $HSHELL_ENDTASK = 10
Global Const $HSHELL_ACCESSIBILITYSTATE = 11
Global Const $HSHELL_APPCOMMAND = 12
Global Const $HSHELL_WINDOWREPLACED = 13
Global Const $HSHELL_WINDOWREPLACING = 14
Global Const $HSHELL_RUDEAPPACTIVATED = 32772
Global Const $HSHELL_FLASH = 32774
Global Const $HWND_BROADCAST = 65535
Global Const $SMTO_BLOCK = 1
Global Const $SMTO_NORMAL = 0
Global Const $SMTO_ABORTIFHUNG = 2
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 8
Global Const $SMTO_ERRORONEXIT = 32
Global Const $INPUTLANGCHANGE_BACKWARD = 4
Global Const $INPUTLANGCHANGE_FORWARD = 2
Global Const $INPUTLANGCHANGE_SYSCHARSET = 1
Global Const $EVENT_MIN = 1
Global Const $EVENT_SYSTEM_SOUND = 1
Global Const $EVENT_SYSTEM_ALERT = 2
Global Const $EVENT_SYSTEM_FOREGROUND = 3
Global Const $EVENT_SYSTEM_MENUSTART = 4
Global Const $EVENT_SYSTEM_MENUEND = 5
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 6
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 7
Global Const $EVENT_SYSTEM_CAPTURESTART = 8
Global Const $EVENT_SYSTEM_CAPTUREEND = 9
Global Const $EVENT_SYSTEM_MOVESIZESTART = 10
Global Const $EVENT_SYSTEM_MOVESIZEEND = 11
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 12
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 13
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 14
Global Const $EVENT_SYSTEM_DRAGDROPEND = 15
Global Const $EVENT_SYSTEM_DIALOGSTART = 16
Global Const $EVENT_SYSTEM_DIALOGEND = 17
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 18
Global Const $EVENT_SYSTEM_SCROLLINGEND = 19
Global Const $EVENT_SYSTEM_SWITCHSTART = 20
Global Const $EVENT_SYSTEM_SWITCHEND = 21
Global Const $EVENT_SYSTEM_MINIMIZESTART = 22
Global Const $EVENT_SYSTEM_MINIMIZEEND = 23
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 32
Global Const $EVENT_OBJECT_CREATE = 32768
Global Const $EVENT_OBJECT_DESTROY = 32769
Global Const $EVENT_OBJECT_SHOW = 32770
Global Const $EVENT_OBJECT_HIDE = 32771
Global Const $EVENT_OBJECT_REORDER = 32772
Global Const $EVENT_OBJECT_FOCUS = 32773
Global Const $EVENT_OBJECT_SELECTION = 32774
Global Const $EVENT_OBJECT_SELECTIONADD = 32775
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 32776
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 32777
Global Const $EVENT_OBJECT_STATECHANGE = 32778
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 32779
Global Const $EVENT_OBJECT_NAMECHANGE = 32780
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 32781
Global Const $EVENT_OBJECT_VALUECHANGE = 32782
Global Const $EVENT_OBJECT_PARENTCHANGE = 32783
Global Const $EVENT_OBJECT_HELPCHANGE = 32784
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 32785
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 32786
Global Const $EVENT_OBJECT_INVOKED = 32787
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 32788
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 32789
Global Const $EVENT_MAX = 2147483647
Global Const $WINEVENT_INCONTEXT = 4
Global Const $WINEVENT_OUTOFCONTEXT = 0
Global Const $WINEVENT_SKIPOWNPROCESS = 2
Global Const $WINEVENT_SKIPOWNTHREAD = 1
Global Const $TME_CANCEL = 2147483648
Global Const $TME_HOVER = 1
Global Const $TME_LEAVE = 2
Global Const $TME_NONCLIENT = 16
Global Const $TME_QUERY = 1073741824
Global Const $DESKTOP_CREATEMENU = 4
Global Const $DESKTOP_CREATEWINDOW = 2
Global Const $DESKTOP_ENUMERATE = 64
Global Const $DESKTOP_HOOKCONTROL = 8
Global Const $DESKTOP_JOURNALPLAYBACK = 32
Global Const $DESKTOP_JOURNALRECORD = 16
Global Const $DESKTOP_READOBJECTS = 1
Global Const $DESKTOP_SWITCHDESKTOP = 256
Global Const $DESKTOP_WRITEOBJECTS = 128
Global Const $DESKTOP_ALL_ACCESS = BitOR ( $DESKTOP_CREATEMENU , $DESKTOP_CREATEWINDOW , $DESKTOP_ENUMERATE , $DESKTOP_HOOKCONTROL , $DESKTOP_JOURNALPLAYBACK , $DESKTOP_JOURNALRECORD , $DESKTOP_READOBJECTS , $DESKTOP_SWITCHDESKTOP , $DESKTOP_WRITEOBJECTS )
Global Const $RIDEV_APPKEYS = 1024
Global Const $RIDEV_CAPTUREMOUSE = 512
Global Const $RIDEV_DEVNOTIFY = 8192
Global Const $RIDEV_EXCLUDE = 16
Global Const $RIDEV_EXINPUTSINK = 4096
Global Const $RIDEV_INPUTSINK = 256
Global Const $RIDEV_NOHOTKEYS = 512
Global Const $RIDEV_NOLEGACY = 48
Global Const $RIDEV_PAGEONLY = 32
Global Const $RIDEV_REMOVE = 1
Global Const $RID_HEADER = 268435461
Global Const $RID_INPUT = 268435459
Global Const $RIM_TYPEHID = 2
Global Const $RIM_TYPEKEYBOARD = 1
Global Const $RIM_TYPEMOUSE = 0
Global Const $RIDI_DEVICENAME = 536870919
Global Const $RIDI_DEVICEINFO = 536870923
Global Const $RIDI_PREPARSEDDATA = 536870917
Global Const $MOUSE_ATTRIBUTES_CHANGED = 4
Global Const $MOUSE_MOVE_ABSOLUTE = 1
Global Const $MOUSE_MOVE_RELATIVE = 0
Global Const $MOUSE_VIRTUAL_DESKTOP = 2
Global Const $RI_MOUSE_LEFT_BUTTON_DOWN = 1
Global Const $RI_MOUSE_LEFT_BUTTON_UP = 2
Global Const $RI_MOUSE_MIDDLE_BUTTON_DOWN = 16
Global Const $RI_MOUSE_MIDDLE_BUTTON_UP = 32
Global Const $RI_MOUSE_RIGHT_BUTTON_DOWN = 4
Global Const $RI_MOUSE_RIGHT_BUTTON_UP = 8
Global Const $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_4_DOWN = 64
Global Const $RI_MOUSE_BUTTON_4_UP = 128
Global Const $RI_MOUSE_BUTTON_5_DOWN = 256
Global Const $RI_MOUSE_BUTTON_5_UP = 512
Global Const $RI_MOUSE_WHEEL = 1024
Global Const $RI_KEY_BREAK = 1
Global Const $RI_KEY_E0 = 2
Global Const $RI_KEY_E1 = 4
Global Const $RI_KEY_MAKE = 0
#Region Global Variables and Constants
Global Const $FLASHW_CAPTION = 1
Global Const $FLASHW_TRAY = 2
Global Const $FLASHW_TIMER = 4
Global Const $FLASHW_TIMERNOFG = 12
Global Const $TAGUPDATELAYEREDWINDOWINFO = "dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom"
Global Const $TAGWINDOWINFO = "dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion"
Global Const $TAGWNDCLASS = "uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName"
Global Const $TAGWNDCLASSEX = "uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Global Const $TAGFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
#Region Public Functions
Func _WINAPI_ADJUSTWINDOWRECTEX ( ByRef $TRECT , $ISTYLE , $IEXSTYLE = 0 , $BMENU = False )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "AdjustWindowRectEx" , "struct*" , $TRECT , "dword" , $ISTYLE , "bool" , $BMENU , "dword" , $IEXSTYLE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ANIMATEWINDOW ( $HWND , $IFLAGS , $IDURATION = 1000 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "AnimateWindow" , "hwnd" , $HWND , "dword" , $IDURATION , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BEGINDEFERWINDOWPOS ( $IAMOUNT = 1 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "BeginDeferWindowPos" , "int" , $IAMOUNT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BRINGWINDOWTOTOP ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "BringWindowToTop" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BROADCASTSYSTEMMESSAGE ( $IMSG , $WPARAM = 0 , $LPARAM = 0 , $IFLAGS = 0 , $IRECIPIENTS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "long" , "BroadcastSystemMessageW" , "dword" , $IFLAGS , "dword*" , $IRECIPIENTS , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return SetExtended ( $ACALL [ 2 ] , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_CALLWINDOWPROC ( $PPREVWNDFUNC , $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "CallWindowProc" , "ptr" , $PPREVWNDFUNC , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CALLWINDOWPROCW ( $PPREVWNDPROC , $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "CallWindowProcW" , "ptr" , $PPREVWNDPROC , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CASCADEWINDOWS ( $AWNDS , $TRECT = 0 , $HPARENT = 0 , $IFLAGS = 0 , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $AWNDS , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ICOUNT = $IEND - $ISTART + 1
	Local $TWNDS = DllStructCreate ( "hwnd[" & $ICOUNT & "]" )
	$ICOUNT = 1
	For $I = $ISTART To $IEND
		DllStructSetData ( $TWNDS , 1 , $AWNDS [ $I ] , $ICOUNT )
		$ICOUNT += 1
	Next
	Local $ACALL = DllCall ( "user32.dll" , "word" , "CascadeWindows" , "hwnd" , $HPARENT , "uint" , $IFLAGS , "struct*" , $TRECT , "uint" , $ICOUNT + 4294967295 , "struct*" , $TWNDS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CHANGEWINDOWMESSAGEFILTEREX ( $HWND , $IMSG , $IACTION )
	Local $TCFS , $ACALL
	If $HWND And ( _WINAPI_GETVERSION ( ) > 6.0 ) Then
		Local Const $TAGCHANGEFILTERSTRUCT = "dword cbSize; dword ExtStatus"
		$TCFS = DllStructCreate ( $TAGCHANGEFILTERSTRUCT )
		DllStructSetData ( $TCFS , 1 , DllStructGetSize ( $TCFS ) )
		$ACALL = DllCall ( "user32.dll" , "bool" , "ChangeWindowMessageFilterEx" , "hwnd" , $HWND , "uint" , $IMSG , "dword" , $IACTION , "struct*" , $TCFS )
	Else
		$TCFS = 0
		$ACALL = DllCall ( "user32.dll" , "bool" , "ChangeWindowMessageFilter" , "uint" , $IMSG , "dword" , $IACTION )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return SetExtended ( DllStructGetData ( $TCFS , 2 ) , 1 )
EndFunc
Func _WINAPI_CHILDWINDOWFROMPOINTEX ( $HWND , $TPOINT , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "ChildWindowFromPointEx" , "hwnd" , $HWND , "struct" , $TPOINT , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CLOSEWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "CloseWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEFERWINDOWPOS ( $HINFO , $HWND , $HAFTER , $IX , $IY , $IWIDTH , $IHEIGHT , $IFLAGS )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "DeferWindowPos" , "handle" , $HINFO , "hwnd" , $HWND , "hwnd" , $HAFTER , "int" , $IX , "int" , $IY , "int" , $IWIDTH , "int" , $IHEIGHT , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEFWINDOWPROC ( $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "DefWindowProc" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEFWINDOWPROCW ( $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "DefWindowProcW" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEREGISTERSHELLHOOKWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "DeregisterShellHookWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DRAGACCEPTFILES ( $HWND , $BACCEPT = True )
	DllCall ( "shell32.dll" , "none" , "DragAcceptFiles" , "hwnd" , $HWND , "bool" , $BACCEPT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAGFINISH ( $HDROP )
	DllCall ( "shell32.dll" , "none" , "DragFinish" , "handle" , $HDROP )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAGQUERYFILEEX ( $HDROP , $IFLAG = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "uint" , "DragQueryFileW" , "handle" , $HDROP , "uint" , + 4294967295 , "ptr" , 0 , "uint" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , 0 , 0 )
	Local $ICOUNT = $ACALL [ 0 ] , $IVALIDROW = 0
	Local $ARET [ $ICOUNT + 1 ]
	For $I = 0 To $ICOUNT + 4294967295
		$ACALL = DllCall ( "shell32.dll" , "uint" , "DragQueryFileW" , "handle" , $HDROP , "uint" , $I , "wstr" , "" , "uint" , 4096 )
		If Not $ACALL [ 0 ] Then Return SetError ( 11 , 0 , 0 )
		If $IFLAG Then
			Local $BDIR = _WINAPI_PATHISDIRECTORY ( $ACALL [ 3 ] )
			If ( ( $IFLAG = 1 ) And $BDIR ) Or ( ( $IFLAG = 2 ) And Not $BDIR ) Then
				ContinueLoop
			EndIf
		EndIf
		$IVALIDROW += 1
		$ARET [ $IVALIDROW ] = $ACALL [ 3 ]
		$ARET [ 0 ] += 1
	Next
	If Not $ARET [ 0 ] Then Return SetError ( 12 , 0 , 0 )
	__INC ( $ARET , + 4294967295 )
	Return $ARET
EndFunc
Func _WINAPI_DRAGQUERYPOINT ( $HDROP )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "DragQueryPoint" , "handle" , $HDROP , "struct*" , $TPOINT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_ENDDEFERWINDOWPOS ( $HINFO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EndDeferWindowPos" , "handle" , $HINFO )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENUMCHILDWINDOWS ( $HWND , $BVISIBLE = True )
	If Not _WINAPI_GETWINDOW ( $HWND , 5 ) Then Return SetError ( 2 , 0 , 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumWindowsProc" , "bool" , "hwnd;lparam" )
	Dim $__G_VENUM [ 101 ] [ 2 ] = [ [ 0 ] ]
	DllCall ( "user32.dll" , "bool" , "EnumChildWindows" , "hwnd" , $HWND , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , $BVISIBLE )
	If @error Or Not $__G_VENUM [ 0 ] [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_FINDWINDOW ( $SCLASSNAME , $SWINDOWNAME )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "FindWindowW" , "wstr" , $SCLASSNAME , "wstr" , $SWINDOWNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FLASHWINDOW ( $HWND , $BINVERT = True )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "FlashWindow" , "hwnd" , $HWND , "bool" , $BINVERT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FLASHWINDOWEX ( $HWND , $IFLAGS = 3 , $ICOUNT = 3 , $ITIMEOUT = 0 )
	Local $TFLASH = DllStructCreate ( $TAGFLASHWINFO )
	Local $IFLASH = DllStructGetSize ( $TFLASH )
	Local $IMODE = 0
	If BitAND ( $IFLAGS , 1 ) <> 0 Then $IMODE = BitOR ( $IMODE , $FLASHW_CAPTION )
	If BitAND ( $IFLAGS , 2 ) <> 0 Then $IMODE = BitOR ( $IMODE , $FLASHW_TRAY )
	If BitAND ( $IFLAGS , 4 ) <> 0 Then $IMODE = BitOR ( $IMODE , $FLASHW_TIMER )
	If BitAND ( $IFLAGS , 8 ) <> 0 Then $IMODE = BitOR ( $IMODE , $FLASHW_TIMERNOFG )
	DllStructSetData ( $TFLASH , "Size" , $IFLASH )
	DllStructSetData ( $TFLASH , "hWnd" , $HWND )
	DllStructSetData ( $TFLASH , "Flags" , $IMODE )
	DllStructSetData ( $TFLASH , "Count" , $ICOUNT )
	DllStructSetData ( $TFLASH , "Timeout" , $ITIMEOUT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "FlashWindowEx" , "struct*" , $TFLASH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETANCESTOR ( $HWND , $IFLAGS = 1 )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetAncestor" , "hwnd" , $HWND , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCLASSINFOEX ( $SCLASS , $HINSTANCE = 0 )
	Local $STYPEOFCLASS = "wstr"
	If Not IsString ( $SCLASS ) Then $STYPEOFCLASS = "ptr"
	Local $TWNDCLASSEX = DllStructCreate ( $TAGWNDCLASSEX )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetClassInfoExW" , "handle" , $HINSTANCE , $STYPEOFCLASS , $SCLASS , "struct*" , $TWNDCLASSEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TWNDCLASSEX
EndFunc
Func _WINAPI_GETCLASSLONGEX ( $HWND , $IINDEX )
	Local $ACALL
	If @AutoItX64 Then
		$ACALL = DllCall ( "user32.dll" , "ulong_ptr" , "GetClassLongPtrW" , "hwnd" , $HWND , "int" , $IINDEX )
	Else
		$ACALL = DllCall ( "user32.dll" , "dword" , "GetClassLongW" , "hwnd" , $HWND , "int" , $IINDEX )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCLIENTHEIGHT ( $HWND )
	Local $TRECT = _WINAPI_GETCLIENTRECT ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TRECT , "Bottom" ) - DllStructGetData ( $TRECT , "Top" )
EndFunc
Func _WINAPI_GETCLIENTWIDTH ( $HWND )
	Local $TRECT = _WINAPI_GETCLIENTRECT ( $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TRECT , "Right" ) - DllStructGetData ( $TRECT , "Left" )
EndFunc
Func _WINAPI_GETDLGITEM ( $HWND , $IITEMID )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetDlgItem" , "hwnd" , $HWND , "int" , $IITEMID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETFOREGROUNDWINDOW ( )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetForegroundWindow" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETGUITHREADINFO ( $ITHREADID )
	Local Const $TAGGUITHREADINFO = "dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct"
	Local $TGTI = DllStructCreate ( $TAGGUITHREADINFO )
	DllStructSetData ( $TGTI , 1 , DllStructGetSize ( $TGTI ) )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetGUIThreadInfo" , "dword" , $ITHREADID , "struct*" , $TGTI )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 11 ]
	For $I = 0 To 10
		$ARET [ $I ] = DllStructGetData ( $TGTI , $I + 2 )
	Next
	For $I = 9 To 10
		$ARET [ $I ] -= $ARET [ $I + 4294967294 ]
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETLASTACTIVEPOPUP ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetLastActivePopup" , "hwnd" , $HWND )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	If $ACALL [ 0 ] = $HWND Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETLAYEREDWINDOWATTRIBUTES ( $HWND , ByRef $ITRANSCOLOR , ByRef $ITRANSGUI , $BCOLORREF = False )
	$ITRANSCOLOR = + 4294967295
	$ITRANSGUI = + 4294967295
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetLayeredWindowAttributes" , "hwnd" , $HWND , "INT*" , $ITRANSCOLOR , "byte*" , $ITRANSGUI , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	If Not $BCOLORREF Then
		$ACALL [ 2 ] = Int ( BinaryMid ( $ACALL [ 2 ] , 3 , 1 ) & BinaryMid ( $ACALL [ 2 ] , 2 , 1 ) & BinaryMid ( $ACALL [ 2 ] , 1 , 1 ) )
	EndIf
	$ITRANSCOLOR = $ACALL [ 2 ]
	$ITRANSGUI = $ACALL [ 3 ]
	Return $ACALL [ 4 ]
EndFunc
Func _WINAPI_GETMESSAGEEXTRAINFO ( )
	Local $ACALL = DllCall ( "user32.dll" , "lparam" , "GetMessageExtraInfo" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSHELLWINDOW ( )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetShellWindow" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTOPWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetTopWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOWDISPLAYAFFINITY ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetWindowDisplayAffinity" , "hwnd" , $HWND , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETWINDOWINFO ( $HWND )
	Local $TWINDOWINFO = DllStructCreate ( $TAGWINDOWINFO )
	DllStructSetData ( $TWINDOWINFO , "Size" , DllStructGetSize ( $TWINDOWINFO ) )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetWindowInfo" , "hwnd" , $HWND , "struct*" , $TWINDOWINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TWINDOWINFO
EndFunc
Func _WINAPI_GETWINDOWPLACEMENT ( $HWND )
	Local $TWINDOWPLACEMENT = DllStructCreate ( $TAGWINDOWPLACEMENT )
	DllStructSetData ( $TWINDOWPLACEMENT , "length" , DllStructGetSize ( $TWINDOWPLACEMENT ) )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetWindowPlacement" , "hwnd" , $HWND , "struct*" , $TWINDOWPLACEMENT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TWINDOWPLACEMENT
EndFunc
Func _WINAPI_ISCHILD ( $HWND , $HWNDPARENT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsChild" , "hwnd" , $HWNDPARENT , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISHUNGAPPWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsHungAppWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISICONIC ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsIconic" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISWINDOWUNICODE ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsWindowUnicode" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISZOOMED ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsZoomed" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_KILLTIMER ( $HWND , $ITIMERID )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "KillTimer" , "hwnd" , $HWND , "uint_ptr" , $ITIMERID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENICON ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "OpenIcon" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_POSTMESSAGE ( $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "PostMessage" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERCLASS ( $TWNDCLASS )
	Local $ACALL = DllCall ( "user32.dll" , "word" , "RegisterClassW" , "struct*" , $TWNDCLASS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERCLASSEX ( $TWNDCLASSEX )
	Local $ACALL = DllCall ( "user32.dll" , "word" , "RegisterClassExW" , "struct*" , $TWNDCLASSEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERSHELLHOOKWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "RegisterShellHookWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERWINDOWMESSAGE ( $SMESSAGE )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "RegisterWindowMessageW" , "wstr" , $SMESSAGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SENDMESSAGETIMEOUT ( $HWND , $IMSG , $WPARAM = 0 , $LPARAM = 0 , $ITIMEOUT = 1000 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "SendMessageTimeoutW" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM , "uint" , $IFLAGS , "uint" , $ITIMEOUT , "dword_ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , + 4294967295 )
	Return $ACALL [ 7 ]
EndFunc
Func _WINAPI_SETCLASSLONGEX ( $HWND , $IINDEX , $INEWLONG )
	Local $ACALL
	If @AutoItX64 Then
		$ACALL = DllCall ( "user32.dll" , "ulong_ptr" , "SetClassLongPtrW" , "hwnd" , $HWND , "int" , $IINDEX , "long_ptr" , $INEWLONG )
	Else
		$ACALL = DllCall ( "user32.dll" , "dword" , "SetClassLongW" , "hwnd" , $HWND , "int" , $IINDEX , "long" , $INEWLONG )
	EndIf
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFOREGROUNDWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetForegroundWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETLAYEREDWINDOWATTRIBUTES ( $HWND , $ITRANSCOLOR , $ITRANSGUI = 255 , $IFLAGS = 3 , $BCOLORREF = False )
	If $IFLAGS = Default Or $IFLAGS = "" Or $IFLAGS < 0 Then $IFLAGS = 3
	If Not $BCOLORREF Then
		$ITRANSCOLOR = Int ( BinaryMid ( $ITRANSCOLOR , 3 , 1 ) & BinaryMid ( $ITRANSCOLOR , 2 , 1 ) & BinaryMid ( $ITRANSCOLOR , 1 , 1 ) )
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetLayeredWindowAttributes" , "hwnd" , $HWND , "INT" , $ITRANSCOLOR , "byte" , $ITRANSGUI , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETMESSAGEEXTRAINFO ( $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "lparam" , "SetMessageExtraInfo" , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETSYSCOLORS ( $VELEMENTS , $VCOLORS )
	Local $BISEARRAY = IsArray ( $VELEMENTS ) , $BISCARRAY = IsArray ( $VCOLORS )
	Local $IELEMENTNUM
	If Not $BISCARRAY And Not $BISEARRAY Then
		$IELEMENTNUM = 1
	ElseIf $BISCARRAY Or $BISEARRAY Then
		If Not $BISCARRAY Or Not $BISEARRAY Then Return SetError ( + 4294967295 , + 4294967295 , False )
		If UBound ( $VELEMENTS ) <> UBound ( $VCOLORS ) Then Return SetError ( + 4294967295 , + 4294967295 , False )
		$IELEMENTNUM = UBound ( $VELEMENTS )
	EndIf
	Local $TELEMENTS = DllStructCreate ( "int Element[" & $IELEMENTNUM & "]" )
	Local $TCOLORS = DllStructCreate ( "INT NewColor[" & $IELEMENTNUM & "]" )
	If Not $BISEARRAY Then
		DllStructSetData ( $TELEMENTS , "Element" , $VELEMENTS , 1 )
	Else
		For $X = 0 To $IELEMENTNUM + 4294967295
			DllStructSetData ( $TELEMENTS , "Element" , $VELEMENTS [ $X ] , $X + 1 )
		Next
	EndIf
	If Not $BISCARRAY Then
		DllStructSetData ( $TCOLORS , "NewColor" , $VCOLORS , 1 )
	Else
		For $X = 0 To $IELEMENTNUM + 4294967295
			DllStructSetData ( $TCOLORS , "NewColor" , $VCOLORS [ $X ] , $X + 1 )
		Next
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetSysColors" , "int" , $IELEMENTNUM , "struct*" , $TELEMENTS , "struct*" , $TCOLORS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTIMER ( $HWND , $ITIMERID , $IELAPSE , $PTIMERFUNC )
	Local $ACALL = DllCall ( "user32.dll" , "uint_ptr" , "SetTimer" , "hwnd" , $HWND , "uint_ptr" , $ITIMERID , "uint" , $IELAPSE , "ptr" , $PTIMERFUNC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWDISPLAYAFFINITY ( $HWND , $IAFFINITY )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetWindowDisplayAffinity" , "hwnd" , $HWND , "dword" , $IAFFINITY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWLONG ( $HWND , $IINDEX , $IVALUE )
	_WINAPI_SETLASTERROR ( 0 )
	Local $SFUNCNAME = "SetWindowLongW"
	If @AutoItX64 Then $SFUNCNAME = "SetWindowLongPtrW"
	Local $ACALL = DllCall ( "user32.dll" , "long_ptr" , $SFUNCNAME , "hwnd" , $HWND , "int" , $IINDEX , "long_ptr" , $IVALUE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWPLACEMENT ( $HWND , $TWINDOWPLACEMENT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetWindowPlacement" , "hwnd" , $HWND , "struct*" , $TWINDOWPLACEMENT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHOWOWNEDPOPUPS ( $HWND , $BSHOW )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ShowOwnedPopups" , "hwnd" , $HWND , "bool" , $BSHOW )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SWITCHTOTHISWINDOW ( $HWND , $BALTTAB = False )
	DllCall ( "user32.dll" , "none" , "SwitchToThisWindow" , "hwnd" , $HWND , "bool" , $BALTTAB )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_TILEWINDOWS ( $AWNDS , $TRECT = 0 , $HPARENT = 0 , $IFLAGS = 0 , $ISTART = 0 , $IEND = + 4294967295 )
	If __CHECKERRORARRAYBOUNDS ( $AWNDS , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ICOUNT = $IEND - $ISTART + 1
	Local $TWNDS = DllStructCreate ( "hwnd[" & $ICOUNT & "]" )
	$ICOUNT = 1
	For $I = $ISTART To $IEND
		DllStructSetData ( $TWNDS , 1 , $AWNDS [ $I ] , $ICOUNT )
		$ICOUNT += 1
	Next
	Local $ACALL = DllCall ( "user32.dll" , "word" , "TileWindows" , "hwnd" , $HPARENT , "uint" , $IFLAGS , "struct*" , $TRECT , "uint" , $ICOUNT + 4294967295 , "struct*" , $TWNDS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNREGISTERCLASS ( $SCLASS , $HINSTANCE = 0 )
	Local $STYPEOFCLASS = "wstr"
	If Not IsString ( $SCLASS ) Then $STYPEOFCLASS = "ptr"
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnregisterClassW" , $STYPEOFCLASS , $SCLASS , "handle" , $HINSTANCE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UPDATELAYEREDWINDOW ( $HWND , $HDESTDC , $TPTDEST , $TSIZE , $HSRCDC , $TPTSRCE , $IRGB , $TBLEND , $IFLAGS )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UpdateLayeredWindow" , "hwnd" , $HWND , "handle" , $HDESTDC , "struct*" , $TPTDEST , "struct*" , $TSIZE , "handle" , $HSRCDC , "struct*" , $TPTSRCE , "dword" , $IRGB , "struct*" , $TBLEND , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UPDATELAYEREDWINDOWEX ( $HWND , $IX , $IY , $HBITMAP , $IOPACITY = 255 , $BDELETE = False )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetDC" , "hwnd" , $HWND )
	Local $HDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "CreateCompatibleDC" , "handle" , $HDC )
	Local $HDESTDC = $ACALL [ 0 ]
	$ACALL = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDESTDC , "handle" , $HBITMAP )
	Local $HDESTSV = $ACALL [ 0 ]
	Local $TPOINT
	If ( $IX = + 4294967295 ) And ( $IY = + 4294967295 ) Then
		$TPOINT = DllStructCreate ( "int;int" )
	Else
		$TPOINT = DllStructCreate ( "int;int;int;int" )
		DllStructSetData ( $TPOINT , 3 , $IX )
		DllStructSetData ( $TPOINT , 4 , $IY )
	EndIf
	DllStructSetData ( $TPOINT , 1 , 0 )
	DllStructSetData ( $TPOINT , 2 , 0 )
	Local $TBLENDFUNCTION = DllStructCreate ( $TAGBLENDFUNCTION )
	DllStructSetData ( $TBLENDFUNCTION , 1 , 0 )
	DllStructSetData ( $TBLENDFUNCTION , 2 , 0 )
	DllStructSetData ( $TBLENDFUNCTION , 3 , $IOPACITY )
	DllStructSetData ( $TBLENDFUNCTION , 4 , 1 )
	Local Const $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
	Local $TOBJ = DllStructCreate ( $TAGBITMAP )
	DllCall ( "gdi32.dll" , "int" , "GetObject" , "handle" , $HBITMAP , "int" , DllStructGetSize ( $TOBJ ) , "struct*" , $TOBJ )
	Local $TSIZE = DllStructCreate ( $TAGSIZE , DllStructGetPtr ( $TOBJ , "bmWidth" ) )
	$ACALL = DllCall ( "user32.dll" , "bool" , "UpdateLayeredWindow" , "hwnd" , $HWND , "handle" , $HDC , "ptr" , DllStructGetPtr ( $TPOINT , 3 ) , "struct*" , $TSIZE , "handle" , $HDESTDC , "struct*" , $TPOINT , "dword" , 0 , "struct*" , $TBLENDFUNCTION , "dword" , 2 )
	Local $IERROR = @error
	DllCall ( "user32.dll" , "bool" , "ReleaseDC" , "hwnd" , $HWND , "handle" , $HDC )
	DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDESTDC , "handle" , $HDESTSV )
	DllCall ( "gdi32.dll" , "bool" , "DeleteDC" , "handle" , $HDESTDC )
	If $IERROR Then Return SetError ( $IERROR , 0 , False )
	If $BDELETE Then
		DllCall ( "gdi32.dll" , "bool" , "DeleteObject" , "handle" , $HBITMAP )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UPDATELAYEREDWINDOWINDIRECT ( $HWND , $TULWINFO )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UpdateLayeredWindowIndirect" , "hwnd" , $HWND , "struct*" , $TULWINFO )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WINDOWFROMPOINT ( ByRef $TPOINT )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "WindowFromPoint" , "struct" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __ENUMDEFAULTPROC ( $PDATA , $LPARAM )
	#forceref $lParam
	Local $ILENGTH = _WINAPI_STRLEN ( $PDATA )
	__INC ( $__G_VENUM )
	If $ILENGTH Then
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = DllStructGetData ( DllStructCreate ( "wchar[" & ( $ILENGTH + 1 ) & "]" , $PDATA ) , 1 )
	Else
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = ""
	EndIf
	Return 1
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $TAGOSVERSIONINFOEX = $TAGOSVERSIONINFO & ";ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved"
Global Const $TAGRAWINPUTDEVICE = "struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct"
Global Const $TAGRAWINPUTHEADER = "struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct"
Global Const $TAGRAWMOUSE = "ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;"
Global Const $TAGRAWKEYBOARD = "ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;"
Global Const $TAGRAWHID = "dword SizeHid;dword Count;"
Global Const $TAGRAWINPUTMOUSE = $TAGRAWINPUTHEADER & ";" & $TAGRAWMOUSE
Global Const $TAGRAWINPUTKEYBOARD = $TAGRAWINPUTHEADER & ";" & $TAGRAWKEYBOARD
Global Const $TAGRAWINPUTHID = $TAGRAWINPUTHEADER & ";" & $TAGRAWHID
Global Const $TAGRID_DEVICE_INFO_MOUSE = "struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc"
Global Const $TAGRID_DEVICE_INFO_KEYBOARD = "struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruct"
Global Const $TAGRID_DEVICE_INFO_HID = "struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc"
Global Const $TAGRID_INFO_MOUSE = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_MOUSE & ";dword Unused[2];"
Global Const $TAGRID_INFO_KEYBOARD = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_KEYBOARD
Global Const $TAGRID_INFO_HID = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_HID & ";dword Unused[2]"
Global Const $TAGUSEROBJECTFLAGS = "int Inherit;int Reserved;dword Flags"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_ACTIVATEKEYBOARDLAYOUT ( $HLOCALE , $IFLAG = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "ActivateKeyboardLayout" , "handle" , $HLOCALE , "uint" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ADDCLIPBOARDFORMATLISTENER ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "AddClipboardFormatListener" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CALLNEXTHOOKEX ( $HHOOK , $ICODE , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "CallNextHookEx" , "handle" , $HHOOK , "int" , $ICODE , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CLOSEDESKTOP ( $HDESKTOP )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "CloseDesktop" , "handle" , $HDESKTOP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CLOSEWINDOWSTATION ( $HSTATION )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "CloseWindowStation" , "handle" , $HSTATION )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COMPRESSBUFFER ( $PUNCOMPRESSEDBUFFER , $IUNCOMPRESSEDSIZE , $PCOMPRESSEDBUFFER , $ICOMPRESSEDSIZE , $IFORMATANDENGINE = 2 )
	Local $ACALL , $PWORKSPACE = 0 , $IERROR = 0
	Do
		$ACALL = DllCall ( "ntdll.dll" , "uint" , "RtlGetCompressionWorkSpaceSize" , "ushort" , $IFORMATANDENGINE , "ulong*" , 0 , "ulong*" , 0 )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
		$PWORKSPACE = __HEAPALLOC ( $ACALL [ 2 ] )
		If @error Then
			$IERROR = @error + 100
			ExitLoop
		EndIf
		$ACALL = DllCall ( "ntdll.dll" , "uint" , "RtlCompressBuffer" , "ushort" , $IFORMATANDENGINE , "struct*" , $PUNCOMPRESSEDBUFFER , "ulong" , $IUNCOMPRESSEDSIZE , "struct*" , $PCOMPRESSEDBUFFER , "ulong" , $ICOMPRESSEDSIZE , "ulong" , 4096 , "ulong*" , 0 , "ptr" , $PWORKSPACE )
		If @error Or $ACALL [ 0 ] Or Not $ACALL [ 7 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
	Until 1
	__HEAPFREE ( $PWORKSPACE )
	If $IERROR Then
		If IsArray ( $ACALL ) Then
			Return SetError ( 10 , $ACALL [ 0 ] , 0 )
		Else
			Return SetError ( $IERROR , 0 , 0 )
		EndIf
	EndIf
	Return $ACALL [ 7 ]
EndFunc
Func _WINAPI_COMPUTECRC32 ( $PMEMORY , $ILENGTH )
	If _WINAPI_ISBADREADPTR ( $PMEMORY , $ILENGTH ) Then Return SetError ( 1 , @extended , 0 )
	Local $ACALL = DllCall ( "ntdll.dll" , "dword" , "RtlComputeCrc32" , "dword" , 0 , "struct*" , $PMEMORY , "int" , $ILENGTH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEDESKTOP ( $SNAME , $IACCESS = 2 , $IFLAGS = 0 , $IHEAP = 0 , $TSECURITY = 0 )
	Local $ACALL
	If $IHEAP Then
		$ACALL = DllCall ( "user32.dll" , "handle" , "CreateDesktopExW" , "wstr" , $SNAME , "ptr" , 0 , "ptr" , 0 , "dword" , $IFLAGS , "dword" , $IACCESS , "struct*" , $TSECURITY , "ulong" , $IHEAP , "ptr" , 0 )
	Else
		$ACALL = DllCall ( "user32.dll" , "handle" , "CreateDesktopW" , "wstr" , $SNAME , "ptr" , 0 , "ptr" , 0 , "dword" , $IFLAGS , "dword" , $IACCESS , "struct*" , $TSECURITY )
	EndIf
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEWINDOWSTATION ( $SNAME = "" , $IACCESS = 0 , $IFLAGS = 0 , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "CreateWindowStationW" , "wstr" , $SNAME , "dword" , $IFLAGS , "dword" , $IACCESS , "struct*" , $TSECURITY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DECOMPRESSBUFFER ( $PUNCOMPRESSEDBUFFER , $IUNCOMPRESSEDSIZE , $PCOMPRESSEDBUFFER , $ICOMPRESSEDSIZE , $IFORMAT = 2 )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "RtlDecompressBuffer" , "ushort" , $IFORMAT , "struct*" , $PUNCOMPRESSEDBUFFER , "ulong" , $IUNCOMPRESSEDSIZE , "struct*" , $PCOMPRESSEDBUFFER , "ulong" , $ICOMPRESSEDSIZE , "ulong*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _WINAPI_DEFRAWINPUTPROC ( $PARAWINPUT , $IINPUT )
	Local $ACALL = DllCall ( "user32.dll" , "lresult" , "DefRawInputProc" , "ptr" , $PARAWINPUT , "int" , $IINPUT , "uint" , DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTHEADER ) ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_ENUMDESKTOPS ( $HSTATION )
	If StringCompare ( _WINAPI_GETUSEROBJECTINFORMATION ( $HSTATION , 3 ) , "WindowStation" ) Then Return SetError ( 1 , 0 , 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumDefaultProc" , "bool" , "ptr;lparam" )
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnumDesktopsW" , "handle" , $HSTATION , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMDESKTOPWINDOWS ( $HDESKTOP , $BVISIBLE = True )
	If StringCompare ( _WINAPI_GETUSEROBJECTINFORMATION ( $HDESKTOP , 3 ) , "Desktop" ) Then Return SetError ( 1 , 0 , 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumWindowsProc" , "bool" , "hwnd;lparam" )
	Dim $__G_VENUM [ 101 ] [ 2 ] = [ [ 0 ] ]
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnumDesktopWindows" , "handle" , $HDESKTOP , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , $BVISIBLE )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMPAGEFILES ( )
	Local $AINFO = _WINAPI_GETSYSTEMINFO ( )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumPageFilesProc" , "bool" , "lparam;ptr;ptr" )
	Dim $__G_VENUM [ 101 ] [ 4 ] = [ [ 0 ] ]
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumPageFilesW" , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , $AINFO [ 1 ] )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMRAWINPUTDEVICES ( )
	Local Const $TAGRAWINPUTDEVICELIST = "struct;handle hDevice;dword Type;endstruct"
	Local $TRIDL , $ILENGTH = DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTDEVICELIST ) )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetRawInputDeviceList" , "ptr" , 0 , "uint*" , 0 , "uint" , $ILENGTH )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	If ( $ACALL [ 0 ] = 4294967295 ) Or ( Not $ACALL [ 2 ] ) Then Return SetError ( 10 , + 4294967295 , 0 )
	Local $TDATA = DllStructCreate ( "byte[" & ( $ACALL [ 2 ] * $ILENGTH ) & "]" )
	Local $PDATA = DllStructGetPtr ( $TDATA )
	If @error Then Return SetError ( @error + 20 , 0 , 0 )
	$ACALL = DllCall ( "user32.dll" , "uint" , "GetRawInputDeviceList" , "ptr" , $PDATA , "uint*" , $ACALL [ 2 ] , "uint" , $ILENGTH )
	If ( $ACALL [ 0 ] = 4294967295 ) Or ( Not $ACALL [ 0 ] ) Then Return SetError ( 1 , + 4294967295 , 0 )
	Local $ARET [ $ACALL [ 2 ] + 1 ] [ 2 ] = [ [ $ACALL [ 2 ] ] ]
	For $I = 1 To $ACALL [ 2 ]
		$TRIDL = DllStructCreate ( "ptr;dword" , $PDATA + $ILENGTH * ( $I + 4294967295 ) )
		For $J = 0 To 1
			$ARET [ $I ] [ $J ] = DllStructGetData ( $TRIDL , $J + 1 )
		Next
	Next
	Return $ARET
EndFunc
Func _WINAPI_ENUMWINDOWSTATIONS ( )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumDefaultProc" , "bool" , "ptr;lparam" )
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "EnumWindowStationsW" , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_EXPANDENVIRONMENTSTRINGS ( $SSTRING )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "ExpandEnvironmentStringsW" , "wstr" , $SSTRING , "wstr" , "" , "dword" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETACTIVEWINDOW ( )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetActiveWindow" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETASYNCKEYSTATE ( $IKEY )
	Local $ACALL = DllCall ( "user32.dll" , "short" , "GetAsyncKeyState" , "int" , $IKEY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCAPTURE ( )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "GetCapture" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCLIPBOARDSEQUENCENUMBER ( )
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "GetClipboardSequenceNumber" )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCURRENTHWPROFILE ( )
	Local $TAGHW_PROFILE_INFO = "dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]"
	Local $THWPI = DllStructCreate ( $TAGHW_PROFILE_INFO )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "GetCurrentHwProfileW" , "struct*" , $THWPI )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 3 ]
	For $I = 0 To 2
		$ARET [ $I ] = DllStructGetData ( $THWPI , $I + 1 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETDEFAULTPRINTER ( )
	Local $ACALL = DllCall ( "winspool.drv" , "bool" , "GetDefaultPrinterW" , "wstr" , "" , "dword*" , 2048 )
	If @error Then Return SetError ( @error , @extended , "" )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_GETDLLDIRECTORY ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetDllDirectoryW" , "dword" , 4096 , "wstr" , "" )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETEFFECTIVECLIENTRECT ( $HWND , $ACTRL , $ISTART = 0 , $IEND = + 4294967295 )
	If Not IsArray ( $ACTRL ) Then
		Local $ICTRL = $ACTRL
		Dim $ACTRL [ 1 ] = [ $ICTRL ]
		$ISTART = 0
		$IEND = 0
	EndIf
	If __CHECKERRORARRAYBOUNDS ( $ACTRL , $ISTART , $IEND ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ICOUNT = $IEND - $ISTART + 1
	Local $TCTRL = DllStructCreate ( "uint64[" & ( $ICOUNT + 2 ) & "]" )
	$ICOUNT = 2
	For $I = $ISTART To $IEND
		If IsHWnd ( $ACTRL [ $I ] ) Then
			$ACTRL [ $I ] = _WINAPI_GETDLGCTRLID ( $ACTRL [ $I ] )
		EndIf
		DllStructSetData ( $TCTRL , 1 , _WINAPI_MAKEQWORD ( 1 , $ACTRL [ $I ] ) , $ICOUNT )
		$ICOUNT += 1
	Next
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllCall ( "comctl32.dll" , "none" , "GetEffectiveClientRect" , "hwnd" , $HWND , "struct*" , $TRECT , "struct*" , $TCTRL )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETHANDLEINFORMATION ( $HOBJECT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetHandleInformation" , "handle" , $HOBJECT , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETIDLETIME ( )
	Local $TLASTINPUTINFO = DllStructCreate ( "uint;dword" )
	DllStructSetData ( $TLASTINPUTINFO , 1 , DllStructGetSize ( $TLASTINPUTINFO ) )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetLastInputInfo" , "struct*" , $TLASTINPUTINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return _WINAPI_GETTICKCOUNT ( ) - DllStructGetData ( $TLASTINPUTINFO , 2 )
EndFunc
Func _WINAPI_GETKEYBOARDLAYOUT ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "GetWindowThreadProcessId" , "hwnd" , $HWND , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	$ACALL = DllCall ( "user32.dll" , "handle" , "GetKeyboardLayout" , "dword" , $ACALL [ 0 ] )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETKEYBOARDLAYOUTLIST ( )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetKeyboardLayoutList" , "int" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TDATA = DllStructCreate ( "handle[" & $ACALL [ 0 ] & "]" )
	$ACALL = DllCall ( "user32.dll" , "uint" , "GetKeyboardLayoutList" , "int" , $ACALL [ 0 ] , "struct*" , $TDATA )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ALIST [ $ACALL [ 0 ] + 1 ] = [ $ACALL [ 0 ] ]
	For $I = 1 To $ALIST [ 0 ]
		$ALIST [ $I ] = DllStructGetData ( $TDATA , 1 , $I )
	Next
	Return $ALIST
EndFunc
Func _WINAPI_GETKEYBOARDSTATE ( )
	Local $TDATA = DllStructCreate ( "byte[256]" )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetKeyboardState" , "struct*" , $TDATA )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TDATA
EndFunc
Func _WINAPI_GETKEYBOARDTYPE ( $ITYPE )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetKeyboardType" , "int" , $ITYPE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETKEYNAMETEXT ( $LPARAM )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "GetKeyNameTextW" , "long" , $LPARAM , "wstr" , "" , "int" , 128 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETKEYSTATE ( $VKEY )
	Local $ACALL = DllCall ( "user32.dll" , "short" , "GetKeyState" , "int" , $VKEY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETMODULEHANDLEEX ( $SMODULE , $IFLAGS = 0 )
	If StringStripWS ( $SMODULE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) = "" Then $SMODULE = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetModuleHandleExW" , "dword" , $IFLAGS , "wstr" , $SMODULE , "ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETMUILANGUAGE ( )
	Local $ACALL = DllCall ( "comctl32.dll" , "word" , "GetMUILanguage" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPERFORMANCEINFO ( )
	Local $TPI = DllStructCreate ( "dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword" )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "GetPerformanceInfo" , "struct*" , $TPI , "dword" , DllStructGetSize ( $TPI ) )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 13 ]
	For $I = 0 To 12
		$ARET [ $I ] = DllStructGetData ( $TPI , $I + 2 )
	Next
	For $I = 0 To 8
		$ARET [ $I ] *= $ARET [ 9 ]
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETPROCADDRESS ( $HMODULE , $VNAME )
	Local $STYPE = "str"
	If IsNumber ( $VNAME ) Then $STYPE = "word"
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "GetProcAddress" , "handle" , $HMODULE , $STYPE , $VNAME )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPHYSICALLYINSTALLEDSYSTEMMEMORY ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetPhysicallyInstalledSystemMemory" , "uint64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_GETPROCESSSHUTDOWNPARAMETERS ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetProcessShutdownParameters" , "dword*" , 0 , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return SetExtended ( Number ( Not $ACALL [ 2 ] ) , $ACALL [ 1 ] )
EndFunc
Func _WINAPI_GETPROCESSWINDOWSTATION ( )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetProcessWindowStation" )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPWRCAPABILITIES ( )
	If Not __DLL ( "powrprof.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $TSPC = DllStructCreate ( "byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]" )
	Local $ACALL = DllCall ( "powrprof.dll" , "boolean" , "GetPwrCapabilities" , "struct*" , $TSPC )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 25 ]
	For $I = 0 To 17
		$ARET [ $I ] = DllStructGetData ( $TSPC , 1 , $I + 1 )
	Next
	$ARET [ 18 ] = DllStructGetData ( $TSPC , 3 )
	For $I = 19 To 20
		$ARET [ $I ] = DllStructGetData ( $TSPC , 5 , $I + 4294967278 )
	Next
	For $I = 21 To 24
		$ARET [ $I ] = DllStructGetData ( $TSPC , 7 , $I + 4294967276 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETRAWINPUTBUFFER ( $PBUFFER , $ILENGTH )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetRawInputBuffer" , "struct*" , $PBUFFER , "uint*" , $ILENGTH , "uint" , DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTHEADER ) ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	If ( $ACALL [ 0 ] = 4294967295 ) Or ( Not $ACALL [ 1 ] ) Then Return SetError ( 10 , + 4294967295 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETRAWINPUTBUFFERLENGTH ( )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetRawInputBuffer" , "ptr" , 0 , "uint*" , 0 , "uint" , DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTHEADER ) ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 4294967295 Then Return SetError ( 10 , + 4294967295 , 0 )
	Return $ACALL [ 2 ] * 8
EndFunc
Func _WINAPI_GETRAWINPUTDATA ( $HRAWINPUT , $PBUFFER , $ILENGTH , $IFLAG )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetRawInputData" , "handle" , $HRAWINPUT , "uint" , $IFLAG , "struct*" , $PBUFFER , "uint*" , $ILENGTH , "uint" , DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTHEADER ) ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 4294967295 Then Return SetError ( 10 , + 4294967295 , 0 )
	Return ( $ACALL [ 3 ] ? $ACALL [ 0 ] : $ACALL [ 4 ] )
EndFunc
Func _WINAPI_GETRAWINPUTDEVICEINFO ( $HDEVICE , $PBUFFER , $ILENGTH , $IFLAG )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetRawInputDeviceInfoW" , "handle" , $HDEVICE , "uint" , $IFLAG , "struct*" , $PBUFFER , "uint*" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 4294967295 Then Return SetError ( 10 , + 4294967295 , 0 )
	Return ( $ACALL [ 3 ] ? $ACALL [ 0 ] : $ACALL [ 4 ] )
EndFunc
Func _WINAPI_GETREGISTEREDRAWINPUTDEVICES ( $PBUFFER , $ILENGTH )
	Local $ILENGTHRAW = DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTDEVICE ) )
	Local $ACALL = DllCall ( "user32.dll" , "uint" , "GetRegisteredRawInputDevices" , "struct*" , $PBUFFER , "uint*" , Floor ( $ILENGTH / $ILENGTHRAW ) , "uint" , $ILENGTHRAW )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = 4294967295 Then
		Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
		If $ILASTERROR = 122 Then Return SetExtended ( $ILASTERROR , $ACALL [ 2 ] * $ILENGTHRAW )
		Return SetError ( 10 , $ILASTERROR , 0 )
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSTARTUPINFO ( )
	Local $TSI = DllStructCreate ( $TAGSTARTUPINFO )
	DllCall ( "kernel32.dll" , "none" , "GetStartupInfoW" , "struct*" , $TSI )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $TSI
EndFunc
Func _WINAPI_GETSYSTEMDEPPOLICY ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "GetSystemDEPPolicy" )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSYSTEMINFO ( )
	Local $SPROC
	If _WINAPI_ISWOW64PROCESS ( ) Then
		$SPROC = "GetNativeSystemInfo"
	Else
		$SPROC = "GetSystemInfo"
	EndIf
	Local Const $TAGSYSTEMINFO = "struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;" & "ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;" & "dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision"
	Local $TSYSTEMINFO = DllStructCreate ( $TAGSYSTEMINFO )
	DllCall ( "kernel32.dll" , "none" , $SPROC , "struct*" , $TSYSTEMINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 10 ]
	$ARET [ 0 ] = DllStructGetData ( $TSYSTEMINFO , 1 )
	For $I = 1 To 9
		$ARET [ $I ] = DllStructGetData ( $TSYSTEMINFO , $I + 2 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETSYSTEMPOWERSTATUS ( )
	Local $TAGSYSTEM_POWER_STATUS = "byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;" & "int BatteryLifeTime;int BatteryFullLifeTime"
	Local $TSYSTEM_POWER_STATUS = DllStructCreate ( $TAGSYSTEM_POWER_STATUS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetSystemPowerStatus" , "struct*" , $TSYSTEM_POWER_STATUS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 5 ]
	$ARET [ 0 ] = DllStructGetData ( $TSYSTEM_POWER_STATUS , 1 )
	$ARET [ 1 ] = DllStructGetData ( $TSYSTEM_POWER_STATUS , 2 )
	$ARET [ 2 ] = DllStructGetData ( $TSYSTEM_POWER_STATUS , 3 )
	$ARET [ 3 ] = DllStructGetData ( $TSYSTEM_POWER_STATUS , 5 )
	$ARET [ 4 ] = DllStructGetData ( $TSYSTEM_POWER_STATUS , 6 )
	Return $ARET
EndFunc
Func _WINAPI_GETSYSTEMTIMES ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetSystemTimes" , "uint64*" , 0 , "uint64*" , 0 , "uint64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 3 ]
	For $I = 0 To 2
		$ARET [ $I ] = $ACALL [ $I + 1 ]
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETSYSTEMWOW64DIRECTORY ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "GetSystemWow64DirectoryW" , "wstr" , "" , "uint" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , _WINAPI_GETLASTERROR ( ) , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_GETTICKCOUNT ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetTickCount" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTICKCOUNT64 ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint64" , "GetTickCount64" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETUSEROBJECTINFORMATION ( $HOBJECT , $IINDEX )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "GetUserObjectInformationW" , "handle" , $HOBJECT , "int" , $IINDEX , "ptr" , 0 , "dword" , 0 , "dword*" , 0 )
	If @error Or Not $ACALL [ 5 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TDATA
	Switch $IINDEX
	Case 1
		$TDATA = DllStructCreate ( $TAGUSEROBJECTFLAGS )
	Case 5 , 6
		$TDATA = DllStructCreate ( "uint" )
	Case 2 , 3
		$TDATA = DllStructCreate ( "wchar[" & $ACALL [ 5 ] & "]" )
	Case 4
		$TDATA = DllStructCreate ( "byte[" & $ACALL [ 5 ] & "]" )
Case Else
		Return SetError ( 20 , 0 , 0 )
	EndSwitch
	$ACALL = DllCall ( "user32.dll" , "bool" , "GetUserObjectInformationW" , "handle" , $HOBJECT , "int" , $IINDEX , "struct*" , $TDATA , "dword" , DllStructGetSize ( $TDATA ) , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 30 , @extended , 0 )
	Switch $IINDEX
	Case 1 , 4
		Return $TDATA
Case Else
		Return DllStructGetData ( $TDATA , 1 )
	EndSwitch
EndFunc
Func _WINAPI_GETVERSIONEX ( )
	Local $TOSVERSIONINFOEX = DllStructCreate ( $TAGOSVERSIONINFOEX )
	DllStructSetData ( $TOSVERSIONINFOEX , "OSVersionInfoSize" , DllStructGetSize ( $TOSVERSIONINFOEX ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetVersionExW" , "struct*" , $TOSVERSIONINFOEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TOSVERSIONINFOEX
EndFunc
Func _WINAPI_GETWORKAREA ( )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "SystemParametersInfo" , "uint" , 48 , "uint" , 0 , "struct*" , $TRECT , "uint" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_INITMUILANGUAGE ( $ILANGUAGE )
	DllCall ( "comctl32.dll" , "none" , "InitMUILanguage" , "word" , $ILANGUAGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_ISLOADKBLAYOUT ( $ILANGUAGE )
	Local $ALAYOUT = _WINAPI_GETKEYBOARDLAYOUTLIST ( )
	If @error Then Return SetError ( @error , @extended , False )
	For $I = 1 To $ALAYOUT [ 0 ]
		If $ALAYOUT [ $I ] = $ILANGUAGE Then Return True
	Next
	Return False
EndFunc
Func _WINAPI_ISPROCESSORFEATUREPRESENT ( $IFEATURE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsProcessorFeaturePresent" , "dword" , $IFEATURE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISWINDOWENABLED ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsWindowEnabled" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_KEYBD_EVENT ( $VKEY , $IFLAGS , $ISCANCODE = 0 , $IEXTRAINFO = 0 )
	DllCall ( "user32.dll" , "none" , "keybd_event" , "byte" , $VKEY , "byte" , $ISCANCODE , "dword" , $IFLAGS , "ulong_ptr" , $IEXTRAINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_LOADKEYBOARDLAYOUT ( $ILANGUAGE , $IFLAG = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "LoadKeyboardLayoutW" , "wstr" , Hex ( $ILANGUAGE , 8 ) , "uint" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOCKWORKSTATION ( )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "LockWorkStation" )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MAPVIRTUALKEY ( $ICODE , $ITYPE , $HLOCALE = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "INT" , "MapVirtualKeyExW" , "uint" , $ICODE , "uint" , $ITYPE , "uint_ptr" , $HLOCALE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MOUSE_EVENT ( $IFLAGS , $IX = 0 , $IY = 0 , $IDATA = 0 , $IEXTRAINFO = 0 )
	DllCall ( "user32.dll" , "none" , "mouse_event" , "dword" , $IFLAGS , "dword" , $IX , "dword" , $IY , "dword" , $IDATA , "ulong_ptr" , $IEXTRAINFO )
	If @error Then Return SetError ( @error , @extended )
EndFunc
Func _WINAPI_OPENDESKTOP ( $SNAME , $IACCESS = 0 , $IFLAGS = 0 , $BINHERIT = False )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "OpenDesktopW" , "wstr" , $SNAME , "dword" , $IFLAGS , "bool" , $BINHERIT , "dword" , $IACCESS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENINPUTDESKTOP ( $IACCESS = 0 , $IFLAGS = 0 , $BINHERIT = False )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "OpenInputDesktop" , "dword" , $IFLAGS , "bool" , $BINHERIT , "dword" , $IACCESS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENWINDOWSTATION ( $SNAME , $IACCESS = 0 , $BINHERIT = False )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "OpenWindowStationW" , "wstr" , $SNAME , "bool" , $BINHERIT , "dword" , $IACCESS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_QUERYPERFORMANCECOUNTER ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "QueryPerformanceCounter" , "int64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_QUERYPERFORMANCEFREQUENCY ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "QueryPerformanceFrequency" , "int64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_REGISTERHOTKEY ( $HWND , $IID , $IMODIFIERS , $VKEY )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "RegisterHotKey" , "hwnd" , $HWND , "int" , $IID , "uint" , $IMODIFIERS , "uint" , $VKEY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERPOWERSETTINGNOTIFICATION ( $HWND , $SGUID )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	$ACALL = DllCall ( "user32.dll" , "handle" , "RegisterPowerSettingNotification" , "handle" , $HWND , "struct*" , $TGUID , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERRAWINPUTDEVICES ( $PADEVICE , $ICOUNT = 1 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "RegisterRawInputDevices" , "struct*" , $PADEVICE , "uint" , $ICOUNT , "uint" , DllStructGetSize ( DllStructCreate ( $TAGRAWINPUTDEVICE ) ) )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RELEASECAPTURE ( )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ReleaseCapture" )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REMOVECLIPBOARDFORMATLISTENER ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "RemoveClipboardFormatListener" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETACTIVEWINDOW ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "SetActiveWindow" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETCAPTURE ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "hwnd" , "SetCapture" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETDEFAULTPRINTER ( $SPRINTER )
	Local $ACALL = DllCall ( "winspool.drv" , "bool" , "SetDefaultPrinterW" , "wstr" , $SPRINTER )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETDLLDIRECTORY ( $SDIRPATH = Default )
	If $SDIRPATH = Default Then $SDIRPATH = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetDllDirectoryW" , "wstr" , $SDIRPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETKEYBOARDLAYOUT ( $HWND , $ILANGUAGE , $IFLAGS = 0 )
	If Not _WINAPI_ISWINDOW ( $HWND ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $HLOCALE = 0
	If $ILANGUAGE Then
		$HLOCALE = _WINAPI_LOADKEYBOARDLAYOUT ( $ILANGUAGE )
		If Not $HLOCALE Then Return SetError ( 10 , 0 , 0 )
	EndIf
	Local Const $WM_INPUTLANGCHANGEREQUEST = 80
	DllCall ( "user32.dll" , "none" , "SendMessage" , "hwnd" , $HWND , "uint" , $WM_INPUTLANGCHANGEREQUEST , "uint" , $IFLAGS , "uint_ptr" , $HLOCALE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SETKEYBOARDSTATE ( ByRef $TSTATE )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "SetKeyboardState" , "struct*" , $TSTATE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETPROCESSSHUTDOWNPARAMETERS ( $ILEVEL , $BDIALOG = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetProcessShutdownParameters" , "dword" , $ILEVEL , "dword" , Not $BDIALOG )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETPROCESSWINDOWSTATION ( $HSTATION )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetProcessWindowStation" , "handle" , $HSTATION )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETUSEROBJECTINFORMATION ( $HOBJECT , $IINDEX , ByRef $TDATA )
	If $IINDEX <> 1 Then Return SetError ( 10 , 0 , False )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetUserObjectInformationW" , "handle" , $HOBJECT , "int" , 1 , "struct*" , $TDATA , "dword" , DllStructGetSize ( $TDATA ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINDOWSHOOKEX ( $IHOOK , $PPROC , $HDLL , $ITHREADID = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "SetWindowsHookEx" , "int" , $IHOOK , "ptr" , $PPROC , "handle" , $HDLL , "dword" , $ITHREADID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETWINEVENTHOOK ( $IEVENTMIN , $IEVENTMAX , $PEVENTPROC , $IPID = 0 , $ITHREADID = 0 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "SetWinEventHook" , "uint" , $IEVENTMIN , "uint" , $IEVENTMAX , "ptr" , 0 , "ptr" , $PEVENTPROC , "dword" , $IPID , "dword" , $ITHREADID , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHUTDOWNBLOCKREASONCREATE ( $HWND , $STEXT )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ShutdownBlockReasonCreate" , "hwnd" , $HWND , "wstr" , $STEXT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHUTDOWNBLOCKREASONDESTROY ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ShutdownBlockReasonDestroy" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHUTDOWNBLOCKREASONQUERY ( $HWND )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "ShutdownBlockReasonQuery" , "hwnd" , $HWND , "wstr" , "" , "dword*" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_SWITCHDESKTOP ( $HDESKTOP )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SwitchDesktop" , "handle" , $HDESKTOP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SYSTEMPARAMETERSINFO ( $IACTION , $IPARAM = 0 , $VPARAM = 0 , $IWININI = 0 )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SystemParametersInfoW" , "uint" , $IACTION , "uint" , $IPARAM , "struct*" , $VPARAM , "uint" , $IWININI )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_TRACKMOUSEEVENT ( $HWND , $IFLAGS , $ITIME = + 4294967295 )
	Local $TTME = DllStructCreate ( "dword;dword;hwnd;dword" )
	DllStructSetData ( $TTME , 1 , DllStructGetSize ( $TTME ) )
	DllStructSetData ( $TTME , 2 , $IFLAGS )
	DllStructSetData ( $TTME , 3 , $HWND )
	DllStructSetData ( $TTME , 4 , $ITIME )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "TrackMouseEvent" , "struct*" , $TTME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNHOOKWINDOWSHOOKEX ( $HHOOK )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnhookWindowsHookEx" , "handle" , $HHOOK )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNHOOKWINEVENT ( $HEVENTHOOK )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnhookWinEvent" , "handle" , $HEVENTHOOK )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNLOADKEYBOARDLAYOUT ( $HLOCALE )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnloadKeyboardLayout" , "handle" , $HLOCALE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNREGISTERHOTKEY ( $HWND , $IID )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnregisterHotKey" , "hwnd" , $HWND , "int" , $IID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNREGISTERPOWERSETTINGNOTIFICATION ( $HNOTIFY )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "UnregisterPowerSettingNotification" , "handle" , $HNOTIFY )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func __ENUMPAGEFILESPROC ( $ISIZE , $PINFO , $PFILE )
	Local $TEPFI = DllStructCreate ( "dword;dword;ulong_ptr;ulong_ptr;ulong_ptr" , $PINFO )
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( DllStructCreate ( "wchar[" & ( _WINAPI_STRLEN ( $PFILE ) + 1 ) & "]" , $PFILE ) , 1 )
	For $I = 1 To 3
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ $I ] = DllStructGetData ( $TEPFI , $I + 2 ) * $ISIZE
	Next
	Return 1
EndFunc
#EndRegion Public Functions
Global $AGLVEX_DATA [ 1 ] [ 26 ] = [ [ 0 , 0 , + 4294967295 , "" , + 4294967295 , + 4294967295 , + 4294967295 , + 4294967295 , _WINAPI_GETSYSTEMMETRICS ( 2 ) , False , + 4294967295 , + 4294967295 , False , "" , 0 , True , 0 , + 4294967295 , + 4294967295 , 0 , 0 , 0 , 0 , "08" ] ]
Global $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IGLVEX_SRCINDEX , $AGLVEX_SRCARRAY , $AGLVEX_SRCCOLARRAY
Global $HGLVEX_TGTHANDLE , $CGLVEX_TGTID , $IGLVEX_TGTINDEX , $AGLVEX_TGTARRAY , $AGLVEX_TGTCOLARRAY
Global $IGLVEX_DRAGGING = 0 , $IGLVEX_DRAGGEDINDEX , $HGLVEX_DRAGGEDIMAGE = 0 , $SGLVEX_DRAGEVENT
Global $IGLVEX_INSERTINDEX = + 4294967295 , $IGLVEX_LASTY , $FGLVEX_BARUNDER , $FGVLEX_RESIZED = + 4294967295
Global $HGLVEX_EDITING , $CGLVEX_EDITID = 9999 , $FGLVEX_EDITCLICKFLAG = 0 , $FGLVEX_HEADEREDIT = False
Global $FGLVEX_SELCHANGEFLAG = 0 , $FGLVEX_USERSELFLAG = 0
Global $AGLVEX_DEFCOLOURS [ 4 ] = [ "0x000000" , "0xFEFEFE" , "0xFFFFFF" , "0xCC6600" ]
Func _GUILISTVIEWEX_INIT ( $HLV , $AARRAY = "" , $ISTART = 0 , $ICOLOUR = 0 , $FIMAGE = False , $IADDED = 0 )
	Local $ILV_INDEX = 0
	For $I = 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
		If $AGLVEX_DATA [ $I ] [ 0 ] = 0 Then
			$ILV_INDEX = $I
			ExitLoop
		EndIf
	Next
	If $ILV_INDEX = 0 Then
		$AGLVEX_DATA [ 0 ] [ 0 ] += 1
		ReDim $AGLVEX_DATA [ $AGLVEX_DATA [ 0 ] [ 0 ] + 1 ] [ UBound ( $AGLVEX_DATA , 2 ) ]
		$ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 0 ]
	EndIf
	If IsHWnd ( $HLV ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] = $HLV
		$AGLVEX_DATA [ $ILV_INDEX ] [ 1 ] = 0
	Else
		$AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] = GUICtrlGetHandle ( $HLV )
		$AGLVEX_DATA [ $ILV_INDEX ] [ 1 ] = $HLV
	EndIf
	$AGLVEX_DATA [ 0 ] [ 24 ] = Opt ( "GUIDataSeparatorChar" )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = _GUILISTVIEWEX_READTOARRAY ( $HLV , 1 )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = + 4294967295
	$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = + 4294967295
	$AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] = $ISTART
	If IsArray ( $AARRAY ) Then
		If UBound ( $AARRAY , 0 ) = 2 Then $AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] += 2
	EndIf
	Local $AEDITABLE [ 4 ] [ UBound ( $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] , 2 ) ]
	$AGLVEX_DATA [ $ILV_INDEX ] [ 7 ] = $AEDITABLE
	_GUICTRLLISTVIEW_SETINSERTMARKCOLOR ( $HLV , BitOR ( BitShift ( BitAND ( $ICOLOUR , 255 ) , + 4294967280 ) , BitAND ( $ICOLOUR , 65280 ) , BitShift ( BitAND ( $ICOLOUR , 16711680 ) , 16 ) ) )
	If $FIMAGE Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 5 ] = 1
	EndIf
	If BitAND ( $IADDED , 1 ) Then
		Local $ALVSORTSTATE [ _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV ) ]
		$AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] = $ALVSORTSTATE
	Else
		$AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] = 0
	EndIf
	If BitAND ( $IADDED , 2 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 11 ] = 1
	EndIf
	If BitAND ( $IADDED , 4 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 9 ] = 1
	EndIf
	If BitAND ( $IADDED , 8 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 8 ] = 1
	EndIf
	Local $ICOLS = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV )
	Local $AHDRDATA [ 4 ] [ $ICOLS ] , $ARET
	If BitAND ( $IADDED , 16 ) Then
		Local $HHEADER = _GUICTRLLISTVIEW_GETHEADER ( $HLV )
		$AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] = $HHEADER
		For $I = 0 To $ICOLS + 4294967295
			$ARET = _GUICTRLLISTVIEW_GETCOLUMN ( $HLV , $I )
			$AHDRDATA [ 0 ] [ $I ] = $ARET [ 5 ]
		Next
	EndIf
	$AGLVEX_DATA [ $ILV_INDEX ] [ 25 ] = $AHDRDATA
	$AGLVEX_DATA [ $ILV_INDEX ] [ 23 ] = $AGLVEX_DEFCOLOURS
	If BitAND ( $IADDED , 32 ) Then
		Local $ACOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
		For $I = 1 To UBound ( $ACOLARRAY , 1 ) + 4294967295
			For $J = 0 To UBound ( $ACOLARRAY , 2 ) + 4294967295
				$ACOLARRAY [ $I ] [ $J ] = ";"
			Next
		Next
		$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $ACOLARRAY
		$AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] = 1
	EndIf
	If BitAND ( $IADDED , 64 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 12 ] = 1
	EndIf
	If BitAND ( $IADDED , 128 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 12 ] += 2
	EndIf
	If BitAND ( $IADDED , 256 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 12 ] += 4
	EndIf
	If BitAND ( $IADDED , 512 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 12 ] += 8 + 2
	EndIf
	If BitAND ( $IADDED , 1024 ) Then
		Local $ISTYLE = _WINAPI_GETWINDOWLONG ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $GWL_STYLE )
		_WINAPI_SETWINDOWLONG ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $GWL_STYLE , BitOR ( $ISTYLE , $LVS_SINGLESEL ) )
		$AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] = 1
		$AGLVEX_DATA [ $ILV_INDEX ] [ 23 ] = $AGLVEX_DEFCOLOURS
	EndIf
	If BitAND ( _GUICTRLLISTVIEW_GETEXTENDEDLISTVIEWSTYLE ( $HLV ) , 4 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 6 ] = 1
	EndIf
	If BitAND ( _GUICTRLLISTVIEW_GETEXTENDEDLISTVIEWSTYLE ( $HLV ) , 16 ) Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 13 ] = 1
	EndIf
	Local $ARECT = _GUICTRLLISTVIEW_GETITEMRECT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , 0 )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 10 ] = $ARECT [ 3 ] - $ARECT [ 1 ]
	Local $ILISTVIEW_COUNT = 0
	For $I = 1 To $ILV_INDEX
		If $AGLVEX_DATA [ $I ] [ 0 ] Then $ILISTVIEW_COUNT += 1
	Next
	If $ILISTVIEW_COUNT = 1 Then _GUILISTVIEWEX_SETACTIVE ( $ILV_INDEX )
	Return $ILV_INDEX
EndFunc
Func _GUILISTVIEWEX_CLOSE ( $ILV_INDEX = 0 )
	Local $IEDITKEYCODE
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	If $ILV_INDEX = 0 Then
		$IEDITKEYCODE = $AGLVEX_DATA [ 0 ] [ 23 ]
		Global $AGLVEX_DATA [ 1 ] [ UBound ( $AGLVEX_DATA , 2 ) ] = [ [ 0 , 0 , + 4294967295 , "" , + 4294967295 , + 4294967295 , + 4294967295 , + 4294967295 , _WINAPI_GETSYSTEMMETRICS ( 2 ) , False , + 4294967295 , + 4294967295 , False , "" , 0 , True , 0 , + 4294967295 , + 4294967295 , 0 , 0 , 0 , 0 , $IEDITKEYCODE ] ]
	Else
		For $I = 0 To UBound ( $AGLVEX_DATA , 2 ) + 4294967295
			$AGLVEX_DATA [ $ILV_INDEX ] [ $I ] = 0
		Next
		If $AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX Then
			$AGLVEX_DATA [ 0 ] [ 1 ] = 0
		EndIf
	EndIf
	Return 1
EndFunc
Func _GUILISTVIEWEX_SETACTIVE ( $ILV_INDEX )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $ICURR_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX Then
		$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
		$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
		$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Else
		$AGLVEX_DATA [ 0 ] [ 1 ] = 0
		$HGLVEX_SRCHANDLE = 0
		$CGLVEX_SRCID = 0
	EndIf
	Return $ICURR_INDEX
EndFunc
Func _GUILISTVIEWEX_GETACTIVE ( )
	Return $AGLVEX_DATA [ 0 ] [ 1 ]
EndFunc
Func _GUILISTVIEWEX_READTOARRAY ( $HLV , $ISTART = 0 )
	Local $ALVARRAY = "" , $AROW
	If Not IsHWnd ( $HLV ) Then
		$HLV = GUICtrlGetHandle ( $HLV )
		If Not IsHWnd ( $HLV ) Then
			Return SetError ( 1 , 0 , "" )
		EndIf
	EndIf
	Local $IROWS = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HLV )
	Local $ICOLS = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV )
	If ( $IROWS + $ISTART <> 0 ) And $ICOLS <> 0 Then
		Local $ALVARRAY [ $IROWS + $ISTART ] [ $ICOLS ] = [ [ $IROWS ] ]
		For $I = 0 To $IROWS + 4294967295
			$AROW = _GUICTRLLISTVIEW_GETITEMTEXTARRAY ( $HLV , $I )
			For $J = 1 To $AROW [ 0 ]
				$ALVARRAY [ $I + $ISTART ] [ $J + 4294967295 ] = $AROW [ $J ]
			Next
		Next
	Else
		Local $ALVARRAY [ 1 ] [ 1 ]
		If $ISTART = 1 Then $ALVARRAY [ 0 ] [ 0 ] = 0
	EndIf
	Return $ALVARRAY
EndFunc
Func _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX , $IMODE = 0 )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , "" )
	Local $HLV = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	Local $SORDER = _GUICTRLLISTVIEW_GETCOLUMNORDER ( $HLV )
	Local $ACOLORDER [ 1 ]
	If $SORDER = "" Then
		$ACOLORDER [ 0 ] = 0
	Else
		$ACOLORDER = StringSplit ( $SORDER , $AGLVEX_DATA [ 0 ] [ 24 ] )
	EndIf
	Local $ADATA_COLOUR = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	If $ACOLORDER [ 0 ] = 0 Then
		$ADATA_COLOUR = ""
		Return SetError ( 2 , 0 , "" )
	EndIf
	Local $IDIM_1 = UBound ( $ADATA_COLOUR , 1 ) , $IDIM_2 = UBound ( $ADATA_COLOUR , 2 )
	Local $ACHECK [ $IDIM_1 ] , $AHEADER [ $IDIM_2 ] , $AHDRDATA
	Switch $IMODE
	Case 0 , 3
	Case 1
		If $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ] Then
			For $I = 1 To $IDIM_1 + 4294967295
				$ACHECK [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HLV , $I + 4294967295 )
			Next
			If BitAND ( $AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] , 1 ) = 0 Then
				__GUILISTVIEWEX_ARRAY_DELETE ( $ACHECK , 0 , True )
			EndIf
			Return $ACHECK
		Else
			Return SetError ( 3 , 0 , "" )
		EndIf
	Case 2
		If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Then
			$ADATA_COLOUR = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
			For $I = 0 To UBound ( $ADATA_COLOUR , 1 ) + 4294967295
				For $J = 0 To UBound ( $ADATA_COLOUR , 2 ) + 4294967295
					$ADATA_COLOUR [ $I ] [ $J ] = StringRegExpReplace ( $ADATA_COLOUR [ $I ] [ $J ] , "0x(.{2})(.{2})(.{2})" , "0x$3$2$1" )
				Next
			Next
			$ADATA_COLOUR [ 0 ] [ 0 ] = $IDIM_1 + 4294967295
		Else
			Return SetError ( 4 , 0 , "" )
		EndIf
	Case 4
		If $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
			$AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
			For $I = 0 To $IDIM_2 + 4294967295
				$AHEADER [ $I ] = $AHDRDATA [ 0 ] [ $I ]
			Next
		Else
			Local $ARET
			For $I = 0 To $IDIM_2 + 4294967295
				$ARET = _GUICTRLLISTVIEW_GETCOLUMN ( $HLV , $I )
				$AHEADER [ $I ] = $ARET [ 5 ]
			Next
		EndIf
	Case 5
		If $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
			$AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
			For $I = 0 To $IDIM_2 + 4294967295
				$AHEADER [ $I ] = $AHDRDATA [ 1 ] [ $I ]
			Next
		Else
			Return SetError ( 5 , 0 , "" )
		EndIf
Case Else
		Return SetError ( 6 , 0 , "" )
	EndSwitch
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 13 ] And UBound ( $ADATA_COLOUR , 2 ) Then
		Switch $IMODE
		Case 0 , 2 , 3
			Local $ADATA_COLOUR_ORDERED [ $IDIM_1 ] [ $IDIM_2 ]
			If $IDIM_1 <> 1 Or $IDIM_2 <> 0 Then
				$ADATA_COLOUR_ORDERED [ 0 ] [ 0 ] = $ADATA_COLOUR [ 0 ] [ 0 ]
				For $I = 1 To $IDIM_1 + 4294967295
					For $J = 0 To $IDIM_2 + 4294967295
						$ADATA_COLOUR_ORDERED [ $I ] [ $J ] = $ADATA_COLOUR [ $I ] [ $ACOLORDER [ $J + 1 ] ]
					Next
				Next
			EndIf
			$ADATA_COLOUR = $ADATA_COLOUR_ORDERED
			$ADATA_COLOUR_ORDERED = ""
		Case 4 , 5
			Local $AHEADER_ORDERED [ $IDIM_2 ]
			If $IDIM_1 <> 1 Or $IDIM_2 <> 0 Then
				For $I = 0 To $IDIM_2 + 4294967295
					$AHEADER_ORDERED [ $I ] = $AHEADER [ $ACOLORDER [ $I + 1 ] ]
				Next
			EndIf
			Return $AHEADER_ORDERED
		EndSwitch
	Else
		If $IMODE = 4 Then
			Return $AHEADER
		EndIf
	EndIf
	Local $ICOUNT = 1
	If BitAND ( $AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] , 1 ) = 0 Or $IMODE = 2 Then
		$ICOUNT = 0
		__GUILISTVIEWEX_ARRAY_DELETE ( $ADATA_COLOUR , 0 , True )
	EndIf
	If BitAND ( $AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] , 2 ) = 0 And $IMODE < 2 Then
		If UBound ( $ADATA_COLOUR , 1 ) = 0 Then
			Local $ADATA_COLOUR [ 0 ]
		Else
			Local $ICOLS = UBound ( $ADATA_COLOUR , 2 )
			Local $ADATA_COLOUR_1D [ UBound ( $ADATA_COLOUR ) ] = [ $ADATA_COLOUR [ 0 ] [ 0 ] ]
			For $I = $ICOUNT To UBound ( $ADATA_COLOUR_1D ) + 4294967295
				Local $ALINE = ""
				For $J = 0 To $ICOLS + 4294967295
					$ALINE &= $ADATA_COLOUR [ $I ] [ $J ] & $AGLVEX_DATA [ 0 ] [ 24 ]
				Next
				$ADATA_COLOUR_1D [ $I ] = StringTrimRight ( $ALINE , 1 )
			Next
			$ADATA_COLOUR = $ADATA_COLOUR_1D
		EndIf
	EndIf
	Return $ADATA_COLOUR
EndFunc
Func _GUILISTVIEWEX_SAVELISTVIEW ( $ILV_INDEX , $SFILENAME )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $HLV_HANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	Local $ISTART = BitAND ( $AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] , 1 )
	Local $SHEADER = "" , $ARET
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
		Local $AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
		For $I = 0 To _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV_HANDLE ) + 4294967295
			$ARET = _GUICTRLLISTVIEW_GETCOLUMN ( $HLV_HANDLE , $I )
			$SHEADER &= $AHDRDATA [ 0 ] [ $I ] & @CR & $ARET [ 4 ] & @CR & $AHDRDATA [ 1 ] [ $I ] & @CR & $AHDRDATA [ 2 ] [ $I ] & @CR & $AHDRDATA [ 3 ] [ $I ] & @LF
		Next
	Else
		For $I = 0 To _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV_HANDLE ) + 4294967295
			$ARET = _GUICTRLLISTVIEW_GETCOLUMN ( $HLV_HANDLE , $I )
			$SHEADER &= $ARET [ 5 ] & @CR & $ARET [ 4 ] & @CR & @CR & @CR & @LF
		Next
	EndIf
	$SHEADER = StringTrimRight ( $SHEADER , 1 )
	Local $ADATA = _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX , 3 )
	If $ISTART Then
		_ARRAYDELETE ( $ADATA , 0 )
	EndIf
	Local $ACHECK = _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX , 1 )
	If $ISTART Then
		_ARRAYDELETE ( $ACHECK , 0 )
	EndIf
	Local $ACOLOUR = _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX , 2 )
	Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
	Local $ASORTABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 4 ]
	Local $SDATA = "" , $SCHECK = "" , $SCOLOUR = "" , $SEDITABLE = "" , $SSORTABLE = ""
	If IsArray ( $ADATA ) Then
		$SDATA = __GUILISTVIEWEX_MAKESTRING ( $ADATA )
	EndIf
	If IsArray ( $ACHECK ) Then
		$SCHECK = __GUILISTVIEWEX_MAKESTRING ( $ACHECK )
	EndIf
	If IsArray ( $ACOLOUR ) Then
		$SCOLOUR = __GUILISTVIEWEX_MAKESTRING ( $ACOLOUR )
	EndIf
	If IsArray ( $AEDITABLE ) Then
		$SEDITABLE = __GUILISTVIEWEX_MAKESTRING ( $AEDITABLE )
	EndIf
	If IsArray ( $ASORTABLE ) Then
		$SSORTABLE = __GUILISTVIEWEX_MAKESTRING ( $ASORTABLE )
	EndIf
	Local $IERROR = 0
	Local $HFILE = FileOpen ( $SFILENAME , $FO_OVERWRITE )
	If @error Then
		$IERROR = 1
	Else
		FileWrite ( $HFILE , $SHEADER & ChrW ( 61199 ) & $SDATA & ChrW ( 61199 ) & $SCHECK & ChrW ( 61199 ) & $SCOLOUR & ChrW ( 61199 ) & $SEDITABLE & ChrW ( 61199 ) & $SSORTABLE )
		If @error Then
			$IERROR = 2
		EndIf
	EndIf
	FileClose ( $HFILE )
	If $IERROR Then Return SetError ( 2 , $IERROR , 0 )
	Return 1
EndFunc
Func _GUILISTVIEWEX_LOADLISTVIEW ( $ILV_INDEX , $SFILENAME , $IDIMS = 2 )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Switch $IDIMS
	Case 1 , 2
Case Else
		Return SetError ( 2 , 0 , 0 )
	EndSwitch
	Local $HLV_HANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	Local $CLV_CID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $ISTART = BitAND ( $AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] , 1 )
	Local $SCONTENT = FileRead ( $SFILENAME )
	If @error Then Return SetError ( 3 , 0 , 0 )
	Local $ASPLIT = StringSplit ( $SCONTENT , ChrW ( 61199 ) , $STR_ENTIRESPLIT )
	Local $AHEADER = __GUILISTVIEWEX_MAKEARRAY ( $ASPLIT [ 1 ] )
	If Not IsArray ( $AHEADER ) Then Return SetError ( 4 , 0 , 0 )
	Local $ADATA = __GUILISTVIEWEX_MAKEARRAY ( $ASPLIT [ 2 ] )
	If Not IsArray ( $ADATA ) Then Return SetError ( 4 , 0 , 0 )
	Local $ACHECK = __GUILISTVIEWEX_MAKEARRAY ( $ASPLIT [ 3 ] )
	Local $ACOLOUR = __GUILISTVIEWEX_MAKEARRAY ( $ASPLIT [ 4 ] )
	Local $AEDITABLE = __GUILISTVIEWEX_MAKEARRAY ( $ASPLIT [ 5 ] )
	Local $ASORTABLE = __GUILISTVIEWEX_MAKEARRAY ( $ASPLIT [ 6 ] )
	If UBound ( $ADATA , 0 ) = 1 Then
		Local $ATEMPDATA [ UBound ( $ADATA ) ] [ 1 ]
		Local $ATEMPCOL [ UBound ( $ADATA ) ] [ 1 ]
		For $I = 0 To UBound ( $ADATA ) + 4294967295
			$ATEMPDATA [ $I ] [ 0 ] = $ADATA [ $I ]
			$ATEMPCOL [ $I ] [ 0 ] = $ACOLOUR [ $I ]
		Next
		$ADATA = $ATEMPDATA
		$ACOLOUR = $ATEMPCOL
	EndIf
	Local $AHDRDATA [ 4 ] [ UBound ( $AHEADER ) ]
	For $I = 0 To UBound ( $AHEADER ) + 4294967295
		$AHDRDATA [ 0 ] [ $I ] = $AHEADER [ $I ] [ 0 ]
		$AHDRDATA [ 1 ] [ $I ] = $AHEADER [ $I ] [ 2 ]
		$AHDRDATA [ 2 ] [ $I ] = $AHEADER [ $I ] [ 3 ]
		$AHDRDATA [ 3 ] [ $I ] = $AHEADER [ $I ] [ 4 ]
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 25 ] = $AHDRDATA
	$AGLVEX_DATA [ 0 ] [ 12 ] = 1
	$AGLVEX_DATA [ 0 ] [ 15 ] = False
	_GUICTRLLISTVIEW_BEGINUPDATE ( $HLV_HANDLE )
	_GUICTRLLISTVIEW_DELETEALLITEMS ( $HLV_HANDLE )
	Local $ICOL_COUNT = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV_HANDLE )
	If $ICOL_COUNT < UBound ( $AHEADER ) Then
		For $I = $ICOL_COUNT To UBound ( $AHEADER ) + 4294967295
			_GUICTRLLISTVIEW_ADDCOLUMN ( $HLV_HANDLE , "" , 100 )
		Next
	EndIf
	If $ICOL_COUNT > UBound ( $AHEADER ) Then
		For $I = $ICOL_COUNT To UBound ( $AHEADER ) Step + 4294967295
			_GUICTRLLISTVIEW_DELETECOLUMN ( $HLV_HANDLE , $I )
		Next
	EndIf
	For $I = 0 To UBound ( $AHEADER ) + 4294967295
		_GUICTRLLISTVIEW_SETCOLUMN ( $HLV_HANDLE , $I , $AHEADER [ $I ] [ 0 ] , $AHEADER [ $I ] [ 1 ] )
	Next
	If $CLV_CID Then
		Local $SLINE , $ILASTCOL = UBound ( $ADATA , 2 ) + 4294967295
		For $I = 0 To UBound ( $ADATA ) + 4294967295
			$SLINE = ""
			For $J = 0 To $ILASTCOL
				$SLINE &= $ADATA [ $I ] [ $J ] & $AGLVEX_DATA [ 0 ] [ 24 ]
			Next
			GUICtrlCreateListViewItem ( StringTrimRight ( $SLINE , 1 ) , $CLV_CID )
		Next
	Else
		_GUICTRLLISTVIEW_ADDARRAY ( $HLV_HANDLE , $ADATA )
	EndIf
	_GUICTRLLISTVIEW_ENDUPDATE ( $HLV_HANDLE )
	_ARRAYINSERT ( $ADATA , 0 , UBound ( $ADATA ) )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $ADATA
	$AGLVEX_DATA [ $ILV_INDEX ] [ 7 ] = $AEDITABLE
	$AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] = $ASORTABLE
	$AGLVEX_DATA [ $ILV_INDEX ] [ 3 ] = $ISTART + ( ( $IDIMS = 2 ) ? ( 2 ) : ( 0 ) )
	If IsArray ( $ACHECK ) Then
		For $I = 0 To UBound ( $ACHECK ) + 4294967295
			If $ACHECK [ $I ] = "True" Then
				_GUICTRLLISTVIEW_SETITEMCHECKED ( $HLV_HANDLE , $I , True )
			EndIf
		Next
	EndIf
	$AGLVEX_DATA [ 0 ] [ 12 ] = 0
	$AGLVEX_DATA [ 0 ] [ 15 ] = True
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Then
		If IsArray ( $ACOLOUR ) Then
			_GUILISTVIEWEX_LOADCOLOUR ( $ILV_INDEX , $ACOLOUR )
		Else
			$ACOLOUR = $ADATA
			For $I = 0 To UBound ( $ADATA ) + 4294967295
				For $J = 0 To UBound ( $ADATA , 2 ) + 4294967295
					$ACOLOUR [ $I ] [ $J ] = ";"
				Next
			Next
			$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $ACOLOUR
		EndIf
	EndIf
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
	Return 1
EndFunc
Func _GUILISTVIEWEX_UP ( )
	Local $IGLVEXMOVE_INDEX , $IGLVEX_MOVING = 0
	Local $ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , 0 )
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $FCHECKBOX = $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ]
	$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	If $AGLVEX_SRCARRAY [ 0 ] [ 0 ] = 0 Then
		$AGLVEX_SRCARRAY = 0
		Return SetError ( 4 , 0 , "" )
	EndIf
	$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
	For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
		$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
	Next
	Local $IINDEX
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
		$IINDEX = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
	Else
		$IINDEX = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HGLVEX_SRCHANDLE )
	EndIf
	If $IINDEX == "" Then
		Return SetError ( 2 , 0 , "" )
	EndIf
	Local $AINDEX = StringSplit ( $IINDEX , "|" )
	$IGLVEXMOVE_INDEX = $AINDEX [ 1 ]
	If $AINDEX [ 0 ] > 1 Then
		For $I = 1 To $AINDEX [ 0 ] + 4294967295
			If $AINDEX [ $I + 1 ] = $AINDEX [ 1 ] + $I Then
				$IGLVEX_MOVING += 1
			Else
				ExitLoop
			EndIf
		Next
	Else
		$IGLVEXMOVE_INDEX = $AINDEX [ 1 ]
	EndIf
	If $IGLVEXMOVE_INDEX < 1 Then
		__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , 0 )
		Return SetError ( 3 , 0 , "" )
	EndIf
	_GUICTRLLISTVIEW_SETITEMSELECTED ( $HGLVEX_SRCHANDLE , + 4294967295 , False )
	$AGLVEX_DATA [ 0 ] [ 12 ] = True
	For $IINDEX = $IGLVEXMOVE_INDEX To $IGLVEXMOVE_INDEX + $IGLVEX_MOVING
		__GUILISTVIEWEX_ARRAY_SWAP ( $AGLVEX_SRCARRAY , $IINDEX , $IINDEX + 1 )
		__GUILISTVIEWEX_ARRAY_SWAP ( $ACHECK_ARRAY , $IINDEX , $IINDEX + 1 )
		__GUILISTVIEWEX_ARRAY_SWAP ( $AGLVEX_SRCCOLARRAY , $IINDEX , $IINDEX + 1 )
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] -= 1
	__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX )
	For $I = 0 To $IGLVEX_MOVING
		__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IGLVEXMOVE_INDEX + $I + 4294967295 )
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
	$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_DOWN ( )
	Local $IGLVEXMOVE_INDEX , $IGLVEX_MOVING = 0
	Local $ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , 0 )
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $FCHECKBOX = $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ]
	$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	If $AGLVEX_SRCARRAY [ 0 ] [ 0 ] = 0 Then
		$AGLVEX_SRCARRAY = 0
		Return SetError ( 4 , 0 , "" )
	EndIf
	$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
	For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
		$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
	Next
	Local $IINDEX
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
		$IINDEX = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
		If $IINDEX = + 4294967295 Then $IINDEX = 0
	Else
		$IINDEX = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HGLVEX_SRCHANDLE )
	EndIf
	If $IINDEX == "" Then
		Return SetError ( 2 , 0 , "" )
	EndIf
	Local $AINDEX = StringSplit ( $IINDEX , "|" )
	If $AINDEX [ 0 ] > 1 Then
		$IGLVEXMOVE_INDEX = $AINDEX [ $AINDEX [ 0 ] ]
		For $I = 1 To $AINDEX [ 0 ] + 4294967295
			If $AINDEX [ $AINDEX [ 0 ] - $I ] = $AINDEX [ $AINDEX [ 0 ] ] - $I Then
				$IGLVEX_MOVING += 1
			Else
				ExitLoop
			EndIf
		Next
	Else
		$IGLVEXMOVE_INDEX = $AINDEX [ 1 ]
	EndIf
	_GUICTRLLISTVIEW_SETITEMSELECTED ( $HGLVEX_SRCHANDLE , + 4294967295 , False )
	If $IGLVEXMOVE_INDEX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_SRCHANDLE ) + 4294967295 Then
		__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IINDEX )
		Return SetError ( 3 , 0 , "" )
	EndIf
	$AGLVEX_DATA [ 0 ] [ 12 ] = True
	For $IINDEX = $IGLVEXMOVE_INDEX To $IGLVEXMOVE_INDEX - $IGLVEX_MOVING Step + 4294967295
		__GUILISTVIEWEX_ARRAY_SWAP ( $AGLVEX_SRCARRAY , $IINDEX + 1 , $IINDEX + 2 )
		__GUILISTVIEWEX_ARRAY_SWAP ( $ACHECK_ARRAY , $IINDEX + 1 , $IINDEX + 2 )
		__GUILISTVIEWEX_ARRAY_SWAP ( $AGLVEX_SRCCOLARRAY , $IINDEX + 1 , $IINDEX + 2 )
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] += 1
	__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX )
	For $I = 0 To $IGLVEX_MOVING
		__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IGLVEXMOVE_INDEX - $IGLVEX_MOVING + $I + 1 )
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
	$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_INSERT ( $VDATA , $FMULTIROW = False , $FRETAINWIDTH = False )
	Local $ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , "" )
	Local $IINDEX
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
		$IINDEX = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
	Else
		$IINDEX = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HGLVEX_SRCHANDLE )
	EndIf
	Local $IINSERT_INDEX = $IINDEX
	If $IINDEX == "" Then $IINSERT_INDEX = + 4294967295
	If StringInStr ( $IINDEX , "|" ) Then
		Local $AINDEX = StringSplit ( $IINDEX , "|" )
		$IINDEX = $AINDEX [ 1 ]
		For $I = 2 To $AINDEX [ 0 ]
			_GUICTRLLISTVIEW_SETITEMSELECTED ( $HGLVEX_SRCHANDLE , $AINDEX [ $I ] , False )
		Next
	EndIf
	Local $VRET = _GUILISTVIEWEX_INSERTSPEC ( $ILV_INDEX , $IINSERT_INDEX + 1 , $VDATA , $FMULTIROW , $FRETAINWIDTH )
	Return SetError ( @error , 0 , $VRET )
EndFunc
Func _GUILISTVIEWEX_INSERTSPEC ( $ILV_INDEX , $IROW , $VDATA , $FMULTIROW = False , $FRETAINWIDTH = False )
	Local $VINSERT , $IMAX_ROW
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , "" )
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $FCHECKBOX = $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ]
	$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	Local $AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
	If UBound ( $AHDRDATA , 2 ) = 0 Then
		$AGLVEX_SRCARRAY = ""
		Return SetError ( 2 , 0 , "" )
	EndIf
	$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
	For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
		$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
	Next
	If Not IsArray ( $AGLVEX_SRCARRAY ) Or UBound ( $AGLVEX_SRCARRAY ) = 0 Then
		$IMAX_ROW = 0
	Else
		$IMAX_ROW = $AGLVEX_SRCARRAY [ 0 ] [ 0 ]
		If $IROW = + 4294967295 Then $IROW = $IMAX_ROW
		If $IROW < 0 Or $IROW > $IMAX_ROW Then Return SetError ( 3 , 0 , "" )
	EndIf
	If IsArray ( $VDATA ) Then
		$VINSERT = $VDATA
	Else
		Local $ADATA = StringSplit ( $VDATA , $AGLVEX_DATA [ 0 ] [ 24 ] )
		Switch $ADATA [ 0 ]
		Case 1
			$VINSERT = $ADATA [ 1 ]
	Case Else
			Local $VINSERT [ $ADATA [ 0 ] ]
			For $I = 0 To $ADATA [ 0 ] + 4294967295
				$VINSERT [ $I ] = $ADATA [ $I + 1 ]
			Next
		EndSwitch
	EndIf
	$AGLVEX_DATA [ 0 ] [ 12 ] = True
	If $IROW = + 4294967295 Then
		__GUILISTVIEWEX_ARRAY_ADD ( $AGLVEX_SRCARRAY , $VINSERT , $FMULTIROW )
		__GUILISTVIEWEX_ARRAY_ADD ( $ACHECK_ARRAY , $VINSERT , $FMULTIROW )
		__GUILISTVIEWEX_ARRAY_ADD ( $AGLVEX_SRCCOLARRAY , ";" , $FMULTIROW )
	Else
		__GUILISTVIEWEX_ARRAY_INSERT ( $AGLVEX_SRCARRAY , $IROW + 1 , $VINSERT , $FMULTIROW )
		__GUILISTVIEWEX_ARRAY_INSERT ( $ACHECK_ARRAY , $IROW + 1 , $VINSERT , $FMULTIROW )
		__GUILISTVIEWEX_ARRAY_INSERT ( $AGLVEX_SRCCOLARRAY , $IROW + 1 , ";" , $FMULTIROW )
	EndIf
	If $AGLVEX_DATA [ 0 ] [ 15 ] Then
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX , $FRETAINWIDTH )
	EndIf
	If $IROW = + 4294967295 Then
		__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_SRCHANDLE ) + 4294967295 )
	Else
		__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IROW )
	EndIf
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
	$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_DELETE ( $VRANGE = "" )
	Local $ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , "" )
	Local $VRET = _GUILISTVIEWEX_DELETESPEC ( $ILV_INDEX , $VRANGE )
	Local $IERROR = @error
	Local $BEMPTY = False
	If UBound ( $VRET ) = 0 Then
		$BEMPTY = True
	Else
		If UBound ( $VRET , 2 ) <> 0 Then
			If $VRET [ 0 ] [ 0 ] = 0 Then
				$BEMPTY = True
			EndIf
		Else
			If $VRET [ 0 ] = 0 Then
				$BEMPTY = True
			EndIf
		EndIf
	EndIf
	If $BEMPTY Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = + 4294967295
	EndIf
	Return SetError ( $IERROR , 0 , $VRET )
EndFunc
Func _GUILISTVIEWEX_DELETESPEC ( $ILV_INDEX , $VRANGE = "" )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , "" )
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $FCHECKBOX = $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ]
	$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	If UBound ( $AGLVEX_SRCARRAY ) = 1 Then
		Return SetError ( 3 , 0 , "" )
	EndIf
	$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
	For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
		$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
	Next
	If $VRANGE = "-1" Then
		$VRANGE = UBound ( $AGLVEX_SRCARRAY ) + 4294967294
	EndIf
	Local $IINDEX , $AINDEX
	If String ( $VRANGE ) <> "" Then
		$AINDEX = __GUILISTVIEWEX_EXPANDRANGE ( $VRANGE , $ILV_INDEX , 0 )
		If @error Then Return SetError ( 4 , 0 , 0 )
	Else
		If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
			$IINDEX = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
		Else
			$IINDEX = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HGLVEX_SRCHANDLE )
		EndIf
		If $IINDEX == "" Then
			Return SetError ( 2 , 0 , "" )
		EndIf
		$AINDEX = StringSplit ( $IINDEX , $AGLVEX_DATA [ 0 ] [ 24 ] )
	EndIf
	For $I = 1 To $AINDEX [ 0 ]
		_GUICTRLLISTVIEW_SETITEMSELECTED ( $HGLVEX_SRCHANDLE , $I , False )
	Next
	$AGLVEX_DATA [ 0 ] [ 12 ] = True
	For $I = $AINDEX [ 0 ] To 1 Step + 4294967295
		If $AINDEX [ $I ] <= UBound ( $AGLVEX_SRCARRAY ) + 4294967294 Then
			__GUILISTVIEWEX_ARRAY_DELETE ( $AGLVEX_SRCARRAY , $AINDEX [ $I ] + 1 )
			__GUILISTVIEWEX_ARRAY_DELETE ( $ACHECK_ARRAY , $AINDEX [ $I ] + 1 )
			__GUILISTVIEWEX_ARRAY_DELETE ( $AGLVEX_SRCCOLARRAY , $AINDEX [ $I ] + 1 )
		EndIf
	Next
	If $AGLVEX_DATA [ 0 ] [ 15 ] Then
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX )
		If $AINDEX [ 1 ] = 0 Then
			__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , 0 )
		Else
			__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $AINDEX [ 1 ] + 4294967295 )
		EndIf
	EndIf
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
	$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_INSERTCOL ( $STITLE = "" , $IWIDTH = 50 )
	Local $ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , "" )
	Local $VRET = _GUILISTVIEWEX_INSERTCOLSPEC ( $ILV_INDEX , $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] + 1 , $STITLE , $IWIDTH )
	Return SetError ( @error , 0 , $VRET )
EndFunc
Func _GUILISTVIEWEX_INSERTCOLSPEC ( $ILV_INDEX , $ICOL = + 4294967295 , $STITLE = "" , $IWIDTH = 75 )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , "" )
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $FCHECKBOX = $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ]
	Local $FCOLOURENABLED = $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ]
	Local $AHDRDATA
	$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	If $FCOLOURENABLED Then
		$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	EndIf
	Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
	$AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
	Local $IMAX_COL = UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
	If $ICOL = + 4294967295 Then $ICOL = $IMAX_COL + 1
	If $ICOL < 0 Or $ICOL > $IMAX_COL Then Return SetError ( 2 , 0 , "" )
	Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
	For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
		$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
	Next
	$AGLVEX_DATA [ 0 ] [ 12 ] = True
	If UBound ( $AHDRDATA , 2 ) = 0 Then
	Else
		ReDim $AGLVEX_SRCARRAY [ UBound ( $AGLVEX_SRCARRAY ) ] [ UBound ( $AGLVEX_SRCARRAY , 2 ) + 1 ]
		If $FCOLOURENABLED Then
			ReDim $AGLVEX_SRCCOLARRAY [ UBound ( $AGLVEX_SRCCOLARRAY ) ] [ UBound ( $AGLVEX_SRCCOLARRAY , 2 ) + 1 ]
		EndIf
		For $I = 0 To UBound ( $AGLVEX_SRCARRAY ) + 4294967295
			For $J = UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967294 To $ICOL Step + 4294967295
				$AGLVEX_SRCARRAY [ $I ] [ $J + 1 ] = $AGLVEX_SRCARRAY [ $I ] [ $J ]
				If $FCOLOURENABLED Then
					$AGLVEX_SRCCOLARRAY [ $I ] [ $J + 1 ] = $AGLVEX_SRCCOLARRAY [ $I ] [ $J ]
				EndIf
			Next
			$AGLVEX_SRCARRAY [ $I ] [ $ICOL ] = ""
			If $FCOLOURENABLED Then
				$AGLVEX_SRCCOLARRAY [ $I ] [ $ICOL ] = ";"
			EndIf
		Next
	EndIf
	ReDim $AEDITABLE [ 4 ] [ UBound ( $AEDITABLE , 2 ) + 1 ]
	ReDim $AHDRDATA [ 4 ] [ UBound ( $AHDRDATA , 2 ) + 1 ]
	For $I = 0 To 3
		For $J = UBound ( $AEDITABLE , 2 ) + 4294967294 To $ICOL Step + 4294967295
			$AEDITABLE [ $I ] [ $J + 1 ] = $AEDITABLE [ $I ] [ $J ]
			$AHDRDATA [ $I ] [ $J + 1 ] = $AHDRDATA [ $I ] [ $J ]
		Next
		$AEDITABLE [ $I ] [ $ICOL ] = ""
	Next
	$AHDRDATA [ 0 ] [ $ICOL ] = $STITLE
	$AHDRDATA [ 1 ] [ $ICOL ] = ";"
	$AHDRDATA [ 2 ] [ $ICOL ] = ""
	$AHDRDATA [ 3 ] [ $ICOL ] = 0
	$AGLVEX_SRCARRAY [ 0 ] [ 0 ] = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_SRCHANDLE )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
	If $FCOLOURENABLED Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	EndIf
	$AGLVEX_DATA [ $ILV_INDEX ] [ 7 ] = $AEDITABLE
	$AGLVEX_DATA [ $ILV_INDEX ] [ 25 ] = $AHDRDATA
	_GUICTRLLISTVIEW_INSERTCOLUMN ( $HGLVEX_SRCHANDLE , $ICOL , $STITLE , $IWIDTH )
	If $AGLVEX_DATA [ 0 ] [ 15 ] Then
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX )
	EndIf
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	Local $ALVSORTSTATE [ _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_SRCHANDLE ) ]
	$AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] = $ALVSORTSTATE
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_DELETECOL ( )
	Local $ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , "" )
	Local $ICOL = $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ]
	If $ICOL = + 4294967295 Then $ICOL = 0
	Local $VRET = _GUILISTVIEWEX_DELETECOLSPEC ( $ILV_INDEX , $ICOL )
	Local $IERROR = @error
	If Not @error Then
		If UBound ( $VRET , 2 ) <= $AGLVEX_DATA [ 0 ] [ 2 ] Then
			$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = + 4294967295
		EndIf
	EndIf
	Return SetError ( $IERROR , 0 , $VRET )
EndFunc
Func _GUILISTVIEWEX_DELETECOLSPEC ( $ILV_INDEX , $ICOL = + 4294967295 )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , "" )
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	Local $FCHECKBOX = $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ]
	Local $FCOLOURENABLED = $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ]
	$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	If $FCOLOURENABLED Then
		$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	EndIf
	Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
	Local $AHDRDATA [ 4 ] [ UBound ( $AGLVEX_SRCARRAY , 2 ) ]
	$AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
	Local $IMAX_COL = UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
	If $ICOL = + 4294967295 Then $ICOL = $IMAX_COL
	If $ICOL < 0 Or $ICOL > $IMAX_COL Then Return SetError ( 2 , 0 , "" )
	Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
	For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
		$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
	Next
	$AGLVEX_DATA [ 0 ] [ 12 ] = True
	If UBound ( $AGLVEX_SRCARRAY , 2 ) = 1 Then
		ReDim $AGLVEX_SRCARRAY [ 1 ] [ 1 ]
		$AGLVEX_SRCARRAY [ 0 ] [ 0 ] = 0
		ReDim $AGLVEX_SRCCOLARRAY [ 1 ] [ 1 ]
		ReDim $AEDITABLE [ 4 ] [ 0 ]
		ReDim $AHDRDATA [ 4 ] [ 0 ]
	Else
		For $I = 0 To UBound ( $AGLVEX_SRCARRAY ) + 4294967295
			For $J = $ICOL To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967294
				$AGLVEX_SRCARRAY [ $I ] [ $J ] = $AGLVEX_SRCARRAY [ $I ] [ $J + 1 ]
				If $FCOLOURENABLED Then
					$AGLVEX_SRCCOLARRAY [ $I ] [ $J ] = $AGLVEX_SRCCOLARRAY [ $I ] [ $J + 1 ]
				EndIf
			Next
		Next
		ReDim $AGLVEX_SRCARRAY [ UBound ( $AGLVEX_SRCARRAY ) ] [ UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295 ]
		If $FCOLOURENABLED Then
			ReDim $AGLVEX_SRCCOLARRAY [ UBound ( $AGLVEX_SRCCOLARRAY ) ] [ UBound ( $AGLVEX_SRCCOLARRAY , 2 ) + 4294967295 ]
		EndIf
		For $I = 0 To 3
			For $J = $ICOL To UBound ( $AEDITABLE , 2 ) + 4294967294
				$AEDITABLE [ $I ] [ $J ] = $AEDITABLE [ $I ] [ $J + 1 ]
				$AHDRDATA [ $I ] [ $J ] = $AHDRDATA [ $I ] [ $J + 1 ]
			Next
		Next
		ReDim $AEDITABLE [ 4 ] [ UBound ( $AEDITABLE , 2 ) + 4294967295 ]
		ReDim $AHDRDATA [ 4 ] [ UBound ( $AHDRDATA , 2 ) + 4294967295 ]
		$AGLVEX_SRCARRAY [ 0 ] [ 0 ] = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_SRCHANDLE )
	EndIf
	_GUICTRLLISTVIEW_DELETECOLUMN ( $HGLVEX_SRCHANDLE , $ICOL )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
	If $FCOLOURENABLED Then
		$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	EndIf
	$AGLVEX_DATA [ $ILV_INDEX ] [ 7 ] = $AEDITABLE
	$AGLVEX_DATA [ $ILV_INDEX ] [ 25 ] = $AHDRDATA
	If $AGLVEX_DATA [ 0 ] [ 15 ] Then
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX )
	EndIf
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	Local $ALVSORTSTATE [ _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_SRCHANDLE ) ]
	$AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] = $ALVSORTSTATE
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_SORTCOL ( $ILV_INDEX , $ICOL = + 4294967295 )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	Local $IMAX_COL = UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
	If $ICOL = + 4294967295 Then
		$ICOL = $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ]
	EndIf
	If $ICOL < 0 Or $ICOL > $IMAX_COL Then Return SetError ( 2 , 0 , 0 )
	Local $ALVSORTSTATE = $AGLVEX_DATA [ $ILV_INDEX ] [ 4 ]
	__GUILISTVIEWEX_COLSORT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $ILV_INDEX , $ALVSORTSTATE , $ICOL )
	Return 1
EndFunc
Func _GUILISTVIEWEX_SETEDITSTATUS ( $ILV_INDEX , $VCOL , $IMODE = 1 , $VPARAM1 = Default , $VPARAM2 = Default )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	Local $ARANGE = __GUILISTVIEWEX_EXPANDRANGE ( $VCOL , $ILV_INDEX )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
	Switch $IMODE
	Case 0 , 1
		If $VPARAM1 = Default Then $VPARAM1 = 0
		If $VPARAM2 = Default Then $VPARAM2 = ""
		Switch $VPARAM1
		Case 0
			If $VPARAM2 Then
				Return SetError ( 4 , 12 , 0 )
			EndIf
		Case 1
			If $VPARAM2 And Not StringRegExp ( $VPARAM2 , "^\d+\|\d+\|(0|1)$" ) Then
				Return SetError ( 4 , 12 , 0 )
			EndIf
	Case Else
			Return SetError ( 4 , 11 , 0 )
		EndSwitch
		For $I = 1 To $ARANGE [ 0 ]
			$AEDITABLE [ 0 ] [ $ARANGE [ $I ] ] = $IMODE
			$AEDITABLE [ 1 ] [ $ARANGE [ $I ] ] = $VPARAM1
			$AEDITABLE [ 2 ] [ $ARANGE [ $I ] ] = $VPARAM2
		Next
	Case 2
		If Not ( IsArray ( $VPARAM1 ) Or IsString ( $VPARAM1 ) ) Then
			Return SetError ( 4 , 21 , 0 )
		EndIf
		If $VPARAM2 = Default Then $VPARAM2 = 0
		Switch $VPARAM2
		Case 0 To 3
	Case Else
			Return SetError ( 4 , 22 , 0 )
		EndSwitch
		For $I = 1 To $ARANGE [ 0 ]
			$AEDITABLE [ 0 ] [ $ARANGE [ $I ] ] = 2
			$AEDITABLE [ 1 ] [ $ARANGE [ $I ] ] = $VPARAM1
			$AEDITABLE [ 2 ] [ $ARANGE [ $I ] ] = $VPARAM2
		Next
	Case 3
		If $VPARAM1 = Default Then
			$VPARAM1 = ""
		EndIf
		If Not StringRegExp ( $VPARAM1 , "^(\d{4}\/\d{2}\/\d{2})?#?$" ) Then
			Return SetError ( 4 , 31 , 0 )
		EndIf
		If $VPARAM2 = Default Then
			$VPARAM2 = ""
		EndIf
		For $I = 1 To $ARANGE [ 0 ]
			$AEDITABLE [ 0 ] [ $ARANGE [ $I ] ] = 3
			$AEDITABLE [ 1 ] [ $ARANGE [ $I ] ] = $VPARAM1
			$AEDITABLE [ 2 ] [ $ARANGE [ $I ] ] = $VPARAM2
		Next
	Case 9
		If Not IsFunc ( $VPARAM1 ) Then
			Return SetError ( 4 , 91 , 0 )
		EndIf
		For $I = 1 To $ARANGE [ 0 ]
			$AEDITABLE [ 0 ] [ $ARANGE [ $I ] ] = 9
			$AEDITABLE [ 1 ] [ $ARANGE [ $I ] ] = $VPARAM1
		Next
Case Else
		Return SetError ( 3 , 0 , 0 )
	EndSwitch
	$AGLVEX_DATA [ $ILV_INDEX ] [ 7 ] = $AEDITABLE
	Return 1
EndFunc
Func _GUILISTVIEWEX_SETEDITKEY ( $SKEY = Default )
	If $SKEY = Default Then
		$AGLVEX_DATA [ 0 ] [ 23 ] = "08"
		Return 1
	EndIf
	If Not StringRegExp ( $SKEY , "(?i)^([!^]){0,2}([0-9a-f]{2})$" ) Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	$AGLVEX_DATA [ 0 ] [ 23 ] = StringReplace ( StringReplace ( $SKEY , "^" , "11;" ) , "!" , "12;" )
	Return 1
EndFunc
Func _GUILISTVIEWEX_EDITITEM ( $ILV_INDEX , $IROW , $ICOL , $IEDITMODE = 0 , $IDELTA_X = 0 , $IDELTA_Y = 0 )
	_GUILISTVIEWEX_SETACTIVE ( $ILV_INDEX )
	If @error Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	Local $IMAX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_SRCHANDLE )
	If $IROW < 0 Or $IROW > $IMAX + 4294967295 Then
		Return SetError ( 3 , 0 , "" )
	EndIf
	$IMAX = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_SRCHANDLE )
	If $ICOL < 0 Or $ICOL > $IMAX + 4294967295 Then
		Return SetError ( 4 , 0 , "" )
	EndIf
	Switch Abs ( $IEDITMODE )
	Case 0 , 11 , 12 , 13 , 21 , 22 , 23 , 31 , 32 , 33
Case Else
		Return SetError ( 5 , 0 , "" )
	EndSwitch
	Local $ALOCATION [ 2 ] = [ $IROW , $ICOL ]
	Local $AEDITED = __GUILISTVIEWEX_EDITPROCESS ( $ILV_INDEX , $ALOCATION , $IDELTA_X , $IDELTA_Y , $IEDITMODE , True )
	If $AEDITED [ 0 ] [ 0 ] = 0 Then
		$AEDITED = ""
	EndIf
	Local $IKEYCODE = @extended
	_WINAPI_GETASYNCKEYSTATE ( $IKEYCODE )
	While _WINAPI_GETASYNCKEYSTATE ( $IKEYCODE )
		Sleep ( 10 )
	WEnd
	_GUICTRLLISTVIEW_SETITEMSELECTED ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , + 4294967295 , False )
	SetExtended ( ( $IKEYCODE = 13 ) ? ( True ) : ( False ) )
	Return $AEDITED
EndFunc
Func _GUILISTVIEWEX_EDITWIDTH ( $ILV_INDEX , $AWIDTH )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If ( Not IsArray ( $AWIDTH ) ) Or ( UBound ( $AWIDTH , 0 ) <> 1 ) Then Return SetError ( 2 , 0 , 0 )
	ReDim $AWIDTH [ _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] ) ]
	$AGLVEX_DATA [ $ILV_INDEX ] [ 14 ] = $AWIDTH
EndFunc
Func _GUILISTVIEWEX_CHANGEITEM ( $ILV_INDEX , $IROW , $ICOL , $VVALUE )
	_GUILISTVIEWEX_SETACTIVE ( $ILV_INDEX )
	If @error Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	Local $IMAX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_SRCHANDLE )
	If $IROW < 0 Or $IROW > $IMAX + 4294967295 Then
		Return SetError ( 3 , 0 , "" )
	EndIf
	$IMAX = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_SRCHANDLE )
	If $ICOL < 0 Or $ICOL > $IMAX + 4294967295 Then
		Return SetError ( 4 , 0 , "" )
	EndIf
	Local $ADATA_ARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	_GUICTRLLISTVIEW_SETITEMTEXT ( $HGLVEX_SRCHANDLE , $IROW , $VVALUE , $ICOL )
	$ADATA_ARRAY [ $IROW + 1 ] [ $ICOL ] = $VVALUE
	$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $ADATA_ARRAY
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX )
	Return _GUILISTVIEWEX_RETURNARRAY ( $ILV_INDEX )
EndFunc
Func _GUILISTVIEWEX_LOADHDRDATA ( $ILV_INDEX , $AHDRDATA )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	If UBound ( $AHDRDATA , 0 ) <> 2 Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If UBound ( $AHDRDATA ) <> 4 Then
		Return SetError ( 2 , 1 , 0 )
	EndIf
	If UBound ( $AHDRDATA , 2 ) <> UBound ( $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] , 2 ) Then
		Return SetError ( 2 , 2 , 0 )
	EndIf
	Local $SCOLSET , $ACOLSPLIT
	For $I = 0 To UBound ( $AHDRDATA , 2 ) + 4294967295
		If $AHDRDATA [ 0 ] [ $I ] = Default Then
			$AHDRDATA [ 0 ] [ $I ] = ""
		EndIf
		$SCOLSET = $AHDRDATA [ 1 ] [ $I ]
		If $SCOLSET = "" Or $SCOLSET = Default Then
			$SCOLSET = ";"
		EndIf
		If Not StringRegExp ( $SCOLSET , "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$" ) Then
			Return SetError ( 4 , 0 , 0 )
		EndIf
		$ACOLSPLIT = StringSplit ( $SCOLSET , ";" )
		For $J = 1 To 2
			If $ACOLSPLIT [ $J ] And Not $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
				Return SetError ( 3 , 0 , 0 )
			Else
				$ACOLSPLIT [ $J ] = StringRegExpReplace ( $ACOLSPLIT [ $J ] , "0x(.{2})(.{2})(.{2})" , "0x$3$2$1" )
			EndIf
		Next
		$AHDRDATA [ 1 ] [ $I ] = $ACOLSPLIT [ 1 ] & ";" & $ACOLSPLIT [ 2 ]
		If $AHDRDATA [ 2 ] [ $I ] = Default Then
			$AHDRDATA [ 2 ] [ $I ] = ""
		EndIf
		If $AHDRDATA [ 3 ] [ $I ] = Default Then
			$AHDRDATA [ 3 ] [ $I ] = _GUICTRLLISTVIEW_GETCOLUMNWIDTH ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $I )
		Else
			$AHDRDATA [ 3 ] [ $I ] = Abs ( Number ( $AHDRDATA [ 3 ] [ $I ] ) )
		EndIf
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 25 ] = $AHDRDATA
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX , True )
	Return 1
EndFunc
Func _GUILISTVIEWEX_EDITHEADER ( $ILV_INDEX = Default , $ICOL = Default , $IDELTA_X = 0 , $IDELTA_Y = 0 )
	Local $ARET = ""
	If $ILV_INDEX = Default Then
		$ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
	EndIf
	_GUILISTVIEWEX_SETACTIVE ( $ILV_INDEX )
	If @error Then
		Return SetError ( 1 , 0 , $ARET )
	EndIf
	Local $HLV_HANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	Local $CLV_CID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 8 ] = "" Then
		Return SetError ( 2 , 0 , $ARET )
	EndIf
	If $ICOL = Default Then
		$ICOL = $AGLVEX_DATA [ 0 ] [ 2 ]
	EndIf
	Local $IMAX = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV_HANDLE )
	If $ICOL < 0 Or $ICOL > $IMAX + 4294967295 Then
		Return SetError ( 3 , 0 , $ARET )
	EndIf
	Local $TLVPOS = DllStructCreate ( "struct;long X;long Y;endstruct" )
	__GUILISTVIEWEX_GETLVCOORDS ( $HLV_HANDLE , $TLVPOS )
	Local $ALVCLIENT = WinGetClientSize ( $HLV_HANDLE )
	Local $ALV_FONTDETAILS = __GUILISTVIEWEX_GETLVFONT ( $HLV_HANDLE )
	WinSetState ( $HLV_HANDLE , "" , @SW_DISABLE )
	Local $AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
	Local $ACOLDATA , $SHEADERORGTEXT
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
		$SHEADERORGTEXT = $AHDRDATA [ 0 ] [ $ICOL ]
	Else
		$ACOLDATA = _GUICTRLLISTVIEW_GETCOLUMN ( $HLV_HANDLE , $ICOL )
		$SHEADERORGTEXT = $ACOLDATA [ 5 ]
	EndIf
	Local $ALOCATION [ 2 ] = [ 0 , $ICOL ]
	Local $AEDIT_COORDS = __GUILISTVIEWEX_EDITCOORDS ( $HLV_HANDLE , $CLV_CID , $ALOCATION , $TLVPOS , $ALVCLIENT [ 0 ] + 4294967291 , $IDELTA_X , $IDELTA_Y )
	Local $HHEADER = _GUICTRLLISTVIEW_GETHEADER ( $HLV_HANDLE )
	Local $AHEADER_POS = WinGetPos ( $HHEADER )
	$AEDIT_COORDS [ 0 ] -= 2
	$AEDIT_COORDS [ 1 ] -= $AHEADER_POS [ 3 ]
	$AEDIT_COORDS [ 3 ] = $AHEADER_POS [ 3 ]
	Local $HCOMBO , $HTEMP_EDIT , $HTEMP_LIST , $HTEMP_COMBO , $SCOMBO_DATA
	If $AHDRDATA [ 2 ] [ $ICOL ] Then
		$SCOMBO_DATA = $AHDRDATA [ 2 ] [ $ICOL ]
		If StringLeft ( $SCOMBO_DATA , 1 ) = @TAB Then
			$CGLVEX_EDITID = GUICtrlCreateCombo ( "" , $AEDIT_COORDS [ 0 ] , $AEDIT_COORDS [ 1 ] , $AEDIT_COORDS [ 2 ] , $AEDIT_COORDS [ 3 ] , 2097219 )
			$SCOMBO_DATA = StringTrimLeft ( $SCOMBO_DATA , 1 )
		Else
			$CGLVEX_EDITID = GUICtrlCreateCombo ( "" , $AEDIT_COORDS [ 0 ] , $AEDIT_COORDS [ 1 ] , $AEDIT_COORDS [ 2 ] , $AEDIT_COORDS [ 3 ] , 2097218 )
		EndIf
		GUICtrlSetData ( $CGLVEX_EDITID , $SCOMBO_DATA )
		$HCOMBO = GUICtrlGetHandle ( $CGLVEX_EDITID )
		Local $TINFO = DllStructCreate ( "dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" & "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList" )
		Local $IINFO = DllStructGetSize ( $TINFO )
		DllStructSetData ( $TINFO , "Size" , $IINFO )
		_SENDMESSAGE ( $HCOMBO , 356 , 0 , $TINFO , 0 , "wparam" , "struct*" )
		$HTEMP_EDIT = DllStructGetData ( $TINFO , "hEdit" )
		$HTEMP_LIST = DllStructGetData ( $TINFO , "hList" )
		$HTEMP_COMBO = DllStructGetData ( $TINFO , "hCombo" )
	Else
		$CGLVEX_EDITID = GUICtrlCreateEdit ( $SHEADERORGTEXT , $AEDIT_COORDS [ 0 ] , $AEDIT_COORDS [ 1 ] , $AEDIT_COORDS [ 2 ] , $AEDIT_COORDS [ 3 ] , 0 )
		$HTEMP_EDIT = GUICtrlGetHandle ( $CGLVEX_EDITID )
	EndIf
	GUICtrlSetFont ( $CGLVEX_EDITID , $ALV_FONTDETAILS [ 0 ] , Default , Default , $ALV_FONTDETAILS [ 1 ] )
	_WINAPI_SETFOCUS ( $HTEMP_EDIT )
	If Not $AGLVEX_DATA [ $ILV_INDEX ] [ 11 ] Then
		GUICtrlSendMsg ( $CGLVEX_EDITID , 177 , 0 , + 4294967295 )
	EndIf
	Local $TMOUSECLICK = DllStructCreate ( $TAGPOINT )
	Local $AKEYS [ 2 ] = [ 13 , 27 ]
	Local $IKEY_CODE = 0
	Local $FCOMBO_STATE = False
	Local $IOLDESC = Opt ( "GUICloseOnESC" , 0 )
	While 1
		If $AGLVEX_DATA [ 0 ] [ 9 ] Then
			$AGLVEX_DATA [ 0 ] [ 9 ] = False
			ExitLoop
		EndIf
		For $I = 0 To 1
			_WINAPI_GETASYNCKEYSTATE ( $AKEYS [ $I ] )
			If _WINAPI_GETASYNCKEYSTATE ( $AKEYS [ $I ] ) Then
				$IKEY_CODE = $AKEYS [ $I ]
				ExitLoop 2
			EndIf
		Next
		If _WINAPI_GETFOCUS ( ) <> $HTEMP_EDIT Then
			ExitLoop
		EndIf
		_WINAPI_GETASYNCKEYSTATE ( 1 )
		If _WINAPI_GETASYNCKEYSTATE ( 1 ) Then
			DllStructSetData ( $TMOUSECLICK , "x" , MouseGetPos ( 0 ) )
			DllStructSetData ( $TMOUSECLICK , "y" , MouseGetPos ( 1 ) )
			Switch _WINAPI_WINDOWFROMPOINT ( $TMOUSECLICK )
			Case $HTEMP_COMBO , $HTEMP_EDIT , $HTEMP_LIST
		Case Else
				ExitLoop
			EndSwitch
			_WINAPI_GETASYNCKEYSTATE ( 1 )
			While _WINAPI_GETASYNCKEYSTATE ( 1 )
				Sleep ( 10 )
			WEnd
		EndIf
		If $HCOMBO Then
			Switch _SENDMESSAGE ( $HCOMBO , 343 )
			Case 0
				If $FCOMBO_STATE = True Then
					If GUICtrlRead ( $CGLVEX_EDITID ) = "" Then
						$FCOMBO_STATE = False
					Else
						$IKEY_CODE = 13
						ExitLoop
					EndIf
				EndIf
			Case 1
				If Not $FCOMBO_STATE Then
					$FCOMBO_STATE = True
				EndIf
			EndSwitch
		EndIf
		Sleep ( 10 )
	WEnd
	Switch $IKEY_CODE
	Case 13
		Local $SHEADERNEWTEXT = GUICtrlRead ( $CGLVEX_EDITID )
		If $SHEADERNEWTEXT <> $SHEADERORGTEXT Then
			If $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
				$AHDRDATA [ 0 ] [ $ICOL ] = $SHEADERNEWTEXT
			Else
				_GUICTRLLISTVIEW_SETCOLUMN ( $HLV_HANDLE , $ICOL , $SHEADERNEWTEXT )
			EndIf
			$AGLVEX_DATA [ $ILV_INDEX ] [ 25 ] = $AHDRDATA
			Local $ARET [ 1 ] [ 3 ] = [ [ $ICOL , $SHEADERORGTEXT , $SHEADERNEWTEXT ] ]
		EndIf
Case Else
		$ARET = ""
	EndSwitch
	_WINAPI_GETASYNCKEYSTATE ( $IKEY_CODE )
	While _WINAPI_GETASYNCKEYSTATE ( $IKEY_CODE )
		Sleep ( 10 )
	WEnd
	Opt ( "GUICloseOnESC" , $IOLDESC )
	GUICtrlDelete ( $CGLVEX_EDITID )
	WinSetState ( $HLV_HANDLE , "" , @SW_ENABLE )
	Return $ARET
EndFunc
Func _GUILISTVIEWEX_LOADCOLOUR ( $ILV_INDEX , $ACOLARRAY )
	Local $SCOLSET
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	If Not $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If UBound ( $ACOLARRAY , 0 ) <> 2 Then
		Return SetError ( 3 , 0 , 0 )
	EndIf
	_ARRAYINSERT ( $ACOLARRAY , 0 )
	If ( UBound ( $ACOLARRAY ) <> UBound ( $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] ) ) Or ( UBound ( $ACOLARRAY , 2 ) <> UBound ( $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] , 2 ) ) Then
		Return SetError ( 3 , 1 , 0 )
	EndIf
	For $I = 1 To UBound ( $ACOLARRAY , 1 ) + 4294967295
		For $J = 0 To UBound ( $ACOLARRAY , 2 ) + 4294967295
			$SCOLSET = $ACOLARRAY [ $I ] [ $J ]
			If $SCOLSET = "" Then
				$SCOLSET = ";"
				$ACOLARRAY [ $I ] [ $J ] = ";"
			EndIf
			If Not StringRegExp ( $SCOLSET , "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$" ) Then
				Return SetError ( 4 , 0 , 0 )
			EndIf
			$ACOLARRAY [ $I ] [ $J ] = StringRegExpReplace ( $SCOLSET , "0x(.{2})(.{2})(.{2})" , "0x$3$2$1" )
		Next
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $ACOLARRAY
	Return 1
EndFunc
Func _GUILISTVIEWEX_SETDEFCOLOURS ( $ILV_INDEX , $ADEFCOLS )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	If Not ( $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] ) Then Return SetError ( 2 , 0 , 0 )
	If Not IsArray ( $ADEFCOLS ) Or UBound ( $ADEFCOLS ) <> 4 Or UBound ( $ADEFCOLS , 0 ) <> 1 Then Return SetError ( 3 , 0 , 0 )
	Local $ACURCOLS = $AGLVEX_DATA [ $ILV_INDEX ] [ 23 ]
	Local $SCOL
	For $I = 0 To 3
		If $ADEFCOLS [ $I ] = Default Then
			$ADEFCOLS [ $I ] = $AGLVEX_DEFCOLOURS [ $I ]
		ElseIf $ADEFCOLS [ $I ] = "" Then
			$ADEFCOLS [ $I ] = $ACURCOLS [ $I ]
		Else
			Switch Number ( $ADEFCOLS [ $I ] )
			Case 0 To 16777215
				$SCOL = "0x" & StringMid ( $ADEFCOLS [ $I ] , 7 , 2 ) & StringMid ( $ADEFCOLS [ $I ] , 5 , 2 ) & StringMid ( $ADEFCOLS [ $I ] , 3 , 2 )
				$ADEFCOLS [ $I ] = $SCOL
		Case Else
				Return SetError ( 4 , 0 , 0 )
			EndSwitch
		EndIf
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 23 ] = $ADEFCOLS
	__GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX , True )
	Return 1
EndFunc
Func _GUILISTVIEWEX_SETCOLOUR ( $ILV_INDEX , $SCOLSET , $IROW , $ICOL )
	_GUILISTVIEWEX_SETACTIVE ( $ILV_INDEX )
	If @error Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If Not $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If $SCOLSET = "" Then
		$SCOLSET = ";"
	EndIf
	Local $FDEFCOL = ( ( $SCOLSET = ";" ) ? ( True ) : ( False ) )
	If Not StringRegExp ( $SCOLSET , "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$" ) Then
		Return SetError ( 3 , 0 , 0 )
	EndIf
	Local $ACOLARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	If $IROW < 0 Or $ICOL < 0 Or $IROW > UBound ( $ACOLARRAY ) + 4294967294 Or $ICOL > UBound ( $ACOLARRAY , 2 ) + 4294967295 Then
		Return SetError ( 4 , 0 , 0 )
	EndIf
	Local $ACURRSPLIT = StringSplit ( $ACOLARRAY [ $IROW + 1 ] [ $ICOL ] , ";" )
	Local $ANEWSPLIT = StringSplit ( $SCOLSET , ";" )
	For $I = 1 To 2
		If $ANEWSPLIT [ $I ] Then
			$ACURRSPLIT [ $I ] = "0x" & StringMid ( $ANEWSPLIT [ $I ] , 7 , 2 ) & StringMid ( $ANEWSPLIT [ $I ] , 5 , 2 ) & StringMid ( $ANEWSPLIT [ $I ] , 3 , 2 )
		EndIf
		If $FDEFCOL Then
			$ACURRSPLIT [ $I ] = ""
		EndIf
	Next
	$ACOLARRAY [ $IROW + 1 ] [ $ICOL ] = $ACURRSPLIT [ 1 ] & ";" & $ACURRSPLIT [ 2 ]
	$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $ACOLARRAY
	$AGLVEX_DATA [ 0 ] [ 14 ] = 0
	_GUICTRLLISTVIEW_REDRAWITEMS ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $IROW , $IROW )
	Return 1
EndFunc
Func _GUILISTVIEWEX_BLOCKREDRAW ( $ILV_INDEX , $BMODE )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	Switch $BMODE
	Case True
		$AGLVEX_DATA [ 0 ] [ 15 ] = False
	Case False
		$AGLVEX_DATA [ 0 ] [ 15 ] = True
		Local $ADATA_ARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
		Local $ACHECK_ARRAY [ UBound ( $ADATA_ARRAY ) ]
		For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
			$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
		Next
		__GUILISTVIEWEX_REWRITELV ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $ADATA_ARRAY , $ACHECK_ARRAY , $ILV_INDEX , $AGLVEX_DATA [ $ILV_INDEX ] [ 6 ] )
Case Else
		Return SetError ( 2 , 0 , 0 )
	EndSwitch
	Return 1
EndFunc
Func _GUILISTVIEWEX_USERSORT ( $ILV_INDEX , $VCOL , $HFUNC = + 4294967295 )
	If $ILV_INDEX < 1 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If Not ( IsArray ( $AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] ) ) Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	Local $ARANGE = __GUILISTVIEWEX_EXPANDRANGE ( $VCOL , $ILV_INDEX )
	If @error Then Return SetError ( 3 , 0 , 0 )
	If Not ( $HFUNC = + 4294967295 ) And Not ( IsFunc ( $HFUNC ) ) Then
		Return SetError ( 4 , 0 , 0 )
	EndIf
	Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
	For $I = 1 To $ARANGE [ 0 ]
		$AEDITABLE [ 3 ] [ $ARANGE [ $I ] ] = $HFUNC
	Next
	$AGLVEX_DATA [ $ILV_INDEX ] [ 7 ] = $AEDITABLE
	Return 1
EndFunc
Func _GUILISTVIEWEX_GETLASTSELITEM ( $ILV_INDEX = 0 )
	Switch $ILV_INDEX
	Case 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
	Case 0 , Default
		$ILV_INDEX = _GUILISTVIEWEX_GETACTIVE ( )
		If $ILV_INDEX = 0 Then Return SetError ( 1 , 0 , "" )
Case Else
		Return SetError ( 2 , 0 , "" )
	EndSwitch
	Local $IROW = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
	Local $ICOL = $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ]
	If $IROW = + 4294967295 Or $ICOL = + 4294967295 Then Return SetError ( 3 , 0 , "" )
	Return $ILV_INDEX & "|" & $IROW & "|" & $ICOL
EndFunc
Func _GUILISTVIEWEX_CONTEXTPOS ( )
	If $AGLVEX_DATA [ 0 ] [ 10 ] = + 4294967295 Then
		Return SetError ( 1 , 0 , "" )
	Else
		Local $APOS [ 3 ] = [ $AGLVEX_DATA [ 0 ] [ 1 ] , $AGLVEX_DATA [ 0 ] [ 10 ] , $AGLVEX_DATA [ 0 ] [ 11 ] ]
		Return $APOS
	EndIf
EndFunc
Func _GUILISTVIEWEX_TOOLTIPINIT ( $ILV_INDEX , $VRANGE , $ITIME = 1000 , $IMODE = 1 )
	If $ILV_INDEX < 0 Or $ILV_INDEX > $AGLVEX_DATA [ 0 ] [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $ARANGE = __GUILISTVIEWEX_EXPANDRANGE ( $VRANGE , $ILV_INDEX )
	If @error Then Return SetError ( 2 , 0 , 0 )
	If Not IsInt ( $ITIME ) Then Return SetError ( 3 , 0 , 0 )
	$AGLVEX_DATA [ $ILV_INDEX ] [ 15 ] = $ARANGE
	$AGLVEX_DATA [ $ILV_INDEX ] [ 16 ] = $ITIME
	$AGLVEX_DATA [ $ILV_INDEX ] [ 17 ] = $IMODE
	Return 1
EndFunc
Func _GUILISTVIEWEX_EVENTMONITOR ( $IEDITMODE = 0 , $IDELTA_X = 0 , $IDELTA_Y = 0 )
	Local $ARET , $VRET , $ILV_INDEX , $IERROR
	If $FGLVEX_EDITCLICKFLAG <> 0 Then
		$ILV_INDEX = $FGLVEX_EDITCLICKFLAG
		$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
		$FGLVEX_EDITCLICKFLAG = 0
		Switch Abs ( $IEDITMODE )
		Case 0 , 1 , 2 , 3 , 10 , 11 , 12 , 13 , 20 , 21 , 22 , 23 , 30 , 31 , 32 , 33
	Case Else
			Return SetError ( 1 , 0 , "" )
		EndSwitch
		Local $ALOCATION [ 2 ] = [ $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 18 ] ]
		If $ALOCATION [ 0 ] = + 4294967295 Then
			Return SetError ( 2 , 0 , "" )
		EndIf
		Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
		If $ALOCATION [ 1 ] = + 4294967295 Then
			For $I = 0 To UBound ( $AEDITABLE , 2 ) + 4294967295
				If $AEDITABLE [ 0 ] [ $I ] <> 0 Then
					$ALOCATION [ 1 ] = $I
					$AGLVEX_DATA [ 0 ] [ 18 ] = $I
					ExitLoop
				EndIf
			Next
		EndIf
		Switch $AEDITABLE [ 0 ] [ $ALOCATION [ 1 ] ]
		Case 0
			Return SetError ( 3 , 0 , "" )
		Case 9
			Local $HUSERFUNCTION = $AEDITABLE [ 1 ] [ $ALOCATION [ 1 ] ]
			$VRET = $HUSERFUNCTION ( $HGLVEX_SRCHANDLE , $ILV_INDEX , $ALOCATION [ 0 ] , $ALOCATION [ 1 ] )
			Return SetError ( @error , @extended , $VRET )
	Case Else
			$ARET = __GUILISTVIEWEX_EDITPROCESS ( $ILV_INDEX , $ALOCATION , $IDELTA_X , $IDELTA_Y , $IEDITMODE )
			$IERROR = @error
			If IsArray ( $ARET ) And $ARET [ 0 ] [ 0 ] Then
				Return SetError ( $IERROR , 1 , $ARET )
			Else
				Return SetError ( $IERROR , 1 , "" )
			EndIf
		EndSwitch
	EndIf
	If $FGLVEX_HEADEREDIT Then
		$FGLVEX_HEADEREDIT = False
		_WINAPI_GETASYNCKEYSTATE ( 1 )
		While _WINAPI_GETASYNCKEYSTATE ( 1 ) Or _WINAPI_GETASYNCKEYSTATE ( 17 )
			Sleep ( 10 )
		WEnd
		$ARET = _GUILISTVIEWEX_EDITHEADER ( )
		$IERROR = @error
		If IsArray ( $ARET ) Then
			Return SetError ( $IERROR , 2 , $ARET )
		Else
			Return SetError ( $IERROR , 2 , "" )
		EndIf
	EndIf
	If $AGLVEX_DATA [ 0 ] [ 19 ] Then
		$VRET = $AGLVEX_DATA [ 0 ] [ 19 ]
		$AGLVEX_DATA [ 0 ] [ 19 ] = ""
		If $AGLVEX_DATA [ 0 ] [ 22 ] = 1 Then
			__GUILISTVIEWEX_REDRAWWINDOW ( $VRET , True )
			$AGLVEX_DATA [ 0 ] [ 22 ] = 0
		EndIf
		Return SetError ( 0 , 3 , $VRET )
	EndIf
	If $SGLVEX_DRAGEVENT Then
		$VRET = $SGLVEX_DRAGEVENT
		$SGLVEX_DRAGEVENT = ""
		If $AGLVEX_DATA [ 0 ] [ 22 ] Then
			Local $AINDEX = StringSplit ( $VRET , ":" )
			__GUILISTVIEWEX_REDRAWWINDOW ( $AINDEX [ 1 ] , True )
			If $AINDEX [ 2 ] <> $AINDEX [ 1 ] Then
				__GUILISTVIEWEX_REDRAWWINDOW ( $AINDEX [ 2 ] , True )
			EndIf
			$AGLVEX_DATA [ 0 ] [ 22 ] = 0
		EndIf
		Return SetError ( 0 , 4 , $VRET )
	EndIf
	Local $IMODE = $AGLVEX_DATA [ $AGLVEX_DATA [ 0 ] [ 1 ] ] [ 17 ]
	If $IMODE Then
		$ILV_INDEX = $AGLVEX_DATA [ 0 ] [ 1 ]
		Local $FTOOLTIPCOL = False
		If $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] Then
			$AGLVEX_DATA [ 0 ] [ 4 ] = $AGLVEX_DATA [ 0 ] [ 17 ]
			$AGLVEX_DATA [ 0 ] [ 5 ] = $AGLVEX_DATA [ 0 ] [ 18 ]
		EndIf
		If $AGLVEX_DATA [ 0 ] [ 4 ] <> $AGLVEX_DATA [ 0 ] [ 6 ] Or $AGLVEX_DATA [ 0 ] [ 5 ] <> $AGLVEX_DATA [ 0 ] [ 7 ] Then
			If $AGLVEX_DATA [ $ILV_INDEX ] [ 15 ] = "*" Then
				$FTOOLTIPCOL = True
			Else
				If IsArray ( $AGLVEX_DATA [ $ILV_INDEX ] [ 15 ] ) Then
					Local $VRANGE = $AGLVEX_DATA [ $ILV_INDEX ] [ 15 ]
					For $I = 1 To $VRANGE [ 0 ]
						If $AGLVEX_DATA [ 0 ] [ 2 ] = $VRANGE [ $I ] Then
							$FTOOLTIPCOL = True
							ExitLoop
						EndIf
					Next
				EndIf
			EndIf
		EndIf
		If $FTOOLTIPCOL Then
			Local $AITEMTEXT = _GUICTRLLISTVIEW_GETITEMTEXTARRAY ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $AGLVEX_DATA [ 0 ] [ 4 ] )
			If Not @error Then
				Local $STEXT
				Switch $IMODE
				Case 1
					$STEXT = $AITEMTEXT [ $AGLVEX_DATA [ 0 ] [ 5 ] + 1 ]
				Case 2
					$STEXT = $AITEMTEXT [ 1 ]
				EndSwitch
				ToolTip ( $STEXT )
				AdlibRegister ( "__GUIListViewEx_ToolTipHide" , $AGLVEX_DATA [ $ILV_INDEX ] [ 16 ] )
				$AGLVEX_DATA [ 0 ] [ 6 ] = $AGLVEX_DATA [ 0 ] [ 4 ]
				$AGLVEX_DATA [ 0 ] [ 7 ] = $AGLVEX_DATA [ 0 ] [ 5 ]
			EndIf
		EndIf
	EndIf
	If $FGLVEX_SELCHANGEFLAG Then
		Local $ARETARRAY [ 3 ] = [ $FGLVEX_SELCHANGEFLAG , $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 18 ] ]
		$FGLVEX_SELCHANGEFLAG = 0
		If $FGLVEX_USERSELFLAG Then
			$FGLVEX_USERSELFLAG = 0
			Return SetError ( 0 , 9 , $ARETARRAY )
		EndIf
	EndIf
	If $FGVLEX_RESIZED <> + 4294967295 Then
		Local $ICOL = $FGVLEX_RESIZED
		$FGVLEX_RESIZED = + 4294967295
		Return SetError ( 0 , 5 , $ICOL )
	EndIf
	Return SetError ( 0 , 0 , "" )
EndFunc
Func _GUILISTVIEWEX_MSGREGISTER ( $FNOTIFY = True , $FMOUSEMOVE = True , $FLBUTTONUP = True , $FSYSCOMMAND = True )
	If $FNOTIFY Then GUIRegisterMsg ( 78 , "_GUIListViewEx_WM_NOTIFY_Handler" )
	If $FMOUSEMOVE Then GUIRegisterMsg ( 512 , "_GUIListViewEx_WM_MOUSEMOVE_Handler" )
	If $FLBUTTONUP Then GUIRegisterMsg ( 514 , "_GUIListViewEx_WM_LBUTTONUP_Handler" )
	If $FSYSCOMMAND Then GUIRegisterMsg ( 274 , "_GUIListViewEx_WM_SYSCOMMAND_Handler" )
EndFunc
Func _GUILISTVIEWEX_WM_NOTIFY_HANDLER ( $HWND , $IMSG , $WPARAM , $LPARAM )
	#forceref $hWnd, $iMsg, $wParam
	Local $DWDRAWSTAGE , $ICOL , $AHDRDATA
	Local $TSTRUCT = DllStructCreate ( "hwnd;uint_ptr;int_ptr;int;int" , $LPARAM )
	If @error Then Return
	Local $HLV = DllStructGetData ( $TSTRUCT , 1 )
	Local $IITEM = DllStructGetData ( $TSTRUCT , 4 )
	Local $ICODE = BitAND ( DllStructGetData ( $TSTRUCT , 3 ) , 4294967295 )
	If $ICODE = + 4294967284 Then
		If $AGLVEX_DATA [ 0 ] [ 12 ] Then Return
		For $ILV_INDEX = 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
			If $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] = DllStructGetData ( $TSTRUCT , 1 ) Then
				ExitLoop
			EndIf
		Next
		If $ILV_INDEX <= $AGLVEX_DATA [ 0 ] [ 0 ] Then
			Local Static $ADEFCOLS = $AGLVEX_DEFCOLOURS
			If $AGLVEX_DATA [ 0 ] [ 14 ] <> DllStructGetData ( $TSTRUCT , 1 ) Then
				$AGLVEX_DATA [ 0 ] [ 14 ] = DllStructGetData ( $TSTRUCT , 1 )
				If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
					$AGLVEX_DATA [ 0 ] [ 13 ] = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
					$ADEFCOLS = $AGLVEX_DATA [ $ILV_INDEX ] [ 23 ]
				EndIf
			EndIf
			If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
				Local $TNMLVCUSTOMDRAW = DllStructCreate ( $TAGNMLVCUSTOMDRAW , $LPARAM )
				$DWDRAWSTAGE = DllStructGetData ( $TNMLVCUSTOMDRAW , "dwDrawStage" )
				Switch $DWDRAWSTAGE
				Case 1
					Return 32
				Case 65537
					Return 32
				Case 196609
					$IITEM = DllStructGetData ( $TNMLVCUSTOMDRAW , "dwItemSpec" )
					Local $ISUBITEM = DllStructGetData ( $TNMLVCUSTOMDRAW , "iSubItem" )
					Local $BSELCOLOUR = False
					If $IITEM = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] Then
						If $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
							If $ISUBITEM = $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] Then
								$BSELCOLOUR = True
							EndIf
						Else
							$BSELCOLOUR = True
						EndIf
					EndIf
					Local $ITEXTCOLOUR = $ADEFCOLS [ 0 ]
					Local $IBACKCOLOUR = $ADEFCOLS [ 1 ]
					If $BSELCOLOUR Then
						$ITEXTCOLOUR = $ADEFCOLS [ 2 ]
						$IBACKCOLOUR = $ADEFCOLS [ 3 ]
					Else
						If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Then
							If StringInStr ( ( $AGLVEX_DATA [ 0 ] [ 13 ] ) [ $IITEM + 1 ] [ $ISUBITEM ] , ";" ) Then
								Local $ASPLITCOLOUR = StringSplit ( ( $AGLVEX_DATA [ 0 ] [ 13 ] ) [ $IITEM + 1 ] [ $ISUBITEM ] , ";" )
								If $ASPLITCOLOUR [ 1 ] Then $ITEXTCOLOUR = $ASPLITCOLOUR [ 1 ]
								If $ASPLITCOLOUR [ 2 ] Then $IBACKCOLOUR = $ASPLITCOLOUR [ 2 ]
							EndIf
						EndIf
					EndIf
					DllStructSetData ( $TNMLVCUSTOMDRAW , "ClrText" , $ITEXTCOLOUR )
					DllStructSetData ( $TNMLVCUSTOMDRAW , "ClrTextBk" , $IBACKCOLOUR )
					Return 2
				EndSwitch
			EndIf
		Else
			For $ILV_INDEX = 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
				If DllStructGetData ( $TSTRUCT , 1 ) = $AGLVEX_DATA [ $ILV_INDEX ] [ 24 ] Then
					ExitLoop
				EndIf
			Next
			If $ILV_INDEX <= $AGLVEX_DATA [ 0 ] [ 0 ] Then
				Local $TNMCUSTOMDRAW = DllStructCreate ( $TAGNMLVCUSTOMDRAW , $LPARAM )
				Local $HDC = DllStructGetData ( $TNMCUSTOMDRAW , "hdc" )
				If $AGLVEX_DATA [ 0 ] [ 20 ] <> DllStructGetData ( $TSTRUCT , 1 ) Then
					$AGLVEX_DATA [ 0 ] [ 20 ] = DllStructGetData ( $TSTRUCT , 1 )
					Local $HFONT = _SENDMESSAGE ( DllStructGetData ( $TSTRUCT , 1 ) , 49 )
					Local $HOBJECT = _WINAPI_SELECTOBJECT ( $HDC , $HFONT )
					Local $TLOGFONT = DllStructCreate ( $TAGLOGFONT )
					_WINAPI_GETOBJECT ( $HFONT , DllStructGetSize ( $TLOGFONT ) , DllStructGetPtr ( $TLOGFONT ) )
					_WINAPI_SELECTOBJECT ( $HDC , $HOBJECT )
					_WINAPI_RELEASEDC ( DllStructGetData ( $TSTRUCT , 1 ) , $HDC )
					DllStructSetData ( $TLOGFONT , "Weight" , 600 )
					$AGLVEX_DATA [ 0 ] [ 21 ] = _WINAPI_CREATEFONTINDIRECT ( $TLOGFONT )
				EndIf
				$DWDRAWSTAGE = DllStructGetData ( $TNMCUSTOMDRAW , "dwDrawStage" )
				Switch $DWDRAWSTAGE
				Case 1
					Return 32
				Case 65537
					Return 16
				Case 65538
					Local $ICOLUMNINDEX = DllStructGetData ( $TNMCUSTOMDRAW , "dwItemSpec" )
					$AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
					Local $ACOLSPLIT = StringSplit ( $AHDRDATA [ 1 ] [ $ICOLUMNINDEX ] , ";" )
					Local $AHDRDEFCOLS = $AGLVEX_DATA [ $ILV_INDEX ] [ 23 ]
					Local $IHDRTEXTCOLOUR , $IHDRBACKCOLOUR
					If $ACOLSPLIT [ 1 ] == "" Then
						$IHDRTEXTCOLOUR = $AHDRDEFCOLS [ 0 ]
					Else
						$IHDRTEXTCOLOUR = $ACOLSPLIT [ 1 ]
					EndIf
					If $ACOLSPLIT [ 2 ] == "" Then
						$IHDRBACKCOLOUR = $AHDRDEFCOLS [ 1 ]
					Else
						$IHDRBACKCOLOUR = $ACOLSPLIT [ 2 ]
					EndIf
					Local $TRECT = DllStructCreate ( $TAGRECT )
					DllStructSetData ( $TRECT , 1 , DllStructGetData ( $TNMCUSTOMDRAW , 6 ) + 1 )
					DllStructSetData ( $TRECT , 2 , DllStructGetData ( $TNMCUSTOMDRAW , 7 ) + 1 )
					DllStructSetData ( $TRECT , 3 , DllStructGetData ( $TNMCUSTOMDRAW , 8 ) + 4294967294 )
					DllStructSetData ( $TRECT , 4 , DllStructGetData ( $TNMCUSTOMDRAW , 9 ) + 4294967294 )
					_WINAPI_SETBKMODE ( $HDC , 1 )
					_WINAPI_SELECTOBJECT ( $HDC , $AGLVEX_DATA [ 0 ] [ 21 ] )
					_WINAPI_SETTEXTCOLOR ( $HDC , $IHDRTEXTCOLOUR )
					Local $HBRUSH = _WINAPI_CREATESOLIDBRUSH ( $IHDRBACKCOLOUR )
					_WINAPI_FILLRECT ( $HDC , $TRECT , $HBRUSH )
					If $ICOLUMNINDEX < _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] ) Then
						Local $ARET = _GUICTRLLISTVIEW_GETCOLUMN ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $ICOLUMNINDEX )
						Local $ICOLALIGN = 2 * $ARET [ 0 ]
						_WINAPI_DRAWTEXT ( $HDC , $AHDRDATA [ 0 ] [ $ICOLUMNINDEX ] , $TRECT , $ICOLALIGN )
					EndIf
					Return 2
				EndSwitch
			EndIf
		EndIf
	Else
		Local $FEDITHOTKEY = False
		For $ILV_INDEX = 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
			If $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] = DllStructGetData ( $TSTRUCT , 1 ) Then
				ExitLoop
			EndIf
		Next
		Local $IROW
		If $ILV_INDEX <= $AGLVEX_DATA [ 0 ] [ 0 ] Then
			If $ILV_INDEX <> $AGLVEX_DATA [ 0 ] [ 1 ] Then
				$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
				$AGLVEX_DATA [ 0 ] [ 17 ] = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
				$AGLVEX_DATA [ 0 ] [ 18 ] = $AGLVEX_DATA [ $ILV_INDEX ] [ 21 ]
			EndIf
			Switch $ICODE
			Case $LVN_BEGINSCROLL
				If $CGLVEX_EDITID <> 9999 Then
					GUICtrlDelete ( $CGLVEX_EDITID )
					$CGLVEX_EDITID = 9999
					WinSetState ( $HGLVEX_EDITING , "" , @SW_ENABLE )
				EndIf
			Case $LVN_BEGINDRAG
				If Not BitAND ( $AGLVEX_DATA [ $ILV_INDEX ] [ 12 ] , 8 ) Then
					$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
					$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
					$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
					$IGLVEX_SRCINDEX = $ILV_INDEX
					$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
					$HGLVEX_TGTHANDLE = $HGLVEX_SRCHANDLE
					$CGLVEX_TGTID = $CGLVEX_SRCID
					$IGLVEX_TGTINDEX = $IGLVEX_SRCINDEX
					$AGLVEX_TGTARRAY = $AGLVEX_SRCARRAY
					$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
					Local $FIMAGE = $AGLVEX_DATA [ $ILV_INDEX ] [ 5 ]
					If $CGLVEX_SRCID Then
						GUICtrlSetState ( $CGLVEX_SRCID , 256 )
					Else
						_WINAPI_SETFOCUS ( $HGLVEX_SRCHANDLE )
					EndIf
					$IGLVEX_DRAGGEDINDEX = DllStructGetData ( $TSTRUCT , 4 )
					$IGLVEX_DRAGGING = 1
					Local $IINDEX
					If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
						$IINDEX = $AGLVEX_DATA [ $ILV_INDEX ] [ 20 ]
					Else
						$IINDEX = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HGLVEX_SRCHANDLE )
					EndIf
					If StringInStr ( $IINDEX , $IGLVEX_DRAGGEDINDEX ) And StringInStr ( $IINDEX , "|" ) Then
						Local $AINDEX = StringSplit ( $IINDEX , "|" )
						For $I = 1 To $AINDEX [ 0 ]
							If $AINDEX [ $I ] = $IGLVEX_DRAGGEDINDEX Then ExitLoop
						Next
						If $I <> 1 Then
							For $J = $I + 4294967295 To 1 Step + 4294967295
								If $AINDEX [ $J ] <> $AINDEX [ $J + 1 ] + 4294967295 Then ExitLoop
								$IGLVEX_DRAGGEDINDEX -= 1
								$IGLVEX_DRAGGING += 1
							Next
						EndIf
						If $I <> $AINDEX [ 0 ] Then
							For $J = $I + 1 To $AINDEX [ 0 ]
								If $AINDEX [ $J ] <> $AINDEX [ $J + 4294967295 ] + 1 Then ExitLoop
								$IGLVEX_DRAGGING += 1
							Next
						EndIf
					Else
						$IGLVEX_DRAGGING = 1
					EndIf
					_GUICTRLLISTVIEW_SETITEMSELECTED ( $HGLVEX_SRCHANDLE , + 4294967295 , False )
					If $FIMAGE Then
						Local $AIMAGEDATA = _GUICTRLLISTVIEW_CREATEDRAGIMAGE ( $HGLVEX_SRCHANDLE , $IGLVEX_DRAGGEDINDEX )
						$HGLVEX_DRAGGEDIMAGE = $AIMAGEDATA [ 0 ]
						_GUIIMAGELIST_BEGINDRAG ( $HGLVEX_DRAGGEDIMAGE , 0 , 0 , 0 )
					EndIf
				EndIf
			Case $LVN_COLUMNCLICK , + 4294967294
				$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
				$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
				$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
				$IROW = DllStructGetData ( $TSTRUCT , 4 )
				$AGLVEX_DATA [ 0 ] [ 4 ] = $IROW
				$AGLVEX_DATA [ 0 ] [ 17 ] = $IROW
				$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $IROW
				$ICOL = DllStructGetData ( $TSTRUCT , 5 )
				$AGLVEX_DATA [ 0 ] [ 2 ] = $ICOL
				$AGLVEX_DATA [ 0 ] [ 5 ] = $ICOL
				$AGLVEX_DATA [ 0 ] [ 18 ] = $ICOL
				$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = $ICOL
				If $ICODE = $LVN_COLUMNCLICK Then
					Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
					Local $ARECT = _GUICTRLLISTVIEW_GETSUBITEMRECT ( $HGLVEX_SRCHANDLE , 0 , $ICOL )
					Local $ALV_POS = WinGetPos ( $HGLVEX_SRCHANDLE )
					If $ARECT [ 0 ] < 0 Or $ARECT [ 2 ] > $ALV_POS [ 2 ] - $AGLVEX_DATA [ 0 ] [ 8 ] Then
						_GUICTRLLISTVIEW_SCROLL ( $HGLVEX_SRCHANDLE , $ARECT [ 0 ] , 0 )
					EndIf
					_WINAPI_GETASYNCKEYSTATE ( 17 )
					If _WINAPI_GETASYNCKEYSTATE ( 17 ) Then
						If $AEDITABLE [ 0 ] [ $ICOL ] Then
							$FGLVEX_HEADEREDIT = True
						EndIf
					Else
						If IsArray ( $AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] ) Then
							$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
							Local $ALVSORTSTATE = $AGLVEX_DATA [ $ILV_INDEX ] [ 4 ]
							__GUILISTVIEWEX_COLSORT ( $HGLVEX_SRCHANDLE , $ILV_INDEX , $ALVSORTSTATE , $ICOL , $AEDITABLE [ 3 ] [ $ICOL ] )
							$AGLVEX_DATA [ $ILV_INDEX ] [ 4 ] = $ALVSORTSTATE
							Local $IDIM2 = UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
							For $J = 1 To $AGLVEX_SRCARRAY [ 0 ] [ 0 ]
								For $K = 0 To $IDIM2
									$AGLVEX_SRCARRAY [ $J ] [ $K ] = _GUICTRLLISTVIEW_GETITEMTEXT ( $HGLVEX_SRCHANDLE , $J + 4294967295 , $K )
								Next
							Next
							$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
							$AGLVEX_SRCARRAY = 0
						EndIf
					EndIf
				Else
					$FGLVEX_USERSELFLAG = 1
				EndIf
			Case $LVN_KEYDOWN
				Local $TKEY = DllStructCreate ( $TAGNMHDR & ";WORD KeyCode" , $LPARAM )
				$AGLVEX_DATA [ 0 ] [ 16 ] = DllStructGetData ( $TKEY , "KeyCode" )
				If __GUILISTVIEWEX_CHECKUSEREDITKEY ( ) Then
					$FEDITHOTKEY = True
					ContinueCase
				EndIf
				If $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
					_GUICTRLLISTVIEW_SETITEMSELECTED ( $HLV , $AGLVEX_DATA [ 0 ] [ 17 ] , False )
					Switch $AGLVEX_DATA [ 0 ] [ 16 ]
					Case 37
						If $AGLVEX_DATA [ 0 ] [ 18 ] > 0 Then $AGLVEX_DATA [ 0 ] [ 18 ] -= 1
						$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = $AGLVEX_DATA [ 0 ] [ 18 ]
						_GUICTRLLISTVIEW_REDRAWITEMS ( $HLV , $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 17 ] )
						$FGLVEX_USERSELFLAG = 1
						$FGLVEX_SELCHANGEFLAG = $ILV_INDEX
					Case 39
						If $AGLVEX_DATA [ 0 ] [ 18 ] < _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HLV ) + 4294967295 Then $AGLVEX_DATA [ 0 ] [ 18 ] += 1
						$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = $AGLVEX_DATA [ 0 ] [ 18 ]
						_GUICTRLLISTVIEW_REDRAWITEMS ( $HLV , $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 17 ] )
						$FGLVEX_USERSELFLAG = 1
						$FGLVEX_SELCHANGEFLAG = $ILV_INDEX
					EndSwitch
				EndIf
			Case + 4294967293
				$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
				$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
				If Not $FEDITHOTKEY Then
					$IROW = DllStructGetData ( $TSTRUCT , 4 )
					$AGLVEX_DATA [ 0 ] [ 17 ] = $IROW
					$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $IROW
					$ICOL = DllStructGetData ( $TSTRUCT , 5 )
					$AGLVEX_DATA [ 0 ] [ 18 ] = $ICOL
					$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = $ICOL
				EndIf
				$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
				$FGLVEX_EDITCLICKFLAG = $ILV_INDEX
			Case $LVN_ITEMCHANGED
				If $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
					_GUICTRLLISTVIEW_SETITEMSELECTED ( $HLV , $IITEM , False )
				EndIf
				If $AGLVEX_DATA [ 0 ] [ 16 ] <> 0 Then
					Switch $AGLVEX_DATA [ 0 ] [ 16 ]
					Case 38
						If $AGLVEX_DATA [ 0 ] [ 17 ] > 0 Then $AGLVEX_DATA [ 0 ] [ 17 ] -= 1
						$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $AGLVEX_DATA [ 0 ] [ 17 ]
						$FGLVEX_USERSELFLAG = 1
					Case 40
						If $AGLVEX_DATA [ 0 ] [ 17 ] < _GUICTRLLISTVIEW_GETITEMCOUNT ( $HLV ) + 4294967295 Then $AGLVEX_DATA [ 0 ] [ 17 ] += 1
						$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $AGLVEX_DATA [ 0 ] [ 17 ]
						$FGLVEX_USERSELFLAG = 1
					EndSwitch
					$AGLVEX_DATA [ 0 ] [ 16 ] = 0
				Else
					_WINAPI_GETASYNCKEYSTATE ( 1 )
					If _WINAPI_GETASYNCKEYSTATE ( 1 ) Then
						Local $AMPOS = MouseGetPos ( )
						Local $TPOINT = DllStructCreate ( "int X;int Y" )
						DllStructSetData ( $TPOINT , "X" , $AMPOS [ 0 ] )
						DllStructSetData ( $TPOINT , "Y" , $AMPOS [ 1 ] )
						_WINAPI_SCREENTOCLIENT ( $HLV , $TPOINT )
						Local $ACURPOS [ 2 ] = [ DllStructGetData ( $TPOINT , "X" ) , DllStructGetData ( $TPOINT , "Y" ) ]
						Local $AHITTEST = _GUICTRLLISTVIEW_SUBITEMHITTEST ( $HLV , $ACURPOS [ 0 ] , $ACURPOS [ 1 ] )
						If $AHITTEST [ 0 ] > + 4294967295 And $AHITTEST [ 1 ] > + 4294967295 And $AHITTEST [ 0 ] = $IITEM Then
							If $AGLVEX_DATA [ 0 ] [ 17 ] <> $IITEM Then _GUICTRLLISTVIEW_REDRAWITEMS ( $HLV , $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 17 ] )
							$AGLVEX_DATA [ 0 ] [ 17 ] = $AHITTEST [ 0 ]
							$AGLVEX_DATA [ 0 ] [ 18 ] = $AHITTEST [ 1 ]
							$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $AGLVEX_DATA [ 0 ] [ 17 ]
							$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = $AGLVEX_DATA [ 0 ] [ 18 ]
							_GUICTRLLISTVIEW_REDRAWITEMS ( $HLV , $IITEM , $IITEM )
						EndIf
						$FGLVEX_USERSELFLAG = 1
					EndIf
				EndIf
				$FGLVEX_SELCHANGEFLAG = $ILV_INDEX
			Case + 4294967291
				$AGLVEX_DATA [ 0 ] [ 1 ] = $ILV_INDEX
				$AGLVEX_DATA [ 0 ] [ 10 ] = DllStructGetData ( $TSTRUCT , 4 )
				$AGLVEX_DATA [ 0 ] [ 11 ] = DllStructGetData ( $TSTRUCT , 5 )
				_GUICTRLLISTVIEW_REDRAWITEMS ( $HLV , $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 17 ] )
				$AGLVEX_DATA [ 0 ] [ 17 ] = DllStructGetData ( $TSTRUCT , 4 )
				$AGLVEX_DATA [ 0 ] [ 18 ] = DllStructGetData ( $TSTRUCT , 5 )
				$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $AGLVEX_DATA [ 0 ] [ 17 ]
				$AGLVEX_DATA [ $ILV_INDEX ] [ 21 ] = $AGLVEX_DATA [ 0 ] [ 18 ]
				_GUICTRLLISTVIEW_REDRAWITEMS ( $HLV , $AGLVEX_DATA [ 0 ] [ 17 ] , $AGLVEX_DATA [ 0 ] [ 17 ] )
			EndSwitch
		Else
			For $ILV_INDEX = 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
				If DllStructGetData ( $TSTRUCT , 1 ) = _GUICTRLLISTVIEW_GETHEADER ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] ) Then
					ExitLoop
				EndIf
			Next
			If $ILV_INDEX <= $AGLVEX_DATA [ 0 ] [ 0 ] Then
				Local $TNMHEADER = DllStructCreate ( $TAGNMHEADER , $LPARAM )
				$ICOL = DllStructGetData ( $TNMHEADER , "Item" )
				Switch $ICOL
				Case 0 To _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] ) + 4294967295
					$AHDRDATA = $AGLVEX_DATA [ $ILV_INDEX ] [ 25 ]
					If IsArray ( $AHDRDATA ) And UBound ( $AHDRDATA , 2 ) Then
						Local $IHDRRESIZE = $AHDRDATA [ 3 ] [ $ICOL ]
						Switch $ICODE
						Case + 4294966990 , + 4294966970
							If $IHDRRESIZE Then
								Return True
							Else
								Return False
							EndIf
						Case + 4294966991 , + 4294966971
							If $IHDRRESIZE Then
								_GUICTRLLISTVIEW_SETCOLUMNWIDTH ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] , $ICOL , $IHDRRESIZE )
								_WINAPI_REDRAWWINDOW ( DllStructGetData ( $TSTRUCT , 1 ) )
							EndIf
						Case + 4294966989 , + 4294966969
							$FGVLEX_RESIZED = $ICOL
						EndSwitch
					EndIf
				EndSwitch
			EndIf
		EndIf
	EndIf
	Return "GUI_RUNDEFMSG"
EndFunc
Func _GUILISTVIEWEX_WM_MOUSEMOVE_HANDLER ( $HWND , $IMSG , $WPARAM , $LPARAM )
	#forceref $hWnd, $iMsg, $wParam
	Local $IVERTSCROLL
	If $IGLVEX_DRAGGING = 0 Then
		Return "GUI_RUNDEFMSG"
	EndIf
	If $AGLVEX_DATA [ $AGLVEX_DATA [ 0 ] [ 1 ] ] [ 10 ] Then
		$IVERTSCROLL = $AGLVEX_DATA [ $AGLVEX_DATA [ 0 ] [ 1 ] ] [ 10 ]
	Else
		Local $ARECT = _GUICTRLLISTVIEW_GETITEMRECT ( $HGLVEX_SRCHANDLE , 0 )
		$IVERTSCROLL = $ARECT [ 3 ] - $ARECT [ 1 ]
	EndIf
	Local $HCURRENT_WND = __GUILISTVIEWEX_GETCURSORWND ( )
	If $HCURRENT_WND <> $HGLVEX_TGTHANDLE Then
		If BitAND ( $AGLVEX_DATA [ $IGLVEX_TGTINDEX ] [ 12 ] , 1 ) Then
			Return "GUI_RUNDEFMSG"
		EndIf
		For $I = 1 To $AGLVEX_DATA [ 0 ] [ 0 ]
			If $AGLVEX_DATA [ $I ] [ 0 ] = $HCURRENT_WND Then
				If BitAND ( $AGLVEX_DATA [ $I ] [ 12 ] , 2 ) Then
					Return "GUI_RUNDEFMSG"
				EndIf
				If _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_SRCHANDLE ) = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HCURRENT_WND ) Then
					_GUICTRLLISTVIEW_SETINSERTMARK ( $HGLVEX_TGTHANDLE , + 4294967295 , True )
					$HGLVEX_TGTHANDLE = $HCURRENT_WND
					$CGLVEX_TGTID = $AGLVEX_DATA [ $I ] [ 1 ]
					$IGLVEX_TGTINDEX = $I
					$AGLVEX_TGTARRAY = $AGLVEX_DATA [ $I ] [ 2 ]
					$AGLVEX_DATA [ 0 ] [ 3 ] = $AGLVEX_DATA [ $I ] [ 10 ]
					ExitLoop
				EndIf
			EndIf
		Next
	EndIf
	Local $ICURR_Y = BitShift ( $LPARAM , 16 )
	If $IGLVEX_INSERTINDEX <> + 4294967295 Then
		If $IGLVEX_LASTY = $ICURR_Y Then
			Return "GUI_RUNDEFMSG"
		ElseIf $IGLVEX_LASTY > $ICURR_Y Then
			$FGLVEX_BARUNDER = False
			_GUICTRLLISTVIEW_SETINSERTMARK ( $HGLVEX_TGTHANDLE , $IGLVEX_INSERTINDEX , False )
		Else
			$FGLVEX_BARUNDER = True
			_GUICTRLLISTVIEW_SETINSERTMARK ( $HGLVEX_TGTHANDLE , $IGLVEX_INSERTINDEX , True )
		EndIf
	EndIf
	$IGLVEX_LASTY = $ICURR_Y
	Local $ALVHIT = _GUICTRLLISTVIEW_HITTEST ( $HGLVEX_TGTHANDLE )
	Local $ICURR_INDEX = $ALVHIT [ 0 ]
	If $ICURR_INDEX = + 4294967295 Then
		If $FGLVEX_BARUNDER Then
			_GUICTRLLISTVIEW_SCROLL ( $HGLVEX_TGTHANDLE , 0 , $IVERTSCROLL )
		Else
			_GUICTRLLISTVIEW_SCROLL ( $HGLVEX_TGTHANDLE , 0 , - $IVERTSCROLL )
		EndIf
		Sleep ( 10 )
	EndIf
	If $IGLVEX_INSERTINDEX <> $ICURR_INDEX Then
		_GUICTRLLISTVIEW_SETINSERTMARK ( $HGLVEX_TGTHANDLE , $ICURR_INDEX , $FGLVEX_BARUNDER )
		$IGLVEX_INSERTINDEX = $ICURR_INDEX
	EndIf
	Return "GUI_RUNDEFMSG"
EndFunc
Func _GUILISTVIEWEX_WM_LBUTTONUP_HANDLER ( $HWND , $IMSG , $WPARAM , $LPARAM )
	#forceref $hWnd, $iMsg, $wParam, $lParam
	If Not $IGLVEX_DRAGGING Then
		Return "GUI_RUNDEFMSG"
	EndIf
	Local $IMULTIPLEITEMS = $IGLVEX_DRAGGING + 4294967295
	$IGLVEX_DRAGGING = 0
	If $IGLVEX_INSERTINDEX = + 4294967295 Then
		$IGLVEX_INSERTINDEX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_TGTHANDLE ) + 4294967295
	EndIf
	Local $HCURRENT_WND = __GUILISTVIEWEX_GETCURSORWND ( )
	If $HCURRENT_WND <> $HGLVEX_TGTHANDLE Then
		_GUICTRLLISTVIEW_SETINSERTMARK ( $HGLVEX_TGTHANDLE , + 4294967295 , True )
		For $I = 0 To $IMULTIPLEITEMS
			__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_TGTHANDLE , $CGLVEX_TGTID , $IGLVEX_DRAGGEDINDEX + $I )
		Next
		$AGLVEX_SRCARRAY = 0
		$AGLVEX_TGTARRAY = 0
		Return
	EndIf
	_GUICTRLLISTVIEW_SETINSERTMARK ( $HGLVEX_TGTHANDLE , + 4294967295 , True )
	If $HGLVEX_DRAGGEDIMAGE Then
		_GUIIMAGELIST_DRAGLEAVE ( $HGLVEX_SRCHANDLE )
		_GUIIMAGELIST_ENDDRAG ( )
		_GUIIMAGELIST_DESTROY ( $HGLVEX_DRAGGEDIMAGE )
		$HGLVEX_DRAGGEDIMAGE = 0
	EndIf
	If $HGLVEX_SRCHANDLE = $HGLVEX_TGTHANDLE Then
		If $FGLVEX_BARUNDER Then
			If $IGLVEX_DRAGGEDINDEX > $IGLVEX_INSERTINDEX Then $IGLVEX_INSERTINDEX += 1
		Else
			If $IGLVEX_DRAGGEDINDEX < $IGLVEX_INSERTINDEX Then $IGLVEX_INSERTINDEX -= 1
		EndIf
		Switch $IGLVEX_INSERTINDEX
		Case $IGLVEX_DRAGGEDINDEX To $IGLVEX_DRAGGEDINDEX + $IMULTIPLEITEMS
			For $I = 0 To $IMULTIPLEITEMS
				__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IGLVEX_DRAGGEDINDEX + $I )
			Next
			$AGLVEX_SRCARRAY = 0
			$AGLVEX_TGTARRAY = 0
			Return
		EndSwitch
		Local $ACHECK_ARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
		For $I = 1 To UBound ( $ACHECK_ARRAY ) + 4294967295
			$ACHECK_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
		Next
		Local $ACHECKDRAG_ARRAY [ $IMULTIPLEITEMS + 1 ]
		$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 18 ]
		Local $BUSERCOL = ( ( IsArray ( $AGLVEX_SRCCOLARRAY ) ) ? ( True ) : ( False ) )
		If $IMULTIPLEITEMS Then
			Local $AINSERTDATA [ $IMULTIPLEITEMS + 1 ]
			Local $ACOLDATA [ $IMULTIPLEITEMS + 1 ]
			Local $AITEMDATA [ UBound ( $AGLVEX_SRCARRAY , 2 ) ]
			For $I = 0 To $IMULTIPLEITEMS
				For $J = 0 To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
					$AITEMDATA [ $J ] = $AGLVEX_SRCARRAY [ $IGLVEX_DRAGGEDINDEX + 1 + $I ] [ $J ]
				Next
				$AINSERTDATA [ $I ] = $AITEMDATA
				If $BUSERCOL Then
					For $J = 0 To UBound ( $AGLVEX_SRCCOLARRAY , 2 ) + 4294967295
						$AITEMDATA [ $J ] = $AGLVEX_SRCCOLARRAY [ $IGLVEX_DRAGGEDINDEX + 1 + $I ] [ $J ]
					Next
					$ACOLDATA [ $I ] = $AITEMDATA
				EndIf
				$ACHECKDRAG_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $IGLVEX_DRAGGEDINDEX + $I )
			Next
		Else
			Local $AINSERTDATA [ 1 ]
			Local $ACOLDATA [ 1 ]
			Local $AITEMDATA [ UBound ( $AGLVEX_SRCARRAY , 2 ) ]
			For $I = 0 To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
				$AITEMDATA [ $I ] = $AGLVEX_SRCARRAY [ $IGLVEX_DRAGGEDINDEX + 1 ] [ $I ]
			Next
			$AINSERTDATA [ 0 ] = $AITEMDATA
			If $BUSERCOL Then
				For $I = 0 To UBound ( $AGLVEX_SRCCOLARRAY , 2 ) + 4294967295
					$AITEMDATA [ $I ] = $AGLVEX_SRCCOLARRAY [ $IGLVEX_DRAGGEDINDEX + 1 ] [ $I ]
				Next
				$ACOLDATA [ 0 ] = $AITEMDATA
			EndIf
			$ACHECKDRAG_ARRAY [ 0 ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $IGLVEX_DRAGGEDINDEX )
		EndIf
		$AGLVEX_DATA [ 0 ] [ 12 ] = True
		For $I = 0 To $IMULTIPLEITEMS
			__GUILISTVIEWEX_ARRAY_DELETE ( $AGLVEX_SRCARRAY , $IGLVEX_DRAGGEDINDEX + 1 )
			__GUILISTVIEWEX_ARRAY_DELETE ( $ACHECK_ARRAY , $IGLVEX_DRAGGEDINDEX + 1 )
			If $BUSERCOL Then __GUILISTVIEWEX_ARRAY_DELETE ( $AGLVEX_SRCCOLARRAY , $IGLVEX_DRAGGEDINDEX + 1 )
		Next
		If $IGLVEX_DRAGGEDINDEX < $IGLVEX_INSERTINDEX Then
			$IGLVEX_INSERTINDEX -= $IMULTIPLEITEMS
		EndIf
		For $I = $IMULTIPLEITEMS To 0 Step + 4294967295
			__GUILISTVIEWEX_ARRAY_INSERT ( $AGLVEX_SRCARRAY , $IGLVEX_INSERTINDEX + 1 , $AINSERTDATA [ $I ] )
			__GUILISTVIEWEX_ARRAY_INSERT ( $ACHECK_ARRAY , $IGLVEX_INSERTINDEX + 1 , $ACHECKDRAG_ARRAY [ $I ] )
			If $BUSERCOL Then __GUILISTVIEWEX_ARRAY_INSERT ( $AGLVEX_SRCCOLARRAY , $IGLVEX_INSERTINDEX + 1 , $ACOLDATA [ $I ] , False , False )
		Next
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_ARRAY , $IGLVEX_SRCINDEX )
		For $I = 0 To $IMULTIPLEITEMS
			__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_SRCHANDLE , $CGLVEX_SRCID , $IGLVEX_INSERTINDEX + $I )
		Next
		$AGLVEX_DATA [ $AGLVEX_DATA [ 0 ] [ 1 ] ] [ 2 ] = $AGLVEX_SRCARRAY
		$AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
	Else
		Local $BCHECKBOX = ( ( $AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 6 ] And $AGLVEX_DATA [ $IGLVEX_TGTINDEX ] [ 6 ] ) ? ( True ) : ( False ) )
		If $FGLVEX_BARUNDER Then
			$IGLVEX_INSERTINDEX += 1
		EndIf
		$AGLVEX_SRCCOLARRAY = $AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 18 ]
		Local $BUSERCOLSRC = ( ( IsArray ( $AGLVEX_SRCCOLARRAY ) ) ? ( True ) : ( False ) )
		$AGLVEX_TGTCOLARRAY = $AGLVEX_DATA [ $IGLVEX_TGTINDEX ] [ 18 ]
		Local $BUSERCOLTGT = ( ( IsArray ( $AGLVEX_TGTCOLARRAY ) ) ? ( True ) : ( False ) )
		Local $ACHECK_SRCARRAY [ UBound ( $AGLVEX_SRCARRAY ) ]
		For $I = 1 To UBound ( $ACHECK_SRCARRAY ) + 4294967295
			$ACHECK_SRCARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $I + 4294967295 )
		Next
		Local $ACHECK_TGTARRAY [ UBound ( $AGLVEX_TGTARRAY ) ]
		For $I = 1 To UBound ( $ACHECK_TGTARRAY ) + 4294967295
			$ACHECK_TGTARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_TGTHANDLE , $I + 4294967295 )
		Next
		Local $ACHECKDRAG_ARRAY [ $IMULTIPLEITEMS + 1 ]
		If $IMULTIPLEITEMS Then
			Local $AINSERTDATA [ $IMULTIPLEITEMS + 1 ]
			Local $ACOLDATA [ $IMULTIPLEITEMS + 1 ]
			Local $AITEMDATA [ UBound ( $AGLVEX_SRCARRAY , 2 ) ]
			For $I = 0 To $IMULTIPLEITEMS
				For $J = 0 To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
					$AITEMDATA [ $J ] = $AGLVEX_SRCARRAY [ $IGLVEX_DRAGGEDINDEX + 1 + $I ] [ $J ]
				Next
				$AINSERTDATA [ $I ] = $AITEMDATA
				If $BUSERCOLTGT Then
					For $J = 0 To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
						If $BUSERCOLSRC Then
							$AITEMDATA [ $J ] = $AGLVEX_SRCCOLARRAY [ $IGLVEX_DRAGGEDINDEX + 1 + $I ] [ $J ]
						Else
							$AITEMDATA [ $J ] = ";"
						EndIf
					Next
					$ACOLDATA [ $I ] = $AITEMDATA
				EndIf
				$ACHECKDRAG_ARRAY [ $I ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $IGLVEX_DRAGGEDINDEX + $I )
			Next
		Else
			Local $AINSERTDATA [ 1 ]
			Local $ACOLDATA [ 1 ]
			Local $AITEMDATA [ UBound ( $AGLVEX_SRCARRAY , 2 ) ]
			For $I = 0 To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
				$AITEMDATA [ $I ] = $AGLVEX_SRCARRAY [ $IGLVEX_DRAGGEDINDEX + 1 ] [ $I ]
			Next
			$AINSERTDATA [ 0 ] = $AITEMDATA
			If $BUSERCOLTGT Then
				For $I = 0 To UBound ( $AGLVEX_SRCARRAY , 2 ) + 4294967295
					If $BUSERCOLSRC Then
						$AITEMDATA [ $I ] = $AGLVEX_SRCCOLARRAY [ $IGLVEX_DRAGGEDINDEX + 1 ] [ $I ]
					Else
						$AITEMDATA [ $I ] = ";"
					EndIf
				Next
				$ACOLDATA [ 0 ] = $AITEMDATA
			EndIf
			$ACHECKDRAG_ARRAY [ 0 ] = _GUICTRLLISTVIEW_GETITEMCHECKED ( $HGLVEX_SRCHANDLE , $IGLVEX_DRAGGEDINDEX )
		EndIf
		$AGLVEX_DATA [ 0 ] [ 12 ] = True
		If Not BitAND ( $AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 12 ] , 4 ) Then
			For $I = 0 To $IMULTIPLEITEMS
				__GUILISTVIEWEX_ARRAY_DELETE ( $AGLVEX_SRCARRAY , $IGLVEX_DRAGGEDINDEX + 1 )
				__GUILISTVIEWEX_ARRAY_DELETE ( $ACHECK_SRCARRAY , $IGLVEX_DRAGGEDINDEX + 1 , $ACHECKDRAG_ARRAY [ $I ] )
				If $BUSERCOLSRC Then __GUILISTVIEWEX_ARRAY_DELETE ( $AGLVEX_SRCCOLARRAY , $IGLVEX_DRAGGEDINDEX + 1 )
			Next
		EndIf
		If $IGLVEX_INSERTINDEX < 0 Then
			$IGLVEX_INSERTINDEX = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_TGTHANDLE )
		EndIf
		For $I = $IMULTIPLEITEMS To 0 Step + 4294967295
			__GUILISTVIEWEX_ARRAY_INSERT ( $AGLVEX_TGTARRAY , $IGLVEX_INSERTINDEX + 1 , $AINSERTDATA [ $I ] )
			__GUILISTVIEWEX_ARRAY_INSERT ( $ACHECK_TGTARRAY , $IGLVEX_INSERTINDEX + 1 , $ACHECKDRAG_ARRAY [ $I ] )
			If $BUSERCOLTGT Then __GUILISTVIEWEX_ARRAY_INSERT ( $AGLVEX_TGTCOLARRAY , $IGLVEX_INSERTINDEX + 1 , $ACOLDATA [ $I ] , False , False )
		Next
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_SRCHANDLE , $AGLVEX_SRCARRAY , $ACHECK_SRCARRAY , $IGLVEX_SRCINDEX , $BCHECKBOX )
		__GUILISTVIEWEX_REWRITELV ( $HGLVEX_TGTHANDLE , $AGLVEX_TGTARRAY , $ACHECK_TGTARRAY , $IGLVEX_TGTINDEX , $BCHECKBOX )
		_GUILISTVIEWEX_SETACTIVE ( $IGLVEX_TGTINDEX )
		For $I = 0 To $IMULTIPLEITEMS
			__GUILISTVIEWEX_HIGHLIGHT ( $HGLVEX_TGTHANDLE , $CGLVEX_TGTID , $IGLVEX_INSERTINDEX + $I )
		Next
		$AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 2 ] = $AGLVEX_SRCARRAY
		$AGLVEX_DATA [ $IGLVEX_SRCINDEX ] [ 18 ] = $AGLVEX_SRCCOLARRAY
		$AGLVEX_DATA [ $IGLVEX_TGTINDEX ] [ 2 ] = $AGLVEX_TGTARRAY
		$AGLVEX_DATA [ $IGLVEX_TGTINDEX ] [ 18 ] = $AGLVEX_TGTCOLARRAY
	EndIf
	$AGLVEX_SRCARRAY = 0
	$AGLVEX_TGTARRAY = 0
	$AGLVEX_SRCCOLARRAY = 0
	$AGLVEX_TGTCOLARRAY = 0
	$SGLVEX_DRAGEVENT = $IGLVEX_SRCINDEX & ":" & $IGLVEX_TGTINDEX
	$AGLVEX_DATA [ 0 ] [ 22 ] = 1
	$AGLVEX_DATA [ 0 ] [ 12 ] = False
	__GUILISTVIEWEX_REDRAWWINDOW ( $IGLVEX_SRCINDEX )
	If $HGLVEX_TGTHANDLE <> $HGLVEX_SRCHANDLE Then
		__GUILISTVIEWEX_REDRAWWINDOW ( $IGLVEX_TGTINDEX )
	EndIf
EndFunc
Func _GUILISTVIEWEX_WM_SYSCOMMAND_HANDLER ( $HWND , $IMSG , $WPARAM , $LPARAM )
	#forceref $hWnd, $iMsg, $lParam, $lParam
	If $HWND = _WINAPI_GETPARENT ( $HGLVEX_SRCHANDLE ) And $WPARAM = 61536 Then
		$AGLVEX_DATA [ 0 ] [ 9 ] = True
	EndIf
EndFunc
Func __GUILISTVIEWEX_EXPANDRANGE ( $VRANGE , $ILV_INDEX , $IMODE = 1 )
	If StringRegExp ( $VRANGE , "[^*0-9-;]" ) <> 0 Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	Local $ICOUNT
	If $IMODE = 1 Then
		$ICOUNT = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] )
	Else
		$ICOUNT = _GUICTRLLISTVIEW_GETITEMCOUNT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] )
	EndIf
	Local $ARET [ $ICOUNT + 1 ]
	$VRANGE = StringStripWS ( $VRANGE , 8 )
	If $VRANGE = "*" Then
		$ARET [ 0 ] = $ICOUNT
		For $I = 1 To $ICOUNT
			$ARET [ $I ] = $I + 4294967295
		Next
	Else
		If StringInStr ( $VRANGE , "-" ) Then
			Local $ASPLIT_1 , $ASPLIT_2 , $INUMBER
			$ASPLIT_1 = StringSplit ( $VRANGE , ";" )
			$VRANGE = ""
			For $I = 1 To $ASPLIT_1 [ 0 ]
				$ASPLIT_2 = StringSplit ( $ASPLIT_1 [ $I ] , "-" )
				$VRANGE &= $ASPLIT_2 [ 1 ] & ";"
				If ( $ASPLIT_2 [ 0 ] ) > 1 Then
					If ( Number ( $ASPLIT_2 [ 2 ] ) > Number ( $ASPLIT_2 [ 1 ] ) ) Then
						$INUMBER = $ASPLIT_2 [ 1 ]
						Do
							$INUMBER += 1
							$VRANGE &= $INUMBER & ";"
						Until $INUMBER = $ASPLIT_2 [ 2 ]
					Else
						Return SetError ( 1 , 0 , 0 )
					EndIf
				EndIf
			Next
		EndIf
		Local $ASPLIT = StringSplit ( $VRANGE , ";" )
		For $I = 1 To $ASPLIT [ 0 ]
			If $ASPLIT [ $I ] Then
				$ARET [ 0 ] += 1
				$ARET [ $ARET [ 0 ] ] = $ASPLIT [ $I ]
			EndIf
		Next
		ReDim $ARET [ $ARET [ 0 ] + 1 ]
	EndIf
	Return $ARET
EndFunc
Func __GUILISTVIEWEX_HIGHLIGHT ( $HLVHANDLE , $CLV_CID , $IINDEXA , $IINDEXB = + 4294967295 )
	If $CLV_CID Then
		GUICtrlSetState ( $CLV_CID , 256 )
	Else
		_WINAPI_SETFOCUS ( $HLVHANDLE )
	EndIf
	If $IINDEXB <> + 4294967295 Then _GUICTRLLISTVIEW_SETITEMSELECTED ( $HLVHANDLE , $IINDEXB , False )
	_GUICTRLLISTVIEW_SETITEMSTATE ( $HLVHANDLE , $IINDEXA , $LVIS_SELECTED , $LVIS_SELECTED )
	_GUICTRLLISTVIEW_ENSUREVISIBLE ( $HLVHANDLE , $IINDEXA )
EndFunc
Func __GUILISTVIEWEX_GETLVFONT ( $HLVHANDLE )
	Local $IERROR = 0 , $AFONTDETAILS [ 2 ] = [ Default , Default ]
	If Not IsHWnd ( $HLVHANDLE ) Then
		$HLVHANDLE = GUICtrlGetHandle ( $HLVHANDLE )
	EndIf
	If Not IsHWnd ( $HLVHANDLE ) Then
		$IERROR = 1
	Else
		Local $HFONT = _SENDMESSAGE ( $HLVHANDLE , 49 )
		If Not $HFONT Then
			$IERROR = 2
		Else
			Local $HDC = _WINAPI_GETDC ( $HLVHANDLE )
			Local $HOBJORG = _WINAPI_SELECTOBJECT ( $HDC , $HFONT )
			Local $TFONT = DllStructCreate ( $TAGLOGFONT )
			Local $ARET = DllCall ( "gdi32.dll" , "int" , "GetObjectW" , "ptr" , $HFONT , "int" , DllStructGetSize ( $TFONT ) , "ptr" , DllStructGetPtr ( $TFONT ) )
			If @error Or $ARET [ 0 ] = 0 Then
				$IERROR = 3
			Else
				$AFONTDETAILS [ 0 ] = Round ( ( + 4294967295 * DllStructGetData ( $TFONT , "Height" ) ) * 72 / _WINAPI_GETDEVICECAPS ( $HDC , 90 ) , 1 )
				$ARET = DllCall ( "gdi32.dll" , "int" , "GetTextFaceW" , "handle" , $HDC , "int" , 0 , "ptr" , 0 )
				Local $ICOUNT = $ARET [ 0 ]
				Local $TBUFFER = DllStructCreate ( "wchar[" & $ICOUNT & "]" )
				Local $PBUFFER = DllStructGetPtr ( $TBUFFER )
				$ARET = DllCall ( "Gdi32.dll" , "int" , "GetTextFaceW" , "handle" , $HDC , "int" , $ICOUNT , "ptr" , $PBUFFER )
				If @error Then
					$IERROR = 4
				Else
					$AFONTDETAILS [ 1 ] = DllStructGetData ( $TBUFFER , 1 )
				EndIf
			EndIf
			_WINAPI_SELECTOBJECT ( $HDC , $HOBJORG )
			_WINAPI_RELEASEDC ( $HLVHANDLE , $HDC )
		EndIf
	EndIf
	Return SetError ( $IERROR , 0 , $AFONTDETAILS )
EndFunc
Func __GUILISTVIEWEX_EDITPROCESS ( $ILV_INDEX , $ALOCATION , $IDELTA_X , $IDELTA_Y , $IEDITMODE , $IFORCE = False )
	Local $HTEMP_COMBO = 9999 , $HTEMP_EDIT = 9999 , $HTEMP_LIST = 9999 , $IKEY_CODE , $FCOMBO_STATE , $ASPLIT , $SINSERT
	Local $IEDITTYPE , $FEDIT , $FCOMBO , $FREAD_ONLY , $FAUTO_DROP , $FDTP , $FCLICK_MOVE = False , $CUPDOWN , $HUPDOWN
	Local $HPREVCURRGUI = GUISwitch ( _WINAPI_GETPARENT ( $HGLVEX_SRCHANDLE ) )
	_GUICTRLLISTVIEW_SETITEMSELECTED ( $HGLVEX_SRCHANDLE , $ALOCATION [ 0 ] , False )
	Local $AEDITED [ 1 ] [ 4 ] = [ [ 0 ] ]
	$HGLVEX_SRCHANDLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ]
	$CGLVEX_SRCID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	$HGLVEX_EDITING = $HGLVEX_SRCHANDLE
	Local $CEDITINGID = $CGLVEX_SRCID
	Local $AKEYS [ 7 ] = [ 9 , 13 , 27 , 37 , 39 , 38 , 40 ]
	Local $FRESET_EDITS = False
	If $IEDITMODE < 0 Then
		$FRESET_EDITS = True
		$IEDITMODE = Abs ( $IEDITMODE )
	EndIf
	Local $IEDITROW = 0 , $IEDITCOL = 0
	If $IEDITMODE Then
		$ASPLIT = StringSplit ( StringFormat ( "%02s" , $IEDITMODE ) , "" )
		$IEDITROW = $ASPLIT [ 1 ]
		$IEDITCOL = $ASPLIT [ 2 ]
	EndIf
	Local $AEDITABLE = $AGLVEX_DATA [ $ILV_INDEX ] [ 7 ]
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 9 ] Then
		$FCLICK_MOVE = True
	EndIf
	Local $TLVPOS = DllStructCreate ( "struct;long X;long Y;endstruct" )
	__GUILISTVIEWEX_GETLVCOORDS ( $HGLVEX_EDITING , $TLVPOS )
	Local $ALVCLIENT = WinGetClientSize ( $HGLVEX_EDITING )
	Local $ALV_FONTDETAILS = __GUILISTVIEWEX_GETLVFONT ( $HGLVEX_EDITING )
	WinSetState ( $HGLVEX_EDITING , "" , @SW_DISABLE )
	Local $AWIDTH = ( $AGLVEX_DATA [ $ILV_INDEX ] [ 14 ] )
	If Not IsArray ( $AWIDTH ) Then Local $AWIDTH [ _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] ) ]
	Local $IWIDTH , $FEXITLOOP , $TMOUSECLICK = DllStructCreate ( $TAGPOINT )
	Local $IOLDMOUSEOPT = Opt ( "MouseCoordMode" , 1 )
	Local $IOLDESC = Opt ( "GUICloseOnESC" , 0 )
	_WINAPI_GETASYNCKEYSTATE ( 1 )
	While _WINAPI_GETASYNCKEYSTATE ( 1 )
		Sleep ( 10 )
	WEnd
	While 1
		$FEDIT = False
		$FCOMBO = False
		$FREAD_ONLY = False
		$FAUTO_DROP = False
		$FDTP = False
		$IEDITTYPE = $AEDITABLE [ 0 ] [ $ALOCATION [ 1 ] ]
		Switch $IEDITTYPE
		Case 0 , 1
			$FEDIT = True
			If $IFORCE Then
				$IEDITTYPE = 1
			EndIf
		Case 2
			$FCOMBO = True
			Local $SCOMBO_DATA = $AEDITABLE [ 1 ] [ $ALOCATION [ 1 ] ]
			$FREAD_ONLY = ( BitAND ( $AEDITABLE [ 2 ] [ $ALOCATION [ 1 ] ] , 1 ) = 1 )
			$FAUTO_DROP = ( BitAND ( $AEDITABLE [ 2 ] [ $ALOCATION [ 1 ] ] , 2 ) = 2 )
		Case 3
			$FDTP = True
			Local $SDTP_DEFAULT = $AEDITABLE [ 1 ] [ $ALOCATION [ 1 ] ]
			If StringRight ( $SDTP_DEFAULT , 1 ) = "#" Then
				$SDTP_DEFAULT = StringTrimRight ( $SDTP_DEFAULT , 1 )
				$FAUTO_DROP = True
			EndIf
			If $SDTP_DEFAULT = Default Then
				$SDTP_DEFAULT = @YEAR & "/" & @MON & "/" & @MDAY
			EndIf
			Local $SDTP_FORMAT = $AEDITABLE [ 2 ] [ $ALOCATION [ 1 ] ]
			If $SDTP_FORMAT = Default Then
				$SDTP_FORMAT = ""
			EndIf
		EndSwitch
		Local $SITEMORGTEXT = _GUICTRLLISTVIEW_GETITEMTEXT ( $HGLVEX_EDITING , $ALOCATION [ 0 ] , $ALOCATION [ 1 ] )
		Local $AEDIT_POS = __GUILISTVIEWEX_EDITCOORDS ( $HGLVEX_EDITING , $CEDITINGID , $ALOCATION , $TLVPOS , $ALVCLIENT [ 0 ] + 4294967291 , $IDELTA_X , $IDELTA_Y )
		$IWIDTH = Number ( $AWIDTH [ $ALOCATION [ 1 ] ] )
		If $IWIDTH > $AEDIT_POS [ 2 ] Then
			If $FREAD_ONLY Then
				If $IWIDTH < 0 Then
					$AEDIT_POS [ 2 ] = Abs ( $IWIDTH )
				EndIf
			Else
				$AEDIT_POS [ 2 ] = Abs ( $IWIDTH )
			EndIf
		EndIf
		Switch $IEDITTYPE
		Case 1
			$CGLVEX_EDITID = GUICtrlCreateInput ( $SITEMORGTEXT , $AEDIT_POS [ 0 ] , $AEDIT_POS [ 1 ] , $AEDIT_POS [ 2 ] , $AEDIT_POS [ 3 ] , 128 )
			$HTEMP_EDIT = GUICtrlGetHandle ( $CGLVEX_EDITID )
			If $AEDITABLE [ 1 ] [ $ALOCATION [ 1 ] ] = 1 Then
				Local $IWRAP = + 4294967295
				If $AEDITABLE [ 2 ] [ $ALOCATION [ 1 ] ] Then
					$ASPLIT = StringSplit ( $AEDITABLE [ 2 ] [ $ALOCATION [ 1 ] ] , "|" )
					If UBound ( $ASPLIT ) = 4 Then
						$IWRAP = ( ( $ASPLIT [ 3 ] = 1 ) ? ( 5 ) : ( + 4294967295 ) )
					EndIf
				EndIf
				$CUPDOWN = GUICtrlCreateUpdown ( $CGLVEX_EDITID , $IWRAP )
				$HUPDOWN = GUICtrlGetHandle ( $CUPDOWN )
				If UBound ( $ASPLIT ) = 4 Then
					GUICtrlSetLimit ( $CUPDOWN , $ASPLIT [ 2 ] , $ASPLIT [ 1 ] )
				EndIf
				_WINAPI_REDRAWWINDOW ( $HUPDOWN )
			EndIf
		Case 2
			If $FREAD_ONLY Then
				$CGLVEX_EDITID = GUICtrlCreateCombo ( "" , $AEDIT_POS [ 0 ] , $AEDIT_POS [ 1 ] , $AEDIT_POS [ 2 ] , $AEDIT_POS [ 3 ] , 2097219 )
				GUICtrlSetData ( $CGLVEX_EDITID , $SCOMBO_DATA , $SITEMORGTEXT )
			Else
				$CGLVEX_EDITID = GUICtrlCreateCombo ( "" , $AEDIT_POS [ 0 ] , $AEDIT_POS [ 1 ] , $AEDIT_POS [ 2 ] , $AEDIT_POS [ 3 ] , 2097218 )
				GUICtrlSetData ( $CGLVEX_EDITID , $SCOMBO_DATA )
			EndIf
			Local $TINFO = DllStructCreate ( "dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" & "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList" )
			Local $IINFO = DllStructGetSize ( $TINFO )
			DllStructSetData ( $TINFO , "Size" , $IINFO )
			Local $HCOMBO = GUICtrlGetHandle ( $CGLVEX_EDITID )
			If $FREAD_ONLY And Abs ( $IWIDTH ) > $AEDIT_POS [ 2 ] Then
				_SENDMESSAGE ( $HCOMBO , 352 , Abs ( $IWIDTH ) )
			EndIf
			_SENDMESSAGE ( $HCOMBO , 356 , 0 , $TINFO , 0 , "wparam" , "struct*" )
			$HTEMP_EDIT = DllStructGetData ( $TINFO , "hEdit" )
			$HTEMP_LIST = DllStructGetData ( $TINFO , "hList" )
			$HTEMP_COMBO = DllStructGetData ( $TINFO , "hCombo" )
		Case 3
			$CGLVEX_EDITID = GUICtrlCreateDate ( $SDTP_DEFAULT , $AEDIT_POS [ 0 ] , $AEDIT_POS [ 1 ] , $AEDIT_POS [ 2 ] , $AEDIT_POS [ 3 ] )
			$HTEMP_EDIT = GUICtrlGetHandle ( $CGLVEX_EDITID )
			If $SDTP_FORMAT Then
				GUICtrlSendMsg ( $CGLVEX_EDITID , 4146 , 0 , $SDTP_FORMAT )
			EndIf
		EndSwitch
		GUICtrlSetFont ( $CGLVEX_EDITID , $ALV_FONTDETAILS [ 0 ] , Default , Default , $ALV_FONTDETAILS [ 1 ] )
		_WINAPI_SETFOCUS ( $HTEMP_EDIT )
		If Not $AGLVEX_DATA [ $ILV_INDEX ] [ 11 ] Then
			GUICtrlSendMsg ( $CGLVEX_EDITID , 177 , 0 , + 4294967295 )
		EndIf
		If $FAUTO_DROP Then
			Switch $IEDITTYPE
			Case 2
				_SENDMESSAGE ( $HCOMBO , 335 , True )
			Case 3
				_SENDMESSAGE ( $HTEMP_EDIT , 513 , 1 , $AEDIT_POS [ 2 ] + 4294967286 )
			EndSwitch
		EndIf
		$AGLVEX_SRCARRAY = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
		$IKEY_CODE = 0
		$FCOMBO_STATE = ( ( $FAUTO_DROP ) ? ( True ) : ( False ) )
		While 1
			$FEXITLOOP = False
			If $AGLVEX_DATA [ 0 ] [ 9 ] Then
				$FEXITLOOP = True
				$AGLVEX_DATA [ 0 ] [ 9 ] = False
			EndIf
			_WINAPI_GETASYNCKEYSTATE ( 1 )
			If _WINAPI_GETASYNCKEYSTATE ( 1 ) Then
				DllStructSetData ( $TMOUSECLICK , "x" , MouseGetPos ( 0 ) )
				DllStructSetData ( $TMOUSECLICK , "y" , MouseGetPos ( 1 ) )
				Switch _WINAPI_WINDOWFROMPOINT ( $TMOUSECLICK )
				Case $HTEMP_COMBO , $HTEMP_EDIT , $HTEMP_LIST , $HUPDOWN
			Case Else
					If Not $FDTP Then
						$FEXITLOOP = True
					EndIf
				EndSwitch
				_WINAPI_GETASYNCKEYSTATE ( 1 )
				While _WINAPI_GETASYNCKEYSTATE ( 1 )
					Sleep ( 10 )
				WEnd
			EndIf
			If $FEXITLOOP Then
				If $FEDIT Then
					If $FCLICK_MOVE Then
						$IKEY_CODE = 2
					Else
						$IKEY_CODE = 1
					EndIf
				EndIf
				ExitLoop
			EndIf
			If $FCOMBO Then
				Switch _SENDMESSAGE ( $HCOMBO , 343 )
				Case 0
					If $FCOMBO_STATE = True Then
						If GUICtrlRead ( $CGLVEX_EDITID ) = "" Then
							$FCOMBO_STATE = False
						Else
							$IKEY_CODE = 13
							ExitLoop
						EndIf
					EndIf
				Case 1
					If Not $FCOMBO_STATE Then
						$FCOMBO_STATE = True
					EndIf
				EndSwitch
			EndIf
			For $I = 0 To 2
				_WINAPI_GETASYNCKEYSTATE ( $AKEYS [ $I ] )
				If _WINAPI_GETASYNCKEYSTATE ( $AKEYS [ $I ] ) Then
					$IKEY_CODE = $AKEYS [ $I ]
					ExitLoop 2
				EndIf
			Next
			For $I = 3 To 6
				_WINAPI_GETASYNCKEYSTATE ( $AKEYS [ $I ] )
				If _WINAPI_GETASYNCKEYSTATE ( $AKEYS [ $I ] ) And _WINAPI_GETASYNCKEYSTATE ( 17 ) Then
					$IKEY_CODE = $AKEYS [ $I ]
					ExitLoop 2
				EndIf
			Next
			If _WINAPI_GETFOCUS ( ) <> $HTEMP_EDIT Then
				ExitLoop
			EndIf
			Sleep ( 10 )
		WEnd
		Switch $IKEY_CODE
		Case 37 , 38 , 39 , 40
			If $FEDIT Then
				ContinueCase
			EndIf
		Case 2 , 9 , 13
			Local $SITEMNEWTEXT = GUICtrlRead ( $CGLVEX_EDITID )
			If $SITEMNEWTEXT <> $SITEMORGTEXT Then
				_GUICTRLLISTVIEW_SETITEMTEXT ( $HGLVEX_EDITING , $ALOCATION [ 0 ] , $SITEMNEWTEXT , $ALOCATION [ 1 ] )
				$AGLVEX_SRCARRAY [ $ALOCATION [ 0 ] + 1 ] [ $ALOCATION [ 1 ] ] = $SITEMNEWTEXT
				$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
				$AEDITED [ 0 ] [ 0 ] += 1
				ReDim $AEDITED [ $AEDITED [ 0 ] [ 0 ] + 1 ] [ 4 ]
				$AEDITED [ $AEDITED [ 0 ] [ 0 ] ] [ 0 ] = $ALOCATION [ 0 ]
				$AEDITED [ $AEDITED [ 0 ] [ 0 ] ] [ 1 ] = $ALOCATION [ 1 ]
				$AEDITED [ $AEDITED [ 0 ] [ 0 ] ] [ 2 ] = $SITEMORGTEXT
				$AEDITED [ $AEDITED [ 0 ] [ 0 ] ] [ 3 ] = $SITEMNEWTEXT
			EndIf
		EndSwitch
		GUICtrlDelete ( $CGLVEX_EDITID )
		GUICtrlDelete ( $CUPDOWN )
		$CGLVEX_EDITID = 9999
		Opt ( "MouseCoordMode" , $IOLDMOUSEOPT )
		If $IEDITMODE = 0 Then
			ExitLoop
		Else
			Switch $IKEY_CODE
			Case 2
				$IKEY_CODE = 1
				ContinueCase
			Case 0 , 1 , 13
				_WINAPI_GETASYNCKEYSTATE ( $IKEY_CODE )
				While _WINAPI_GETASYNCKEYSTATE ( $IKEY_CODE )
					Sleep ( 10 )
				WEnd
				ExitLoop
			Case 27
				If $FRESET_EDITS Then
					For $I = $AEDITED [ 0 ] [ 0 ] To 1 Step + 4294967295
						_GUICTRLLISTVIEW_SETITEMTEXT ( $HGLVEX_EDITING , $AEDITED [ $I ] [ 0 ] , $AEDITED [ $I ] [ 2 ] , $AEDITED [ $I ] [ 1 ] )
						Switch UBound ( $AGLVEX_SRCARRAY , 0 )
						Case 1
							$ASPLIT = StringSplit ( $AGLVEX_SRCARRAY [ $AEDITED [ $I ] [ 0 ] + 1 ] , $AGLVEX_DATA [ 0 ] [ 24 ] )
							$ASPLIT [ $AEDITED [ $I ] [ 1 ] + 1 ] = $AEDITED [ $I ] [ 2 ]
							$SINSERT = ""
							For $J = 1 To $ASPLIT [ 0 ]
								$SINSERT &= $ASPLIT [ $J ] & $AGLVEX_DATA [ 0 ] [ 24 ]
							Next
							$AGLVEX_SRCARRAY [ $AEDITED [ $I ] [ 0 ] + 1 ] = StringTrimRight ( $SINSERT , 1 )
						Case 2
							$AGLVEX_SRCARRAY [ $AEDITED [ $I ] [ 0 ] + 1 ] [ $AEDITED [ $I ] [ 1 ] ] = $AEDITED [ $I ] [ 2 ]
						EndSwitch
					Next
					$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $AGLVEX_SRCARRAY
					Local $AEDITED [ 1 ] [ 4 ] = [ [ 0 ] ]
				EndIf
				_WINAPI_GETASYNCKEYSTATE ( 27 )
				While _WINAPI_GETASYNCKEYSTATE ( 27 )
					Sleep ( 10 )
				WEnd
				ExitLoop
			Case 9 , 39
				While 1
					If $IEDITCOL <> 0 Then
						$ALOCATION [ 1 ] += 1
						If $ALOCATION [ 1 ] = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_EDITING ) Then
							Switch $IEDITCOL
							Case 1
								ExitLoop 2
							Case 2
								$ALOCATION [ 1 ] -= 1
								ExitLoop
							Case 3
								$ALOCATION [ 1 ] = 0
							EndSwitch
						EndIf
						If $AEDITABLE [ 0 ] [ $ALOCATION [ 1 ] ] <> 0 Then
							ExitLoop
						Else
							ExitLoop 2
						EndIf
					Else
						ExitLoop 2
					EndIf
				WEnd
			Case 37
				While 1
					If $IEDITCOL <> 0 Then
						$ALOCATION [ 1 ] -= 1
						If $ALOCATION [ 1 ] < 0 Then
							Switch $IEDITCOL
							Case 1
								ExitLoop 2
							Case 2
								$ALOCATION [ 1 ] += 1
								ExitLoop
							Case 3
								$ALOCATION [ 1 ] = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_EDITING ) + 4294967295
							EndSwitch
						EndIf
						If $AEDITABLE [ 0 ] [ $ALOCATION [ 1 ] ] <> 0 Then
							ExitLoop
						Else
							ExitLoop 2
						EndIf
					Else
						ExitLoop 2
					EndIf
				WEnd
			Case 40
				While 1
					If $IEDITROW <> 0 Then
						$ALOCATION [ 0 ] += 1
						If $ALOCATION [ 0 ] = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_EDITING ) Then
							Switch $IEDITROW
							Case 1
								ExitLoop 2
							Case 2
								$ALOCATION [ 0 ] -= 1
								ExitLoop
							Case 3
								$ALOCATION [ 0 ] = + 4294967295
							EndSwitch
						Else
							ExitLoop
						EndIf
					Else
						ExitLoop 2
					EndIf
				WEnd
			Case 38
				While 1
					If $IEDITROW <> 0 Then
						$ALOCATION [ 0 ] -= 1
						If $ALOCATION [ 0 ] < 0 Then
							Switch $IEDITROW
							Case 1
								ExitLoop 2
							Case 2
								$ALOCATION [ 0 ] += 1
								ExitLoop
							Case 3
								$ALOCATION [ 0 ] = _GUICTRLLISTVIEW_GETITEMCOUNT ( $HGLVEX_EDITING )
							EndSwitch
						Else
							ExitLoop
						EndIf
					Else
						ExitLoop 2
					EndIf
				WEnd
			EndSwitch
			_WINAPI_GETASYNCKEYSTATE ( $IKEY_CODE )
			While _WINAPI_GETASYNCKEYSTATE ( $IKEY_CODE )
				Sleep ( 10 )
			WEnd
		EndIf
	WEnd
	$AGLVEX_SRCARRAY = 0
	WinSetState ( $HGLVEX_EDITING , "" , @SW_ENABLE )
	_GUICTRLLISTVIEW_SETITEMSTATE ( $HGLVEX_EDITING , $ALOCATION [ 0 ] , $LVIS_SELECTED , $LVIS_SELECTED )
	SetExtended ( $IKEY_CODE )
	Opt ( "GUICloseOnESC" , $IOLDESC )
	GUISwitch ( $HPREVCURRGUI )
	_WINAPI_SETFOCUS ( $HGLVEX_EDITING )
	Return $AEDITED
EndFunc
Func __GUILISTVIEWEX_EDITCOORDS ( $HLV_HANDLE , $CLV_CID , $ALOCATION , $TLVPOS , $ILVWIDTH , $IDELTA_X , $IDELTA_Y )
	Local $AEDIT_DATA [ 4 ]
	_GUICTRLLISTVIEW_ENSUREVISIBLE ( $HLV_HANDLE , $ALOCATION [ 0 ] )
	Local $ARECT = _GUICTRLLISTVIEW_GETSUBITEMRECT ( $HLV_HANDLE , $ALOCATION [ 0 ] , $ALOCATION [ 1 ] )
	$AEDIT_DATA [ 3 ] = $ARECT [ 3 ] - $ARECT [ 1 ] + 1
	$AEDIT_DATA [ 2 ] = _GUICTRLLISTVIEW_GETCOLUMNWIDTH ( $HLV_HANDLE , $ALOCATION [ 1 ] )
	If $ARECT [ 0 ] < 0 Or $ARECT [ 2 ] > $ILVWIDTH Then
		_GUICTRLLISTVIEW_SCROLL ( $HLV_HANDLE , $ARECT [ 0 ] , 0 )
		$ARECT = _GUICTRLLISTVIEW_GETSUBITEMRECT ( $HLV_HANDLE , $ALOCATION [ 0 ] , $ALOCATION [ 1 ] )
		If $ARECT [ 0 ] + $AEDIT_DATA [ 2 ] > $ILVWIDTH Then
			$AEDIT_DATA [ 2 ] = $ILVWIDTH - $ARECT [ 0 ]
		EndIf
	EndIf
	If $CLV_CID Then
		$IDELTA_Y += 1
	EndIf
	$AEDIT_DATA [ 0 ] = DllStructGetData ( $TLVPOS , "X" ) + $ARECT [ 0 ] + $IDELTA_X + 2
	$AEDIT_DATA [ 1 ] = DllStructGetData ( $TLVPOS , "Y" ) + $ARECT [ 1 ] + $IDELTA_Y
	Return $AEDIT_DATA
EndFunc
Func __GUILISTVIEWEX_REWRITELV ( $HLVHANDLE , ByRef $ALV_ARRAY , ByRef $ACHECK_ARRAY , $ILV_INDEX , $FCHECKBOX = True , $FRETAINWIDTH = True )
	Local $IVERTSCROLL , $ICOLCOUNT
	Local $ILV_CID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
	If $AGLVEX_DATA [ $ILV_INDEX ] [ 10 ] Then
		$IVERTSCROLL = $AGLVEX_DATA [ $ILV_INDEX ] [ 10 ]
	Else
		Local $ARECT = _GUICTRLLISTVIEW_GETITEMRECT ( $HLVHANDLE , 0 )
		$AGLVEX_DATA [ $ILV_INDEX ] [ 10 ] = $ARECT [ 3 ] - $ARECT [ 1 ]
		If $IVERTSCROLL = 0 Then
			$IVERTSCROLL = 20
		EndIf
	EndIf
	Local $ITOPINDEX_ORG = _GUICTRLLISTVIEW_GETTOPINDEX ( $HLVHANDLE )
	If $FRETAINWIDTH And $ILV_CID Then
		$ICOLCOUNT = _GUICTRLLISTVIEW_GETCOLUMNCOUNT ( $HGLVEX_SRCHANDLE )
		Local $ACOL_WIDTH [ $ICOLCOUNT ]
		For $I = 1 To $ICOLCOUNT + 4294967295
			$ACOL_WIDTH [ $I ] = _GUICTRLLISTVIEW_GETCOLUMNWIDTH ( $HGLVEX_SRCHANDLE , $I )
		Next
	EndIf
	_GUICTRLLISTVIEW_BEGINUPDATE ( $HLVHANDLE )
	_GUICTRLLISTVIEW_DELETEALLITEMS ( $HLVHANDLE )
	If UBound ( $ALV_ARRAY , 2 ) Then
		Local $AARRAY = $ALV_ARRAY
		_ARRAYDELETE ( $AARRAY , 0 )
		Local $CLV_CID = $AGLVEX_DATA [ $ILV_INDEX ] [ 1 ]
		If $CLV_CID Then
			Local $SLINE , $ILASTCOL = UBound ( $AARRAY , 2 ) + 4294967295
			For $I = 0 To UBound ( $AARRAY ) + 4294967295
				$SLINE = ""
				For $J = 0 To $ILASTCOL
					$SLINE &= $AARRAY [ $I ] [ $J ] & $AGLVEX_DATA [ 0 ] [ 24 ]
				Next
				GUICtrlCreateListViewItem ( StringTrimRight ( $SLINE , 1 ) , $CLV_CID )
			Next
		Else
			_GUICTRLLISTVIEW_ADDARRAY ( $HLVHANDLE , $AARRAY )
		EndIf
		For $I = 1 To $ALV_ARRAY [ 0 ] [ 0 ]
			If $FCHECKBOX And $ACHECK_ARRAY [ $I ] Then
				_GUICTRLLISTVIEW_SETITEMCHECKED ( $HLVHANDLE , $I + 4294967295 )
			EndIf
		Next
		Local $ITOPINDEX_CURR = _GUICTRLLISTVIEW_GETTOPINDEX ( $HLVHANDLE )
		While $ITOPINDEX_CURR < $ITOPINDEX_ORG
			_GUICTRLLISTVIEW_SCROLL ( $HLVHANDLE , 0 , $IVERTSCROLL )
			If _GUICTRLLISTVIEW_GETTOPINDEX ( $HLVHANDLE ) = $ITOPINDEX_CURR Then
				ExitLoop
			Else
				$ITOPINDEX_CURR = _GUICTRLLISTVIEW_GETTOPINDEX ( $HLVHANDLE )
			EndIf
		WEnd
	EndIf
	If $FRETAINWIDTH And $ILV_CID Then
		For $I = 1 To $ICOLCOUNT + 4294967295
			$ACOL_WIDTH [ $I ] = _GUICTRLLISTVIEW_SETCOLUMNWIDTH ( $HGLVEX_SRCHANDLE , $I , $ACOL_WIDTH [ $I ] )
		Next
	EndIf
	_GUICTRLLISTVIEW_ENDUPDATE ( $HLVHANDLE )
EndFunc
Func __GUILISTVIEWEX_GETLVCOORDS ( $HLV_HANDLE , ByRef $TLVPOS )
	Local $AWND = DllCall ( "user32.dll" , "hwnd" , "GetParent" , "hwnd" , $HLV_HANDLE )
	Local $HWND = $AWND [ 0 ]
	Local $ALVPOS = WinGetPos ( $HLV_HANDLE )
	DllStructSetData ( $TLVPOS , "X" , $ALVPOS [ 0 ] )
	DllStructSetData ( $TLVPOS , "Y" , $ALVPOS [ 1 ] )
	_WINAPI_SCREENTOCLIENT ( $HWND , $TLVPOS )
EndFunc
Func __GUILISTVIEWEX_GETCURSORWND ( )
	Local $IOLDMOUSEOPT = Opt ( "MouseCoordMode" , 1 )
	Local $TMPOS = DllStructCreate ( "struct;long X;long Y;endstruct" )
	DllStructSetData ( $TMPOS , "X" , MouseGetPos ( 0 ) )
	DllStructSetData ( $TMPOS , "Y" , MouseGetPos ( 1 ) )
	Opt ( "MouseCoordMode" , $IOLDMOUSEOPT )
	Return _WINAPI_WINDOWFROMPOINT ( $TMPOS )
EndFunc
Func __GUILISTVIEWEX_ARRAY_ADD ( ByRef $AVARRAY , $VADD , $FMULTIROW = False , $BCOUNT = True )
	Local $IINDEX_MAX = UBound ( $AVARRAY )
	Local $IADD_DIM
	Switch UBound ( $AVARRAY , 0 )
	Case 1
		If UBound ( $VADD , 0 ) = 2 Or $FMULTIROW Then
			$IADD_DIM = UBound ( $VADD , 1 )
			ReDim $AVARRAY [ $IINDEX_MAX + $IADD_DIM ]
		Else
			ReDim $AVARRAY [ $IINDEX_MAX + 1 ]
		EndIf
	Case 2
		Local $IDIM2 = UBound ( $AVARRAY , 2 )
		If UBound ( $VADD , 0 ) = 2 Then
			$IADD_DIM = UBound ( $VADD , 1 )
			ReDim $AVARRAY [ $IINDEX_MAX + $IADD_DIM ] [ $IDIM2 ]
			$AVARRAY [ 0 ] [ 0 ] += $IADD_DIM
			Local $IADD_MAX = UBound ( $VADD , 2 )
			For $I = 0 To $IADD_DIM + 4294967295
				For $J = 0 To $IDIM2 + 4294967295
					If $J > $IADD_MAX + 4294967295 Then
						$AVARRAY [ $IINDEX_MAX + $I ] [ $J ] = ""
					Else
						$AVARRAY [ $IINDEX_MAX + $I ] [ $J ] = $VADD [ $I ] [ $J ]
					EndIf
				Next
			Next
		ElseIf $FMULTIROW Then
			$IADD_DIM = UBound ( $VADD , 1 )
			ReDim $AVARRAY [ $IINDEX_MAX + $IADD_DIM ] [ $IDIM2 ]
			$AVARRAY [ 0 ] [ 0 ] += $IADD_DIM
			For $I = 0 To $IADD_DIM + 4294967295
				$AVARRAY [ $IINDEX_MAX + $I ] [ 0 ] = $VADD [ $I ]
			Next
		Else
			ReDim $AVARRAY [ $IINDEX_MAX + 1 ] [ $IDIM2 ]
			If $BCOUNT Then
				$AVARRAY [ 0 ] [ 0 ] += 1
			EndIf
			If IsArray ( $VADD ) Then
				Local $VADD_MAX = UBound ( $VADD )
				For $J = 0 To $IDIM2 + 4294967295
					If $J > $VADD_MAX + 4294967295 Then
						$AVARRAY [ $IINDEX_MAX ] [ $J ] = ""
					Else
						$AVARRAY [ $IINDEX_MAX ] [ $J ] = $VADD [ $J ]
					EndIf
				Next
			Else
				For $J = 0 To $IDIM2 + 4294967295
					$AVARRAY [ $IINDEX_MAX ] [ $J ] = $VADD
				Next
			EndIf
		EndIf
	EndSwitch
EndFunc
Func __GUILISTVIEWEX_ARRAY_INSERT ( ByRef $AVARRAY , $IINDEX , $VINSERT , $FMULTIROW = False , $BCOUNT = True )
	Local $IINDEX_MAX = UBound ( $AVARRAY )
	Local $IINSERT_DIM = UBound ( $VINSERT , 1 )
	Switch UBound ( $AVARRAY , 0 )
	Case 1
		If UBound ( $VINSERT , 0 ) = 2 Or $FMULTIROW Then
			ReDim $AVARRAY [ $IINDEX_MAX + $IINSERT_DIM ]
			For $I = $IINDEX_MAX + $IINSERT_DIM + 4294967295 To $IINDEX + 1 Step + 4294967295
				$AVARRAY [ $I ] = $AVARRAY [ $I + 4294967295 ]
			Next
		Else
			ReDim $AVARRAY [ $IINDEX_MAX + 1 ]
			For $I = $IINDEX_MAX To $IINDEX + 1 Step + 4294967295
				$AVARRAY [ $I ] = $AVARRAY [ $I + 4294967295 ]
			Next
			$AVARRAY [ $IINDEX ] = $VINSERT
		EndIf
	Case 2
		If $IINDEX > $IINDEX_MAX + 4294967295 Then
			__GUILISTVIEWEX_ARRAY_ADD ( $AVARRAY , $VINSERT , $FMULTIROW , $BCOUNT )
			Return
		EndIf
		Local $IDIM2 = UBound ( $AVARRAY , 2 )
		If UBound ( $VINSERT , 0 ) = 2 Then
			$IINSERT_DIM = UBound ( $VINSERT , 1 )
			ReDim $AVARRAY [ $IINDEX_MAX + $IINSERT_DIM ] [ $IDIM2 ]
			If $BCOUNT Then
				$AVARRAY [ 0 ] [ 0 ] += $IINSERT_DIM
			EndIf
			For $I = $IINDEX_MAX + $IINSERT_DIM + 4294967295 To $IINDEX + $IINSERT_DIM Step + 4294967295
				For $J = 0 To $IDIM2 + 4294967295
					$AVARRAY [ $I ] [ $J ] = $AVARRAY [ $I - $IINSERT_DIM ] [ $J ]
				Next
			Next
			Local $IINSERT_MAX = UBound ( $VINSERT , 2 )
			For $I = 0 To $IINSERT_DIM + 4294967295
				For $J = 0 To $IDIM2 + 4294967295
					If $J > $IINSERT_MAX + 4294967295 Then
						$AVARRAY [ $IINDEX + $I ] [ $J ] = ""
					Else
						$AVARRAY [ $IINDEX + $I ] [ $J ] = $VINSERT [ $I ] [ $J ]
					EndIf
				Next
			Next
		ElseIf $FMULTIROW Then
			$IINSERT_DIM = UBound ( $VINSERT , 1 )
			ReDim $AVARRAY [ $IINDEX_MAX + $IINSERT_DIM ] [ $IDIM2 ]
			$AVARRAY [ 0 ] [ 0 ] += $IINSERT_DIM
			For $I = $IINDEX_MAX + $IINSERT_DIM + 4294967295 To $IINDEX + $IINSERT_DIM Step + 4294967295
				For $J = 0 To $IDIM2 + 4294967295
					$AVARRAY [ $I ] [ $J ] = $AVARRAY [ $I - $IINSERT_DIM ] [ $J ]
				Next
			Next
			For $I = 0 To $IINSERT_DIM + 4294967295
				$AVARRAY [ $IINDEX + $I ] [ 0 ] = $VINSERT [ $I ]
			Next
		Else
			ReDim $AVARRAY [ $IINDEX_MAX + 1 ] [ $IDIM2 ]
			$AVARRAY [ 0 ] [ 0 ] += 1
			For $I = $IINDEX_MAX To $IINDEX + 1 Step + 4294967295
				For $J = 0 To $IDIM2 + 4294967295
					$AVARRAY [ $I ] [ $J ] = $AVARRAY [ $I + 4294967295 ] [ $J ]
				Next
			Next
			If IsArray ( $VINSERT ) Then
				Local $VINSERT_MAX = UBound ( $VINSERT )
				For $J = 0 To $IDIM2 + 4294967295
					If $J > $VINSERT_MAX + 4294967295 Then
						$AVARRAY [ $IINDEX ] [ $J ] = ""
					Else
						$AVARRAY [ $IINDEX ] [ $J ] = $VINSERT [ $J ]
					EndIf
				Next
			Else
				For $J = 0 To $IDIM2 + 4294967295
					$AVARRAY [ $IINDEX ] [ $J ] = $VINSERT
				Next
			EndIf
		EndIf
	EndSwitch
EndFunc
Func __GUILISTVIEWEX_ARRAY_DELETE ( ByRef $AVARRAY , $IINDEX , $BDELCOUNT = False )
	Local $IINDEX_MAX = UBound ( $AVARRAY )
	If $IINDEX_MAX = 0 Then Return
	If Not $BDELCOUNT Then
		If $IINDEX = 0 Then $IINDEX = 1
	EndIf
	Switch UBound ( $AVARRAY , 0 )
	Case 1
		For $I = $IINDEX To $IINDEX_MAX + 4294967294
			$AVARRAY [ $I ] = $AVARRAY [ $I + 1 ]
		Next
		ReDim $AVARRAY [ $IINDEX_MAX + 4294967295 ]
	Case 2
		Local $IDIM2 = UBound ( $AVARRAY , 2 )
		For $I = $IINDEX To $IINDEX_MAX + 4294967294
			For $J = 0 To $IDIM2 + 4294967295
				$AVARRAY [ $I ] [ $J ] = $AVARRAY [ $I + 1 ] [ $J ]
			Next
		Next
		ReDim $AVARRAY [ $IINDEX_MAX + 4294967295 ] [ $IDIM2 ]
		If Not $BDELCOUNT Then
			$AVARRAY [ 0 ] [ 0 ] -= 1
		EndIf
	EndSwitch
EndFunc
Func __GUILISTVIEWEX_ARRAY_SWAP ( ByRef $AVARRAY , $IINDEX1 , $IINDEX2 )
	Local $VTEMP
	Switch UBound ( $AVARRAY , 0 )
	Case 1
		$VTEMP = $AVARRAY [ $IINDEX1 ]
		$AVARRAY [ $IINDEX1 ] = $AVARRAY [ $IINDEX2 ]
		$AVARRAY [ $IINDEX2 ] = $VTEMP
	Case 2
		Local $IDIM2 = UBound ( $AVARRAY , 2 )
		For $I = 0 To $IDIM2 + 4294967295
			$VTEMP = $AVARRAY [ $IINDEX1 ] [ $I ]
			$AVARRAY [ $IINDEX1 ] [ $I ] = $AVARRAY [ $IINDEX2 ] [ $I ]
			$AVARRAY [ $IINDEX2 ] [ $I ] = $VTEMP
		Next
	EndSwitch
	Return 0
EndFunc
Func __GUILISTVIEWEX_TOOLTIPHIDE ( )
	AdlibUnRegister ( "__GUIListViewEx_ToolTipHide" )
	ToolTip ( "" )
EndFunc
Func __GUILISTVIEWEX_MAKESTRING ( $AARRAY )
	If Not IsArray ( $AARRAY ) Then Return SetError ( 1 , 0 , "" )
	Local $SRET = ""
	Local $SDELIM_COL = @CR
	Local $SDELIM_ROW = @LF
	Switch UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	Case 1
		For $I = 0 To UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
			$SRET &= $AARRAY [ $I ] & $SDELIM_ROW
		Next
		Return StringTrimRight ( $SRET , StringLen ( $SDELIM_COL ) )
	Case 2
		For $I = 0 To UBound ( $AARRAY , $UBOUND_ROWS ) + 4294967295
			For $J = 0 To UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
				$SRET &= $AARRAY [ $I ] [ $J ] & $SDELIM_COL
			Next
			$SRET = StringTrimRight ( $SRET , StringLen ( $SDELIM_COL ) ) & $SDELIM_ROW
		Next
		Return StringTrimRight ( $SRET , StringLen ( $SDELIM_ROW ) )
Case Else
		Return SetError ( 2 , 0 , "" )
	EndSwitch
EndFunc
Func __GUILISTVIEWEX_MAKEARRAY ( $SSTRING )
	If $SSTRING = "" Then Return SetError ( 1 , 0 , "" )
	Local $ARETARRAY , $AROWS , $AITEMS
	Local $SROWDELIMITER = @LF
	Local $SCOLDELIMITER = @CR
	If StringInStr ( $SSTRING , $SCOLDELIMITER ) Then
		$AROWS = StringSplit ( $SSTRING , $SROWDELIMITER )
		StringReplace ( $AROWS [ 1 ] , $SCOLDELIMITER , "" )
		Local $ARETARRAY [ $AROWS [ 0 ] ] [ @extended + 1 ]
		For $I = 1 To $AROWS [ 0 ]
			$AITEMS = StringSplit ( $AROWS [ $I ] , $SCOLDELIMITER )
			For $J = 1 To $AITEMS [ 0 ]
				$ARETARRAY [ $I + 4294967295 ] [ $J + 4294967295 ] = $AITEMS [ $J ]
			Next
		Next
	Else
		$ARETARRAY = StringSplit ( $SSTRING , $SROWDELIMITER , $STR_NOCOUNT )
	EndIf
	Return $ARETARRAY
EndFunc
Func __GUILISTVIEWEX_COLSORT ( $HLV , $ILV_INDEX , ByRef $VSORTSENSE , $ICOL , $HUSERSORTFUNCTION = 0 , $BTOGGLESENSE = True )
	Local $ALISTVIEWCONTENT = $AGLVEX_DATA [ $ILV_INDEX ] [ 2 ]
	Local $ACOLOURSETTINGS = $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ]
	Local $IITEMCOUNT = $ALISTVIEWCONTENT [ 0 ] [ 0 ]
	If $IITEMCOUNT Then
		Local $IDESCENDING = 0
		If UBound ( $VSORTSENSE ) Then
			$IDESCENDING = $VSORTSENSE [ $ICOL ]
		Else
			$IDESCENDING = $VSORTSENSE
		EndIf
		Local $ICOLUMNCOUNT = UBound ( $ALISTVIEWCONTENT , 2 )
		Local $FCOLOURENABLED = ( ( IsArray ( $AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] ) ) ? ( True ) : ( False ) )
		If $FCOLOURENABLED Then
			ReDim $ALISTVIEWCONTENT [ UBound ( $ALISTVIEWCONTENT ) ] [ ( $ICOLUMNCOUNT * 2 ) + 2 ]
			For $I = 1 To $IITEMCOUNT
				For $J = 0 To $ICOLUMNCOUNT + 4294967295
					$ALISTVIEWCONTENT [ $I ] [ $ICOLUMNCOUNT + $J + 2 ] = $ACOLOURSETTINGS [ $I ] [ $J ]
				Next
			Next
		Else
			ReDim $ALISTVIEWCONTENT [ UBound ( $ALISTVIEWCONTENT ) ] [ $ICOLUMNCOUNT + 2 ]
		EndIf
		Local Enum $IINDEXVALUE = $ICOLUMNCOUNT , $IITEMPARAM
		Local $SSELECTEDITEMS = _GUICTRLLISTVIEW_GETSELECTEDINDICES ( $HLV )
		Local $ASELECTEDITEMS
		If $SSELECTEDITEMS = "" Then
			Local $ASELECTEDITEMS [ 2 ] = [ 1 , $AGLVEX_DATA [ 0 ] [ 17 ] ]
		Else
			$ASELECTEDITEMS = StringSplit ( $SSELECTEDITEMS , Opt ( "GUIDataSeparatorChar" ) )
		EndIf
		Local $ACHECKEDITEMS [ $IITEMCOUNT + 1 ] = [ 0 ]
		For $I = 0 To $IITEMCOUNT + 4294967295
			If _GUICTRLLISTVIEW_GETITEMCHECKED ( $HLV , $I ) Then
				$ACHECKEDITEMS [ 0 ] += 1
				$ACHECKEDITEMS [ $ACHECKEDITEMS [ 0 ] ] = $I
			EndIf
		Next
		ReDim $ACHECKEDITEMS [ $ACHECKEDITEMS [ 0 ] + 1 ]
		Local $IFOCUSED = + 4294967295
		For $I = 0 To $IITEMCOUNT + 4294967295
			If $IFOCUSED = + 4294967295 Then
				If _GUICTRLLISTVIEW_GETITEMFOCUSED ( $HLV , $I ) Then $IFOCUSED = $I
			EndIf
			_GUICTRLLISTVIEW_SETITEMSELECTED ( $HLV , $I , False )
			_GUICTRLLISTVIEW_SETITEMCHECKED ( $HLV , $I , False )
			$ALISTVIEWCONTENT [ $I + 1 ] [ $IINDEXVALUE ] = $I
			$ALISTVIEWCONTENT [ $I + 1 ] [ $IITEMPARAM ] = _GUICTRLLISTVIEW_GETITEMPARAM ( $HLV , $I )
		Next
		If IsFunc ( $HUSERSORTFUNCTION ) Then
			$HUSERSORTFUNCTION ( $ALISTVIEWCONTENT , $IDESCENDING , 1 , 0 , $ICOL )
		ElseIf $HUSERSORTFUNCTION = + 4294967295 Then
		Else
			_ARRAYSORT ( $ALISTVIEWCONTENT , $IDESCENDING , 1 , 0 , $ICOL )
		EndIf
		For $I = 1 To $IITEMCOUNT
			For $J = 0 To $ICOLUMNCOUNT + 4294967295
				_GUICTRLLISTVIEW_SETITEMTEXT ( $HLV , $I + 4294967295 , $ALISTVIEWCONTENT [ $I ] [ $J ] , $J )
				If $FCOLOURENABLED Then
					$ACOLOURSETTINGS [ $I ] [ $J ] = $ALISTVIEWCONTENT [ $I ] [ $ICOLUMNCOUNT + $J + 2 ]
				EndIf
			Next
			_GUICTRLLISTVIEW_SETITEMPARAM ( $HLV , $I + 4294967295 , $ALISTVIEWCONTENT [ $I ] [ $IITEMPARAM ] )
			For $J = 1 To $ASELECTEDITEMS [ 0 ]
				If $ALISTVIEWCONTENT [ $I ] [ $IINDEXVALUE ] = $ASELECTEDITEMS [ $J ] Then
					$AGLVEX_DATA [ 0 ] [ 17 ] = $I + 4294967295
					$AGLVEX_DATA [ $ILV_INDEX ] [ 20 ] = $I + 4294967295
					If Not ( $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] ) Then
						If $ALISTVIEWCONTENT [ $I + 4294967295 ] [ $IINDEXVALUE ] = $IFOCUSED Then
							_GUICTRLLISTVIEW_SETITEMSELECTED ( $HLV , $I + 4294967295 , True , True )
						Else
							_GUICTRLLISTVIEW_SETITEMSELECTED ( $HLV , $I + 4294967295 , True )
						EndIf
						ExitLoop
					EndIf
				EndIf
			Next
			For $J = 1 To $ACHECKEDITEMS [ 0 ]
				If $ALISTVIEWCONTENT [ $I ] [ $IINDEXVALUE ] = $ACHECKEDITEMS [ $J ] Then
					_GUICTRLLISTVIEW_SETITEMCHECKED ( $HLV , $I + 4294967295 , True )
					ExitLoop
				EndIf
			Next
		Next
		If $BTOGGLESENSE Then
			If UBound ( $VSORTSENSE ) Then
				$VSORTSENSE [ $ICOL ] = Not $IDESCENDING
			Else
				$VSORTSENSE = Not $IDESCENDING
			EndIf
		EndIf
		ReDim $ALISTVIEWCONTENT [ UBound ( $ALISTVIEWCONTENT ) ] [ $ICOLUMNCOUNT ]
		$AGLVEX_DATA [ $ILV_INDEX ] [ 2 ] = $ALISTVIEWCONTENT
		$AGLVEX_DATA [ $ILV_INDEX ] [ 18 ] = $ACOLOURSETTINGS
		$AGLVEX_DATA [ 0 ] [ 19 ] = $ILV_INDEX
		$AGLVEX_DATA [ 0 ] [ 22 ] = 1
	EndIf
EndFunc
Func __GUILISTVIEWEX_REDRAWWINDOW ( $ILV_INDEX , $FFORCE = False )
	If $FFORCE Or $AGLVEX_DATA [ $ILV_INDEX ] [ 19 ] Or $AGLVEX_DATA [ $ILV_INDEX ] [ 22 ] Then
		$AGLVEX_DATA [ 0 ] [ 14 ] = 0
		If $AGLVEX_DATA [ 0 ] [ 15 ] Then
			_WINAPI_REDRAWWINDOW ( $AGLVEX_DATA [ $ILV_INDEX ] [ 0 ] )
		EndIf
	EndIf
EndFunc
Func __GUILISTVIEWEX_CHECKUSEREDITKEY ( )
	Local $AKEY = StringSplit ( $AGLVEX_DATA [ 0 ] [ 23 ] , ";" ) , $IKEYVALUE
	Local $FCHECK = True
	For $I = 1 To $AKEY [ 0 ]
		$IKEYVALUE = Dec ( $AKEY [ $I ] )
		If Not _WINAPI_GETASYNCKEYSTATE ( $IKEYVALUE ) Then
			$FCHECK = False
			ExitLoop
		EndIf
	Next
	Return $FCHECK
EndFunc
Global Const $__DLG_WM_USER = 1024
Global Const $BIF_BROWSEFILEJUNCTIONS = 65536
Global Const $BIF_BROWSEFORCOMPUTER = 4096
Global Const $BIF_BROWSEFORPRINTER = 8192
Global Const $BIF_BROWSEINCLUDEFILES = 16384
Global Const $BIF_BROWSEINCLUDEURLS = 128
Global Const $BIF_DONTGOBELOWDOMAIN = 2
Global Const $BIF_EDITBOX = 16
Global Const $BIF_NEWDIALOGSTYLE = 64
Global Const $BIF_NONEWFOLDERBUTTON = 512
Global Const $BIF_NOTRANSLATETARGETS = 1024
Global Const $BIF_RETURNFSANCESTORS = 8
Global Const $BIF_RETURNONLYFSDIRS = 1
Global Const $BIF_SHAREABLE = 32768
Global Const $BIF_STATUSTEXT = 4
Global Const $BIF_USENEWUI = BitOR ( $BIF_EDITBOX , $BIF_NEWDIALOGSTYLE )
Global Const $BIF_UAHINT = 256
Global Const $BIF_VALIDATE = 32
Global Const $BFFM_INITIALIZED = 1
Global Const $BFFM_IUNKNOWN = 5
Global Const $BFFM_SELCHANGED = 2
Global Const $BFFM_VALIDATEFAILED = 4
Global Const $BFFM_SETSTATUSTEXTA = $__DLG_WM_USER + 100
Global Const $BFFM_ENABLEOK = $__DLG_WM_USER + 101
Global Const $BFFM_SETSELECTIONA = $__DLG_WM_USER + 102
Global Const $BFFM_SETSELECTIONW = $__DLG_WM_USER + 103
Global Const $BFFM_SETSTATUSTEXTW = $__DLG_WM_USER + 104
Global Const $BFFM_SETOKTEXT = $__DLG_WM_USER + 105
Global Const $BFFM_SETEXPANDED = $__DLG_WM_USER + 106
Global Const $CDERR_DIALOGFAILURE = 65535
Global Const $CDERR_FINDRESFAILURE = 6
Global Const $CDERR_INITIALIZATION = 2
Global Const $CDERR_LOADRESFAILURE = 7
Global Const $CDERR_LOADSTRFAILURE = 5
Global Const $CDERR_LOCKRESFAILURE = 8
Global Const $CDERR_MEMALLOCFAILURE = 9
Global Const $CDERR_MEMLOCKFAILURE = 10
Global Const $CDERR_NOHINSTANCE = 4
Global Const $CDERR_NOHOOK = 11
Global Const $CDERR_NOTEMPLATE = 3
Global Const $CDERR_REGISTERMSGFAIL = 12
Global Const $CDERR_STRUCTSIZE = 1
Global Const $PDERR_CREATEICFAILURE = 4106
Global Const $PDERR_DEFAULTDIFFERENT = 4108
Global Const $PDERR_DNDMMISMATCH = 4105
Global Const $PDERR_GETDEVMODEFAIL = 4101
Global Const $PDERR_INITFAILURE = 4102
Global Const $PDERR_LOADDRVFAILURE = 4100
Global Const $PDERR_NODEFAULTPRN = 4104
Global Const $PDERR_NODEVICES = 4103
Global Const $PDERR_PARSEFAILURE = 4098
Global Const $PDERR_PRINTERNOTFOUND = 4107
Global Const $PDERR_RETDEFFAILURE = 4099
Global Const $PDERR_SETUPFAILURE = 4097
Global Const $CFERR_MAXLESSTHANMIN = 8194
Global Const $CFERR_NOFONTS = 8193
Global Const $FNERR_BUFFERTOOSMALL = 12291
Global Const $FNERR_INVALIDFILENAME = 12290
Global Const $FNERR_SUBCLASSFAILURE = 12289
Global Const $FRERR_BUFFERLENGTHZERO = 16385
Global Const $FR_DIALOGTERM = 64
Global Const $FR_DOWN = 1
Global Const $FR_ENABLEHOOK = 256
Global Const $FR_ENABLETEMPLATE = 512
Global Const $FR_ENABLETEMPLATEHANDLE = 8192
Global Const $FR_FINDNEXT = 8
Global Const $FR_HIDEUPDOWN = 16384
Global Const $FR_HIDEMATCHCASE = 32768
Global Const $FR_HIDEWHOLEWORD = 65536
Global Const $FR_MATCHCASE = 4
Global Const $FR_NOMATCHCASE = 2048
Global Const $FR_NOUPDOWN = 1024
Global Const $FR_NOWHOLEWORD = 4096
Global Const $FR_REPLACE = 16
Global Const $FR_REPLACEALL = 32
Global Const $FR_SHOWHELP = 128
Global Const $FR_WHOLEWORD = 2
Global Const $SHFMT_ID_DEFAULT = 65535
Global Const $SHFMT_OPT_FULL = 0
Global Const $SHFMT_OPT_QUICKFORMAT = 1
Global Const $SHFMT_OPT_SYSONLY = 2
Global Const $SHFMT_ERROR = + 4294967295
Global Const $SHFMT_CANCEL = + 4294967294
Global Const $SHFMT_NOFORMAT = + 4294967293
Global Const $CDM_FIRST = $__DLG_WM_USER + 100
Global Const $CDM_GETSPEC = $CDM_FIRST
Global Const $CDM_GETFILEPATH = $CDM_FIRST + 1
Global Const $CDM_GETFOLDERPATH = $CDM_FIRST + 2
Global Const $CDM_GETFOLDERIDLIST = $CDM_FIRST + 3
Global Const $CDM_SETCONTROLTEXT = $CDM_FIRST + 4
Global Const $CDM_HIDECONTROL = $CDM_FIRST + 5
Global Const $CDM_SETDEFEXT = $CDM_FIRST + 6
Global Const $CDM_LAST = $__DLG_WM_USER + 200
Global Const $CDN_FIRST = + 4294966695
Global Const $CDN_INITDONE = $CDN_FIRST
Global Const $CDN_SELCHANGE = $CDN_FIRST + 4294967295
Global Const $CDN_FOLDERCHANGE = $CDN_FIRST + 4294967294
Global Const $CDN_SHAREVIOLATION = $CDN_FIRST + 4294967293
Global Const $CDN_HELP = $CDN_FIRST + 4294967292
Global Const $CDN_FILEOK = $CDN_FIRST + 4294967291
Global Const $CDN_TYPECHANGE = $CDN_FIRST + 4294967290
Global Const $CDN_INCLUDEITEM = $CDN_FIRST + 4294967289
Global Const $CDN_LAST = + 4294966597
Global Const $PSD_DEFAULTMINMARGINS = 0
Global Const $PSD_DISABLEMARGINS = 16
Global Const $PSD_DISABLEORIENTATION = 256
Global Const $PSD_DISABLEPAGEPAINTING = 524288
Global Const $PSD_DISABLEPAPER = 512
Global Const $PSD_DISABLEPRINTER = 32
Global Const $PSD_ENABLEPAGEPAINTHOOK = 262144
Global Const $PSD_ENABLEPAGESETUPHOOK = 8192
Global Const $PSD_ENABLEPAGESETUPTEMPLATE = 32768
Global Const $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072
Global Const $PSD_INHUNDREDTHSOFMILLIMETERS = 8
Global Const $PSD_INTHOUSANDTHSOFINCHES = 4
Global Const $PSD_MARGINS = 2
Global Const $PSD_MINMARGINS = 1
Global Const $PSD_NONETWORKBUTTON = 2097152
Global Const $PSD_NOWARNING = 128
Global Const $PSD_RETURNDEFAULT = 1024
Global Const $PSD_SHOWHELP = 2048
Global Const $WM_PSD_PAGESETUPDLG = $__DLG_WM_USER
Global Const $WM_PSD_FULLPAGERECT = $__DLG_WM_USER + 1
Global Const $WM_PSD_MINMARGINRECT = $__DLG_WM_USER + 2
Global Const $WM_PSD_MARGINRECT = $__DLG_WM_USER + 3
Global Const $WM_PSD_GREEKTEXTRECT = $__DLG_WM_USER + 4
Global Const $WM_PSD_ENVSTAMPRECT = $__DLG_WM_USER + 5
Global Const $WM_PSD_YAFULLPAGERECT = $__DLG_WM_USER + 6
Global Const $PD_ALLPAGES = 0
Global Const $PD_COLLATE = 16
Global Const $PD_CURRENTPAGE = 4194304
Global Const $PD_DISABLEPRINTTOFILE = 524288
Global Const $PD_ENABLEPRINTHOOK = 4096
Global Const $PD_ENABLEPRINTTEMPLATE = 16384
Global Const $PD_ENABLEPRINTTEMPLATEHANDLE = 65536
Global Const $PD_ENABLESETUPHOOK = 8192
Global Const $PD_ENABLESETUPTEMPLATE = 32768
Global Const $PD_ENABLESETUPTEMPLATEHANDLE = 131072
Global Const $PD_EXCLUSIONFLAGS = 16777216
Global Const $PD_HIDEPRINTTOFILE = 1048576
Global Const $PD_NOCURRENTPAGE = 8388608
Global Const $PD_NONETWORKBUTTON = 2097152
Global Const $PD_NOPAGENUMS = 8
Global Const $PD_NOSELECTION = 4
Global Const $PD_NOWARNING = 128
Global Const $PD_PAGENUMS = 2
Global Const $PD_PRINTSETUP = 64
Global Const $PD_PRINTTOFILE = 32
Global Const $PD_RETURNDC = 256
Global Const $PD_RETURNDEFAULT = 1024
Global Const $PD_RETURNIC = 512
Global Const $PD_SELECTION = 1
Global Const $PD_SHOWHELP = 2048
Global Const $PD_USEDEVMODECOPIES = 262144
Global Const $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
Global Const $PD_USELARGETEMPLATE = 268435456
Global Const $PD_RESULT_APPLY = 2
Global Const $PD_RESULT_CANCEL = 0
Global Const $PD_RESULT_PRINT = 1
Global Const $EWX_LOGOFF = 0
Global Const $EWX_POWEROFF = 8
Global Const $EWX_REBOOT = 2
Global Const $EWX_SHUTDOWN = 1
Global Const $EWX_FORCE = 4
Global Const $EWX_FORCEIFHUNG = 16
Global Const $OAIF_ALLOW_REGISTRATION = 1
Global Const $OAIF_REGISTER_EXT = 2
Global Const $OAIF_EXEC = 4
Global Const $OAIF_FORCE_REGISTRATION = 8
Global Const $OAIF_HIDE_REGISTRATION = 32
Global Const $OAIF_URL_PROTOCOL = 64
Global Const $CREDUI_FLAGS_ALWAYS_SHOW_UI = 128
Global Const $CREDUI_FLAGS_COMPLETE_USERNAME = 2048
Global Const $CREDUI_FLAGS_DO_NOT_PERSIST = 2
Global Const $CREDUI_FLAGS_EXCLUDE_CERTIFICATES = 8
Global Const $CREDUI_FLAGS_EXPECT_CONFIRMATION = 131072
Global Const $CREDUI_FLAGS_GENERIC_CREDENTIALS = 262144
Global Const $CREDUI_FLAGS_INCORRECT_PASSWORD = 1
Global Const $CREDUI_FLAGS_KEEP_USERNAME = 1048576
Global Const $CREDUI_FLAGS_PASSWORD_ONLY_OK = 512
Global Const $CREDUI_FLAGS_PERSIST = 4096
Global Const $CREDUI_FLAGS_REQUEST_ADMINISTRATOR = 4
Global Const $CREDUI_FLAGS_REQUIRE_CERTIFICATE = 16
Global Const $CREDUI_FLAGS_REQUIRE_SMARTCARD = 256
Global Const $CREDUI_FLAGS_SERVER_CREDENTIAL = 16384
Global Const $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = 64
Global Const $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = 524288
Global Const $CREDUI_FLAGS_VALIDATE_USERNAME = 1024
Global Const $CREDUIWIN_AUTHPACKAGE_ONLY = 16
Global Const $CREDUIWIN_CHECKBOX = 2
Global Const $CREDUIWIN_ENUMERATE_ADMINS = 256
Global Const $CREDUIWIN_ENUMERATE_CURRENT_USER = 512
Global Const $CREDUIWIN_GENERIC = 1
Global Const $CREDUIWIN_IN_CRED_ONLY = 32
Global Const $CREDUIWIN_SECURE_PROMPT = 4096
Global Const $CREDUIWIN_PACK_32_WOW = 268435456
Global Const $CREDUIWIN_PREPROMPTING = 8192
Global Const $DLLVER_PLATFORM_WINDOWS = 1
Global Const $DLLVER_PLATFORM_NT = 2
Global Const $SHCNE_ALLEVENTS = 2147483647
Global Const $SHCNE_ASSOCCHANGED = 134217728
Global Const $SHCNE_ATTRIBUTES = 2048
Global Const $SHCNE_CREATE = 2
Global Const $SHCNE_DELETE = 4
Global Const $SHCNE_DRIVEADD = 256
Global Const $SHCNE_DRIVEADDGUI = 65536
Global Const $SHCNE_DRIVEREMOVED = 128
Global Const $SHCNE_EXTENDED_EVENT = 67108864
Global Const $SHCNE_FREESPACE = 262144
Global Const $SHCNE_MEDIAINSERTED = 32
Global Const $SHCNE_MEDIAREMOVED = 64
Global Const $SHCNE_MKDIR = 8
Global Const $SHCNE_NETSHARE = 512
Global Const $SHCNE_NETUNSHARE = 1024
Global Const $SHCNE_RENAMEFOLDER = 131072
Global Const $SHCNE_RENAMEITEM = 1
Global Const $SHCNE_RMDIR = 16
Global Const $SHCNE_SERVERDISCONNECT = 16384
Global Const $SHCNE_UPDATEDIR = 4096
Global Const $SHCNE_UPDATEIMAGE = 32768
Global Const $SHCNE_UPDATEITEM = 8192
Global Const $SHCNE_DISKEVENTS = 145439
Global Const $SHCNE_GLOBALEVENTS = 201687520
Global Const $SHCNE_INTERRUPT = 2147483648
Global Const $SHCNF_DWORD = 3
Global Const $SHCNF_IDLIST = 0
Global Const $SHCNF_PATH = 1
Global Const $SHCNF_PRINTER = 2
Global Const $SHCNF_FLUSH = 4096
Global Const $SHCNF_FLUSHNOWAIT = 8192
Global Const $SHCNF_NOTIFYRECURSIVE = 65536
Global Const $SHCNRF_INTERRUPTLEVEL = 1
Global Const $SHCNRF_SHELLLEVEL = 2
Global Const $SHCNRF_RECURSIVEINTERRUPT = 4096
Global Const $SHCNRF_NEWDELIVERY = 32768
Global Const $SHERB_NOCONFIRMATION = 1
Global Const $SHERB_NOPROGRESSUI = 2
Global Const $SHERB_NOSOUND = 4
Global Const $SHERB_NO_UI = BitOR ( $SHERB_NOCONFIRMATION , $SHERB_NOPROGRESSUI , $SHERB_NOSOUND )
Global Const $SEE_MASK_DEFAULT = 0
Global Const $SEE_MASK_CLASSNAME = 1
Global Const $SEE_MASK_CLASSKEY = 3
Global Const $SEE_MASK_IDLIST = 4
Global Const $SEE_MASK_INVOKEIDLIST = 12
Global Const $SEE_MASK_ICON = 16
Global Const $SEE_MASK_HOTKEY = 32
Global Const $SEE_MASK_NOCLOSEPROCESS = 64
Global Const $SEE_MASK_CONNECTNETDRV = 128
Global Const $SEE_MASK_NOASYNC = 256
Global Const $SEE_MASK_FLAG_DDEWAIT = $SEE_MASK_NOASYNC
Global Const $SEE_MASK_DOENVSUBST = 512
Global Const $SEE_MASK_FLAG_NO_UI = 1024
Global Const $SEE_MASK_UNICODE = 16384
Global Const $SEE_MASK_NO_CONSOLE = 32768
Global Const $SEE_MASK_ASYNCOK = 1048576
Global Const $SEE_MASK_NOQUERYCLASSSTORE = 16777216
Global Const $SEE_MASK_HMONITOR = 2097152
Global Const $SEE_MASK_NOZONECHECKS = 8388608
Global Const $SEE_MASK_WAITFORINPUTIDLE = 33554432
Global Const $SEE_MASK_FLAG_LOG_USAGE = 67108864
Global Const $SE_ERR_ACCESSDENIED = 5
Global Const $SE_ERR_ASSOCINCOMPLETE = 27
Global Const $SE_ERR_DDEBUSY = 30
Global Const $SE_ERR_DDEFAIL = 29
Global Const $SE_ERR_DDETIMEOUT = 28
Global Const $SE_ERR_DLLNOTFOUND = 32
Global Const $SE_ERR_FNF = 2
Global Const $SE_ERR_NOASSOC = 31
Global Const $SE_ERR_OOM = 8
Global Const $SE_ERR_PNF = 3
Global Const $SE_ERR_SHARE = 26
Global Const $FO_COPY = 2
Global Const $FO_DELETE = 3
Global Const $FO_MOVE = 1
Global Const $FO_RENAME = 4
Global Const $FOF_ALLOWUNDO = 64
Global Const $FOF_CONFIRMMOUSE = 2
Global Const $FOF_FILESONLY = 128
Global Const $FOF_MULTIDESTFILES = 1
Global Const $FOF_NOCONFIRMATION = 16
Global Const $FOF_NOCONFIRMMKDIR = 512
Global Const $FOF_NO_CONNECTED_ELEMENTS = 8192
Global Const $FOF_NOCOPYSECURITYATTRIBS = 2048
Global Const $FOF_NOERRORUI = 1024
Global Const $FOF_NORECURSEREPARSE = 32768
Global Const $FOF_NORECURSION = 4096
Global Const $FOF_RENAMEONCOLLISION = 8
Global Const $FOF_SILENT = 4
Global Const $FOF_SIMPLEPROGRESS = 256
Global Const $FOF_WANTMAPPINGHANDLE = 32
Global Const $FOF_WANTNUKEWARNING = 16384
Global Const $FOF_NO_UI = BitOR ( $FOF_NOCONFIRMATION , $FOF_NOCONFIRMMKDIR , $FOF_NOERRORUI , $FOF_SILENT )
Global Const $SHGFI_ADDOVERLAYS = 32
Global Const $SHGFI_ATTR_SPECIFIED = 131072
Global Const $SHGFI_ATTRIBUTES = 2048
Global Const $SHGFI_DISPLAYNAME = 512
Global Const $SHGFI_EXETYPE = 8192
Global Const $SHGFI_ICON = 256
Global Const $SHGFI_ICONLOCATION = 4096
Global Const $SHGFI_LARGEICON = 0
Global Const $SHGFI_LINKOVERLAY = 32768
Global Const $SHGFI_OPENICON = 2
Global Const $SHGFI_OVERLAYINDEX = 64
Global Const $SHGFI_PIDL = 8
Global Const $SHGFI_SELECTED = 65536
Global Const $SHGFI_SHELLICONSIZE = 4
Global Const $SHGFI_SMALLICON = 1
Global Const $SHGFI_SYSICONINDEX = 16384
Global Const $SHGFI_TYPENAME = 1024
Global Const $SHGFI_USEFILEATTRIBUTES = 16
Global Const $SFGAO_CANCOPY = 1
Global Const $SFGAO_CANMOVE = 2
Global Const $SFGAO_CANLINK = 4
Global Const $SFGAO_STORAGE = 8
Global Const $SFGAO_CANRENAME = 16
Global Const $SFGAO_CANDELETE = 32
Global Const $SFGAO_HASPROPSHEET = 64
Global Const $SFGAO_DROPTARGET = 256
Global Const $SFGAO_CAPABILITYMASK = BitOR ( $SFGAO_CANCOPY , $SFGAO_CANMOVE , $SFGAO_CANLINK , $SFGAO_CANRENAME , $SFGAO_CANDELETE , $SFGAO_HASPROPSHEET , $SFGAO_DROPTARGET )
Global Const $SFGAO_SYSTEM = 4096
Global Const $SFGAO_ENCRYPTED = 8192
Global Const $SFGAO_ISSLOW = 16384
Global Const $SFGAO_GHOSTED = 32768
Global Const $SFGAO_LINK = 65536
Global Const $SFGAO_SHARE = 131072
Global Const $SFGAO_READONLY = 262144
Global Const $SFGAO_HIDDEN = 524288
Global Const $SFGAO_DISPLAYATTRMASK = BitOR ( $SFGAO_ISSLOW , $SFGAO_GHOSTED , $SFGAO_LINK , $SFGAO_SHARE , $SFGAO_READONLY , $SFGAO_HIDDEN )
Global Const $SFGAO_NONENUMERATED = 1048576
Global Const $SFGAO_NEWCONTENT = 2097152
Global Const $SFGAO_STREAM = 4194304
Global Const $SFGAO_STORAGEANCESTOR = 8388608
Global Const $SFGAO_VALIDATE = 16777216
Global Const $SFGAO_REMOVABLE = 33554432
Global Const $SFGAO_COMPRESSED = 67108864
Global Const $SFGAO_BROWSABLE = 134217728
Global Const $SFGAO_FILESYSANCESTOR = 268435456
Global Const $SFGAO_FOLDER = 536870912
Global Const $SFGAO_FILESYSTEM = 1073741824
Global Const $SFGAO_STORAGECAPMASK = BitOR ( $SFGAO_STORAGE , $SFGAO_LINK , $SFGAO_READONLY , $SFGAO_STREAM , $SFGAO_STORAGEANCESTOR , $SFGAO_FILESYSANCESTOR , $SFGAO_FOLDER , $SFGAO_FILESYSTEM )
Global Const $SFGAO_HASSUBFOLDER = 2147483648
Global Const $SFGAO_CONTENTSMASK = $SFGAO_HASSUBFOLDER
Global Const $SFGAO_PKEYSFGAOMASK = BitOR ( $SFGAO_ISSLOW , $SFGAO_READONLY , $SFGAO_HASSUBFOLDER , $SFGAO_VALIDATE )
Global Const $IDO_SHGIOI_DEFAULT = 268435452
Global Const $IDO_SHGIOI_LINK = 268435454
Global Const $IDO_SHGIOI_SHARE = 268435455
Global Const $IDO_SHGIOI_SLOWFILE = 268435453
Global Const $FCSM_VIEWID = 1
Global Const $FCSM_WEBVIEWTEMPLATE = 2
Global Const $FCSM_INFOTIP = 4
Global Const $FCSM_CLSID = 8
Global Const $FCSM_ICONFILE = 16
Global Const $FCSM_LOGO = 32
Global Const $FCSM_FLAGS = 64
Global Const $FCS_READ = 1
Global Const $FCS_FORCEWRITE = 2
Global Const $FCS_WRITE = BitOR ( $FCS_READ , $FCS_FORCEWRITE )
Global Const $SSF_AUTOCHECKSELECT = 8388608
Global Const $SSF_DESKTOPHTML = 512
Global Const $SSF_DONTPRETTYPATH = 2048
Global Const $SSF_DOUBLECLICKINWEBVIEW = 128
Global Const $SSF_HIDEICONS = 16384
Global Const $SSF_ICONSONLY = 16777216
Global Const $SSF_MAPNETDRVBUTTON = 4096
Global Const $SSF_NOCONFIRMRECYCLE = 32768
Global Const $SSF_NONETCRAWLING = 1048576
Global Const $SSF_SEPPROCESS = 524288
Global Const $SSF_SHOWALLOBJECTS = 1
Global Const $SSF_SHOWCOMPCOLOR = 8
Global Const $SSF_SHOWEXTENSIONS = 2
Global Const $SSF_SHOWINFOTIP = 8192
Global Const $SSF_SHOWSUPERHIDDEN = 262144
Global Const $SSF_SHOWSYSFILES = 32
Global Const $SSF_SHOWTYPEOVERLAY = 33554432
Global Const $SSF_STARTPANELON = 2097152
Global Const $SSF_WIN95CLASSIC = 1024
Global Const $SSF_WEBVIEW = 131072
Global Const $CSIDL_ADMINTOOLS = 48
Global Const $CSIDL_ALTSTARTUP = 29
Global Const $CSIDL_APPDATA = 26
Global Const $CSIDL_BITBUCKET = 10
Global Const $CSIDL_CDBURN_AREA = 59
Global Const $CSIDL_COMMON_ADMINTOOLS = 47
Global Const $CSIDL_COMMON_ALTSTARTUP = 30
Global Const $CSIDL_COMMON_APPDATA = 35
Global Const $CSIDL_COMMON_DESKTOPDIRECTORY = 25
Global Const $CSIDL_COMMON_DOCUMENTS = 46
Global Const $CSIDL_COMMON_FAVORITES = 31
Global Const $CSIDL_COMMON_MUSIC = 53
Global Const $CSIDL_COMMON_PICTURES = 54
Global Const $CSIDL_COMMON_PROGRAMS = 23
Global Const $CSIDL_COMMON_STARTMENU = 22
Global Const $CSIDL_COMMON_STARTUP = 24
Global Const $CSIDL_COMMON_TEMPLATES = 45
Global Const $CSIDL_COMMON_VIDEO = 55
Global Const $CSIDL_COMPUTERSNEARME = 61
Global Const $CSIDL_CONNECTIONS = 49
Global Const $CSIDL_CONTROLS = 3
Global Const $CSIDL_COOKIES = 33
Global Const $CSIDL_DESKTOP = 0
Global Const $CSIDL_DESKTOPDIRECTORY = 16
Global Const $CSIDL_DRIVES = 17
Global Const $CSIDL_FAVORITES = 6
Global Const $CSIDL_FONTS = 20
Global Const $CSIDL_INTERNET_CACHE = 32
Global Const $CSIDL_HISTORY = 34
Global Const $CSIDL_LOCAL_APPDATA = 28
Global Const $CSIDL_MYMUSIC = 13
Global Const $CSIDL_MYPICTURES = 39
Global Const $CSIDL_MYVIDEO = 14
Global Const $CSIDL_NETHOOD = 19
Global Const $CSIDL_PERSONAL = 5
Global Const $CSIDL_PRINTERS = 4
Global Const $CSIDL_PRINTHOOD = 27
Global Const $CSIDL_PROFILE = 40
Global Const $CSIDL_PROGRAM_FILES = 38
Global Const $CSIDL_PROGRAM_FILES_COMMON = 43
Global Const $CSIDL_PROGRAM_FILES_COMMONX86 = 44
Global Const $CSIDL_PROGRAM_FILESX86 = 42
Global Const $CSIDL_PROGRAMS = 2
Global Const $CSIDL_RECENT = 8
Global Const $CSIDL_SENDTO = 9
Global Const $CSIDL_STARTMENU = 11
Global Const $CSIDL_STARTUP = 7
Global Const $CSIDL_SYSTEM = 37
Global Const $CSIDL_SYSTEMX86 = 41
Global Const $CSIDL_TEMPLATES = 21
Global Const $CSIDL_WINDOWS = 36
Global Const $SIID_DOCNOASSOC = 0
Global Const $SIID_DOCASSOC = 1
Global Const $SIID_APPLICATION = 2
Global Const $SIID_FOLDER = 3
Global Const $SIID_FOLDEROPEN = 4
Global Const $SIID_DRIVE525 = 5
Global Const $SIID_DRIVE35 = 6
Global Const $SIID_DRIVEREMOVE = 7
Global Const $SIID_DRIVEFIXED = 8
Global Const $SIID_DRIVENET = 9
Global Const $SIID_DRIVENETDISABLED = 10
Global Const $SIID_DRIVECD = 11
Global Const $SIID_DRIVERAM = 12
Global Const $SIID_WORLD = 13
Global Const $SIID_SERVER = 15
Global Const $SIID_PRINTER = 16
Global Const $SIID_MYNETWORK = 17
Global Const $SIID_FIND = 22
Global Const $SIID_HELP = 23
Global Const $SIID_SHARE = 28
Global Const $SIID_LINK = 29
Global Const $SIID_SLOWFILE = 30
Global Const $SIID_RECYCLER = 31
Global Const $SIID_RECYCLERFULL = 32
Global Const $SIID_MEDIACDAUDIO = 40
Global Const $SIID_LOCK = 47
Global Const $SIID_AUTOLIST = 49
Global Const $SIID_PRINTERNET = 50
Global Const $SIID_SERVERSHARE = 51
Global Const $SIID_PRINTERFAX = 52
Global Const $SIID_PRINTERFAXNET = 53
Global Const $SIID_PRINTERFILE = 54
Global Const $SIID_STACK = 55
Global Const $SIID_MEDIASVCD = 56
Global Const $SIID_STUFFEDFOLDER = 57
Global Const $SIID_DRIVEUNKNOWN = 58
Global Const $SIID_DRIVEDVD = 59
Global Const $SIID_MEDIADVD = 60
Global Const $SIID_MEDIADVDRAM = 61
Global Const $SIID_MEDIADVDRW = 62
Global Const $SIID_MEDIADVDR = 63
Global Const $SIID_MEDIADVDROM = 64
Global Const $SIID_MEDIACDAUDIOPLUS = 65
Global Const $SIID_MEDIACDRW = 66
Global Const $SIID_MEDIACDR = 67
Global Const $SIID_MEDIACDBURN = 68
Global Const $SIID_MEDIABLANKCD = 69
Global Const $SIID_MEDIACDROM = 70
Global Const $SIID_AUDIOFILES = 71
Global Const $SIID_IMAGEFILES = 72
Global Const $SIID_VIDEOFILES = 73
Global Const $SIID_MIXEDFILES = 74
Global Const $SIID_FOLDERBACK = 75
Global Const $SIID_FOLDERFRONT = 76
Global Const $SIID_SHIELD = 77
Global Const $SIID_WARNING = 78
Global Const $SIID_INFO = 79
Global Const $SIID_ERROR = 80
Global Const $SIID_KEY = 81
Global Const $SIID_SOFTWARE = 82
Global Const $SIID_RENAME = 83
Global Const $SIID_DELETE = 84
Global Const $SIID_MEDIAAUDIODVD = 85
Global Const $SIID_MEDIAMOVIEDVD = 86
Global Const $SIID_MEDIAENHANCEDCD = 87
Global Const $SIID_MEDIAENHANCEDDVD = 88
Global Const $SIID_MEDIAHDDVD = 89
Global Const $SIID_MEDIABLURAY = 90
Global Const $SIID_MEDIAVCD = 91
Global Const $SIID_MEDIADVDPLUSR = 92
Global Const $SIID_MEDIADVDPLUSRW = 93
Global Const $SIID_DESKTOPPC = 94
Global Const $SIID_MOBILEPC = 95
Global Const $SIID_USERS = 96
Global Const $SIID_MEDIASMARTMEDIA = 97
Global Const $SIID_MEDIACOMPACTFLASH = 98
Global Const $SIID_DEVICECELLPHONE = 99
Global Const $SIID_DEVICECAMERA = 100
Global Const $SIID_DEVICEVIDEOCAMERA = 101
Global Const $SIID_DEVICEAUDIOPLAYER = 102
Global Const $SIID_NETWORKCONNECT = 103
Global Const $SIID_INTERNET = 104
Global Const $SIID_ZIPFILE = 105
Global Const $SIID_SETTINGS = 106
Global Const $SIID_DRIVEHDDVD = 132
Global Const $SIID_DRIVEBD = 133
Global Const $SIID_MEDIAHDDVDROM = 134
Global Const $SIID_MEDIAHDDVDR = 135
Global Const $SIID_MEDIAHDDVDRAM = 136
Global Const $SIID_MEDIABDROM = 137
Global Const $SIID_MEDIABDR = 138
Global Const $SIID_MEDIABDRE = 139
Global Const $SIID_CLUSTEREDDRIVE = 140
Global Const $SIID_MAX_ICONS = 174
Global Const $SHGSI_ICONLOCATION = 0
Global Const $SHGSI_ICON = $SHGFI_ICON
Global Const $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
Global Const $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
Global Const $SHGSI_SELECTED = $SHGFI_SELECTED
Global Const $SHGSI_LARGEICON = $SHGFI_LARGEICON
Global Const $SHGSI_SMALLICON = $SHGFI_SMALLICON
Global Const $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE
Global Const $NIM_ADD = 0
Global Const $NIM_MODIFY = 1
Global Const $NIM_DELETE = 2
Global Const $NIM_SETFOCUS = 3
Global Const $NIM_SETVERSION = 4
Global Const $NIF_MESSAGE = 1
Global Const $NIF_ICON = 2
Global Const $NIF_TIP = 4
Global Const $NIF_STATE = 8
Global Const $NIF_INFO = 16
Global Const $NIF_GUID = 32
Global Const $NIF_REALTIME = 64
Global Const $NIF_SHOWTIP = 128
Global Const $NIS_HIDDEN = 1
Global Const $NIS_SHAREDICON = 2
Global Const $NIIF_NONE = 0
Global Const $NIIF_INFO = 1
Global Const $NIIF_WARNING = 2
Global Const $NIIF_ERROR = 3
Global Const $NIIF_USER = 4
Global Const $NIIF_NOSOUND = 16
Global Const $NIIF_LARGE_ICON = 16
Global Const $NIIF_RESPECT_QUIET_TIME = 128
Global Const $NIIF_ICON_MASK = 15
Global Const $SHOP_PRINTERNAME = 1
Global Const $SHOP_FILEPATH = 2
Global Const $SHOP_VOLUMEGUID = 4
Global Const $OFASI_EDIT = 1
Global Const $OFASI_OPENDESKTOP = 2
Global Const $QUNS_NOT_PRESENT = 1
Global Const $QUNS_BUSY = 2
Global Const $QUNS_RUNNING_D3D_FULL_SCREEN = 3
Global Const $QUNS_PRESENTATION_MODE = 4
Global Const $QUNS_ACCEPTS_NOTIFICATIONS = 5
Global Const $QUNS_QUIET_TIME = 6
Global Const $REST_NORUN = 1
Global Const $REST_NOCLOSE = 2
Global Const $REST_NOSAVESET = 3
Global Const $REST_NOFILEMENU = 4
Global Const $REST_NOSETFOLDERS = 5
Global Const $REST_NOSETTASKBAR = 6
Global Const $REST_NODESKTOP = 7
Global Const $REST_NOFIND = 8
Global Const $REST_NODRIVES = 9
Global Const $REST_NODRIVEAUTORUN = 10
Global Const $REST_NODRIVETYPEAUTORUN = 11
Global Const $REST_NONETHOOD = 12
Global Const $REST_STARTBANNER = 13
Global Const $REST_RESTRICTRUN = 14
Global Const $REST_NOPRINTERTABS = 15
Global Const $REST_NOPRINTERDELETE = 16
Global Const $REST_NOPRINTERADD = 17
Global Const $REST_NOSTARTMENUSUBFOLDERS = 18
Global Const $REST_MYDOCSONNET = 19
Global Const $REST_NOEXITTODOS = 20
Global Const $REST_ENFORCESHELLEXTSECURITY = 21
Global Const $REST_LINKRESOLVEIGNORELINKINFO = 22
Global Const $REST_NOCOMMONGROUPS = 23
Global Const $REST_SEPARATEDESKTOPPROCESS = 24
Global Const $REST_NOWEB = 25
Global Const $REST_NOTRAYCONTEXTMENU = 26
Global Const $REST_NOVIEWCONTEXTMENU = 27
Global Const $REST_NONETCONNECTDISCONNECT = 28
Global Const $REST_STARTMENULOGOFF = 29
Global Const $REST_NOSETTINGSASSIST = 30
Global Const $REST_NOINTERNETICON = 31
Global Const $REST_NORECENTDOCSHISTORY = 32
Global Const $REST_NORECENTDOCSMENU = 33
Global Const $REST_NOACTIVEDESKTOP = 34
Global Const $REST_NOACTIVEDESKTOPCHANGES = 35
Global Const $REST_NOFAVORITESMENU = 36
Global Const $REST_CLEARRECENTDOCSONEXIT = 37
Global Const $REST_CLASSICSHELL = 38
Global Const $REST_NOCUSTOMIZEWEBVIEW = 39
Global Const $REST_NOHTMLWALLPAPER = 40
Global Const $REST_NOCHANGINGWALLPAPER = 41
Global Const $REST_NODESKCOMP = 42
Global Const $REST_NOADDDESKCOMP = 43
Global Const $REST_NODELDESKCOMP = 44
Global Const $REST_NOCLOSEDESKCOMP = 45
Global Const $REST_NOCLOSE_DRAGDROPBAND = 46
Global Const $REST_NOMOVINGBAND = 47
Global Const $REST_NOEDITDESKCOMP = 48
Global Const $REST_NORESOLVESEARCH = 49
Global Const $REST_NORESOLVETRACK = 50
Global Const $REST_FORCECOPYACLWITHFILE = 51
Global Const $REST_NOLOGO3CHANNELNOTIFY = 52
Global Const $REST_NOFORGETSOFTWAREUPDATE = 53
Global Const $REST_NOSETACTIVEDESKTOP = 54
Global Const $REST_NOUPDATEWINDOWS = 55
Global Const $REST_NOCHANGESTARMENU = 56
Global Const $REST_NOFOLDEROPTIONS = 57
Global Const $REST_HASFINDCOMPUTERS = 58
Global Const $REST_INTELLIMENUS = 59
Global Const $REST_RUNDLGMEMCHECKBOX = 60
Global Const $REST_ARP_SHOWPOSTSETUP = 61
Global Const $REST_NOCSC = 62
Global Const $REST_NOCONTROLPANEL = 63
Global Const $REST_ENUMWORKGROUP = 64
Global Const $REST_ARP_NOARP = 65
Global Const $REST_ARP_NOREMOVEPAGE = 66
Global Const $REST_ARP_NOADDPAGE = 67
Global Const $REST_ARP_NOWINSETUPPAGE = 68
Global Const $REST_GREYMSIADS = 69
Global Const $REST_NOCHANGEMAPPEDDRIVELABEL = 70
Global Const $REST_NOCHANGEMAPPEDDRIVECOMMENT = 71
Global Const $REST_MAXRECENTDOCS = 72
Global Const $REST_NONETWORKCONNECTIONS = 73
Global Const $REST_FORCESTARTMENULOGOFF = 74
Global Const $REST_NOWEBVIEW = 75
Global Const $REST_NOCUSTOMIZETHISFOLDER = 76
Global Const $REST_NOENCRYPTION = 77
Global Const $REST_DONTSHOWSUPERHIDDEN = 78
Global Const $REST_NOSHELLSEARCHBUTTON = 79
Global Const $REST_NOHARDWARETAB = 80
Global Const $REST_NORUNASINSTALLPROMPT = 81
Global Const $REST_PROMPTRUNASINSTALLNETPATH = 82
Global Const $REST_NOMANAGEMYCOMPUTERVERB = 83
Global Const $REST_NORECENTDOCSNETHOOD = 84
Global Const $REST_DISALLOWRUN = 85
Global Const $REST_NOWELCOMESCREEN = 86
Global Const $REST_RESTRICTCPL = 87
Global Const $REST_DISALLOWCPL = 88
Global Const $REST_NOSMBALLOONTIP = 89
Global Const $REST_NOSMHELP = 90
Global Const $REST_NOWINKEYS = 91
Global Const $REST_NOENCRYPTONMOVE = 92
Global Const $REST_NOLOCALMACHINERUN = 93
Global Const $REST_NOCURRENTUSERRUN = 94
Global Const $REST_NOLOCALMACHINERUNONCE = 95
Global Const $REST_NOCURRENTUSERRUNONCE = 96
Global Const $REST_FORCEACTIVEDESKTOPON = 97
Global Const $REST_NOCOMPUTERSNEARME = 98
Global Const $REST_NOVIEWONDRIVE = 99
Global Const $REST_NONETCRAWL = 100
Global Const $REST_NOSHAREDDOCUMENTS = 101
Global Const $REST_NOSMMYDOCS = 102
Global Const $REST_NOSMMYPICS = 103
Global Const $REST_ALLOWBITBUCKDRIVES = 104
Global Const $REST_NONLEGACYSHELLMODE = 105
Global Const $REST_NOCONTROLPANELBARRICADE = 106
Global Const $REST_NOSTARTPAGE = 107
Global Const $REST_NOAUTOTRAYNOTIFY = 108
Global Const $REST_NOTASKGROUPING = 109
Global Const $REST_NOCDBURNING = 110
Global Const $REST_MYCOMPNOPROP = 111
Global Const $REST_MYDOCSNOPROP = 112
Global Const $REST_NOSTARTPANEL = 113
Global Const $REST_NODISPLAYAPPEARANCEPAGE = 114
Global Const $REST_NOTHEMESTAB = 115
Global Const $REST_NOVISUALSTYLECHOICE = 116
Global Const $REST_NOSIZECHOICE = 117
Global Const $REST_NOCOLORCHOICE = 118
Global Const $REST_SETVISUALSTYLE = 119
Global Const $REST_STARTRUNNOHOMEPATH = 120
Global Const $REST_NOUSERNAMEINSTARTPANEL = 121
Global Const $REST_NOMYCOMPUTERICON = 122
Global Const $REST_NOSMNETWORKPLACES = 123
Global Const $REST_NOSMPINNEDLIST = 124
Global Const $REST_NOSMMYMUSIC = 125
Global Const $REST_NOSMEJECTPC = 126
Global Const $REST_NOSMMOREPROGRAMS = 127
Global Const $REST_NOSMMFUPROGRAMS = 128
Global Const $REST_NOTRAYITEMSDISPLAY = 129
Global Const $REST_NOTOOLBARSONTASKBAR = 130
Global Const $REST_NOSMCONFIGUREPROGRAMS = 131
Global Const $REST_HIDECLOCK = 132
Global Const $REST_NOLOWDISKSPACECHECKS = 133
Global Const $REST_NOENTIRENETWORK = 134
Global Const $REST_NODESKTOPCLEANUP = 135
Global Const $REST_BITBUCKNUKEONDELETE = 136
Global Const $REST_BITBUCKCONFIRMDELETE = 137
Global Const $REST_BITBUCKNOPROP = 138
Global Const $REST_NODISPBACKGROUND = 139
Global Const $REST_NODISPSCREENSAVEPG = 140
Global Const $REST_NODISPSETTINGSPG = 141
Global Const $REST_NODISPSCREENSAVEPREVIEW = 142
Global Const $REST_NODISPLAYCPL = 143
Global Const $REST_HIDERUNASVERB = 144
Global Const $REST_NOTHUMBNAILCACHE = 145
Global Const $REST_NOSTRCMPLOGICAL = 146
Global Const $REST_NOPUBLISHWIZARD = 147
Global Const $REST_NOONLINEPRINTSWIZARD = 148
Global Const $REST_NOWEBSERVICES = 149
Global Const $REST_ALLOWUNHASHEDWEBVIEW = 150
Global Const $REST_ALLOWLEGACYWEBVIEW = 151
Global Const $REST_REVERTWEBVIEWSECURITY = 152
Global Const $REST_INHERITCONSOLEHANDLES = 153
Global Const $REST_SORTMAXITEMCOUNT = 154
Global Const $REST_NOREMOTERECURSIVEEVENTS = 155
Global Const $REST_NOREMOTECHANGENOTIFY = 156
Global Const $REST_NOSIMPLENETIDLIST = 157
Global Const $REST_NOENUMENTIRENETWORK = 158
Global Const $REST_NODETAILSTHUMBNAILONNETWORK = 159
Global Const $REST_NOINTERNETOPENWITH = 160
Global Const $REST_ALLOWLEGACYLMZBEHAVIOR = 161
Global Const $REST_DONTRETRYBADNETNAME = 162
Global Const $REST_ALLOWFILECLSIDJUNCTIONS = 163
Global Const $REST_NOUPNPINSTALL = 164
Global Const $REST_ARP_DONTGROUPPATCHES = 165
Global Const $REST_ARP_NOCHOOSEPROGRAMSPAGE = 166
Global Const $REST_NODISCONNECT = 167
Global Const $REST_NOSECURITY = 168
Global Const $REST_NOFILEASSOCIATE = 169
Global Const $REST_ALLOWCOMMENTTOGGLE = 170
Global Const $REST_USEDESKTOPINICACHE = 171
Global Const $GIL_DONTCACHE = 16
Global Const $GIL_NOTFILENAME = 8
Global Const $GIL_PERCLASS = 4
Global Const $GIL_PERINSTANCE = 2
Global Const $GIL_SIMULATEDOC = 1
Global Const $GIL_SHIELD = 512
Global Const $GIL_FORCENOSHIELD = 1024
Global Const $FOLDERID_ADDNEWPROGRAMS = "{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}"
Global Const $FOLDERID_ADMINTOOLS = "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"
Global Const $FOLDERID_APPUPDATES = "{A305CE99-F527-492B-8B1A-7E76FA98D6E4}"
Global Const $FOLDERID_CDBURNING = "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"
Global Const $FOLDERID_CHANGEREMOVEPROGRAMS = "{DF7266AC-9274-4867-8D55-3BD661DE872D}"
Global Const $FOLDERID_COMMONADMINTOOLS = "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"
Global Const $FOLDERID_COMMONOEMLINKS = "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"
Global Const $FOLDERID_COMMONPROGRAMS = "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"
Global Const $FOLDERID_COMMONSTARTMENU = "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"
Global Const $FOLDERID_COMMONSTARTUP = "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"
Global Const $FOLDERID_COMMONTEMPLATES = "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"
Global Const $FOLDERID_COMPUTERFOLDER = "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"
Global Const $FOLDERID_CONFLICTFOLDER = "{4BFEFB45-347D-4006-A5BE-AC0CB0567192}"
Global Const $FOLDERID_CONNECTIONSFOLDER = "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"
Global Const $FOLDERID_CONTACTS = "{56784854-C6CB-462B-8169-88E350ACB882}"
Global Const $FOLDERID_CONTROLPANELFOLDER = "{82A74AEB-AEB4-465C-A014-D097EE346D63}"
Global Const $FOLDERID_COOKIES = "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"
Global Const $FOLDERID_DESKTOP = "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"
Global Const $FOLDERID_DEVICEMETADATASTORE = "{5CE4A5E9-E4EB-479D-B89F-130C02886155}"
Global Const $FOLDERID_DOCUMENTSLIBRARY = "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}"
Global Const $FOLDERID_DOWNLOADS = "{374DE290-123F-4565-9164-39C4925E467B}"
Global Const $FOLDERID_FAVORITES = "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"
Global Const $FOLDERID_FONTS = "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"
Global Const $FOLDERID_GAMES = "{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}"
Global Const $FOLDERID_GAMETASKS = "{054FAE61-4DD8-4787-80B6-090220C4B700}"
Global Const $FOLDERID_HISTORY = "{D9DC8A3B-B784-432E-A781-5A1130A75963}"
Global Const $FOLDERID_HOMEGROUP = "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}"
Global Const $FOLDERID_IMPLICITAPPSHORTCUTS = "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}"
Global Const $FOLDERID_INTERNETCACHE = "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"
Global Const $FOLDERID_INTERNETFOLDER = "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"
Global Const $FOLDERID_LIBRARIES = "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}"
Global Const $FOLDERID_LINKS = "{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}"
Global Const $FOLDERID_LOCALAPPDATA = "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"
Global Const $FOLDERID_LOCALAPPDATALOW = "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"
Global Const $FOLDERID_LOCALIZEDRESOURCESDIR = "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"
Global Const $FOLDERID_MUSIC = "{4BD8D571-6D19-48D3-BE97-422220080E43}"
Global Const $FOLDERID_MUSICLIBRARY = "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}"
Global Const $FOLDERID_NETHOOD = "{C5ABBF53-E17F-4121-8900-86626FC2C973}"
Global Const $FOLDERID_NETWORKFOLDER = "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"
Global Const $FOLDERID_ORIGINALIMAGES = "{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}"
Global Const $FOLDERID_PHOTOALBUMS = "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}"
Global Const $FOLDERID_PICTURESLIBRARY = "{A990AE9F-A03B-4E80-94BC-9912D7504104}"
Global Const $FOLDERID_PICTURES = "{33E28130-4E1E-4676-835A-98395C3BC3BB}"
Global Const $FOLDERID_PLAYLISTS = "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"
Global Const $FOLDERID_PRINTERSFOLDER = "{76FC4E2D-D6AD-4519-A663-37BD56068185}"
Global Const $FOLDERID_PRINTHOOD = "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"
Global Const $FOLDERID_PROFILE = "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"
Global Const $FOLDERID_PROGRAMDATA = "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"
Global Const $FOLDERID_PROGRAMFILES = "{905E63B6-C1BF-494E-B29C-65B732D3D21A}"
Global Const $FOLDERID_PROGRAMFILESX64 = "{6D809377-6AF0-444B-8957-A3773F02200E}"
Global Const $FOLDERID_PROGRAMFILESX86 = "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"
Global Const $FOLDERID_PROGRAMFILESCOMMON = "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"
Global Const $FOLDERID_PROGRAMFILESCOMMONX64 = "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"
Global Const $FOLDERID_PROGRAMFILESCOMMONX86 = "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"
Global Const $FOLDERID_PROGRAMS = "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"
Global Const $FOLDERID_PUBLIC = "{DFDF76A2-C82A-4D63-906A-5644AC457385}"
Global Const $FOLDERID_PUBLICDESKTOP = "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"
Global Const $FOLDERID_PUBLICDOCUMENTS = "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"
Global Const $FOLDERID_PUBLICDOWNLOADS = "{3D644C9B-1FB8-4F30-9B45-F670235F79C0}"
Global Const $FOLDERID_PUBLICGAMETASKS = "{DEBF2536-E1A8-4C59-B6A2-414586476AEA}"
Global Const $FOLDERID_PUBLICLIBRARIES = "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}"
Global Const $FOLDERID_PUBLICMUSIC = "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"
Global Const $FOLDERID_PUBLICPICTURES = "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"
Global Const $FOLDERID_PUBLICRINGTONES = "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}"
Global Const $FOLDERID_PUBLICVIDEOS = "{2400183A-6185-49FB-A2D8-4A392A602BA3}"
Global Const $FOLDERID_QUICKLAUNCH = "{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}"
Global Const $FOLDERID_RECENT = "{AE50C081-EBD2-438A-8655-8A092E34987A}"
Global Const $FOLDERID_RECORDEDTVLIBRARY = "{1A6FDBA2-F42D-4358-A798-B74D745926C5}"
Global Const $FOLDERID_RECYCLEBINFOLDER = "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"
Global Const $FOLDERID_RESOURCEDIR = "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"
Global Const $FOLDERID_RINGTONES = "{C870044B-F49E-4126-A9C3-B52A1FF411E8}"
Global Const $FOLDERID_ROAMINGAPPDATA = "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"
Global Const $FOLDERID_SAMPLEMUSIC = "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"
Global Const $FOLDERID_SAMPLEPICTURES = "{C4900540-2379-4C75-844B-64E6FAF8716B}"
Global Const $FOLDERID_SAMPLEPLAYLISTS = "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}"
Global Const $FOLDERID_SAMPLEVIDEOS = "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"
Global Const $FOLDERID_SAVEDGAMES = "{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}"
Global Const $FOLDERID_SAVEDSEARCHES = "{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}"
Global Const $FOLDERID_SEARCH_CSC = "{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}"
Global Const $FOLDERID_SEARCH_MAPI = "{98EC0E18-2098-4D44-8644-66979315A281}"
Global Const $FOLDERID_SEARCHHOME = "{190337D1-B8CA-4121-A639-6D472D16972A}"
Global Const $FOLDERID_SENDTO = "{8983036C-27C0-404B-8F08-102D10DCFD74}"
Global Const $FOLDERID_SIDEBARDEFAULTPARTS = "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"
Global Const $FOLDERID_SIDEBARPARTS = "{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}"
Global Const $FOLDERID_STARTMENU = "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"
Global Const $FOLDERID_STARTUP = "{B97D20BB-F46A-4C97-BA10-5E3608430854}"
Global Const $FOLDERID_SYNCMANAGERFOLDER = "{43668BF8-C14E-49B2-97C9-747784D784B7}"
Global Const $FOLDERID_SYNCRESULTSFOLDER = "{289A9A43-BE44-4057-A41B-587A76D7E7F9}"
Global Const $FOLDERID_SYNCSETUPFOLDER = "{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}"
Global Const $FOLDERID_SYSTEM = "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"
Global Const $FOLDERID_SYSTEMX86 = "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"
Global Const $FOLDERID_TEMPLATES = "{A63293E8-664E-48DB-A079-DF759E0509F7}"
Global Const $FOLDERID_USERPINNED = "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}"
Global Const $FOLDERID_USERPROFILES = "{0762D272-C50A-4BB0-A382-697DCD729B80}"
Global Const $FOLDERID_USERPROGRAMFILES = "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}"
Global Const $FOLDERID_USERPROGRAMFILESCOMMON = "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}"
Global Const $FOLDERID_USERSFILES = "{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}"
Global Const $FOLDERID_USERSLIBRARIES = "{A302545D-DEFF-464B-ABE8-61C8648D939B}"
Global Const $FOLDERID_VIDEOS = "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"
Global Const $FOLDERID_VIDEOSLIBRARY = "{491E922F-5643-4AF4-A7EB-4E7A138D8174}"
Global Const $FOLDERID_WINDOWS = "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"
Global Const $KF_FLAG_ALIAS_ONLY = 2147483648
Global Const $KF_FLAG_CREATE = 32768
Global Const $KF_FLAG_DONT_VERIFY = 16384
Global Const $KF_FLAG_DONT_UNEXPAND = 8192
Global Const $KF_FLAG_NO_ALIAS = 4096
Global Const $KF_FLAG_INIT = 2048
Global Const $KF_FLAG_DEFAULT_PATH = 1024
Global Const $KF_FLAG_NO_APPCONTAINER_REDIRECTION = 65536
Global Const $KF_FLAG_NOT_PARENT_RELATIVE = 512
Global Const $KF_FLAG_SIMPLE_IDLIST = 256
Global Const $URL_SCHEME_INVALID = + 4294967295
Global Const $URL_SCHEME_UNKNOWN = 0
Global Const $URL_SCHEME_FTP = 1
Global Const $URL_SCHEME_HTTP = 2
Global Const $URL_SCHEME_GOPHER = 3
Global Const $URL_SCHEME_MAILTO = 4
Global Const $URL_SCHEME_NEWS = 5
Global Const $URL_SCHEME_NNTP = 6
Global Const $URL_SCHEME_TELNET = 7
Global Const $URL_SCHEME_WAIS = 8
Global Const $URL_SCHEME_FILE = 9
Global Const $URL_SCHEME_MK = 10
Global Const $URL_SCHEME_HTTPS = 11
Global Const $URL_SCHEME_SHELL = 12
Global Const $URL_SCHEME_SNEWS = 13
Global Const $URL_SCHEME_LOCAL = 14
Global Const $URL_SCHEME_JAVASCRIPT = 15
Global Const $URL_SCHEME_VBSCRIPT = 16
Global Const $URL_SCHEME_ABOUT = 17
Global Const $URL_SCHEME_RES = 18
Global Const $URL_SCHEME_MSSHELLROOTED = 19
Global Const $URL_SCHEME_MSSHELLIDLIST = 20
Global Const $URL_SCHEME_MSHELP = 21
Global Const $URL_SCHEME_MSSHELLDEVICE = 22
Global Const $URL_SCHEME_WILDCARD = 23
Global Const $URL_SCHEME_SEARCH_MS = 24
Global Const $URL_SCHEME_SEARCH = 25
Global Const $URL_SCHEME_KNOWNFOLDER = 26
Global Const $GCT_INVALID = 0
Global Const $GCT_LFNCHAR = 1
Global Const $GCT_SEPARATOR = 8
Global Const $GCT_SHORTCHAR = 2
Global Const $GCT_WILD = 4
Global Const $URL_APPLY_DEFAULT = 1
Global Const $URL_APPLY_GUESSSCHEME = 2
Global Const $URL_APPLY_GUESSFILE = 4
Global Const $URL_APPLY_FORCEAPPLY = 8
Global Const $URL_DONT_SIMPLIFY = 134217728
Global Const $URL_ESCAPE_AS_UTF8 = 262144
Global Const $URL_ESCAPE_PERCENT = 4096
Global Const $URL_ESCAPE_SPACES_ONLY = 67108864
Global Const $URL_ESCAPE_UNSAFE = 536870912
Global Const $URL_NO_META = 134217728
Global Const $URL_PLUGGABLE_PROTOCOL = 1073741824
Global Const $URL_UNESCAPE = 268435456
Global Const $URL_PART_HOSTNAME = 2
Global Const $URL_PART_PASSWORD = 4
Global Const $URL_PART_PORT = 5
Global Const $URL_PART_QUERY = 6
Global Const $URL_PART_SCHEME = 1
Global Const $URL_PART_USERNAME = 3
Global Const $URLIS_APPLIABLE = 4
Global Const $URLIS_DIRECTORY = 5
Global Const $URLIS_FILEURL = 3
Global Const $URLIS_HASQUERY = 6
Global Const $URLIS_NOHISTORY = 2
Global Const $URLIS_OPAQUE = 1
Global Const $URLIS_URL = 0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_COMMANDLINETOARGV ( $SCMD )
	Local $ARET [ 1 ] = [ 0 ]
	$SCMD = StringStripWS ( $SCMD , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	If Not $SCMD Then
		Return $ARET
	EndIf
	Local $ACALL = DllCall ( "shell32.dll" , "ptr" , "CommandLineToArgvW" , "wstr" , $SCMD , "int*" , 0 )
	If @error Or Not $ACALL [ 0 ] Or ( Not $ACALL [ 2 ] ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TPTR = DllStructCreate ( "ptr[" & $ACALL [ 2 ] & "]" , $ACALL [ 0 ] )
	Dim $ARET [ $ACALL [ 2 ] + 1 ] = [ $ACALL [ 2 ] ]
	For $I = 1 To $ACALL [ 2 ]
		$ARET [ $I ] = _WINAPI_GETSTRING ( DllStructGetData ( $TPTR , 1 , $I ) )
	Next
	DllCall ( "kernel32.dll" , "handle" , "LocalFree" , "handle" , $ACALL [ 0 ] )
	Return $ARET
EndFunc
Func _WINAPI_ISNAMEINEXPRESSION ( $SSTRING , $SPATTERN , $BCASESENSITIVE = False )
	If Not $BCASESENSITIVE Then $SPATTERN = StringUpper ( $SPATTERN )
	Local $TUS1 = __US ( $SPATTERN )
	Local $TUS2 = __US ( $SSTRING )
	Local $ACALL = DllCall ( "ntdll.dll" , "boolean" , "RtlIsNameInExpression" , "struct*" , $TUS1 , "struct*" , $TUS2 , "boolean" , Not $BCASESENSITIVE , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PARSEURL ( $SURL )
	Local $TAGPARSEDURL = "dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme"
	Local $TPURL = DllStructCreate ( $TAGPARSEDURL )
	DllStructSetData ( $TPURL , 1 , DllStructGetSize ( $TPURL ) )
	Local $TURL = DllStructCreate ( "wchar[4096]" )
	DllStructSetData ( $TURL , 1 , $SURL )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "ParseURLW" , "struct*" , $TURL , "struct*" , $TPURL )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Local $ARET [ 3 ]
	$ARET [ 0 ] = DllStructGetData ( DllStructCreate ( "wchar[" & DllStructGetData ( $TPURL , 3 ) & "]" , DllStructGetData ( $TPURL , 2 ) ) , 1 )
	$ARET [ 1 ] = DllStructGetData ( DllStructCreate ( "wchar[" & DllStructGetData ( $TPURL , 5 ) & "]" , DllStructGetData ( $TPURL , 4 ) ) , 1 )
	$ARET [ 2 ] = DllStructGetData ( $TPURL , 6 )
	Return $ARET
EndFunc
Func _WINAPI_PARSEUSERNAME ( $SUSER )
	If Not __DLL ( "credui.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $ACALL = DllCall ( "credui.dll" , "dword" , "CredUIParseUserNameW" , "wstr" , $SUSER , "wstr" , "" , "ulong" , 4096 , "wstr" , "" , "ulong" , 4096 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Switch $ACALL [ 0 ]
	Case 0
	Case 1315
		If StringStripWS ( $SUSER , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
			$ACALL [ 2 ] = $SUSER
			$ACALL [ 4 ] = ""
		Else
			ContinueCase
		EndIf
Case Else
		Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	EndSwitch
	Local $ARET [ 2 ]
	$ARET [ 0 ] = $ACALL [ 4 ]
	$ARET [ 1 ] = $ACALL [ 2 ]
	Return $ARET
EndFunc
Func _WINAPI_PATHADDBACKSLASH ( $SFILEPATH )
	Local $TPATH = DllStructCreate ( "wchar[260]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "PathAddBackslashW" , "struct*" , $TPATH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return DllStructGetData ( $TPATH , 1 )
EndFunc
Func _WINAPI_PATHADDEXTENSION ( $SFILEPATH , $SEXT = "" )
	Local $TPATH = DllStructCreate ( "wchar[260]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	If Not StringStripWS ( $SEXT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SEXT = Null
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathAddExtensionW" , "struct*" , $TPATH , "wstr" , $SEXT )
	If @error Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , DllStructGetData ( $TPATH , 1 ) )
EndFunc
Func _WINAPI_PATHAPPEND ( $SFILEPATH , $SMORE )
	Local $TPATH = DllStructCreate ( "wchar[260]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathAppendW" , "struct*" , $TPATH , "wstr" , $SMORE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return DllStructGetData ( $TPATH , 1 )
EndFunc
Func _WINAPI_PATHBUILDROOT ( $IDRIVE )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "PathBuildRootW" , "wstr" , "" , "int" , $IDRIVE )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHCANONICALIZE ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathCanonicalizeW" , "wstr" , "" , "wstr" , $SFILEPATH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , $SFILEPATH )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHCOMMONPREFIX ( $SPATH1 , $SPATH2 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "int" , "PathCommonPrefixW" , "wstr" , $SPATH1 , "wstr" , $SPATH2 , "wstr" , "" )
	If @error Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 3 ] )
EndFunc
Func _WINAPI_PATHCOMPACTPATH ( $HWND , $SFILEPATH , $IWIDTH = 0 )
	If $IWIDTH < 1 Then
		Local $TRECT = DllStructCreate ( $TAGRECT )
		DllCall ( "user32.dll" , "bool" , "GetClientRect" , "hwnd" , $HWND , "struct*" , $TRECT )
		$IWIDTH += DllStructGetData ( $TRECT , "Right" ) - DllStructGetData ( $TRECT , "Left" )
	EndIf
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetDC" , "hwnd" , $HWND )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , $SFILEPATH )
	Local $HDC = $ACALL [ 0 ]
	Local Const $WM_GETFONT = 49
	$ACALL = DllCall ( "user32.dll" , "ptr" , "SendMessage" , "hwnd" , $HWND , "uint" , $WM_GETFONT , "wparam" , 0 , "lparam" , 0 )
	Local $HBACK = DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDC , "handle" , $ACALL [ 0 ] )
	Local $IERROR = 0
	$ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathCompactPathW" , "handle" , $HDC , "wstr" , $SFILEPATH , "int" , $IWIDTH )
	If @error Or Not $ACALL [ 0 ] Then $IERROR = @error + 10
	DllCall ( "gdi32.dll" , "handle" , "SelectObject" , "handle" , $HDC , "handle" , $HBACK [ 0 ] )
	DllCall ( "user32.dll" , "int" , "ReleaseDC" , "hwnd" , $HWND , "handle" , $HDC )
	If $IERROR Then Return SetError ( $IERROR , 0 , $SFILEPATH )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_PATHCOMPACTPATHEX ( $SFILEPATH , $IMAX )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathCompactPathExW" , "wstr" , "" , "wstr" , $SFILEPATH , "uint" , $IMAX + 1 , "dword" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , $SFILEPATH )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHCREATEFROMURL ( $SURL )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "PathCreateFromUrlW" , "wstr" , $SURL , "wstr" , "" , "dword*" , 4096 , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_PATHFINDEXTENSION ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "wstr" , "PathFindExtensionW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHFINDFILENAME ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "wstr" , "PathFindFileNameW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , $SFILEPATH )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHFINDNEXTCOMPONENT ( $SFILEPATH )
	Local $TPATH = DllStructCreate ( "wchar[" & ( StringLen ( $SFILEPATH ) + 1 ) & "]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "PathFindNextComponentW" , "struct*" , $TPATH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return _WINAPI_GETSTRING ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_PATHFINDONPATH ( Const $SFILEPATH , $AEXTRAPATHS = "" , Const $SPATHDELIMITER = @LF )
	Local $IEXTRACOUNT = 0
	If IsString ( $AEXTRAPATHS ) Then
		If StringLen ( $AEXTRAPATHS ) Then
			$AEXTRAPATHS = StringSplit ( $AEXTRAPATHS , $SPATHDELIMITER , $STR_ENTIRESPLIT + $STR_NOCOUNT )
			$IEXTRACOUNT = UBound ( $AEXTRAPATHS , $UBOUND_ROWS )
		EndIf
	ElseIf IsArray ( $AEXTRAPATHS ) Then
		$IEXTRACOUNT = UBound ( $AEXTRAPATHS )
	EndIf
	Local $TPATHS , $TPATHPTRS
	If $IEXTRACOUNT Then
		Local $TAGSTRUCT = ""
		For $PATH In $AEXTRAPATHS
			$TAGSTRUCT &= "wchar[" & StringLen ( $PATH ) + 1 & "];"
		Next
		$TPATHS = DllStructCreate ( $TAGSTRUCT )
		$TPATHPTRS = DllStructCreate ( "ptr[" & $IEXTRACOUNT + 1 & "]" )
		For $I = 1 To $IEXTRACOUNT
			DllStructSetData ( $TPATHS , $I , $AEXTRAPATHS [ $I + 4294967295 ] )
			DllStructSetData ( $TPATHPTRS , 1 , DllStructGetPtr ( $TPATHS , $I ) , $I )
		Next
		DllStructSetData ( $TPATHPTRS , 1 , Ptr ( 0 ) , $IEXTRACOUNT + 1 )
	EndIf
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathFindOnPathW" , "wstr" , $SFILEPATH , "struct*" , $TPATHPTRS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , $SFILEPATH )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHGETARGS ( $SFILEPATH )
	Local $TPATH = DllStructCreate ( "wchar[" & ( StringLen ( $SFILEPATH ) + 1 ) & "]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "PathGetArgsW" , "struct*" , $TPATH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return _WINAPI_GETSTRING ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_PATHGETCHARTYPE ( $SCHAR )
	Local $ACALL = DllCall ( "shlwapi.dll" , "uint" , "PathGetCharTypeW" , "word" , AscW ( $SCHAR ) )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHGETDRIVENUMBER ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "int" , "PathGetDriveNumberW" , "wstr" , $SFILEPATH )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then Return SetError ( @error , @extended , "" )
	Return Chr ( $ACALL [ 0 ] + 65 ) & ":"
EndFunc
Func _WINAPI_PATHISCONTENTTYPE ( $SFILEPATH , $STYPE )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsContentTypeW" , "wstr" , $SFILEPATH , "wstr" , $STYPE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISEXE ( $SFILEPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "PathIsExe" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISFILESPEC ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsFileSpecW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISLFNFILESPEC ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsLFNFileSpecW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISRELATIVE ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsRelativeW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISROOT ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsRootW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISSAMEROOT ( $SPATH1 , $SPATH2 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsSameRootW" , "wstr" , $SPATH1 , "wstr" , $SPATH2 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISSYSTEMFOLDER ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsSystemFolderW" , "wstr" , $SFILEPATH , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISUNC ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsUNCW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISUNCSERVER ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsUNCServerW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISUNCSERVERSHARE ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsUNCServerShareW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHMAKESYSTEMFOLDER ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathMakeSystemFolderW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHMATCHSPEC ( $SFILEPATH , $SSPEC )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathMatchSpecW" , "wstr" , $SFILEPATH , "wstr" , $SSPEC )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHPARSEICONLOCATION ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "int" , "PathParseIconLocationW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 2 ]
	$ARET [ 0 ] = $ACALL [ 1 ]
	$ARET [ 1 ] = $ACALL [ 0 ]
	Return $ARET
EndFunc
Func _WINAPI_PATHRELATIVEPATHTO ( $SPATHFROM , $BDIRFROM , $SPATHTO , $BDIRTO )
	If $BDIRFROM Then
		$BDIRFROM = 16
	EndIf
	If $BDIRTO Then
		$BDIRTO = 16
	EndIf
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathRelativePathToW" , "wstr" , "" , "wstr" , $SPATHFROM , "dword" , $BDIRFROM , "wstr" , $SPATHTO , "dword" , $BDIRTO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHREMOVEARGS ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "none" , "PathRemoveArgsW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHREMOVEBACKSLASH ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "PathRemoveBackslashW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHREMOVEEXTENSION ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "none" , "PathRemoveExtensionW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHREMOVEFILESPEC ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathRemoveFileSpecW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 1 ] )
EndFunc
Func _WINAPI_PATHRENAMEEXTENSION ( $SFILEPATH , $SEXT )
	Local $TPATH = DllStructCreate ( "wchar[260]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathRenameExtensionW" , "struct*" , $TPATH , "wstr" , $SEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return DllStructGetData ( $TPATH , 1 )
EndFunc
Func _WINAPI_PATHSEARCHANDQUALIFY ( $SFILEPATH , $BEXISTS = False )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathSearchAndQualifyW" , "wstr" , $SFILEPATH , "wstr" , "" , "int" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	If $BEXISTS And Not FileExists ( $ACALL [ 2 ] ) Then Return SetError ( 20 , 0 , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_PATHSKIPROOT ( $SFILEPATH )
	Local $TPATH = DllStructCreate ( "wchar[" & ( StringLen ( $SFILEPATH ) + 1 ) & "]" )
	DllStructSetData ( $TPATH , 1 , $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "ptr" , "PathSkipRootW" , "struct*" , $TPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	If Not $ACALL [ 0 ] Then Return $SFILEPATH
	Return _WINAPI_GETSTRING ( $ACALL [ 0 ] )
EndFunc
Func _WINAPI_PATHSTRIPPATH ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "none" , "PathStripPathW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHSTRIPTOROOT ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathStripToRootW" , "wstr" , $SFILEPATH )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHUNDECORATE ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "none" , "PathUndecorateW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHUNEXPANDENVSTRINGS ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathUnExpandEnvStringsW" , "wstr" , $SFILEPATH , "wstr" , "" , "uint" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_PATHUNMAKESYSTEMFOLDER ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathUnmakeSystemFolderW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHUNQUOTESPACES ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "none" , "PathUnquoteSpacesW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_PATHYETANOTHERMAKEUNIQUENAME ( $SFILEPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "PathYetAnotherMakeUniqueName" , "wstr" , "" , "wstr" , $SFILEPATH , "ptr" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_SHELLGETIMAGELIST ( $BSMALL = False )
	Local $PLARGE , $PSMALL , $TPTR = DllStructCreate ( "ptr" )
	If $BSMALL Then
		$PLARGE = 0
		$PSMALL = DllStructGetPtr ( $TPTR )
	Else
		$PLARGE = DllStructGetPtr ( $TPTR )
		$PSMALL = 0
	EndIf
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "Shell_GetImageLists" , "ptr" , $PLARGE , "ptr" , $PSMALL )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return DllStructGetData ( $TPTR , 1 )
EndFunc
Func _WINAPI_URLAPPLYSCHEME ( $SURL , $IFLAGS = 1 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlApplySchemeW" , "wstr" , $SURL , "wstr" , "" , "dword*" , 4096 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_URLCANONICALIZE ( $SURL , $IFLAGS )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlCanonicalizeW" , "wstr" , $SURL , "wstr" , "" , "dword*" , 4096 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_URLCOMBINE ( $SURL , $SPART , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlCombineW" , "wstr" , $SURL , "wstr" , $SPART , "wstr" , "" , "dword*" , 4096 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_URLCOMPARE ( $SURL1 , $SURL2 , $BIGNORESLASH = False )
	Local $ACALL = DllCall ( "shlwapi.dll" , "int" , "UrlCompareW" , "wstr" , $SURL1 , "wstr" , $SURL2 , "bool" , $BIGNORESLASH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_URLCREATEFROMPATH ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlCreateFromPathW" , "wstr" , $SFILEPATH , "wstr" , "" , "dword*" , 4096 , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] < 0 Or $ACALL [ 0 ] > 1 Then
		Return SetError ( 10 , $ACALL [ 0 ] , "" )
	EndIf
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_URLFIXUP ( $SURL )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlFixupW" , "wstr" , $SURL , "wstr" , "" , "dword" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_URLGETPART ( $SURL , $IPART )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlGetPartW" , "wstr" , $SURL , "wstr" , "" , "dword*" , 4096 , "dword" , $IPART , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_URLHASH ( $SURL , $ILENGTH = 32 )
	If $ILENGTH <= 0 Or $ILENGTH > 256 Then Return SetError ( 256 , 0 , 0 )
	Local $TDATA = DllStructCreate ( "byte[" & $ILENGTH & "]" )
	Local $ACALL = DllCall ( "shlwapi.dll" , "long" , "UrlHashW" , "wstr" , $SURL , "struct*" , $TDATA , "dword" , $ILENGTH )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return DllStructGetData ( $TDATA , 1 )
EndFunc
Func _WINAPI_URLIS ( $SURL , $ITYPE = 0 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "UrlIsW" , "wstr" , $SURL , "uint" , $ITYPE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __US ( $SSTRING , $ILENGTH = 0 )
	If $ILENGTH Then
		$SSTRING = StringLeft ( $SSTRING , $ILENGTH )
	Else
		$ILENGTH = StringLen ( $SSTRING )
	EndIf
	Local $TUS = DllStructCreate ( "ushort;ushort;ptr;wchar[" & ( $ILENGTH + 1 ) & "]" )
	DllStructSetData ( $TUS , 1 , 2 * StringLen ( $SSTRING ) )
	DllStructSetData ( $TUS , 2 , 2 * $ILENGTH )
	DllStructSetData ( $TUS , 3 , DllStructGetPtr ( $TUS , 4 ) )
	DllStructSetData ( $TUS , 4 , $SSTRING )
	Return $TUS
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $TAGNOTIFYICONDATA = "struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;endstruct"
Global Const $TAGNOTIFYICONDATA_V3 = $TAGNOTIFYICONDATA & ";" & $TAGGUID
Global Const $TAGNOTIFYICONDATA_V4 = $TAGNOTIFYICONDATA_V3 & ";ptr hBalloonIcon;"
Global Const $TAGSHELLEXECUTEINFO = "dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey;ptr hMonitor;ptr hProcess"
Global Const $TAGSHFILEINFO = "ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]"
Global Const $TAGSHFILEOPSTRUCT = "hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle"
Global Const $TAGSHFOLDERCUSTOMSETTINGS = "dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL"
Global Const $TAGSHSTOCKICONINFO = "dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_DEFSUBCLASSPROC ( $HWND , $IMSG , $WPARAM , $LPARAM )
	Local $ACALL = DllCall ( "comctl32.dll" , "lresult" , "DefSubclassProc" , "hwnd" , $HWND , "uint" , $IMSG , "wparam" , $WPARAM , "lparam" , $LPARAM )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DLLGETVERSION ( $SFILEPATH )
	Local $TVERSION = DllStructCreate ( "dword[5]" )
	DllStructSetData ( $TVERSION , 1 , DllStructGetSize ( $TVERSION ) , 1 )
	Local $ACALL = DllCall ( $SFILEPATH , "uint" , "DllGetVersion" , "struct*" , $TVERSION )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 4 ]
	For $I = 0 To 3
		$ARET [ $I ] = DllStructGetData ( $TVERSION , 1 , $I + 2 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_FINDEXECUTABLE ( $SFILENAME , $SDIRECTORY = "" )
	Local $ACALL = DllCall ( "shell32.dll" , "INT" , "FindExecutableW" , "wstr" , $SFILENAME , "wstr" , $SDIRECTORY , "wstr" , "" )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] <= 32 Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 3 ] )
EndFunc
Func _WINAPI_GETALLUSERSPROFILEDIRECTORY ( )
	Local $ACALL = DllCall ( "userenv.dll" , "bool" , "GetAllUsersProfileDirectoryW" , "wstr" , "" , "dword*" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_GETDEFAULTUSERPROFILEDIRECTORY ( )
	Local $ACALL = DllCall ( "userenv.dll" , "bool" , "GetDefaultUserProfileDirectoryW" , "wstr" , "" , "dword*" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_GETWINDOWSUBCLASS ( $HWND , $PSUBCLASSPROC , $IDSUBCLASS )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "GetWindowSubclass" , "hwnd" , $HWND , "ptr" , $PSUBCLASSPROC , "uint_ptr" , $IDSUBCLASS , "dword_ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _WINAPI_REMOVEWINDOWSUBCLASS ( $HWND , $PSUBCLASSPROC , $IDSUBCLASS )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "RemoveWindowSubclass" , "hwnd" , $HWND , "ptr" , $PSUBCLASSPROC , "uint_ptr" , $IDSUBCLASS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETCURRENTPROCESSEXPLICITAPPUSERMODELID ( $SAPPID )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SetCurrentProcessExplicitAppUserModelID" , "wstr" , $SAPPID )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SETWINDOWSUBCLASS ( $HWND , $PSUBCLASSPROC , $IDSUBCLASS , $PDATA = 0 )
	Local $ACALL = DllCall ( "comctl32.dll" , "bool" , "SetWindowSubclass" , "hwnd" , $HWND , "ptr" , $PSUBCLASSPROC , "uint_ptr" , $IDSUBCLASS , "dword_ptr" , $PDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLADDTORECENTDOCS ( $SFILEPATH )
	If StringStripWS ( $SFILEPATH , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
		$SFILEPATH = _WINAPI_PATHSEARCHANDQUALIFY ( $SFILEPATH , 1 )
		If Not $SFILEPATH Then
			Return SetError ( 1 , 0 , 0 )
		EndIf
	Else
		$SFILEPATH = Null
	EndIf
	DllCall ( "shell32.dll" , "none" , "SHAddToRecentDocs" , "uint" , 3 , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLCHANGENOTIFY ( $IEVENT , $IFLAGS , $IITEM1 = 0 , $IITEM2 = 0 )
	Local $STYPEOFITEM1 = "dword_ptr" , $STYPEOFITEM2 = "dword_ptr"
	If IsString ( $IITEM1 ) Then
		$STYPEOFITEM1 = "wstr"
	EndIf
	If IsString ( $IITEM2 ) Then
		$STYPEOFITEM2 = "wstr"
	EndIf
	DllCall ( "shell32.dll" , "none" , "SHChangeNotify" , "long" , $IEVENT , "uint" , $IFLAGS , $STYPEOFITEM1 , $IITEM1 , $STYPEOFITEM2 , $IITEM2 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLCHANGENOTIFYDEREGISTER ( $IID )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "SHChangeNotifyDeregister" , "ulong" , $IID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLCHANGENOTIFYREGISTER ( $HWND , $IMSG , $IEVENTS , $ISOURCES , $APATHS , $BRECURSIVE = False )
	Local $IPATH = $APATHS , $TAGSTRUCT = ""
	If IsArray ( $APATHS ) Then
		If UBound ( $APATHS , $UBOUND_COLUMNS ) Then Return SetError ( 1 , 0 , 0 )
	Else
		Dim $APATHS [ 1 ] = [ $IPATH ]
	EndIf
	For $I = 0 To UBound ( $APATHS ) + 4294967295
		If Not _WINAPI_PATHISDIRECTORY ( $APATHS [ $I ] ) Then Return SetError ( 2 , 0 , 0 )
	Next
	For $I = 0 To UBound ( $APATHS ) + 4294967295
		$TAGSTRUCT &= "ptr;int;"
	Next
	Local $TENTRY = DllStructCreate ( $TAGSTRUCT )
	For $I = 0 To UBound ( $APATHS ) + 4294967295
		$APATHS [ $I ] = _WINAPI_SHELLILCREATEFROMPATH ( _WINAPI_PATHSEARCHANDQUALIFY ( $APATHS [ $I ] ) )
		DllStructSetData ( $TENTRY , 2 * $I + 1 , $APATHS [ $I ] )
		DllStructSetData ( $TENTRY , 2 * $I + 2 , $BRECURSIVE )
	Next
	Local $IERROR = 0
	Local $ACALL = DllCall ( "shell32.dll" , "ulong" , "SHChangeNotifyRegister" , "hwnd" , $HWND , "int" , $ISOURCES , "long" , $IEVENTS , "uint" , $IMSG , "int" , UBound ( $APATHS ) , "struct*" , $TENTRY )
	If @error Or Not $ACALL [ 0 ] Then $IERROR = @error + 10
	For $I = 0 To UBound ( $APATHS ) + 4294967295
		_WINAPI_COTASKMEMFREE ( $APATHS [ $I ] )
	Next
	Return SetError ( $IERROR , 0 , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_SHELLCREATEDIRECTORY ( $SFILEPATH , $HPARENT = 0 , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "SHCreateDirectoryExW" , "hwnd" , $HPARENT , "wstr" , $SFILEPATH , "struct*" , $TSECURITY )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLEMPTYRECYCLEBIN ( $SROOT = "" , $IFLAGS = 0 , $HPARENT = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHEmptyRecycleBinW" , "hwnd" , $HPARENT , "wstr" , $SROOT , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLEXECUTE ( $SFILEPATH , $SARGS = "" , $SDIR = "" , $SVERB = "" , $ISHOW = 1 , $HPARENT = 0 )
	If Not StringStripWS ( $SARGS , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SARGS = Null
	If Not StringStripWS ( $SDIR , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SDIR = Null
	If Not StringStripWS ( $SVERB , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SVERB = Null
	Local $ACALL = DllCall ( "shell32.dll" , "ULONG_PTR" , "ShellExecuteW" , "hwnd" , $HPARENT , "wstr" , $SVERB , "wstr" , $SFILEPATH , "wstr" , $SARGS , "wstr" , $SDIR , "int" , $ISHOW )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] <= 32 Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLEXECUTEEX ( ByRef $TSHEXINFO )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "ShellExecuteExW" , "struct*" , $TSHEXINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLEXTRACTASSOCIATEDICON ( $SFILEPATH , $BSMALL = False )
	Local $IFLAGS = 256
	If Not _WINAPI_PATHISDIRECTORY ( $SFILEPATH ) Then
		$IFLAGS = BitOR ( $IFLAGS , 16 )
	EndIf
	If $BSMALL Then
		$IFLAGS = BitOR ( $IFLAGS , 1 )
	EndIf
	Local $TSHFILEINFO = DllStructCreate ( $TAGSHFILEINFO )
	If Not _WINAPI_SHELLGETFILEINFO ( $SFILEPATH , $IFLAGS , 0 , $TSHFILEINFO ) Then Return SetError ( @error + 10 , @extended , 0 )
	Return DllStructGetData ( $TSHFILEINFO , "hIcon" )
EndFunc
Func _WINAPI_SHELLEXTRACTICON ( $SICON , $IINDEX , $IWIDTH , $IHEIGHT )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "SHExtractIconsW" , "wstr" , $SICON , "int" , $IINDEX , "int" , $IWIDTH , "int" , $IHEIGHT , "ptr*" , 0 , "ptr*" , 0 , "int" , 1 , "int" , 0 )
	If @error Or Not $ACALL [ 0 ] Or Not $ACALL [ 5 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_SHELLFILEOPERATION ( $SFROM , $STO , $IFUNC , $IFLAGS , $STITLE = "" , $HPARENT = 0 )
	Local $IDATA
	If Not IsArray ( $SFROM ) Then
		$IDATA = $SFROM
		Dim $SFROM [ 1 ] = [ $IDATA ]
	EndIf
	Local $TFROM = _WINAPI_ARRAYTOSTRUCT ( $SFROM )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	If Not IsArray ( $STO ) Then
		$IDATA = $STO
		Dim $STO [ 1 ] = [ $IDATA ]
	EndIf
	Local $TTO = _WINAPI_ARRAYTOSTRUCT ( $STO )
	If @error Then Return SetError ( @error + 30 , @extended , 0 )
	Local $TSHFILEOPSTRUCT = DllStructCreate ( $TAGSHFILEOPSTRUCT )
	DllStructSetData ( $TSHFILEOPSTRUCT , "hWnd" , $HPARENT )
	DllStructSetData ( $TSHFILEOPSTRUCT , "Func" , $IFUNC )
	DllStructSetData ( $TSHFILEOPSTRUCT , "From" , DllStructGetPtr ( $TFROM ) )
	DllStructSetData ( $TSHFILEOPSTRUCT , "To" , DllStructGetPtr ( $TTO ) )
	DllStructSetData ( $TSHFILEOPSTRUCT , "Flags" , $IFLAGS )
	DllStructSetData ( $TSHFILEOPSTRUCT , "ProgressTitle" , $STITLE )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "SHFileOperationW" , "struct*" , $TSHFILEOPSTRUCT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TSHFILEOPSTRUCT
EndFunc
Func _WINAPI_SHELLFLUSHSFCACHE ( )
	DllCall ( "shell32.dll" , "none" , "SHFlushSFCache" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLGETFILEINFO ( $SFILEPATH , $IFLAGS , $IATTRIBUTES , ByRef $TSHFILEINFO )
	Local $ACALL = DllCall ( "shell32.dll" , "dword_ptr" , "SHGetFileInfoW" , "wstr" , $SFILEPATH , "dword" , $IATTRIBUTES , "struct*" , $TSHFILEINFO , "uint" , DllStructGetSize ( $TSHFILEINFO ) , "uint" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLGETICONOVERLAYINDEX ( $SICON , $IINDEX )
	If Not StringStripWS ( $SICON , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SICON = Null
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "SHGetIconOverlayIndexW" , "wstr" , $SICON , "int" , $IINDEX )
	If @error Or ( $ACALL [ 0 ] = + 4294967295 ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLGETKNOWNFOLDERIDLIST ( $SGUID , $IFLAGS = 0 , $HTOKEN = 0 )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "uint" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	$ACALL = DllCall ( "shell32.dll" , "uint" , "SHGetKnownFolderIDList" , "struct*" , $TGUID , "dword" , $IFLAGS , "handle" , $HTOKEN , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _WINAPI_SHELLGETKNOWNFOLDERPATH ( $SGUID , $IFLAGS = 0 , $HTOKEN = 0 )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	$ACALL = DllCall ( "shell32.dll" , "long" , "SHGetKnownFolderPath" , "struct*" , $TGUID , "dword" , $IFLAGS , "handle" , $HTOKEN , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Local $SPATH = _WINAPI_GETSTRING ( $ACALL [ 4 ] )
	_WINAPI_COTASKMEMFREE ( $ACALL [ 4 ] )
	Return $SPATH
EndFunc
Func _WINAPI_SHELLGETLOCALIZEDNAME ( $SFILEPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHGetLocalizedName" , "wstr" , $SFILEPATH , "wstr" , "" , "uint*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 2 ]
	Local $ACALL1 = DllCall ( "kernel32.dll" , "dword" , "ExpandEnvironmentStringsW" , "wstr" , $ACALL [ 2 ] , "wstr" , "" , "dword" , 4096 )
	$ARET [ 0 ] = $ACALL1 [ 2 ]
	$ARET [ 1 ] = $ACALL [ 4 ]
	Return $ARET
EndFunc
Func _WINAPI_SHELLGETPATHFROMIDLIST ( $PPIDL )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "SHGetPathFromIDListW" , "struct*" , $PPIDL , "wstr" , "" )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_SHELLGETSETFOLDERCUSTOMSETTINGS ( $SFILEPATH , $IFLAG , ByRef $TSHFCS )
	Local $SPROC = "SHGetSetFolderCustomSettings"
	If _WINAPI_GETVERSION ( ) < 6.0 Then $SPROC &= "W"
	Local $ACALL = DllCall ( "shell32.dll" , "long" , $SPROC , "struct*" , $TSHFCS , "wstr" , $SFILEPATH , "dword" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLGETSETTINGS ( $IFLAGS )
	Local $TSHELLSTATE = DllStructCreate ( "uint[8]" )
	DllCall ( "shell32.dll" , "none" , "SHGetSetSettings" , "struct*" , $TSHELLSTATE , "dword" , $IFLAGS , "bool" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $IVAL1 = DllStructGetData ( $TSHELLSTATE , 1 , 1 )
	Local $IVAL2 = DllStructGetData ( $TSHELLSTATE , 1 , 8 )
	Local $IRESULT = 0
	Local $AOPT [ 20 ] [ 2 ] = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 4 , 32768 ] , [ 8 , 32 ] , [ 16 , 8 ] , [ 32 , 128 ] , [ 64 , 512 ] , [ 128 , 1024 ] , [ 256 , 2048 ] , [ 1024 , 4096 ] , [ 2048 , 8192 ] , [ 4096 , 16384 ] , [ 8192 , 131072 ] , [ 32768 , 262144 ] , [ 65536 , 1048576 ] , [ 1 , 524288 ] , [ 2 , 2097152 ] , [ 8 , 8388608 ] , [ 16 , 16777216 ] , [ 32 , 33554432 ] ]
	For $I = 0 To 14
		If BitAND ( $IVAL1 , $AOPT [ $I ] [ 0 ] ) Then
			$IRESULT += $AOPT [ $I ] [ 1 ]
		EndIf
	Next
	For $I = 15 To 19
		If BitAND ( $IVAL2 , $AOPT [ $I ] [ 0 ] ) Then
			$IRESULT += $AOPT [ $I ] [ 1 ]
		EndIf
	Next
	Return $IRESULT
EndFunc
Func _WINAPI_SHELLGETSPECIALFOLDERLOCATION ( $ICSIDL )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHGetSpecialFolderLocation" , "hwnd" , 0 , "int" , $ICSIDL , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_SHELLGETSPECIALFOLDERPATH ( $ICSIDL , $BCREATE = False )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "SHGetSpecialFolderPathW" , "hwnd" , 0 , "wstr" , "" , "int" , $ICSIDL , "bool" , $BCREATE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_SHELLGETSTOCKICONINFO ( $ISIID , $IFLAGS )
	Local $TSHSTOCKICONINFO = DllStructCreate ( $TAGSHSTOCKICONINFO )
	DllStructSetData ( $TSHSTOCKICONINFO , "Size" , DllStructGetSize ( $TSHSTOCKICONINFO ) )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHGetStockIconInfo" , "int" , $ISIID , "uint" , $IFLAGS , "struct*" , $TSHSTOCKICONINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TSHSTOCKICONINFO
EndFunc
Func _WINAPI_SHELLILCREATEFROMPATH ( $SFILEPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHILCreateFromPath" , "wstr" , $SFILEPATH , "ptr*" , 0 , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_SHELLNOTIFYICON ( $IMESSAGE , ByRef $TNOTIFYICONDATA )
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "Shell_NotifyIconW" , "dword" , $IMESSAGE , "struct*" , $TNOTIFYICONDATA )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLNOTIFYICONGETRECT ( $HWND , $IID , $TGUID = 0 )
	Local $TNII = DllStructCreate ( "dword;hwnd;uint;" & $TAGGUID )
	DllStructSetData ( $TNII , 1 , DllStructGetSize ( $TNII ) )
	DllStructSetData ( $TNII , 2 , $HWND )
	DllStructSetData ( $TNII , 3 , $IID )
	If IsDllStruct ( $TGUID ) Then
		If Not _WINAPI_MOVEMEMORY ( DllStructGetPtr ( $TNII , 4 ) , $TGUID , 16 ) Then Return SetError ( @error + 10 , @extended , 0 )
	EndIf
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "Shell_NotifyIconGetRect" , "struct*" , $TNII , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_SHELLOBJECTPROPERTIES ( $SFILEPATH , $ITYPE = 2 , $SPROPERTY = "" , $HPARENT = 0 )
	If Not StringStripWS ( $SPROPERTY , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SPROPERTY = Null
	Local $ACALL = DllCall ( "shell32.dll" , "bool" , "SHObjectProperties" , "hwnd" , $HPARENT , "dword" , $ITYPE , "wstr" , $SFILEPATH , "wstr" , $SPROPERTY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLOPENFOLDERANDSELECTITEMS ( $SFILEPATH , $ANAMES = 0 , $ISTART = 0 , $IEND = + 4294967295 , $IFLAGS = 0 )
	Local $PPIDL , $ACALL , $TPTR = 0 , $ICOUNT = 0 , $IOBJ = 0 , $IERROR = 0
	$SFILEPATH = _WINAPI_PATHREMOVEBACKSLASH ( _WINAPI_PATHSEARCHANDQUALIFY ( $SFILEPATH ) )
	If IsArray ( $ANAMES ) Then
		If $SFILEPATH And Not _WINAPI_PATHISDIRECTORY ( $SFILEPATH ) Then Return SetError ( @error + 20 , @extended , 0 )
	EndIf
	$PPIDL = _WINAPI_SHELLILCREATEFROMPATH ( $SFILEPATH )
	If @error Then Return SetError ( @error + 30 , @extended , 0 )
	If Not __CHECKERRORARRAYBOUNDS ( $ANAMES , $ISTART , $IEND ) Then
		$TPTR = DllStructCreate ( "ptr[" & ( $IEND - $ISTART + 1 ) & "]" )
		For $I = $ISTART To $IEND
			$ICOUNT += 1
			If $ANAMES [ $I ] Then
				DllStructSetData ( $TPTR , 1 , _WINAPI_SHELLILCREATEFROMPATH ( $SFILEPATH & "\" & $ANAMES [ $I ] ) , $ICOUNT )
			Else
				DllStructSetData ( $TPTR , 1 , 0 , $ICOUNT )
			EndIf
		Next
	EndIf
	If _WINAPI_COINITIALIZE ( ) Then $IOBJ = 1
	$ACALL = DllCall ( "shell32.dll" , "long" , "SHOpenFolderAndSelectItems" , "ptr" , $PPIDL , "uint" , $ICOUNT , "struct*" , $TPTR , "dword" , $IFLAGS )
	If @error Then
		$IERROR = @error + 10
	Else
		If $ACALL [ 0 ] Then $IERROR = 10
	EndIf
	If $IOBJ Then _WINAPI_COUNINITIALIZE ( )
	_WINAPI_COTASKMEMFREE ( $PPIDL )
	For $I = 1 To $ICOUNT
		$PPIDL = DllStructGetData ( $TPTR , $I )
		If $PPIDL Then
			_WINAPI_COTASKMEMFREE ( $PPIDL )
		EndIf
	Next
	If $IERROR = 10 Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLQUERYRECYCLEBIN ( $SROOT = "" )
	Local $TAGSHQUERYRBINFO = ( @AutoItX64 ? "" : "align 1;" ) & "dword cbSize;int64 Size;int64 nbFiles"
	Local $TSHQRBI = DllStructCreate ( $TAGSHQUERYRBINFO )
	DllStructSetData ( $TSHQRBI , 1 , DllStructGetSize ( $TSHQRBI ) )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHQueryRecycleBinW" , "wstr" , $SROOT , "struct*" , $TSHQRBI )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 2 ]
	$ARET [ 0 ] = DllStructGetData ( $TSHQRBI , 2 )
	$ARET [ 1 ] = DllStructGetData ( $TSHQRBI , 3 )
	Return $ARET
EndFunc
Func _WINAPI_SHELLQUERYUSERNOTIFICATIONSTATE ( )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHQueryUserNotificationState" , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_SHELLREMOVELOCALIZEDNAME ( $SFILEPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHRemoveLocalizedName" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLRESTRICTED ( $IRESTRICTION )
	Local $ACALL = DllCall ( "shell32.dll" , "dword" , "SHRestricted" , "uint" , $IRESTRICTION )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLSETKNOWNFOLDERPATH ( $SGUID , $SFILEPATH , $IFLAGS = 0 , $HTOKEN = 0 )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	Local $ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $SGUID , "struct*" , $TGUID )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	$ACALL = DllCall ( "shell32.dll" , "long" , "SHSetKnownFolderPath" , "struct*" , $TGUID , "dword" , $IFLAGS , "handle" , $HTOKEN , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLSETLOCALIZEDNAME ( $SFILEPATH , $SMODULE , $IRESID )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHSetLocalizedName" , "wstr" , $SFILEPATH , "wstr" , $SMODULE , "int" , $IRESID )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLSETSETTINGS ( $IFLAGS , $BSET )
	Local $IVAL1 = 0 , $IVAL2 = 0
	Local $AOPT [ 20 ] [ 2 ] = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 4 , 32768 ] , [ 8 , 32 ] , [ 16 , 8 ] , [ 32 , 128 ] , [ 64 , 512 ] , [ 128 , 1024 ] , [ 256 , 2048 ] , [ 1024 , 4096 ] , [ 2048 , 8192 ] , [ 4096 , 16384 ] , [ 8192 , 131072 ] , [ 32768 , 262144 ] , [ 65536 , 1048576 ] , [ 1 , 524288 ] , [ 2 , 2097152 ] , [ 8 , 8388608 ] , [ 16 , 16777216 ] , [ 32 , 33554432 ] ]
	If $BSET Then
		For $I = 0 To 14
			If BitAND ( $IFLAGS , $AOPT [ $I ] [ 1 ] ) Then
				$IVAL1 += $AOPT [ $I ] [ 0 ]
			EndIf
		Next
		For $I = 15 To 19
			If BitAND ( $IFLAGS , $AOPT [ $I ] [ 1 ] ) Then
				$IVAL2 += $AOPT [ $I ] [ 0 ]
			EndIf
		Next
	EndIf
	Local $TSHELLSTATE = DllStructCreate ( "uint[8]" )
	DllStructSetData ( $TSHELLSTATE , 1 , $IVAL1 , 1 )
	DllStructSetData ( $TSHELLSTATE , 1 , $IVAL2 , 8 )
	DllCall ( "shell32.dll" , "none" , "SHGetSetSettings" , "struct*" , $TSHELLSTATE , "dword" , $IFLAGS , "bool" , 1 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLUPDATEIMAGE ( $SICON , $IINDEX , $IIMAGE , $IFLAGS = 0 )
	DllCall ( "shell32.dll" , "none" , "SHUpdateImageW" , "wstr" , $SICON , "int" , $IINDEX , "uint" , $IFLAGS , "int" , $IIMAGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global $__G_PFRBUFFER = 0 , $__G_IFRBUFFERSIZE = 16385
Global Const $TAGDEVNAMES = "ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default"
Global Const $TAGFINDREPLACE = "dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName"
Global Const $TAGMSGBOXPARAMS = "uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId"
Global Const $TAGPAGESETUPDLG = "dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate"
Global Const $TAGPRINTDLG = ( @AutoItX64 ? "" : "align 1;" ) & "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate"
Global Const $TAGPRINTDLGEX = "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction"
Global Const $TAGPRINTPAGERANGE = "dword FromPage;dword ToPage"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_BROWSEFORFOLDERDLG ( $SROOT = "" , $STEXT = "" , $IFLAGS = 0 , $PBROWSEPROC = 0 , $LPARAM = 0 , $HPARENT = 0 )
	Local Const $TAGBROWSEINFO = "hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage"
	Local $TBROWSEINFO = DllStructCreate ( $TAGBROWSEINFO & ";wchar[" & ( StringLen ( $STEXT ) + 1 ) & "];wchar[260]" )
	Local $PPIDL = 0 , $SRESULT = ""
	If StringStripWS ( $SROOT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
		Local $SPATH = _WINAPI_PATHSEARCHANDQUALIFY ( $SROOT , 1 )
		If @error Then
			$SPATH = $SROOT
		EndIf
		$PPIDL = _WINAPI_SHELLILCREATEFROMPATH ( $SPATH )
		If @error Then
		EndIf
	EndIf
	DllStructSetData ( $TBROWSEINFO , 1 , $HPARENT )
	DllStructSetData ( $TBROWSEINFO , 2 , $PPIDL )
	DllStructSetData ( $TBROWSEINFO , 3 , DllStructGetPtr ( $TBROWSEINFO , 10 ) )
	DllStructSetData ( $TBROWSEINFO , 4 , DllStructGetPtr ( $TBROWSEINFO , 9 ) )
	DllStructSetData ( $TBROWSEINFO , 5 , $IFLAGS )
	DllStructSetData ( $TBROWSEINFO , 6 , $PBROWSEPROC )
	DllStructSetData ( $TBROWSEINFO , 7 , $LPARAM )
	DllStructSetData ( $TBROWSEINFO , 8 , 0 )
	DllStructSetData ( $TBROWSEINFO , 9 , $STEXT )
	Local $ACALL = DllCall ( "shell32.dll" , "ptr" , "SHBrowseForFolderW" , "struct*" , $TBROWSEINFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	$SRESULT = _WINAPI_SHELLGETPATHFROMIDLIST ( $ACALL [ 0 ] )
	_WINAPI_COTASKMEMFREE ( $ACALL [ 0 ] )
	If $PPIDL Then
		_WINAPI_COTASKMEMFREE ( $PPIDL )
	EndIf
	If Not $SRESULT Then Return SetError ( 10 , 0 , "" )
	Return $SRESULT
EndFunc
Func _WINAPI_COMMDLGEXTENDEDERROR ( )
	Local Const $CDERR_DIALOGFAILURE = 65535
	Local Const $CDERR_FINDRESFAILURE = 6
	Local Const $CDERR_INITIALIZATION = 2
	Local Const $CDERR_LOADRESFAILURE = 7
	Local Const $CDERR_LOADSTRFAILURE = 5
	Local Const $CDERR_LOCKRESFAILURE = 8
	Local Const $CDERR_MEMALLOCFAILURE = 9
	Local Const $CDERR_MEMLOCKFAILURE = 10
	Local Const $CDERR_NOHINSTANCE = 4
	Local Const $CDERR_NOHOOK = 11
	Local Const $CDERR_NOTEMPLATE = 3
	Local Const $CDERR_REGISTERMSGFAIL = 12
	Local Const $CDERR_STRUCTSIZE = 1
	Local Const $FNERR_BUFFERTOOSMALL = 12291
	Local Const $FNERR_INVALIDFILENAME = 12290
	Local Const $FNERR_SUBCLASSFAILURE = 12289
	Local $ACALL = DllCall ( "comdlg32.dll" , "dword" , "CommDlgExtendedError" )
	If Not @error Then
		Switch $ACALL [ 0 ]
		Case $CDERR_DIALOGFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle." )
		Case $CDERR_FINDRESFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function failed to find a specified resource." )
		Case $CDERR_INITIALIZATION
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available." )
		Case $CDERR_LOADRESFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function failed to load a specified resource." )
		Case $CDERR_LOADSTRFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function failed to load a specified string." )
		Case $CDERR_LOCKRESFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function failed to lock a specified resource." )
		Case $CDERR_MEMALLOCFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function was unable to allocate memory for internal structures." )
		Case $CDERR_MEMLOCKFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "The common dialog box function was unable to lock the memory associated with a handle." )
		Case $CDERR_NOHINSTANCE
			Return SetError ( $ACALL [ 0 ] , 0 , "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle." )
		Case $CDERR_NOHOOK
			Return SetError ( $ACALL [ 0 ] , 0 , "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure." )
		Case $CDERR_NOTEMPLATE
			Return SetError ( $ACALL [ 0 ] , 0 , "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template." )
		Case $CDERR_REGISTERMSGFAIL
			Return SetError ( $ACALL [ 0 ] , 0 , "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function." )
		Case $CDERR_STRUCTSIZE
			Return SetError ( $ACALL [ 0 ] , 0 , "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid" )
		Case $FNERR_BUFFERTOOSMALL
			Return SetError ( $ACALL [ 0 ] , 0 , "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name." )
		Case $FNERR_INVALIDFILENAME
			Return SetError ( $ACALL [ 0 ] , 0 , "A file name is invalid." )
		Case $FNERR_SUBCLASSFAILURE
			Return SetError ( $ACALL [ 0 ] , 0 , "An attempt to subclass a list box failed because sufficient memory was not available." )
		EndSwitch
	EndIf
	Return SetError ( @error , @extended , "0x" & Hex ( $ACALL [ 0 ] ) )
EndFunc
Func _WINAPI_COMMDLGEXTENDEDERROREX ( )
	Local $ACALL = DllCall ( "comdlg32.dll" , "dword" , "CommDlgExtendedError" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CONFIRMCREDENTIALS ( $STARGET , $BCONFIRM )
	If Not __DLL ( "credui.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $ACALL = DllCall ( "credui.dll" , "dword" , "CredUIConfirmCredentialsW" , "wstr" , $STARGET , "bool" , $BCONFIRM )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_FINDTEXTDLG ( $HOWNER , $SFINDWHAT = "" , $IFLAGS = 0 , $PFINDPROC = 0 , $LPARAM = 0 )
	$__G_PFRBUFFER = __HEAPREALLOC ( $__G_PFRBUFFER , 2 * $__G_IFRBUFFERSIZE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	DllStructSetData ( DllStructCreate ( "wchar[" & $__G_IFRBUFFERSIZE & "]" , $__G_PFRBUFFER ) , 1 , StringLeft ( $SFINDWHAT , $__G_IFRBUFFERSIZE + 4294967295 ) )
	Local $TFR = DllStructCreate ( $TAGFINDREPLACE )
	DllStructSetData ( $TFR , "Size" , DllStructGetSize ( $TFR ) )
	DllStructSetData ( $TFR , "hOwner" , $HOWNER )
	DllStructSetData ( $TFR , "hInstance" , 0 )
	DllStructSetData ( $TFR , "Flags" , $IFLAGS )
	DllStructSetData ( $TFR , "FindWhat" , $__G_PFRBUFFER )
	DllStructSetData ( $TFR , "ReplaceWith" , 0 )
	DllStructSetData ( $TFR , "FindWhatLen" , $__G_IFRBUFFERSIZE * 2 )
	DllStructSetData ( $TFR , "ReplaceWithLen" , 0 )
	DllStructSetData ( $TFR , "lParam" , $LPARAM )
	DllStructSetData ( $TFR , "Hook" , $PFINDPROC )
	DllStructSetData ( $TFR , "TemplateName" , 0 )
	Local $ACALL = DllCall ( "comdlg32.dll" , "hwnd" , "FindTextW" , "struct*" , $TFR )
	If @error Or Not $ACALL [ 0 ] Then
		Local $IERROR = @error + 30
		__HEAPFREE ( $__G_PFRBUFFER )
		If IsArray ( $ACALL ) Then
			Return SetError ( 10 , _WINAPI_COMMDLGEXTENDEDERROREX ( ) , 0 )
		Else
			Return SetError ( $IERROR , @extended , 0 )
		EndIf
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FLUSHFRBUFFER ( )
	If Not __HEAPFREE ( $__G_PFRBUFFER , 1 ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_FORMATDRIVEDLG ( $SDRIVE , $IOPTION = 0 , $HPARENT = 0 )
	If Not IsString ( $SDRIVE ) Then Return SetError ( 10 , 0 , 0 )
	$SDRIVE = StringLeft ( StringUpper ( StringStripWS ( $SDRIVE , $STR_STRIPLEADING ) ) , 1 )
	If Not $SDRIVE Then Return SetError ( 11 , 0 , 0 )
	$SDRIVE = Asc ( $SDRIVE ) + 4294967231
	If ( $SDRIVE < 0 ) Or ( $SDRIVE > 25 ) Then Return SetError ( 12 , 0 , 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "dword" , "SHFormatDrive" , "hwnd" , $HPARENT , "uint" , $SDRIVE , "uint" , 65535 , "uint" , $IOPTION )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] < 0 Then Return SetError ( $ACALL [ 0 ] , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCONNECTEDDLG ( $IDLG , $IFLAGS = 0 , $HPARENT = 0 )
	If Not __DLL ( "connect.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Switch $IDLG
	Case 0
		$IDLG = "GetNetworkConnected"
	Case 1
		$IDLG = "GetInternetConnected"
	Case 2
		$IDLG = "GetVPNConnected"
Case Else
		Return SetError ( 1 , 0 , 0 )
	EndSwitch
	Local $SSTR = ""
	If BitAND ( $IFLAGS , 1 ) Then
		$SSTR &= "-SkipInternetDetection "
	EndIf
	If BitAND ( $IFLAGS , 2 ) Then
		$SSTR &= "-SkipExistingConnections "
	EndIf
	If BitAND ( $IFLAGS , 4 ) Then
		$SSTR &= "-HideFinishPage "
	EndIf
	Local $ACALL = DllCall ( "connect.dll" , "long" , $IDLG , "hwnd" , $HPARENT , "dword" , 0 , "dword" , 0 , "dword" , 0 , "handle" , 0 , "wstr" , StringStripWS ( $SSTR , $STR_STRIPTRAILING ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not ( $ACALL [ 0 ] = 0 Or $ACALL [ 0 ] = 1 ) Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return Number ( Not $ACALL [ 0 ] )
EndFunc
Func _WINAPI_GETFRBUFFER ( )
	Return $__G_IFRBUFFERSIZE + 4294967295
EndFunc
Func _WINAPI_GETOPENFILENAME ( $STITLE = "" , $SFILTER = "All files (*.*)" , $SINITALDIR = "." , $SDEFAULTFILE = "" , $SDEFAULTEXT = "" , $IFILTERINDEX = 1 , $IFLAGS = 0 , $IFLAGSEX = 0 , $HWNDOWNER = 0 )
	Local $VRESULT = __OFNDLG ( 0 , $STITLE , $SINITALDIR , $SFILTER , $IFILTERINDEX , $SDEFAULTFILE , $SDEFAULTEXT , $IFLAGS , $IFLAGSEX , 0 , 0 , $HWNDOWNER )
	If @error Then Return SetError ( @error , @extended , $VRESULT )
	If BitAND ( $IFLAGS , $OFN_ALLOWMULTISELECT ) Then
		Return __WINAPI_PARSEMULTISELECTFILEDIALOGPATH ( $VRESULT )
	Else
		Return __WINAPI_PARSEFILEDIALOGPATH ( $VRESULT )
	EndIf
EndFunc
Func _WINAPI_GETSAVEFILENAME ( $STITLE = "" , $SFILTER = "All files (*.*)" , $SINITALDIR = "." , $SDEFAULTFILE = "" , $SDEFAULTEXT = "" , $IFILTERINDEX = 1 , $IFLAGS = 0 , $IFLAGSEX = 0 , $HWNDOWNER = 0 )
	Local $VRETURN = __OFNDLG ( 1 , $STITLE , $SINITALDIR , $SFILTER , $IFILTERINDEX , $SDEFAULTFILE , $SDEFAULTEXT , $IFLAGS , $IFLAGSEX , 0 , 0 , $HWNDOWNER )
	If @error Then Return SetError ( @error , @extended , $VRETURN )
	Return __WINAPI_PARSEFILEDIALOGPATH ( $VRETURN )
EndFunc
Func _WINAPI_MESSAGEBOXCHECK ( $ITYPE , $STITLE , $STEXT , $SREGVAL , $IDEFAULT = + 4294967295 , $HPARENT = 0 )
	Local $ACALL = DllCall ( "shlwapi.dll" , "int" , "SHMessageBoxCheckW" , "hwnd" , $HPARENT , "wstr" , $STEXT , "wstr" , $STITLE , "uint" , $ITYPE , "int" , $IDEFAULT , "wstr" , $SREGVAL )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MESSAGEBOXINDIRECT ( $TMSGBOXPARAMS )
	Local $ACALL = DllCall ( "user32.dll" , "int" , "MessageBoxIndirectW" , "struct*" , $TMSGBOXPARAMS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENFILEDLG ( $STITLE = "" , $SINITDIR = "" , $SFILTERS = "" , $IDEFAULTFILTER = 0 , $SDEFAULTFILEPATH = "" , $SDEFAULTEXT = "" , $IFLAGS = 0 , $IFLAGSEX = 0 , $POFNPROC = 0 , $PDATA = 0 , $HPARENT = 0 )
	Local $VRESULT = __OFNDLG ( 0 , $STITLE , $SINITDIR , $SFILTERS , $IDEFAULTFILTER , $SDEFAULTFILEPATH , $SDEFAULTEXT , $IFLAGS , $IFLAGSEX , $POFNPROC , $PDATA , $HPARENT )
	If @error Then Return SetError ( @error , @extended , $VRESULT )
	Return $VRESULT
EndFunc
Func _WINAPI_PAGESETUPDLG ( ByRef $TPAGESETUPDLG )
	Local $ACALL = DllCall ( "comdlg32.dll" , "int" , "PageSetupDlgW" , "struct*" , $TPAGESETUPDLG )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_COMMDLGEXTENDEDERROREX ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PICKICONDLG ( $SICON = "" , $IINDEX = 0 , $HPARENT = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "PickIconDlg" , "hwnd" , $HPARENT , "wstr" , $SICON , "int" , 4096 , "int*" , $IINDEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 2 ]
	Local $ARES = DllCall ( "kernel32.dll" , "dword" , "ExpandEnvironmentStringsW" , "wstr" , $ACALL [ 2 ] , "wstr" , "" , "dword" , 4096 )
	$ARET [ 0 ] = $ARES [ 2 ]
	$ARET [ 1 ] = $ACALL [ 4 ]
	Return $ARET
EndFunc
Func _WINAPI_PRINTDLG ( ByRef $TPRINTDLG )
	Local $ACALL = DllCall ( "comdlg32.dll" , "long" , "PrintDlgW" , "struct*" , $TPRINTDLG )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_COMMDLGEXTENDEDERROREX ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PRINTDLGEX ( ByRef $TPRINTDLGEX )
	Local $TPDEX = DllStructCreate ( $TAGPRINTDLGEX , DllStructGetPtr ( $TPRINTDLGEX ) )
	Local $ACALL = DllCall ( "comdlg32.dll" , "long" , "PrintDlgExW" , "struct*" , $TPDEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return SetExtended ( DllStructGetData ( $TPDEX , "ResultAction" ) , 1 )
EndFunc
Func _WINAPI_REPLACETEXTDLG ( $HOWNER , $SFINDWHAT = "" , $SREPLACEWITH = "" , $IFLAGS = 0 , $PREPLACEPROC = 0 , $LPARAM = 0 )
	$__G_PFRBUFFER = __HEAPREALLOC ( $__G_PFRBUFFER , 4 * $__G_IFRBUFFERSIZE )
	If @error Then Return SetError ( @error + 100 , @extended , 0 )
	Local $TBUFF = DllStructCreate ( "wchar[" & $__G_IFRBUFFERSIZE & "];wchar[" & $__G_IFRBUFFERSIZE & "]" , $__G_PFRBUFFER )
	DllStructSetData ( $TBUFF , 1 , StringLeft ( $SFINDWHAT , $__G_IFRBUFFERSIZE + 4294967295 ) )
	DllStructSetData ( $TBUFF , 2 , StringLeft ( $SREPLACEWITH , $__G_IFRBUFFERSIZE + 4294967295 ) )
	Local $TFR = DllStructCreate ( $TAGFINDREPLACE )
	DllStructSetData ( $TFR , "Size" , DllStructGetSize ( $TFR ) )
	DllStructSetData ( $TFR , "hOwner" , $HOWNER )
	DllStructSetData ( $TFR , "hInstance" , 0 )
	DllStructSetData ( $TFR , "Flags" , $IFLAGS )
	DllStructSetData ( $TFR , "FindWhat" , DllStructGetPtr ( $TBUFF , 1 ) )
	DllStructSetData ( $TFR , "ReplaceWith" , DllStructGetPtr ( $TBUFF , 2 ) )
	DllStructSetData ( $TFR , "FindWhatLen" , $__G_IFRBUFFERSIZE * 2 )
	DllStructSetData ( $TFR , "ReplaceWithLen" , $__G_IFRBUFFERSIZE * 2 )
	DllStructSetData ( $TFR , "lParam" , $LPARAM )
	DllStructSetData ( $TFR , "Hook" , $PREPLACEPROC )
	DllStructSetData ( $TFR , "TemplateName" , 0 )
	Local $ACALL = DllCall ( "comdlg32.dll" , "hwnd" , "ReplaceTextW" , "struct*" , $TFR )
	If @error Or Not $ACALL [ 0 ] Then
		Local $IERROR = @error
		__HEAPFREE ( $__G_PFRBUFFER )
		If IsArray ( $ACALL ) Then
			Return SetError ( 10 , _WINAPI_COMMDLGEXTENDEDERROREX ( ) , 0 )
		Else
			Return SetError ( $IERROR , 0 , 0 )
		EndIf
	EndIf
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RESTARTDLG ( $STEXT = "" , $IFLAGS = 2 , $HPARENT = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "RestartDialog" , "hwnd" , $HPARENT , "wstr" , $STEXT , "int" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SAVEFILEDLG ( $STITLE = "" , $SINITDIR = "" , $SFILTERS = "" , $IDEFAULTFILTER = 0 , $SDEFAULTFILEPATH = "" , $SDEFAULTEXT = "" , $IFLAGS = 0 , $IFLAGSEX = 0 , $POFNPROC = 0 , $PDATA = 0 , $HPARENT = 0 )
	Local $VRESULT = __OFNDLG ( 1 , $STITLE , $SINITDIR , $SFILTERS , $IDEFAULTFILTER , $SDEFAULTFILEPATH , $SDEFAULTEXT , $IFLAGS , $IFLAGSEX , $POFNPROC , $PDATA , $HPARENT )
	If @error Then Return SetError ( @error , @extended , $VRESULT )
	Return $VRESULT
EndFunc
Func _WINAPI_SETFRBUFFER ( $ICHARS )
	$ICHARS = Number ( $ICHARS )
	If $ICHARS < 80 Then
		$ICHARS = 80
	EndIf
	$__G_IFRBUFFERSIZE = $ICHARS + 1
	Return 1
EndFunc
Func _WINAPI_SHELLABOUTDLG ( $STITLE , $SNAME , $STEXT , $HICON = 0 , $HPARENT = 0 )
	Local $ACALL = DllCall ( "shell32.dll" , "int" , "ShellAboutW" , "hwnd" , $HPARENT , "wstr" , $STITLE & "#" & $SNAME , "wstr" , $STEXT , "handle" , $HICON )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SHELLOPENWITHDLG ( $SFILEPATH , $IFLAGS = 0 , $HPARENT = 0 )
	Local $TOPENASINFO = DllStructCreate ( "ptr;ptr;dword;wchar[" & ( StringLen ( $SFILEPATH ) + 1 ) & "]" )
	DllStructSetData ( $TOPENASINFO , 1 , DllStructGetPtr ( $TOPENASINFO , 4 ) )
	DllStructSetData ( $TOPENASINFO , 2 , 0 )
	DllStructSetData ( $TOPENASINFO , 3 , $IFLAGS )
	DllStructSetData ( $TOPENASINFO , 4 , $SFILEPATH )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "SHOpenWithDialog" , "hwnd" , $HPARENT , "struct*" , $TOPENASINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLSTARTNETCONNECTIONDLG ( $SREMOTE = "" , $IFLAGS = 0 , $HPARENT = 0 )
	If Not StringStripWS ( $SREMOTE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SREMOTE = Null
	DllCall ( "shell32.dll" , "long" , "SHStartNetConnectionDialogW" , "hwnd" , $HPARENT , "wstr" , $SREMOTE , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SHELLUSERAUTHENTICATIONDLG ( $SCAPTION , $SMESSAGE , $SUSER , $SPASSWORD , $STARGET , $IFLAGS = 0 , $IERROR = 0 , $BSAVE = False , $HBITMAP = 0 , $HPARENT = 0 )
	If Not __DLL ( "credui.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $TINFO = DllStructCreate ( "dword;hwnd;ptr;ptr;ptr;wchar[" & ( StringLen ( $SMESSAGE ) + 1 ) & "];wchar[" & ( StringLen ( $SCAPTION ) + 1 ) & "]" )
	DllStructSetData ( $TINFO , 1 , DllStructGetPtr ( $TINFO , 6 ) - DllStructGetPtr ( $TINFO ) )
	DllStructSetData ( $TINFO , 2 , $HPARENT )
	DllStructSetData ( $TINFO , 3 , DllStructGetPtr ( $TINFO , 6 ) )
	DllStructSetData ( $TINFO , 4 , DllStructGetPtr ( $TINFO , 7 ) )
	DllStructSetData ( $TINFO , 5 , $HBITMAP )
	DllStructSetData ( $TINFO , 6 , $SMESSAGE )
	DllStructSetData ( $TINFO , 7 , $SCAPTION )
	Local $ACALL = DllCall ( "credui.dll" , "dword" , "CredUIPromptForCredentialsW" , "struct*" , $TINFO , "wstr" , $STARGET , "ptr" , 0 , "dword" , $IERROR , "wstr" , $SUSER , "ulong" , 4096 , "wstr" , $SPASSWORD , "ulong" , 4096 , "bool*" , $BSAVE , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 3 ]
	$ARET [ 0 ] = $ACALL [ 5 ]
	$ARET [ 1 ] = $ACALL [ 7 ]
	$ARET [ 2 ] = $ACALL [ 9 ]
	Return $ARET
EndFunc
Func _WINAPI_SHELLUSERAUTHENTICATIONDLGEX ( $SCAPTION , $SMESSAGE , $SUSER , $SPASSWORD , $IFLAGS = 0 , $IAUTHERROR = 0 , $BSAVE = False , $IPACKAGE = 0 , $HPARENT = 0 )
	If Not __DLL ( "credui.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $TBLOB = 0 , $ACALL
	If StringLen ( $SUSER ) Then
		$ACALL = DllCall ( "credui.dll" , "bool" , "CredPackAuthenticationBufferW" , "dword" , 1 , "wstr" , $SUSER , "wstr" , $SPASSWORD , "ptr" , 0 , "dword*" , 0 )
		If @error Or Not $ACALL [ 5 ] Then Return SetError ( @error + 10 , @extended , 0 )
		$TBLOB = DllStructCreate ( "byte[" & $ACALL [ 5 ] & "]" )
		$ACALL = DllCall ( "credui.dll" , "bool" , "CredPackAuthenticationBufferW" , "dword" , 1 , "wstr" , $SUSER , "wstr" , $SPASSWORD , "struct*" , $TBLOB , "dword*" , $ACALL [ 5 ] )
		If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	EndIf
	Local $TINFO = DllStructCreate ( "dword;hwnd;ptr;ptr;ptr;wchar[" & ( StringLen ( $SMESSAGE ) + 1 ) & "];wchar[" & ( StringLen ( $SCAPTION ) + 1 ) & "]" )
	DllStructSetData ( $TINFO , 1 , DllStructGetPtr ( $TINFO , 6 ) - DllStructGetPtr ( $TINFO ) )
	DllStructSetData ( $TINFO , 2 , $HPARENT )
	DllStructSetData ( $TINFO , 3 , DllStructGetPtr ( $TINFO , 6 ) )
	DllStructSetData ( $TINFO , 4 , DllStructGetPtr ( $TINFO , 7 ) )
	DllStructSetData ( $TINFO , 5 , 0 )
	DllStructSetData ( $TINFO , 6 , $SMESSAGE )
	DllStructSetData ( $TINFO , 7 , $SCAPTION )
	$ACALL = DllCall ( "credui.dll" , "dword" , "CredUIPromptForWindowsCredentialsW" , "struct*" , $TINFO , "dword" , $IAUTHERROR , "ulong*" , $IPACKAGE , "struct*" , $TBLOB , "ulong" , DllStructGetSize ( $TBLOB ) , "ptr*" , 0 , "ulong*" , 0 , "bool*" , $BSAVE , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error + 30 , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 30 , $ACALL [ 0 ] , 0 )
	Local $ARET [ 4 ] , $IERROR = 0
	$ARET [ 2 ] = $ACALL [ 8 ]
	$ARET [ 3 ] = $ACALL [ 3 ]
	Local $PBLOB = $ACALL [ 6 ]
	Local $ISIZE = $ACALL [ 7 ]
	$ACALL = DllCall ( "credui.dll" , "bool" , "CredUnPackAuthenticationBufferW" , "dword" , 1 , "ptr" , $PBLOB , "dword" , $ISIZE , "wstr" , "" , "dword*" , 4096 , "wstr" , "" , "dword*" , 4096 , "wstr" , "" , "dword*" , 4096 )
	If Not @error And $ACALL [ 0 ] Then
		$ARET [ 0 ] = $ACALL [ 4 ]
		$ARET [ 1 ] = $ACALL [ 8 ]
	Else
		$IERROR = @error + 40
	EndIf
	If Not _WINAPI_ZEROMEMORY ( $PBLOB , $ISIZE ) Then
	EndIf
	_WINAPI_COTASKMEMFREE ( $PBLOB )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ARET
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __OFNDLG ( $IDLG , $STITLE , $SINITDIR , $SFILTERS , $IDEFFILTER , $SDEFFILE , $SDEFEXT , $IFLAGS , $IFLAGSEX , $POFNPROC , $PDATA , $HPARENT )
	Local $VERROR [ 1 ] = [ 0 ]
	If BitAND ( $IFLAGS , $OFN_ALLOWMULTISELECT ) = 0 Then $VERROR = ""
	Local $TBUFFER = DllStructCreate ( "wchar[32768]" )
	Local $TFILTERS = 0 , $TDEFEXT = 0 , $TINITDIR = 0 , $TTITLE = 0
	Local $TOFN = DllStructCreate ( $TAGOPENFILENAME )
	DllStructSetData ( $TOFN , "StructSize" , DllStructGetSize ( $TOFN ) )
	DllStructSetData ( $TOFN , "hwndOwner" , $HPARENT )
	DllStructSetData ( $TOFN , 3 , 0 )
	Local $ADATA = StringSplit ( $SFILTERS , "|" )
	Local $AFILTERS [ $ADATA [ 0 ] * 2 ]
	Local $ICOUNT = 0
	For $I = 1 To $ADATA [ 0 ]
		$AFILTERS [ $ICOUNT + 0 ] = StringStripWS ( $ADATA [ $I ] , $STR_STRIPLEADING + $STR_STRIPTRAILING )
		$AFILTERS [ $ICOUNT + 1 ] = StringStripWS ( StringRegExpReplace ( $ADATA [ $I ] , ".*\((.*)\)" , "\1" ) , $STR_STRIPALL )
		If $AFILTERS [ $ICOUNT + 1 ] Then
			$ICOUNT += 2
		EndIf
	Next
	If $ICOUNT Then
		$TFILTERS = _WINAPI_ARRAYTOSTRUCT ( $AFILTERS , 0 , $ICOUNT + 4294967295 )
		If @error Then
		EndIf
	EndIf
	DllStructSetData ( $TOFN , "lpstrFilter" , DllStructGetPtr ( $TFILTERS ) )
	DllStructSetData ( $TOFN , 5 , 0 )
	DllStructSetData ( $TOFN , 6 , 0 )
	DllStructSetData ( $TOFN , "nFilterIndex" , $IDEFFILTER )
	$SDEFFILE = StringStripWS ( $SDEFFILE , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	If $SDEFFILE Then
		DllStructSetData ( $TBUFFER , 1 , $SDEFFILE )
	EndIf
	DllStructSetData ( $TOFN , "lpstrFile" , DllStructGetPtr ( $TBUFFER ) )
	DllStructSetData ( $TOFN , "nMaxFile" , 32768 )
	DllStructSetData ( $TOFN , 10 , 0 )
	DllStructSetData ( $TOFN , 11 , 0 )
	$SINITDIR = StringStripWS ( $SINITDIR , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	If $SINITDIR Then
		$TINITDIR = DllStructCreate ( "wchar[" & ( StringLen ( $SINITDIR ) + 1 ) & "]" )
	EndIf
	DllStructSetData ( $TINITDIR , 1 , $SINITDIR )
	DllStructSetData ( $TOFN , "lpstrInitialDir" , DllStructGetPtr ( $TINITDIR ) )
	$STITLE = StringStripWS ( $STITLE , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	If $STITLE Then
		$TTITLE = DllStructCreate ( "wchar[" & ( StringLen ( $STITLE ) + 1 ) & "]" )
	EndIf
	DllStructSetData ( $TTITLE , 1 , $STITLE )
	DllStructSetData ( $TOFN , "lpstrTitle" , DllStructGetPtr ( $TTITLE ) )
	DllStructSetData ( $TOFN , "Flags" , $IFLAGS )
	DllStructSetData ( $TOFN , 15 , 0 )
	DllStructSetData ( $TOFN , 16 , 0 )
	$SDEFEXT = StringStripWS ( $SDEFEXT , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	If $SDEFEXT Then
		$TDEFEXT = DllStructCreate ( "wchar[" & ( StringLen ( $TDEFEXT ) + 1 ) & "]" )
	EndIf
	DllStructSetData ( $TDEFEXT , 1 , StringReplace ( $SDEFEXT , "." , "" ) )
	DllStructSetData ( $TOFN , "lpstrDefExt" , DllStructGetPtr ( $TDEFEXT ) )
	DllStructSetData ( $TOFN , "lCustData" , $PDATA )
	DllStructSetData ( $TOFN , "lpfnHook" , $POFNPROC )
	DllStructSetData ( $TOFN , 20 , 0 )
	DllStructSetData ( $TOFN , 21 , 0 )
	DllStructSetData ( $TOFN , 22 , 0 )
	DllStructSetData ( $TOFN , "FlagsEx" , $IFLAGSEX )
	Local $ACALL
	Switch $IDLG
	Case 0
		$ACALL = DllCall ( "comdlg32.dll" , "bool" , "GetOpenFileNameW" , "struct*" , $TOFN )
	Case 1
		$ACALL = DllCall ( "comdlg32.dll" , "bool" , "GetSaveFileNameW" , "struct*" , $TOFN )
Case Else
	EndSwitch
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , _WINAPI_COMMDLGEXTENDEDERROREX ( ) , $VERROR )
	If BitAND ( $IFLAGS , $OFN_ALLOWMULTISELECT ) Then
		If BitAND ( $IFLAGS , $OFN_EXPLORER ) Then
			$ADATA = _WINAPI_STRUCTTOARRAY ( $TBUFFER )
			If @error Then
				Return SetError ( 11 , 0 , $VERROR )
			EndIf
		Else
			$ADATA = StringSplit ( DllStructGetData ( $TBUFFER , 1 ) , " " )
		EndIf
		Switch $ADATA [ 0 ]
		Case 0
			Return SetError ( 12 , 0 , $VERROR )
		Case 1
	Case Else
			Local $SPATH = $ADATA [ 1 ]
			For $I = 2 To $ADATA [ 0 ]
				$ADATA [ $I + 4294967295 ] = _WINAPI_PATHAPPEND ( $SPATH , $ADATA [ $I ] )
			Next
			ReDim $ADATA [ $ADATA [ 0 ] ]
			$ADATA [ 0 ] -= 1
		EndSwitch
	Else
		$ADATA = DllStructGetData ( $TBUFFER , 1 )
	EndIf
	$__G_VEXT = $TOFN
	Return $ADATA
EndFunc
Func __WINAPI_PARSEMULTISELECTFILEDIALOGPATH ( $APATH )
	Local $AFILES [ UBound ( $APATH ) + 1 ]
	$AFILES [ 0 ] = UBound ( $APATH )
	$AFILES [ 1 ] = StringMid ( $APATH [ 1 ] , 1 , StringInStr ( $APATH [ 1 ] , "\" , $STR_NOCASESENSEBASIC , + 4294967295 ) + 4294967295 )
	For $I = 1 To UBound ( $APATH ) + 4294967295
		$AFILES [ $I + 1 ] = StringMid ( $APATH [ $I ] , StringInStr ( $APATH [ $I ] , "\" , $STR_NOCASESENSEBASIC , + 4294967295 ) + 1 )
	Next
	Return $AFILES
EndFunc
Func __WINAPI_PARSEFILEDIALOGPATH ( $SPATH )
	Local $AFILES [ 3 ]
	$AFILES [ 0 ] = 2
	$AFILES [ 1 ] = StringMid ( $SPATH , 1 , StringInStr ( $SPATH , "\" , $STR_NOCASESENSEBASIC , + 4294967295 ) + 4294967295 )
	$AFILES [ 2 ] = StringMid ( $SPATH , StringInStr ( $SPATH , "\" , $STR_NOCASESENSEBASIC , + 4294967295 ) + 1 )
	Return $AFILES
EndFunc
#EndRegion Internal Functions
Global Const $BACKUP_ALTERNATE_DATA = 4
Global Const $BACKUP_DATA = 1
Global Const $BACKUP_EA_DATA = 2
Global Const $BACKUP_LINK = 5
Global Const $BACKUP_OBJECT_ID = 7
Global Const $BACKUP_PROPERTY_DATA = 6
Global Const $BACKUP_REPARSE_DATA = 8
Global Const $BACKUP_SECURITY_DATA = 3
Global Const $BACKUP_SPARSE_BLOCK = 9
Global Const $BACKUP_TXFS_DATA = 10
Global Const $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 8
Global Const $COPY_FILE_COPY_SYMLINK = 2048
Global Const $COPY_FILE_FAIL_IF_EXISTS = 1
Global Const $COPY_FILE_NO_BUFFERING = 4096
Global Const $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 4
Global Const $COPY_FILE_RESTARTABLE = 2
Global Const $MOVE_FILE_COPY_ALLOWED = 2
Global Const $MOVE_FILE_CREATE_HARDLINK = 16
Global Const $MOVE_FILE_DELAY_UNTIL_REBOOT = 4
Global Const $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 32
Global Const $MOVE_FILE_REPLACE_EXISTING = 1
Global Const $MOVE_FILE_WRITE_THROUGH = 8
Global Const $PROGRESS_CONTINUE = 0
Global Const $PROGRESS_CANCEL = 1
Global Const $PROGRESS_STOP = 2
Global Const $PROGRESS_QUIET = 3
Global Const $FILE_APPEND_DATA = 4
Global Const $FILE_DELETE_CHILD = 64
Global Const $FILE_EXECUTE = 32
Global Const $FILE_READ_ATTRIBUTES = 128
Global Const $FILE_READ_DATA = 1
Global Const $FILE_READ_EA = 8
Global Const $FILE_WRITE_ATTRIBUTES = 256
Global Const $FILE_WRITE_DATA = 2
Global Const $FILE_WRITE_EA = 16
Global Const $FILE_ADD_FILE = $FILE_WRITE_DATA
Global Const $FILE_ADD_SUBDIRECTORY = $FILE_APPEND_DATA
Global Const $FILE_CREATE_PIPE_INSTANCE = $FILE_APPEND_DATA
Global Const $FILE_LIST_DIRECTORY = $FILE_READ_DATA
Global Const $FILE_TRAVERSE = $FILE_EXECUTE
Global Const $FILE_ALL_ACCESS = 2032127
Global Const $FILE_FLAG_BACKUP_SEMANTICS = 33554432
Global Const $FILE_FLAG_DELETE_ON_CLOSE = 67108864
Global Const $FILE_FLAG_NO_BUFFERING = 536870912
Global Const $FILE_FLAG_OPEN_NO_RECALL = 1048576
Global Const $FILE_FLAG_OPEN_REPARSE_POINT = 2097152
Global Const $FILE_FLAG_OVERLAPPED = 1073741824
Global Const $FILE_FLAG_POSIX_SEMANTICS = 1048576
Global Const $FILE_FLAG_RANDOM_ACCESS = 268435456
Global Const $FILE_FLAG_SEQUENTIAL_SCAN = 134217728
Global Const $FILE_FLAG_WRITE_THROUGH = 2147483648
Global Const $SECURITY_ANONYMOUS = 0
Global Const $SECURITY_CONTEXT_TRACKING = 262144
Global Const $SECURITY_DELEGATION = 196608
Global Const $SECURITY_EFFECTIVE_ONLY = 524288
Global Const $SECURITY_IDENTIFICATION = 65536
Global Const $SECURITY_IMPERSONATION = 131072
Global Const $SEC_COMMIT = 134217728
Global Const $SEC_IMAGE = 16777216
Global Const $SEC_LARGE_PAGES = 2147483648
Global Const $SEC_NOCACHE = 268435456
Global Const $SEC_RESERVE = 67108864
Global Const $SEC_WRITECOMBINE = 1073741824
Global Const $SECTION_EXTEND_SIZE = 16
Global Const $SECTION_MAP_EXECUTE = 8
Global Const $SECTION_MAP_READ = 4
Global Const $SECTION_MAP_WRITE = 2
Global Const $SECTION_QUERY = 1
Global Const $SECTION_ALL_ACCESS = 2031647
Global Const $FILE_MAP_COPY = 1
Global Const $FILE_MAP_EXECUTE = 32
Global Const $FILE_MAP_READ = 4
Global Const $FILE_MAP_WRITE = 2
Global Const $FILE_MAP_ALL_ACCESS = $SECTION_ALL_ACCESS
Global Const $DDD_EXACT_MATCH_ON_REMOVE = 4
Global Const $DDD_NO_BROADCAST_SYSTEM = 8
Global Const $DDD_RAW_TARGET_PATH = 1
Global Const $DDD_REMOVE_DEFINITION = 2
Global Const $FSCTL_ALLOW_EXTENDED_DASD_IO = 589955
Global Const $FSCTL_CREATE_OR_GET_OBJECT_ID = 590016
Global Const $FSCTL_CREATE_USN_JOURNAL = 590055
Global Const $FSCTL_DELETE_OBJECT_ID = 589984
Global Const $FSCTL_DELETE_REPARSE_POINT = 589996
Global Const $FSCTL_DELETE_USN_JOURNAL = 590072
Global Const $FSCTL_DISMOUNT_VOLUME = 589856
Global Const $FSCTL_DUMP_PROPERTY_DATA = 589975
Global Const $FSCTL_ENABLE_UPGRADE = 622800
Global Const $FSCTL_ENCRYPTION_FSCTL_IO = 590043
Global Const $FSCTL_ENUM_USN_DATA = 590003
Global Const $FSCTL_EXTEND_VOLUME = 590064
Global Const $FSCTL_FILESYSTEM_GET_STATISTICS = 589920
Global Const $FSCTL_FIND_FILES_BY_SID = 589967
Global Const $FSCTL_GET_COMPRESSION = 589884
Global Const $FSCTL_GET_NTFS_FILE_RECORD = 589928
Global Const $FSCTL_GET_NTFS_VOLUME_DATA = 589924
Global Const $FSCTL_GET_OBJECT_ID = 589980
Global Const $FSCTL_GET_REPARSE_POINT = 589992
Global Const $FSCTL_GET_RETRIEVAL_POINTERS = 589939
Global Const $FSCTL_GET_VOLUME_BITMAP = 589935
Global Const $FSCTL_HSM_DATA = 639251
Global Const $FSCTL_HSM_MSG = 639240
Global Const $FSCTL_INVALIDATE_VOLUMES = 589908
Global Const $FSCTL_IS_PATHNAME_VALID = 589868
Global Const $FSCTL_IS_VOLUME_DIRTY = 589944
Global Const $FSCTL_IS_VOLUME_MOUNTED = 589864
Global Const $FSCTL_LOCK_VOLUME = 589848
Global Const $FSCTL_MARK_AS_SYSTEM_HIVE = 589903
Global Const $FSCTL_MARK_HANDLE = 590076
Global Const $FSCTL_MARK_VOLUME_DIRTY = 589872
Global Const $FSCTL_MOVE_FILE = 589940
Global Const $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 589840
Global Const $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 589904
Global Const $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 589836
Global Const $FSCTL_OPLOCK_BREAK_NOTIFY = 589844
Global Const $FSCTL_QUERY_ALLOCATED_RANGES = 606415
Global Const $FSCTL_QUERY_FAT_BPB = 589912
Global Const $FSCTL_QUERY_RETRIEVAL_POINTERS = 589883
Global Const $FSCTL_QUERY_USN_JOURNAL = 590068
Global Const $FSCTL_READ_FILE_USN_DATA = 590059
Global Const $FSCTL_READ_PROPERTY_DATA = 589959
Global Const $FSCTL_READ_RAW_ENCRYPTED = 590051
Global Const $FSCTL_READ_USN_JOURNAL = 590011
Global Const $FSCTL_RECALL_FILE = 590103
Global Const $FSCTL_REQUEST_BATCH_OPLOCK = 589832
Global Const $FSCTL_REQUEST_FILTER_OPLOCK = 589916
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 589824
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 589828
Global Const $FSCTL_SECURITY_ID_CHECK = 606391
Global Const $FSCTL_SET_COMPRESSION = 639040
Global Const $FSCTL_SET_ENCRYPTION = 590039
Global Const $FSCTL_SET_OBJECT_ID = 589976
Global Const $FSCTL_SET_OBJECT_ID_EXTENDED = 590012
Global Const $FSCTL_SET_REPARSE_POINT = 589988
Global Const $FSCTL_SET_SPARSE = 590020
Global Const $FSCTL_SET_ZERO_DATA = 622792
Global Const $FSCTL_SIS_COPYFILE = 590080
Global Const $FSCTL_SIS_LINK_FILES = 639236
Global Const $FSCTL_UNLOCK_VOLUME = 589852
Global Const $FSCTL_WRITE_PROPERTY_DATA = 589963
Global Const $FSCTL_WRITE_RAW_ENCRYPTED = 590047
Global Const $FSCTL_WRITE_USN_CLOSE_RECORD = 590063
Global Const $IOCTL_AACS_END_SESSION = 3363020
Global Const $IOCTL_AACS_GENERATE_BINDING_NONCE = 3395824
Global Const $IOCTL_AACS_GET_CERTIFICATE = 3363028
Global Const $IOCTL_AACS_GET_CHALLENGE_KEY = 3363032
Global Const $IOCTL_AACS_READ_BINDING_NONCE = 3363052
Global Const $IOCTL_AACS_READ_MEDIA_ID = 3363048
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 3363012
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 3363008
Global Const $IOCTL_AACS_READ_SERIAL_NUMBER = 3363044
Global Const $IOCTL_AACS_READ_VOLUME_ID = 3363040
Global Const $IOCTL_AACS_SEND_CERTIFICATE = 3363024
Global Const $IOCTL_AACS_SEND_CHALLENGE_KEY = 3363036
Global Const $IOCTL_AACS_START_SESSION = 3363016
Global Const $IOCTL_ATA_PASS_THROUGH = 315436
Global Const $IOCTL_ATA_PASS_THROUGH_DIRECT = 315440
Global Const $IOCTL_CDROM_CHECK_VERIFY = 149504
Global Const $IOCTL_CDROM_DISK_TYPE = 131136
Global Const $IOCTL_CDROM_EJECT_MEDIA = 149512
Global Const $IOCTL_CDROM_FIND_NEW_DEVICES = 149528
Global Const $IOCTL_CDROM_GET_CONFIGURATION = 147544
Global Const $IOCTL_CDROM_GET_CONTROL = 147508
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 147532
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 147536
Global Const $IOCTL_CDROM_GET_LAST_SESSION = 147512
Global Const $IOCTL_CDROM_GET_VOLUME = 147476
Global Const $IOCTL_CDROM_LOAD_MEDIA = 149516
Global Const $IOCTL_CDROM_MEDIA_REMOVAL = 149508
Global Const $IOCTL_CDROM_PAUSE_AUDIO = 147468
Global Const $IOCTL_CDROM_PLAY_AUDIO_MSF = 147480
Global Const $IOCTL_CDROM_RAW_READ = 147518
Global Const $IOCTL_CDROM_READ_Q_CHANNEL = 147500
Global Const $IOCTL_CDROM_READ_TOC = 147456
Global Const $IOCTL_CDROM_READ_TOC_EX = 147540
Global Const $IOCTL_CDROM_RELEASE = 149524
Global Const $IOCTL_CDROM_RESERVE = 149520
Global Const $IOCTL_CDROM_RESUME_AUDIO = 147472
Global Const $IOCTL_CDROM_SEEK_AUDIO_MSF = 147460
Global Const $IOCTL_CDROM_SET_VOLUME = 147496
Global Const $IOCTL_CDROM_STOP_AUDIO = 147464
Global Const $IOCTL_CDROM_UNLOAD_DRIVER = 151560
Global Const $IOCTL_DISK_CHECK_VERIFY = 477184
Global Const $IOCTL_DISK_CONTROLLER_NUMBER = 458820
Global Const $IOCTL_DISK_CREATE_DISK = 507992
Global Const $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 508160
Global Const $IOCTL_DISK_EJECT_MEDIA = 477192
Global Const $IOCTL_DISK_FIND_NEW_DEVICES = 477208
Global Const $IOCTL_DISK_FORMAT_TRACKS = 507928
Global Const $IOCTL_DISK_FORMAT_TRACKS_EX = 507948
Global Const $IOCTL_DISK_GET_CACHE_INFORMATION = 475348
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY = 458752
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 458912
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT = 475148
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 458832
Global Const $IOCTL_DISK_GET_LENGTH_INFO = 475228
Global Const $IOCTL_DISK_GET_MEDIA_TYPES = 461824
Global Const $IOCTL_DISK_GET_PARTITION_INFO = 475140
Global Const $IOCTL_DISK_GET_PARTITION_INFO_EX = 458824
Global Const $IOCTL_DISK_GET_WRITE_CACHE_STATE = 475356
Global Const $IOCTL_DISK_GROW_PARTITION = 508112
Global Const $IOCTL_DISK_HISTOGRAM_DATA = 458804
Global Const $IOCTL_DISK_HISTOGRAM_RESET = 458808
Global Const $IOCTL_DISK_HISTOGRAM_STRUCTURE = 458800
Global Const $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 459783
Global Const $IOCTL_DISK_INTERNAL_SET_NOTIFY = 459784
Global Const $IOCTL_DISK_INTERNAL_SET_VERIFY = 459779
Global Const $IOCTL_DISK_IS_WRITABLE = 458788
Global Const $IOCTL_DISK_LOAD_MEDIA = 477196
Global Const $IOCTL_DISK_LOGGING = 458792
Global Const $IOCTL_DISK_MEDIA_REMOVAL = 477188
Global Const $IOCTL_DISK_PERFORMANCE = 458784
Global Const $IOCTL_DISK_PERFORMANCE_OFF = 458848
Global Const $IOCTL_DISK_REASSIGN_BLOCKS = 507932
Global Const $IOCTL_DISK_RELEASE = 477204
Global Const $IOCTL_DISK_REQUEST_DATA = 458816
Global Const $IOCTL_DISK_REQUEST_STRUCTURE = 458812
Global Const $IOCTL_DISK_RESERVE = 477200
Global Const $IOCTL_DISK_SET_CACHE_INFORMATION = 508120
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT = 507920
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 507988
Global Const $IOCTL_DISK_SET_PARTITION_INFO = 507912
Global Const $IOCTL_DISK_SET_PARTITION_INFO_EX = 507980
Global Const $IOCTL_DISK_UPDATE_DRIVE_SIZE = 508104
Global Const $IOCTL_DISK_UPDATE_PROPERTIES = 459072
Global Const $IOCTL_DISK_VERIFY = 458772
Global Const $IOCTL_DVD_END_SESSION = 3362828
Global Const $IOCTL_DVD_GET_REGION = 3362836
Global Const $IOCTL_DVD_READ_KEY = 3362820
Global Const $IOCTL_DVD_READ_STRUCTURE = 3363136
Global Const $IOCTL_DVD_SEND_KEY = 3362824
Global Const $IOCTL_DVD_SEND_KEY2 = 3395608
Global Const $IOCTL_DVD_SET_READ_AHEAD = 3362832
Global Const $IOCTL_DVD_START_SESSION = 3362816
Global Const $IOCTL_MOUNTDEV_LINK_CREATED = 5046288
Global Const $IOCTL_MOUNTDEV_LINK_DELETED = 5046292
Global Const $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 5046296
Global Const $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 5046284
Global Const $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 5046272
Global Const $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 5046276
Global Const $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 7192596
Global Const $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 7159840
Global Const $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 7159848
Global Const $IOCTL_MOUNTMGR_CREATE_POINT = 7192576
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS = 7192580
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 7192588
Global Const $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 7192612
Global Const $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 7192592
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 7143472
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 7143476
Global Const $IOCTL_MOUNTMGR_QUERY_POINTS = 7143432
Global Const $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 7159852
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 7192600
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 7192604
Global Const $IOCTL_SCSI_GET_INQUIRY_DATA = 266252
Global Const $IOCTL_SCSI_GET_CAPABILITIES = 266256
Global Const $IOCTL_SCSI_GET_ADDRESS = 266264
Global Const $IOCTL_SCSI_MINIPORT = 315400
Global Const $IOCTL_SCSI_PASS_THROUGH = 315396
Global Const $IOCTL_SCSI_PASS_THROUGH_DIRECT = 315412
Global Const $IOCTL_SCSI_RESCAN_BUS = 266268
Global Const $IOCTL_STORAGE_BREAK_RESERVATION = 2969620
Global Const $IOCTL_STORAGE_CHECK_VERIFY = 2967552
Global Const $IOCTL_STORAGE_CHECK_VERIFY2 = 2951168
Global Const $IOCTL_STORAGE_EJECT_MEDIA = 2967560
Global Const $IOCTL_STORAGE_EJECTION_CONTROL = 2951488
Global Const $IOCTL_STORAGE_FIND_NEW_DEVICES = 2967576
Global Const $IOCTL_STORAGE_GET_DEVICE_NUMBER = 2953344
Global Const $IOCTL_STORAGE_GET_HOTPLUG_INFO = 2952212
Global Const $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 2952208
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES = 2952192
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 2952196
Global Const $IOCTL_STORAGE_LOAD_MEDIA = 2967564
Global Const $IOCTL_STORAGE_LOAD_MEDIA2 = 2951180
Global Const $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 2987012
Global Const $IOCTL_STORAGE_MCN_CONTROL = 2951492
Global Const $IOCTL_STORAGE_MEDIA_REMOVAL = 2967556
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 2969624
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 2969628
Global Const $IOCTL_STORAGE_PREDICT_FAILURE = 2953472
Global Const $IOCTL_STORAGE_QUERY_PROPERTY = 2954240
Global Const $IOCTL_STORAGE_RELEASE = 2967572
Global Const $IOCTL_STORAGE_RESERVE = 2967568
Global Const $IOCTL_STORAGE_RESET_BUS = 2969600
Global Const $IOCTL_STORAGE_RESET_DEVICE = 2969604
Global Const $IOCTL_STORAGE_SET_HOTPLUG_INFO = 3001368
Global Const $IOCTL_STORAGE_SET_READ_AHEAD = 2966528
Global Const $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 5636152
Global Const $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 5636096
Global Const $IOCTL_VOLUME_IS_CLUSTERED = 5636144
Global Const $IOCTL_VOLUME_IS_IO_CAPABLE = 5636116
Global Const $IOCTL_VOLUME_IS_OFFLINE = 5636112
Global Const $IOCTL_VOLUME_IS_PARTITION = 5636136
Global Const $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 5636128
Global Const $IOCTL_VOLUME_OFFLINE = 5685260
Global Const $IOCTL_VOLUME_ONLINE = 5685256
Global Const $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 5636132
Global Const $IOCTL_VOLUME_QUERY_FAILOVER_SET = 5636120
Global Const $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 5636124
Global Const $IOCTL_VOLUME_READ_PLEX = 5652526
Global Const $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 5636148
Global Const $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 5636100
Global Const $SMART_GET_VERSION = 475264
Global Const $SMART_RCV_DRIVE_DATA = 508040
Global Const $SMART_SEND_DRIVE_COMMAND = 508036
Global Const $FILE_ENCRYPTABLE = 0
Global Const $FILE_IS_ENCRYPTED = 1
Global Const $FILE_READ_ONLY = 8
Global Const $FILE_ROOT_DIR = 3
Global Const $FILE_SYSTEM_ATTR = 2
Global Const $FILE_SYSTEM_DIR = 4
Global Const $FILE_SYSTEM_NOT_SUPPORT = 6
Global Const $FILE_UNKNOWN = 5
Global Const $FILE_USER_DISALLOWED = 7
Global Const $SCS_32BIT_BINARY = 0
Global Const $SCS_64BIT_BINARY = 6
Global Const $SCS_DOS_BINARY = 1
Global Const $SCS_OS216_BINARY = 5
Global Const $SCS_PIF_BINARY = 3
Global Const $SCS_POSIX_BINARY = 4
Global Const $SCS_WOW_BINARY = 2
Global Const $DRIVE_BUS_TYPE_UNKNOWN = 0
Global Const $DRIVE_BUS_TYPE_SCSI = 1
Global Const $DRIVE_BUS_TYPE_ATAPI = 2
Global Const $DRIVE_BUS_TYPE_ATA = 3
Global Const $DRIVE_BUS_TYPE_1394 = 4
Global Const $DRIVE_BUS_TYPE_SSA = 5
Global Const $DRIVE_BUS_TYPE_FIBRE = 6
Global Const $DRIVE_BUS_TYPE_USB = 7
Global Const $DRIVE_BUS_TYPE_RAID = 8
Global Const $DRIVE_BUS_TYPE_ISCSI = 9
Global Const $DRIVE_BUS_TYPE_SAS = 10
Global Const $DRIVE_BUS_TYPE_SATA = 11
Global Const $DRIVE_BUS_TYPE_SD = 12
Global Const $DRIVE_BUS_TYPE_MMC = 13
Global Const $DRIVE_UNKNOWN = 0
Global Const $DRIVE_NO_ROOT_DIR = 1
Global Const $DRIVE_REMOVABLE = 2
Global Const $DRIVE_FIXED = 3
Global Const $DRIVE_REMOTE = 4
Global Const $DRIVE_CDROM = 5
Global Const $DRIVE_RAMDISK = 6
Global Const $FILE_TYPE_CHAR = 2
Global Const $FILE_TYPE_DISK = 1
Global Const $FILE_TYPE_PIPE = 3
Global Const $FILE_TYPE_REMOTE = 32768
Global Const $FILE_TYPE_UNKNOWN = 0
Global Const $FILE_NAME_NORMALIZED = 0
Global Const $FILE_NAME_OPENED = 8
Global Const $VOLUME_NAME_DOS = 0
Global Const $VOLUME_NAME_GUID = 1
Global Const $VOLUME_NAME_NONE = 4
Global Const $VOLUME_NAME_NT = 2
Global Const $IMAGE_FILE_MACHINE_UNKNOWN = 0
Global Const $IMAGE_FILE_MACHINE_AM33 = 467
Global Const $IMAGE_FILE_MACHINE_AMD64 = 34404
Global Const $IMAGE_FILE_MACHINE_ARM = 448
Global Const $IMAGE_FILE_MACHINE_EBC = 3772
Global Const $IMAGE_FILE_MACHINE_I386 = 332
Global Const $IMAGE_FILE_MACHINE_IA64 = 512
Global Const $IMAGE_FILE_MACHINE_M32R = 36929
Global Const $IMAGE_FILE_MACHINE_MIPS16 = 614
Global Const $IMAGE_FILE_MACHINE_MIPSFPU = 870
Global Const $IMAGE_FILE_MACHINE_MIPSFPU16 = 1126
Global Const $IMAGE_FILE_MACHINE_POWERPC = 496
Global Const $IMAGE_FILE_MACHINE_POWERPCFP = 497
Global Const $IMAGE_FILE_MACHINE_R4000 = 358
Global Const $IMAGE_FILE_MACHINE_SH3 = 418
Global Const $IMAGE_FILE_MACHINE_SH3DSP = 419
Global Const $IMAGE_FILE_MACHINE_SH4 = 422
Global Const $IMAGE_FILE_MACHINE_SH5 = 424
Global Const $IMAGE_FILE_MACHINE_THUMB = 450
Global Const $IMAGE_FILE_MACHINE_WCEMIPSV2 = 361
Global Const $FILE_CASE_PRESERVED_NAMES = 2
Global Const $FILE_CASE_SENSITIVE_SEARCH = 1
Global Const $FILE_FILE_COMPRESSION = 16
Global Const $FILE_NAMED_STREAMS = 262144
Global Const $FILE_PERSISTENT_ACLS = 8
Global Const $FILE_READ_ONLY_VOLUME = 524288
Global Const $FILE_SEQUENTIAL_WRITE_ONCE = 1048576
Global Const $FILE_SUPPORTS_ENCRYPTION = 131072
Global Const $FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 8388608
Global Const $FILE_SUPPORTS_HARD_LINKS = 4194304
Global Const $FILE_SUPPORTS_OBJECT_IDS = 65536
Global Const $FILE_SUPPORTS_OPEN_BY_FILE_ID = 16777216
Global Const $FILE_SUPPORTS_REPARSE_POINTS = 128
Global Const $FILE_SUPPORTS_SPARSE_FILES = 64
Global Const $FILE_SUPPORTS_TRANSACTIONS = 2097152
Global Const $FILE_SUPPORTS_USN_JOURNAL = 33554432
Global Const $FILE_UNICODE_ON_DISK = 4
Global Const $FILE_VOLUME_IS_COMPRESSED = 32768
Global Const $FILE_VOLUME_QUOTAS = 32
Global Const $FILE_DEVICE_8042_PORT = 39
Global Const $FILE_DEVICE_ACPI = 50
Global Const $FILE_DEVICE_BATTERY = 41
Global Const $FILE_DEVICE_BEEP = 1
Global Const $FILE_DEVICE_BUS_EXTENDER = 42
Global Const $FILE_DEVICE_CD_ROM = 2
Global Const $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 3
Global Const $FILE_DEVICE_CHANGER = 48
Global Const $FILE_DEVICE_CONTROLLER = 4
Global Const $FILE_DEVICE_DATALINK = 5
Global Const $FILE_DEVICE_DFS = 6
Global Const $FILE_DEVICE_DFS_FILE_SYSTEM = 53
Global Const $FILE_DEVICE_DFS_VOLUME = 54
Global Const $FILE_DEVICE_DISK = 7
Global Const $FILE_DEVICE_DISK_FILE_SYSTEM = 8
Global Const $FILE_DEVICE_DVD = 51
Global Const $FILE_DEVICE_FILE_SYSTEM = 9
Global Const $FILE_DEVICE_FIPS = 58
Global Const $FILE_DEVICE_FULLSCREEN_VIDEO = 52
Global Const $FILE_DEVICE_INPORT_PORT = 10
Global Const $FILE_DEVICE_KEYBOARD = 11
Global Const $FILE_DEVICE_KS = 47
Global Const $FILE_DEVICE_KSEC = 57
Global Const $FILE_DEVICE_MAILSLOT = 12
Global Const $FILE_DEVICE_MASS_STORAGE = 45
Global Const $FILE_DEVICE_MIDI_IN = 13
Global Const $FILE_DEVICE_MIDI_OUT = 14
Global Const $FILE_DEVICE_MODEM = 43
Global Const $FILE_DEVICE_MOUSE = 15
Global Const $FILE_DEVICE_MULTI_UNC_PROVIDER = 16
Global Const $FILE_DEVICE_NAMED_PIPE = 17
Global Const $FILE_DEVICE_NETWORK = 18
Global Const $FILE_DEVICE_NETWORK_BROWSER = 19
Global Const $FILE_DEVICE_NETWORK_FILE_SYSTEM = 20
Global Const $FILE_DEVICE_NETWORK_REDIRECTOR = 40
Global Const $FILE_DEVICE_NULL = 21
Global Const $FILE_DEVICE_PARALLEL_PORT = 22
Global Const $FILE_DEVICE_PHYSICAL_NETCARD = 23
Global Const $FILE_DEVICE_PRINTER = 24
Global Const $FILE_DEVICE_SCANNER = 25
Global Const $FILE_DEVICE_SCREEN = 28
Global Const $FILE_DEVICE_SERENUM = 55
Global Const $FILE_DEVICE_SERIAL_MOUSE_PORT = 26
Global Const $FILE_DEVICE_SERIAL_PORT = 27
Global Const $FILE_DEVICE_SMARTCARD = 49
Global Const $FILE_DEVICE_SMB = 46
Global Const $FILE_DEVICE_SOUND = 29
Global Const $FILE_DEVICE_STREAMS = 30
Global Const $FILE_DEVICE_TAPE = 31
Global Const $FILE_DEVICE_TAPE_FILE_SYSTEM = 32
Global Const $FILE_DEVICE_TERMSRV = 56
Global Const $FILE_DEVICE_TRANSPORT = 33
Global Const $FILE_DEVICE_UNKNOWN = 34
Global Const $FILE_DEVICE_VDM = 44
Global Const $FILE_DEVICE_VIDEO = 35
Global Const $FILE_DEVICE_VIRTUAL_DISK = 36
Global Const $FILE_DEVICE_WAVE_IN = 37
Global Const $FILE_DEVICE_WAVE_OUT = 38
Global Const $FILE_ANY_ACCESS = 0
Global Const $FILE_SPECIAL_ACCESS = $FILE_ANY_ACCESS
Global Const $FILE_READ_ACCESS = 1
Global Const $FILE_WRITE_ACCESS = 2
Global Const $METHOD_BUFFERED = 0
Global Const $METHOD_IN_DIRECT = 1
Global Const $METHOD_OUT_DIRECT = 2
Global Const $METHOD_NEITHER = 3
Global Const $FILE_NOTIFY_CHANGE_FILE_NAME = 1
Global Const $FILE_NOTIFY_CHANGE_DIR_NAME = 2
Global Const $FILE_NOTIFY_CHANGE_ATTRIBUTES = 4
Global Const $FILE_NOTIFY_CHANGE_SIZE = 8
Global Const $FILE_NOTIFY_CHANGE_LAST_WRITE = 16
Global Const $FILE_NOTIFY_CHANGE_LAST_ACCESS = 32
Global Const $FILE_NOTIFY_CHANGE_CREATION = 64
Global Const $FILE_NOTIFY_CHANGE_SECURITY = 256
Global Const $FILE_ACTION_ADDED = 1
Global Const $FILE_ACTION_REMOVED = 2
Global Const $FILE_ACTION_MODIFIED = 3
Global Const $FILE_ACTION_RENAMED_OLD_NAME = 4
Global Const $FILE_ACTION_RENAMED_NEW_NAME = 5
Global Const $REPLACEFILE_WRITE_THROUGH = 1
Global Const $REPLACEFILE_IGNORE_MERGE_ERRORS = 2
Global Const $REPLACEFILE_IGNORE_ACL_ERRORS = 4
Global Const $BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 1
Global Const $BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 65536
Global Const $BASE_SEARCH_PATH_PERMANENT = 32768
#Region Global Variables and Constants
Global $__G_IHEAPSIZE = 8388608
Global Const $TAGFILEINFO = "uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes"
Global Const $TAGFILE_ID_DESCRIPTOR = "dword Size;uint Type;" & $TAGGUID
Global Const $TAGWIN32_FIND_STREAM_DATA = "int64 StreamSize;wchar StreamName[296]"
Global Const $TAGWIN32_STREAM_ID = "dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_BACKUPREAD ( $HFILE , $PBUFFER , $ILENGTH , ByRef $IBYTES , ByRef $PCONTEXT , $BSECURITY = False )
	$IBYTES = 0
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "BackupRead" , "handle" , $HFILE , "struct*" , $PBUFFER , "dword" , $ILENGTH , "dword*" , 0 , "bool" , 0 , "bool" , $BSECURITY , "ptr*" , $PCONTEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	$IBYTES = $ACALL [ 4 ]
	$PCONTEXT = $ACALL [ 7 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BACKUPREADABORT ( ByRef $PCONTEXT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "BackupRead" , "handle" , 0 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "bool" , 1 , "bool" , 0 , "ptr*" , $PCONTEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	$PCONTEXT = $ACALL [ 7 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BACKUPSEEK ( $HFILE , $ISEEK , ByRef $IBYTES , ByRef $PCONTEXT )
	$IBYTES = 0
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "BackupSeek" , "handle" , $HFILE , "dword" , _WINAPI_LODWORD ( $ISEEK ) , "dword" , _WINAPI_HIDWORD ( $ISEEK ) , "dword*" , 0 , "dword*" , 0 , "ptr*" , $PCONTEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	$IBYTES = __WINAPI_MAKEQWORD ( $ACALL [ 4 ] , $ACALL [ 5 ] )
	$PCONTEXT = $ACALL [ 6 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BACKUPWRITE ( $HFILE , $PBUFFER , $ILENGTH , ByRef $IBYTES , ByRef $PCONTEXT , $BSECURITY = False )
	$IBYTES = 0
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "BackupWrite" , "handle" , $HFILE , "struct*" , $PBUFFER , "dword" , $ILENGTH , "dword*" , 0 , "bool" , 0 , "bool" , $BSECURITY , "ptr*" , $PCONTEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	$IBYTES = $ACALL [ 4 ]
	$PCONTEXT = $ACALL [ 7 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BACKUPWRITEABORT ( ByRef $PCONTEXT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "BackupWrite" , "handle" , 0 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "bool" , 1 , "bool" , 0 , "ptr*" , $PCONTEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	$PCONTEXT = $ACALL [ 7 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_COPYFILEEX ( $SEXISTINGFILE , $SNEWFILE , $IFLAGS = 0 , $PPROGRESSPROC = 0 , $PDATA = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "CopyFileExW" , "wstr" , $SEXISTINGFILE , "wstr" , $SNEWFILE , "ptr" , $PPROGRESSPROC , "struct*" , $PDATA , "bool*" , 0 , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEDIRECTORY ( $SDIR , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "CreateDirectoryW" , "wstr" , $SDIR , "struct*" , $TSECURITY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEDIRECTORYEX ( $SNEWDIR , $STEMPLATEDIR , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "CreateDirectoryExW" , "wstr" , $STEMPLATEDIR , "wstr" , $SNEWDIR , "struct*" , $TSECURITY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEFILEEX ( $SFILEPATH , $ICREATION , $IACCESS = 0 , $ISHARE = 0 , $IFLAGSANDATTRIBUTES = 0 , $TSECURITY = 0 , $HTEMPLATE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateFileW" , "wstr" , $SFILEPATH , "dword" , $IACCESS , "dword" , $ISHARE , "struct*" , $TSECURITY , "dword" , $ICREATION , "dword" , $IFLAGSANDATTRIBUTES , "handle" , $HTEMPLATE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = Ptr ( + 4294967295 ) Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEFILEMAPPING ( $HFILE , $ISIZE = 0 , $SNAME = "" , $IPROTECT = 4 , $TSECURITY = 0 )
	If Not StringStripWS ( $SNAME , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SNAME = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateFileMappingW" , "handle" , $HFILE , "struct*" , $TSECURITY , "dword" , $IPROTECT , "dword" , _WINAPI_HIDWORD ( $ISIZE ) , "dword" , _WINAPI_LODWORD ( $ISIZE ) , "wstr" , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( _WINAPI_GETLASTERROR ( ) , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_CREATEHARDLINK ( $SNEWFILE , $SEXISTINGFILE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "CreateHardLinkW" , "wstr" , $SNEWFILE , "wstr" , $SEXISTINGFILE , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEOBJECTID ( $SFILEPATH )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TFOID = DllStructCreate ( "byte[16];byte[48]" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 590016 , "ptr" , 0 , "dword" , 0 , "struct*" , $TFOID , "dword" , DllStructGetSize ( $TFOID ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	_WINAPI_MOVEMEMORY ( $TGUID , $TFOID , 16 )
	Return $TGUID
EndFunc
Func _WINAPI_CREATESYMBOLICLINK ( $SSYMLINK , $STARGET , $BDIRECTORY = False )
	If $BDIRECTORY Then
		$BDIRECTORY = 1
	EndIf
	Local $ACALL = DllCall ( "kernel32.dll" , "boolean" , "CreateSymbolicLinkW" , "wstr" , $SSYMLINK , "wstr" , $STARGET , "dword" , $BDIRECTORY )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DECRYPTFILE ( $SFILEPATH )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "DecryptFileW" , "wstr" , $SFILEPATH , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEFINEDOSDEVICE ( $SDEVICE , $IFLAGS , $SFILEPATH = "" )
	If Not StringStripWS ( $SFILEPATH , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SFILEPATH = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DefineDosDeviceW" , "dword" , $IFLAGS , "wstr" , $SDEVICE , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DELETEFILE ( $SFILEPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeleteFileW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DELETEOBJECTID ( $SFILEPATH )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , $GENERIC_WRITE , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 589984 , "ptr" , 0 , "dword" , 0 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_DELETEVOLUMEMOUNTPOINT ( $SMOUNTEDPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeleteVolumeMountPointW" , "wstr" , $SMOUNTEDPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DEVICEIOCONTROL ( $HDEVICE , $ICONTROLCODE , $PINBUFFER = 0 , $IINBUFFERSIZE = 0 , $POUTBUFFER = 0 , $IOUTBUFFERSIZE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HDEVICE , "dword" , $ICONTROLCODE , "struct*" , $PINBUFFER , "dword" , $IINBUFFERSIZE , "struct*" , $POUTBUFFER , "dword" , $IOUTBUFFERSIZE , "dword*" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return SetExtended ( $ACALL [ 7 ] , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_DUPLICATEENCRYPTIONINFOFILE ( $SSRCFILEPATH , $SDESTFILEPATH , $ICREATION = 2 , $IATTRIBUTES = 0 , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "advapi32.dll" , "dword" , "DuplicateEncryptionInfoFile" , "wstr" , $SSRCFILEPATH , "wstr" , $SDESTFILEPATH , "dword" , $ICREATION , "dword" , $IATTRIBUTES , "struct*" , $TSECURITY )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_EJECTMEDIA ( $SDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , $GENERIC_READ , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 2967560 , "ptr" , 0 , "dword" , 0 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_ENCRYPTFILE ( $SFILEPATH )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "EncryptFileW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENCRYPTIONDISABLE ( $SDIR , $BDISABLE )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "EncryptionDisable" , "wstr" , $SDIR , "bool" , $BDISABLE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ENUMFILES ( $SDIR , $IFLAG = 0 , $STEMPLATE = "" , $BEXCLUDE = False )
	Local $ACALL , $IERROR = 0
	Local $ADATA [ 501 ] [ 7 ] = [ [ 0 ] ]
	Local $HDIR = _WINAPI_CREATEFILEEX ( $SDIR , $OPEN_EXISTING , 1 , $FILE_SHARE_ANY , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $PBUFFER = __HEAPALLOC ( $__G_IHEAPSIZE )
	If @error Then
		$IERROR = @error
	Else
		Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
		$ACALL = DllCall ( "ntdll.dll" , "uint" , "ZwQueryDirectoryFile" , "handle" , $HDIR , "ptr" , 0 , "ptr" , 0 , "ptr" , 0 , "struct*" , $TIOSB , "struct*" , $PBUFFER , "ulong" , 8388608 , "uint" , 1 , "boolean" , 0 , "ptr" , 0 , "boolean" , 1 )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 40
		EndIf
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HDIR )
	If $IERROR Then
		__HEAPFREE ( $PBUFFER , 1 )
		If IsArray ( $ACALL ) Then
			Return SetError ( 10 , $ACALL [ 0 ] , 0 )
		Else
			Return SetError ( $IERROR , 0 , 0 )
		EndIf
	EndIf
	Local $TFDI , $IATTRIB , $STARGET , $ILENGTH = 0 , $IOFFSET = 0
	Do
		$ILENGTH += $IOFFSET
		$TFDI = DllStructCreate ( "ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[" & ( DllStructGetData ( DllStructCreate ( "ulong" , $PBUFFER + $ILENGTH + 60 ) , 1 ) / 2 ) & "]" , $PBUFFER + $ILENGTH )
		$STARGET = DllStructGetData ( $TFDI , 11 )
		$IATTRIB = DllStructGetData ( $TFDI , 9 )
		$IOFFSET = DllStructGetData ( $TFDI , 1 )
		Switch $STARGET
		Case "." , ".."
			ContinueLoop
	Case Else
			Switch $IFLAG
			Case 1 , 2
				If BitAND ( $IATTRIB , 16 ) Then
					If $IFLAG = 1 Then
						ContinueLoop
					EndIf
				Else
					If $IFLAG = 2 Then
						ContinueLoop
					EndIf
				EndIf
			EndSwitch
			If $STEMPLATE Then
				$ACALL = DllCall ( "shlwapi.dll" , "int" , "PathMatchSpecW" , "wstr" , $STARGET , "wstr" , $STEMPLATE )
				If @error Or ( $ACALL [ 0 ] And $BEXCLUDE ) Or ( Not $ACALL [ 0 ] And Not $BEXCLUDE ) Then
					ContinueLoop
				EndIf
			EndIf
		EndSwitch
		__INC ( $ADATA , 500 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 0 ] = $STARGET
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( $TFDI , 3 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 2 ] = DllStructGetData ( $TFDI , 4 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 3 ] = DllStructGetData ( $TFDI , 5 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 4 ] = DllStructGetData ( $TFDI , 7 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 5 ] = DllStructGetData ( $TFDI , 8 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 6 ] = $IATTRIB
	Until Not $IOFFSET
	__HEAPFREE ( $PBUFFER )
	__INC ( $ADATA , + 4294967295 )
	Return $ADATA
EndFunc
Func _WINAPI_ENUMFILESTREAMS ( $SFILEPATH )
	Local $TDATA = DllStructCreate ( "byte[32768]" )
	Local $PDATA = DllStructGetPtr ( $TDATA )
	Local $ADATA [ 101 ] [ 2 ] = [ [ 0 ] ]
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $IERROR = 0
	Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryInformationFile" , "handle" , $HFILE , "struct*" , $TIOSB , "ptr" , $PDATA , "ulong" , 32768 , "uint" , 22 )
	If @error Then $IERROR = @error
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HFILE )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $TFSI , $ILENGTH = 0 , $IOFFSET = 0
	Do
		$ILENGTH += $IOFFSET
		$TFSI = DllStructCreate ( "ulong;ulong;int64;int64;wchar[" & ( DllStructGetData ( DllStructCreate ( "ulong" , $PDATA + $ILENGTH + 4 ) , 1 ) / 2 ) & "]" , $PDATA + $ILENGTH )
		__INC ( $ADATA )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TFSI , 5 )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( $TFSI , 3 )
		$IOFFSET = DllStructGetData ( $TFSI , 1 )
	Until Not $IOFFSET
	__INC ( $ADATA , + 4294967295 )
	Return $ADATA
EndFunc
Func _WINAPI_ENUMHARDLINKS ( $SFILEPATH )
	Local $TDATA = DllStructCreate ( "byte[32768]" )
	Local $PDATA = DllStructGetPtr ( $TDATA )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $IERROR = 0
	Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryInformationFile" , "handle" , $HFILE , "struct*" , $TIOSB , "ptr" , $PDATA , "ulong" , 32768 , "uint" , 46 )
	If @error Or $ACALL [ 0 ] Then
		$IERROR = @error + 10
		DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HFILE )
		If $ACALL Then Return SetError ( $IERROR , 0 , 0 )
		If $ACALL [ 0 ] Then Return SetError ( 10 , $IERROR , 0 )
	EndIf
	Local $ICOUNT = DllStructGetData ( DllStructCreate ( "ulong;ulong" , $PDATA ) , 2 )
	Local $ADATA [ $ICOUNT + 1 ] = [ $ICOUNT ]
	Local $TFLEI , $HPATH , $SPATH , $ILENGTH = 8
	For $I = 1 To $ICOUNT
		$TFLEI = DllStructCreate ( "ulong;int64;ulong;wchar[" & ( DllStructGetData ( DllStructCreate ( "ulong" , $PDATA + $ILENGTH + 16 ) , 1 ) ) & "]" , $PDATA + $ILENGTH )
		$IERROR = 0
		Do
			$HPATH = _WINAPI_OPENFILEBYID ( $HFILE , DllStructGetData ( $TFLEI , 2 ) , 1048704 , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
			If @error Then
				$IERROR = @error + 100
				ExitLoop
			EndIf
			$SPATH = _WINAPI_GETFINALPATHNAMEBYHANDLEEX ( $HPATH )
			If @error Then
				$IERROR = @error + 200
				ExitLoop
			EndIf
		Until 1
		If $HPATH Then
			DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPATH )
		EndIf
		If $IERROR Then ExitLoop
		$ADATA [ $I ] = _WINAPI_PATHAPPEND ( $SPATH , DllStructGetData ( $TFLEI , 4 ) )
		$ILENGTH += DllStructGetData ( $TFLEI , 1 )
	Next
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HFILE )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ADATA
EndFunc
Func _WINAPI_FILEENCRYPTIONSTATUS ( $SFILEPATH )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "FileEncryptionStatusW" , "wstr" , $SFILEPATH , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_FILEEXISTS ( $SFILEPATH )
	If Not FileExists ( $SFILEPATH ) Then Return 0
	If _WINAPI_PATHISDIRECTORY ( $SFILEPATH ) Then Return SetExtended ( 1 , 0 )
	Return 1
EndFunc
Func _WINAPI_FILEINUSE ( $SFILEPATH )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , $GENERIC_READ )
	If @error Then
		If @extended = 32 Then Return 1
		Return SetError ( @error , @extended , 0 )
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HFILE )
	Return 0
EndFunc
Func _WINAPI_FINDCLOSE ( $HSEARCH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindClose" , "handle" , $HSEARCH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDCLOSECHANGENOTIFICATION ( $HCHANGE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindCloseChangeNotification" , "handle" , $HCHANGE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDFIRSTCHANGENOTIFICATION ( $SDIRECTORY , $IFLAGS , $BSUBTREE = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindFirstChangeNotificationW" , "wstr" , $SDIRECTORY , "bool" , $BSUBTREE , "dword" , $IFLAGS )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDFIRSTFILE ( $SFILEPATH , $TDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindFirstFileW" , "wstr" , $SFILEPATH , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = Ptr ( + 4294967295 ) Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDFIRSTFILENAME ( $SFILEPATH , ByRef $SLINK )
	$SLINK = ""
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindFirstFileNameW" , "wstr" , $SFILEPATH , "dword" , 0 , "dword*" , 4096 , "wstr" , "" )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error + 10 , @extended , 0 )
	$SLINK = $ACALL [ 4 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDFIRSTSTREAM ( $SFILEPATH , $TDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "FindFirstStreamW" , "wstr" , $SFILEPATH , "uint" , 0 , "struct*" , $TDATA , "dword" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = Ptr ( + 4294967295 ) Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDNEXTCHANGENOTIFICATION ( $HCHANGE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindNextChangeNotification" , "handle" , $HCHANGE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDNEXTFILE ( $HSEARCH , $TDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindNextFileW" , "handle" , $HSEARCH , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , False )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDNEXTFILENAME ( $HSEARCH , ByRef $SLINK )
	$SLINK = ""
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindNextFileNameW" , "handle" , $HSEARCH , "dword*" , 4096 , "wstr" , "" )
	If @error Then Return SetError ( @error , @extended , False )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	$SLINK = $ACALL [ 3 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FINDNEXTSTREAM ( $HSEARCH , $TDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FindNextStreamW" , "handle" , $HSEARCH , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , False )
	If Not $ACALL [ 0 ] Then Return SetError ( 10 , _WINAPI_GETLASTERROR ( ) , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FLUSHFILEBUFFERS ( $HFILE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FlushFileBuffers" , "handle" , $HFILE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FLUSHVIEWOFFILE ( $PADDRESS , $IBYTES = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FlushViewOfFile" , "struct*" , $PADDRESS , "dword" , $IBYTES )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETBINARYTYPE ( $SFILEPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetBinaryTypeW" , "wstr" , $SFILEPATH , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not $ACALL [ 0 ] Then $ACALL [ 2 ] = 0
	Return SetExtended ( $ACALL [ 2 ] , $ACALL [ 0 ] )
EndFunc
Func _WINAPI_GETCDTYPE ( $SDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , $GENERIC_READWRITE , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TAGSCSI_PASS_THROUGH = "struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct"
	Local $TSPT = DllStructCreate ( $TAGSCSI_PASS_THROUGH & ";byte Hdr[8]" )
	Local $TCDB = DllStructCreate ( "byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]" , DllStructGetPtr ( $TSPT , "Cdb" ) )
	Local $THDR = DllStructCreate ( "byte[4];byte;byte;byte[2]" , DllStructGetPtr ( $TSPT , "Hdr" ) )
	Local $ISIZE = DllStructGetPtr ( $TSPT , "Hdr" ) - DllStructGetPtr ( $TSPT )
	DllStructSetData ( $TSPT , "Length" , $ISIZE )
	DllStructSetData ( $TSPT , "ScsiStatus" , 0 )
	DllStructSetData ( $TSPT , "PathId" , 0 )
	DllStructSetData ( $TSPT , "TargetId" , 0 )
	DllStructSetData ( $TSPT , "Lun" , 0 )
	DllStructSetData ( $TSPT , "CdbLength" , 12 )
	DllStructSetData ( $TSPT , "SenseInfoLength" , 0 )
	DllStructSetData ( $TSPT , "DataIn" , 1 )
	DllStructSetData ( $TSPT , "DataTransferLength" , 8 )
	DllStructSetData ( $TSPT , "TimeOutValue" , 86400 )
	DllStructSetData ( $TSPT , "DataBufferOffset" , $ISIZE )
	DllStructSetData ( $TSPT , "SenseInfoOffset" , 0 )
	DllStructSetData ( $TCDB , 1 , 70 )
	DllStructSetData ( $TCDB , 2 , 0 )
	DllStructSetData ( $TCDB , 3 , 0 , 1 )
	DllStructSetData ( $TCDB , 3 , 0 , 2 )
	DllStructSetData ( $TCDB , 5 , 0 , 1 )
	DllStructSetData ( $TCDB , 5 , 8 , 2 )
	DllStructSetData ( $TCDB , 6 , 0 )
	DllStructSetData ( $TCDB , 7 , 0 , 1 )
	DllStructSetData ( $TCDB , 7 , 0 , 2 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 315396 , "struct*" , $TSPT , "dword" , $ISIZE , "struct*" , $TSPT , "dword" , DllStructGetSize ( $TSPT ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Return BitOR ( BitShift ( DllStructGetData ( $THDR , 4 , 1 ) , + 4294967288 ) , DllStructGetData ( $THDR , 4 , 2 ) )
EndFunc
Func _WINAPI_GETCOMPRESSEDFILESIZE ( $SFILEPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetCompressedFileSizeW" , "wstr" , $SFILEPATH , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = + 4294967295 Then
		Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
		If $ACALL [ 2 ] = 0 Then Return SetError ( 10 , $ILASTERROR , 0 )
		If $ILASTERROR Then Return SetError ( 11 , $ILASTERROR , 0 )
	EndIf
	Return __WINAPI_MAKEQWORD ( $ACALL [ 0 ] , $ACALL [ 2 ] )
EndFunc
Func _WINAPI_GETCOMPRESSION ( $SFILEPATH )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , $GENERIC_READ , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 589884 , "ptr" , 0 , "dword" , 0 , "ushort*" , 0 , "dword" , 2 , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_GETCURRENTDIRECTORY ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetCurrentDirectoryW" , "dword" , 4096 , "wstr" , "" )
	If @error Then Return SetError ( @error , @extended , "" )
	Return SetExtended ( $ACALL [ 0 ] , $ACALL [ 2 ] )
EndFunc
Func _WINAPI_GETDISKFREESPACEEX ( $SDRIVE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetDiskFreeSpaceEx" , "str" , $SDRIVE , "int64*" , 0 , "int64*" , 0 , "int64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 3 ]
	For $I = 0 To 2
		$ARET [ $I ] = $ACALL [ $I + 2 ]
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETDRIVEBUSTYPE ( $SDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , + 4294967295 )
	Local $TAGSTORAGE_PROPERTY_QUERY = "ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]"
	Local $TSPQ = DllStructCreate ( $TAGSTORAGE_PROPERTY_QUERY )
	Local $TSDD = DllStructCreate ( "ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]" )
	DllStructSetData ( $TSPQ , "PropertyId" , 0 )
	DllStructSetData ( $TSPQ , "QueryType" , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 2954240 , "struct*" , $TSPQ , "dword" , DllStructGetSize ( $TSPQ ) , "struct*" , $TSDD , "dword" , DllStructGetSize ( $TSDD ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , + 4294967295 )
	Return DllStructGetData ( $TSDD , "BusType" )
EndFunc
Func _WINAPI_GETDRIVEGEOMETRYEX ( $IDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\PhysicalDrive" & $IDRIVE , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TDGEX = DllStructCreate ( "uint64;dword;dword;dword;dword;uint64" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 458912 , "ptr" , 0 , "dword" , 0 , "struct*" , $TDGEX , "dword" , DllStructGetSize ( $TDGEX ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 6 ]
	For $I = 0 To 5
		$ARET [ $I ] = DllStructGetData ( $TDGEX , $I + 1 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETDRIVENUMBER ( $SDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TSDN = DllStructCreate ( "dword;dword;dword" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 2953344 , "ptr" , 0 , "dword" , 0 , "struct*" , $TSDN , "dword" , DllStructGetSize ( $TSDN ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 3 ]
	For $I = 0 To 2
		$ARET [ $I ] = DllStructGetData ( $TSDN , $I + 1 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETDRIVETYPE ( $SDRIVE = "" )
	If Not StringStripWS ( $SDRIVE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SDRIVE = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "GetDriveType" , "str" , $SDRIVE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETFILEATTRIBUTES ( $SFILEPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetFileAttributesW" , "wstr" , $SFILEPATH )
	If @error Or ( $ACALL [ 0 ] = 4294967295 ) Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETFILEID ( $HFILE )
	Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryInformationFile" , "handle" , $HFILE , "struct*" , $TIOSB , "int64*" , 0 , "ulong" , 8 , "uint" , 6 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETFILEINFORMATIONBYHANDLE ( $HFILE )
	Local $TBHFI = DllStructCreate ( "dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetFileInformationByHandle" , "handle" , $HFILE , "struct*" , $TBHFI )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 8 ]
	$ARET [ 0 ] = DllStructGetData ( $TBHFI , 1 )
	For $I = 1 To 3
		If DllStructGetData ( $TBHFI , $I + 1 ) Then
			$ARET [ $I ] = DllStructCreate ( $TAGFILETIME )
			_WINAPI_MOVEMEMORY ( $ARET [ $I ] , DllStructGetPtr ( $TBHFI , $I + 1 ) , 8 )
		Else
			$ARET [ $I ] = 0
		EndIf
	Next
	$ARET [ 4 ] = DllStructGetData ( $TBHFI , 5 )
	$ARET [ 5 ] = __WINAPI_MAKEQWORD ( DllStructGetData ( $TBHFI , 7 ) , DllStructGetData ( $TBHFI , 6 ) )
	$ARET [ 6 ] = DllStructGetData ( $TBHFI , 8 )
	$ARET [ 7 ] = __WINAPI_MAKEQWORD ( DllStructGetData ( $TBHFI , 9 ) , DllStructGetData ( $TBHFI , 10 ) )
	Return $ARET
EndFunc
Func _WINAPI_GETFILEINFORMATIONBYHANDLEEX ( $HFILE )
	Local $TFI = DllStructCreate ( $TAGFILEINFO )
	Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryInformationFile" , "handle" , $HFILE , "struct*" , $TIOSB , "struct*" , $TFI , "ulong" , DllStructGetSize ( $TFI ) , "uint" , 4 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TFI
EndFunc
Func _WINAPI_GETFILEPOINTEREX ( $HFILE )
	Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryInformationFile" , "handle" , $HFILE , "struct*" , $TIOSB , "int64*" , 0 , "ulong" , 8 , "uint" , 14 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETFILESIZEEX ( $HFILE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetFileSizeEx" , "handle" , $HFILE , "int64*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETFILESIZEONDISK ( $SFILEPATH )
	Local $ISIZE = FileGetSize ( $SFILEPATH )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetDiskFreeSpaceW" , "wstr" , _WINAPI_PATHSTRIPTOROOT ( _WINAPI_GETFULLPATHNAME ( $SFILEPATH ) ) , "dword*" , 0 , "dword*" , 0 , "dword*" , 0 , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return Ceiling ( $ISIZE / ( $ACALL [ 2 ] * $ACALL [ 3 ] ) ) * ( $ACALL [ 2 ] * $ACALL [ 3 ] )
EndFunc
Func _WINAPI_GETFILETITLE ( $SFILEPATH )
	Local $ACALL = DllCall ( "comdlg32.dll" , "short" , "GetFileTitleW" , "wstr" , $SFILEPATH , "wstr" , "" , "word" , 4096 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETFILETYPE ( $HFILE )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetFileType" , "handle" , $HFILE )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
	If Not $ACALL [ 0 ] And $ILASTERROR Then Return SetError ( 10 , $ILASTERROR , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETFINALPATHNAMEBYHANDLE ( $HFILE )
	Local $TFNI = DllStructCreate ( "ulong;wchar[4096]" )
	Local $TIOSB = DllStructCreate ( "ptr;ulong_ptr" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQueryInformationFile" , "handle" , $HFILE , "struct*" , $TIOSB , "struct*" , $TFNI , "ulong" , DllStructGetSize ( $TFNI ) , "uint" , 9 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Local $ILENGTH = DllStructGetData ( $TFNI , 1 )
	If Not $ILENGTH Then Return SetError ( 12 , 0 , "" )
	Return DllStructGetData ( DllStructCreate ( "wchar[" & ( $ILENGTH / 2 ) & "]" , DllStructGetPtr ( $TFNI , 2 ) ) , 1 )
EndFunc
Func _WINAPI_GETFINALPATHNAMEBYHANDLEEX ( $HFILE , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetFinalPathNameByHandleW" , "handle" , $HFILE , "wstr" , "" , "dword" , 4096 , "dword" , $IFLAGS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETFULLPATHNAME ( $SFILEPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetFullPathNameW" , "wstr" , $SFILEPATH , "dword" , 4096 , "wstr" , "" , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETLOGICALDRIVES ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetLogicalDrives" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETOBJECTID ( $SFILEPATH )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TFOID = DllStructCreate ( "byte[16];byte[48]" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 589980 , "ptr" , 0 , "dword" , 0 , "struct*" , $TFOID , "dword" , DllStructGetSize ( $TFOID ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Local $TGUID = DllStructCreate ( $TAGGUID )
	_WINAPI_MOVEMEMORY ( $TGUID , $TFOID , 16 )
	Return $TGUID
EndFunc
Func _WINAPI_GETOVERLAPPEDRESULT ( $HFILE , $TOVERLAPPED , ByRef $IBYTES , $BWAIT = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetOverlappedResult" , "handle" , $HFILE , "struct*" , $TOVERLAPPED , "dword*" , 0 , "bool" , $BWAIT )
	If @error Then Return SetError ( @error , @extended , False )
	$IBYTES = $ACALL [ 3 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPETYPE ( $SFILEPATH )
	Local $TDATA = DllStructCreate ( "ushort[2]" )
	Local $TUINT = DllStructCreate ( "uint" , DllStructGetPtr ( $TDATA ) )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , $GENERIC_READ , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $IERROR = 0 , $IVAL
	Do
		Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "struct*" , $TDATA , "dword" , 2 , "dword*" , 0 , "ptr" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( $ACALL [ 4 ] <> 2 ) Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$IVAL = DllStructGetData ( $TDATA , 1 , 1 )
		If $IVAL <> 23117 Then
			$IERROR = 3
			ExitLoop
		EndIf
		If Not _WINAPI_SETFILEPOINTEREX ( $HFILE , 60 ) Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "struct*" , $TDATA , "dword" , 4 , "dword*" , 0 , "ptr" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( $ACALL [ 4 ] <> 4 ) Then
			$IERROR = @error + 50
			ExitLoop
		EndIf
		If Not _WINAPI_SETFILEPOINTEREX ( $HFILE , DllStructGetData ( $TUINT , 1 ) ) Then
			$IERROR = @error + 60
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "struct*" , $TDATA , "dword" , 4 , "dword*" , 0 , "ptr" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( $ACALL [ 4 ] <> 4 ) Then
			$IERROR = @error + 70
			ExitLoop
		EndIf
		$IVAL = DllStructGetData ( $TUINT , 1 )
		If $IVAL <> 17744 Then
			$IERROR = 4
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadFile" , "handle" , $HFILE , "struct*" , $TDATA , "dword" , 2 , "dword*" , 0 , "ptr" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( $ACALL [ 4 ] <> 2 ) Then
			$IERROR = @error + 80
			ExitLoop
		EndIf
		$IVAL = DllStructGetData ( $TDATA , 1 , 1 )
	Until 1
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HFILE )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $IVAL
EndFunc
Func _WINAPI_GETPROFILESDIRECTORY ( )
	Local $ACALL = DllCall ( "userenv.dll" , "bool" , "GetProfilesDirectoryW" , "wstr" , "" , "dword*" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_GETTEMPFILENAME ( $SFILEPATH , $SPREFIX = "" )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "GetTempFileNameW" , "wstr" , $SFILEPATH , "wstr" , $SPREFIX , "uint" , 0 , "wstr" , "" )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 4 ]
EndFunc
Func _WINAPI_GETVOLUMEINFORMATION ( $SROOT = "" )
	If Not StringStripWS ( $SROOT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SROOT = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetVolumeInformationW" , "wstr" , $SROOT , "wstr" , "" , "dword" , 4096 , "dword*" , 0 , "dword*" , 0 , "dword*" , 0 , "wstr" , "" , "dword" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 5 ]
	For $I = 0 To 4
		Switch $I
		Case 0
			$ARET [ $I ] = $ACALL [ 2 ]
	Case Else
			$ARET [ $I ] = $ACALL [ $I + 3 ]
		EndSwitch
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETVOLUMEINFORMATIONBYHANDLE ( $HFILE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetVolumeInformationByHandleW" , "handle" , $HFILE , "wstr" , "" , "dword" , 4096 , "dword*" , 0 , "dword*" , 0 , "dword*" , 0 , "wstr" , "" , "dword" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ARET [ 5 ]
	For $I = 0 To 4
		Switch $I
		Case 0
			$ARET [ $I ] = $ACALL [ 2 ]
	Case Else
			$ARET [ $I ] = $ACALL [ $I + 3 ]
		EndSwitch
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETVOLUMENAMEFORVOLUMEMOUNTPOINT ( $SMOUNTEDPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetVolumeNameForVolumeMountPointW" , "wstr" , $SMOUNTEDPATH , "wstr" , "" , "dword" , 80 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_IOCTL ( $IDEVICETYPE , $IFUNCTION , $IMETHOD , $IACCESS )
	Return BitOR ( BitShift ( $IDEVICETYPE , + 4294967280 ) , BitShift ( $IACCESS , + 4294967282 ) , BitShift ( $IFUNCTION , + 4294967294 ) , $IMETHOD )
EndFunc
Func _WINAPI_ISDOOROPEN ( $SDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , $GENERIC_READWRITE , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , False )
	Local $TSPT = DllStructCreate ( "ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]" & ( @AutoItX64 ? ";byte[4]" : "" ) & ";byte Hdr[8]" )
	Local $TCDB = DllStructCreate ( "byte;byte;byte[6];byte[2];byte;byte;byte[4]" , DllStructGetPtr ( $TSPT , "Cdb" ) )
	Local $THDR = DllStructCreate ( "byte;byte;byte[3];byte;byte[2]" , DllStructGetPtr ( $TSPT , "Hdr" ) )
	Local $ISIZE = DllStructGetPtr ( $TSPT , "Hdr" ) - DllStructGetPtr ( $TSPT )
	DllStructSetData ( $TSPT , "Length" , $ISIZE )
	DllStructSetData ( $TSPT , "ScsiStatus" , 0 )
	DllStructSetData ( $TSPT , "PathId" , 0 )
	DllStructSetData ( $TSPT , "TargetId" , 0 )
	DllStructSetData ( $TSPT , "Lun" , 0 )
	DllStructSetData ( $TSPT , "CdbLength" , 12 )
	DllStructSetData ( $TSPT , "SenseInfoLength" , 0 )
	DllStructSetData ( $TSPT , "DataIn" , 1 )
	DllStructSetData ( $TSPT , "DataTransferLength" , 8 )
	DllStructSetData ( $TSPT , "TimeOutValue" , 86400 )
	DllStructSetData ( $TSPT , "DataBufferOffset" , $ISIZE )
	DllStructSetData ( $TSPT , "SenseInfoOffset" , 0 )
	DllStructSetData ( $TCDB , 1 , 189 )
	DllStructSetData ( $TCDB , 2 , 0 )
	DllStructSetData ( $TCDB , 4 , 0 , 1 )
	DllStructSetData ( $TCDB , 4 , 8 , 2 )
	DllStructSetData ( $TCDB , 5 , 0 )
	DllStructSetData ( $TCDB , 6 , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 315396 , "struct*" , $TSPT , "dword" , $ISIZE , "struct*" , $TSPT , "dword" , DllStructGetSize ( $TSPT ) , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , False )
	Return ( BitAND ( DllStructGetData ( $THDR , 2 ) , 16 ) = 16 )
EndFunc
Func _WINAPI_ISPATHSHARED ( $SFILEPATH )
	If Not __DLL ( "ntshrui.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $ACALL = DllCall ( "ntshrui.dll" , "bool" , "IsPathSharedW" , "wstr" , _WINAPI_PATHREMOVEBACKSLASH ( $SFILEPATH ) , "int" , 1 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISWRITABLE ( $SDRIVE )
	DriveGetFileSystem ( $SDRIVE )
	If @error Then Return SetError ( 40 + @error , _WINAPI_GETLASTERROR ( ) , 0 )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 458788 , "ptr" , 0 , "dword" , 0 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "ptr" , 0 )
	Local Const $ERROR_WRITE_PROTECT = 19
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE , 1 ) <> 10 And @extended = $ERROR_WRITE_PROTECT Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOADMEDIA ( $SDRIVE )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , $GENERIC_READ , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 2967564 , "ptr" , 0 , "dword" , 0 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOCKDEVICE ( $SDRIVE , $BLOCK )
	Local $HFILE = _WINAPI_CREATEFILEEX ( "\\.\" & $SDRIVE , $OPEN_EXISTING , $GENERIC_READWRITE , $FILE_SHARE_READWRITE )
	If @error Then Return SetError ( @error + 20 , @extended , False )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 2967556 , "boolean*" , $BLOCK , "dword" , 1 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_LOCKFILE ( $HFILE , $IOFFSET , $ILENGTH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "LockFile" , "handle" , $HFILE , "dword" , _WINAPI_LODWORD ( $IOFFSET ) , "dword" , _WINAPI_HIDWORD ( $IOFFSET ) , "dword" , _WINAPI_LODWORD ( $ILENGTH ) , "dword" , _WINAPI_HIDWORD ( $ILENGTH ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MAPVIEWOFFILE ( $HMAPPING , $IOFFSET = 0 , $IBYTES = 0 , $IACCESS = 6 )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "MapViewOfFile" , "handle" , $HMAPPING , "dword" , $IACCESS , "dword" , _WINAPI_HIDWORD ( $IOFFSET ) , "dword" , _WINAPI_LODWORD ( $IOFFSET ) , "ulong_ptr" , $IBYTES )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_MOVEFILEEX ( $SEXISTINGFILE , $SNEWFILE , $IFLAGS = 0 , $PPROGRESSPROC = 0 , $PDATA = 0 )
	If Not StringStripWS ( $SNEWFILE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SNEWFILE = Null
	If BitAND ( $IFLAGS , $MOVE_FILE_DELAY_UNTIL_REBOOT ) Then
		If $SNEWFILE = 0 Then $SNEWFILE = Null
	EndIf
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "MoveFileWithProgressW" , "wstr" , $SEXISTINGFILE , "wstr" , $SNEWFILE , "ptr" , $PPROGRESSPROC , "ptr" , $PDATA , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENFILEBYID ( $HFILE , $VID , $IACCESS = 0 , $ISHARE = 0 , $IFLAGS = 0 )
	Local $TFIDD = DllStructCreate ( "dword;uint;int64;int64" )
	Local $HOBJ , $ACALL , $ITYPE , $IERROR = 0
	Select
	Case IsString ( $VID )
		$ACALL = DllCall ( "ole32.dll" , "long" , "CLSIDFromString" , "wstr" , $VID , "ptr" , DllStructGetPtr ( $TFIDD , 3 ) )
		If @error Or $ACALL [ 0 ] Then
			Return SetError ( @error + 30 , 0 , 0 )
		EndIf
		$ITYPE = 1
	Case IsDllStruct ( $VID )
		If Not _WINAPI_MOVEMEMORY ( DllStructGetPtr ( $TFIDD , 3 ) , DllStructGetPtr ( $VID ) , 16 ) Then
			Return SetError ( @error + 40 , 0 , 0 )
		EndIf
		$ITYPE = 1
Case Else
		DllStructSetData ( $TFIDD , 3 , $VID )
		$ITYPE = 0
	EndSelect
	DllStructSetData ( $TFIDD , 1 , DllStructGetSize ( $TFIDD ) )
	DllStructSetData ( $TFIDD , 2 , $ITYPE )
	If IsString ( $HFILE ) Then
		$HOBJ = _WINAPI_CREATEFILEEX ( $HFILE , $OPEN_EXISTING , 0 , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
		If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Else
		$HOBJ = $HFILE
	EndIf
	$ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenFileById" , "handle" , $HOBJ , "struct*" , $TFIDD , "dword" , $IACCESS , "dword" , $ISHARE , "ptr" , 0 , "dword" , $IFLAGS )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then $IERROR = @error + 10
	If IsString ( $HFILE ) Then
		DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HOBJ )
	EndIf
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENFILEMAPPING ( $SNAME , $IACCESS = 6 , $BINHERIT = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenFileMappingW" , "dword" , $IACCESS , "bool" , $BINHERIT , "wstr" , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_PATHISDIRECTORYEMPTY ( $SFILEPATH )
	Local $ACALL = DllCall ( "shlwapi.dll" , "bool" , "PathIsDirectoryEmptyW" , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_QUERYDOSDEVICE ( $SDEVICE )
	If Not StringStripWS ( $SDEVICE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SDEVICE = Null
	Local $TDATA = DllStructCreate ( "wchar[16384]" )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "QueryDosDeviceW" , "wstr" , $SDEVICE , "struct*" , $TDATA , "dword" , 16384 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Local $ARET = _WINAPI_STRUCTTOARRAY ( $TDATA )
	If IsString ( $SDEVICE ) Then
		$ARET = $ARET [ 1 ]
	EndIf
	Return $ARET
EndFunc
Func _WINAPI_READDIRECTORYCHANGES ( $HDIRECTORY , $IFILTER , $PBUFFER , $ILENGTH , $BSUBTREE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadDirectoryChangesW" , "handle" , $HDIRECTORY , "struct*" , $PBUFFER , "dword" , $ILENGTH - Mod ( $ILENGTH , 4 ) , "bool" , $BSUBTREE , "dword" , $IFILTER , "dword*" , 0 , "ptr" , 0 , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Or ( Not $ACALL [ 6 ] ) Then Return SetError ( @error + 10 , @extended , 0 )
	$PBUFFER = $ACALL [ 2 ]
	Local $ADATA [ 101 ] [ 2 ] = [ [ 0 ] ]
	Local $TFNI , $IBUFFER = 0 , $IOFFSET = 0
	Do
		$IBUFFER += $IOFFSET
		$TFNI = DllStructCreate ( "dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[" & ( DllStructGetData ( DllStructCreate ( "dword FileNameLength" , $PBUFFER + $IBUFFER + 8 ) , 1 ) / 2 ) & "]" , $PBUFFER + $IBUFFER )
		__INC ( $ADATA )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TFNI , "FileName" )
		$ADATA [ $ADATA [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( $TFNI , "Action" )
		$IOFFSET = DllStructGetData ( $TFNI , "NextEntryOffset" )
	Until Not $IOFFSET
	__INC ( $ADATA , + 4294967295 )
	Return $ADATA
EndFunc
Func _WINAPI_REMOVEDIRECTORY ( $SDIRPATH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "RemoveDirectoryW" , "wstr" , $SDIRPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REOPENFILE ( $HFILE , $IACCESS , $ISHARE , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "ReOpenFile" , "handle" , $HFILE , "dword" , $IACCESS , "dword" , $ISHARE , "dword" , $IFLAGS )
	If @error Or ( $ACALL [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REPLACEFILE ( $SREPLACEDFILE , $SREPLACEMENTFILE , $SBACKUPFILE = "" , $IFLAGS = 0 )
	If Not StringStripWS ( $SBACKUPFILE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SBACKUPFILE = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReplaceFileW" , "wstr" , $SREPLACEDFILE , "wstr" , $SREPLACEMENTFILE , "wstr" , $SBACKUPFILE , "dword" , $IFLAGS , "ptr" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SEARCHPATH ( $SFILEPATH , $SSEARCHPATH = "" )
	If Not StringStripWS ( $SSEARCHPATH , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SSEARCHPATH = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "SearchPathW" , "wstr" , $SSEARCHPATH , "wstr" , $SFILEPATH , "ptr" , 0 , "dword" , 4096 , "wstr" , "" , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_SETCOMPRESSION ( $SFILEPATH , $ICOMPRESSION )
	Local $HFILE = _WINAPI_CREATEFILEEX ( $SFILEPATH , $OPEN_EXISTING , $GENERIC_READWRITE , $FILE_SHARE_READWRITE , $FILE_FLAG_BACKUP_SEMANTICS )
	If @error Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DeviceIoControl" , "handle" , $HFILE , "dword" , 639040 , "ushort*" , $ICOMPRESSION , "dword" , 2 , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "ptr" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HFILE ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SETCURRENTDIRECTORY ( $SDIR )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "SetCurrentDirectoryW" , "wstr" , $SDIR )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETENDOFFILE ( $HFILE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetEndOfFile" , "handle" , $HFILE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFILEATTRIBUTES ( $SFILEPATH , $IATTRIBUTES )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "SetFileAttributesW" , "wstr" , $SFILEPATH , "dword" , $IATTRIBUTES )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFILEINFORMATIONBYHANDLEEX ( $HFILE , $TFILEINFO )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwSetInformationFile" , "handle" , $HFILE , "struct*" , $TFILEINFO , "struct*" , $TFILEINFO , "ulong" , DllStructGetSize ( $TFILEINFO ) , "uint" , 4 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SETFILEPOINTER ( $HFILE , $IPOS , $IMETHOD = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "INT" , "SetFilePointer" , "handle" , $HFILE , "long" , $IPOS , "ptr" , 0 , "long" , $IMETHOD )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFILEPOINTEREX ( $HFILE , $IPOS , $IMETHOD = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetFilePointerEx" , "handle" , $HFILE , "int64" , $IPOS , "int64*" , 0 , "dword" , $IMETHOD )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFILESHORTNAME ( $HFILE , $SSHORTNAME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetFileShortNameW" , "handle" , $HFILE , "wstr" , $SSHORTNAME )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETFILEVALIDDATA ( $HFILE , $ILENGTH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetFileValidData" , "handle" , $HFILE , "int64" , $ILENGTH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETSEARCHPATHMODE ( $IFLAGS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetSearchPathMode" , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETVOLUMEMOUNTPOINT ( $SFILEPATH , $SGUID )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetVolumeMountPointW" , "wstr" , $SFILEPATH , "wstr" , $SGUID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SFCISFILEPROTECTED ( $SFILEPATH )
	If Not __DLL ( "sfc.dll" ) Then Return SetError ( 103 , 0 , False )
	Local $ACALL = DllCall ( "sfc.dll" , "bool" , "SfcIsFileProtected" , "handle" , 0 , "wstr" , $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNLOCKFILE ( $HFILE , $IOFFSET , $ILENGTH )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "UnlockFile" , "handle" , $HFILE , "dword" , _WINAPI_LODWORD ( $IOFFSET ) , "dword" , _WINAPI_HIDWORD ( $IOFFSET ) , "dword" , _WINAPI_LODWORD ( $ILENGTH ) , "dword" , _WINAPI_HIDWORD ( $ILENGTH ) )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNMAPVIEWOFFILE ( $PADDRESS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "UnmapViewOfFile" , "ptr" , $PADDRESS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WOW64ENABLEWOW64FSREDIRECTION ( $BENABLE )
	Local $ACALL = DllCall ( "kernel32.dll" , "boolean" , "Wow64EnableWow64FsRedirection" , "boolean" , $BENABLE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __WINAPI_MAKEQWORD ( $ILODWORD , $IHIDWORD )
	Local $TINT64 = DllStructCreate ( "uint64" )
	Local $TDWORDS = DllStructCreate ( "dword;dword" , DllStructGetPtr ( $TINT64 ) )
	DllStructSetData ( $TDWORDS , 1 , $ILODWORD )
	DllStructSetData ( $TDWORDS , 2 , $IHIDWORD )
	Return DllStructGetData ( $TINT64 , 1 )
EndFunc
#EndRegion Internal Functions
Global Const $CREATE_BREAKAWAY_FROM_JOB = 16777216
Global Const $CREATE_DEFAULT_ERROR_MODE = 67108864
Global Const $CREATE_NEW_CONSOLE = 16
Global Const $CREATE_NEW_PROCESS_GROUP = 512
Global Const $CREATE_NO_WINDOW = 134217728
Global Const $CREATE_PROTECTED_PROCESS = 262144
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432
Global Const $CREATE_SEPARATE_WOW_VDM = 2048
Global Const $CREATE_SHARED_WOW_VDM = 4096
Global Const $CREATE_SUSPENDED = 4
Global Const $CREATE_UNICODE_ENVIRONMENT = 1024
Global Const $LIST_MODULES_32BIT = 1
Global Const $LIST_MODULES_64BIT = 2
Global Const $LIST_MODULES_ALL = 3
Global Const $LIST_MODULES_DEFAULT = 0
Global Const $ABOVE_NORMAL_PRIORITY_CLASS = 32768
Global Const $BELOW_NORMAL_PRIORITY_CLASS = 16384
Global Const $HIGH_PRIORITY_CLASS = 128
Global Const $IDLE_PRIORITY_CLASS = 64
Global Const $NORMAL_PRIORITY_CLASS = 32
Global Const $REALTIME_PRIORITY_CLASS = 256
Global Const $PROCESS_MODE_BACKGROUND_BEGIN = 1048576
Global Const $PROCESS_MODE_BACKGROUND_END = 2097152
Global Const $MUTEX_MODIFY_STATE = 1
Global Const $MUTEX_ALL_ACCESS = 2031617
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 1
Global Const $JOB_OBJECT_QUERY = 4
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 2
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 16
Global Const $JOB_OBJECT_TERMINATE = 8
Global Const $JOB_OBJECT_ALL_ACCESS = 2031647
Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 8
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 16
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 2048
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 1024
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 512
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 4
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 8192
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 64
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 32
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 256
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 2
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 128
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 4096
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 1
Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 64
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 16
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 128
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 32
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 1
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 2
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 8
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 4
Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 8
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 1
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 4
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 2
Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 1
Global Const $SEMAPHORE_MODIFY_STATE = 2
Global Const $SEMAPHORE_QUERY_STATE = 1
Global Const $SEMAPHORE_ALL_ACCESS = 2031619
Global Const $ES_AWAYMODE_REQUIRED = 64
Global Const $ES_CONTINUOUS = 2147483648
Global Const $ES_DISPLAY_REQUIRED = 2
Global Const $ES_SYSTEM_REQUIRED = 1
Global Const $ES_USER_PRESENT = 4
#Region Global Variables and Constants
Global Const $TAGIO_COUNTERS = "struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct"
Global Const $TAGJOBOBJECT_ASSOCIATE_COMPLETION_PORT = "ulong_ptr CompletionKey;ptr CompletionPort"
Global Const $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = "struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct"
Global Const $TAGJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ";" & $TAGIO_COUNTERS
Global Const $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION = "struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct"
Global Const $TAGJOBOBJECT_BASIC_PROCESS_ID_LIST = "dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList"
Global Const $TAGJOBOBJECT_BASIC_UI_RESTRICTIONS = "dword UIRestrictionsClass"
Global Const $TAGJOBOBJECT_END_OF_JOB_TIME_INFORMATION = "dword EndOfJobTimeAction"
Global Const $TAGJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION & ";" & $TAGIO_COUNTERS & ";ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed"
Global Const $TAGJOBOBJECT_GROUP_INFORMATION = ""
Global Const $TAGJOBOBJECT_SECURITY_LIMIT_INFORMATION = "dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids"
Global Const $TAGMODULEINFO = "ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint"
Global Const $TAGPROCESSENTRY32 = "dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_ADJUSTTOKENPRIVILEGES ( $HTOKEN , $APRIVILEGES , $IATTRIBUTES , ByRef $AADJUST )
	$AADJUST = 0
	If Not $APRIVILEGES And IsNumber ( $APRIVILEGES ) Then Return 0
	Local $TTP1 = 0 , $TTP2 , $ICOUNT , $ACALL , $BDISABLE = False
	If $APRIVILEGES = + 4294967295 Then
		$TTP2 = DllStructCreate ( "dword" )
		$ACALL = DllCall ( "advapi32.dll" , "bool" , "AdjustTokenPrivileges" , "handle" , $HTOKEN , "bool" , 1 , "ptr" , 0 , "dword" , 0 , "struct*" , $TTP2 , "dword*" , 0 )
		If @error Then Return SetError ( @error , @extended , 0 )
		Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
		Switch $ILASTERROR
		Case 122
			$TTP2 = DllStructCreate ( "dword;dword[" & ( $ACALL [ 6 ] / 4 + 4294967295 ) & "]" )
			If @error Then
				ContinueCase
			EndIf
	Case Else
			Return SetError ( 10 , $ILASTERROR , 0 )
		EndSwitch
		$BDISABLE = True
	Else
		Local $APREV = 0
		If Not IsArray ( $APRIVILEGES ) Then
			Dim $APREV [ 1 ] [ 2 ]
			$APREV [ 0 ] [ 0 ] = $APRIVILEGES
			$APREV [ 0 ] [ 1 ] = $IATTRIBUTES
		Else
			If Not UBound ( $APRIVILEGES , $UBOUND_COLUMNS ) Then
				$ICOUNT = UBound ( $APRIVILEGES )
				Dim $APREV [ $ICOUNT ] [ 2 ]
				For $I = 0 To $ICOUNT + 4294967295
					$APREV [ $I ] [ 0 ] = $APRIVILEGES [ $I ]
					$APREV [ $I ] [ 1 ] = $IATTRIBUTES
				Next
			EndIf
		EndIf
		If IsArray ( $APREV ) Then
			$APRIVILEGES = $APREV
		EndIf
		Local $TAGSTRUCT = "dword;dword[" & ( 3 * UBound ( $APRIVILEGES ) ) & "]"
		$TTP1 = DllStructCreate ( $TAGSTRUCT )
		$TTP2 = DllStructCreate ( $TAGSTRUCT )
		If @error Then Return SetError ( @error + 20 , 0 , 0 )
		DllStructSetData ( $TTP1 , 1 , UBound ( $APRIVILEGES ) )
		For $I = 0 To UBound ( $APRIVILEGES ) + 4294967295
			DllStructSetData ( $TTP1 , 2 , $APRIVILEGES [ $I ] [ 1 ] , 3 * $I + 3 )
			$ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupPrivilegeValueW" , "ptr" , 0 , "wstr" , $APRIVILEGES [ $I ] [ 0 ] , "ptr" , DllStructGetPtr ( $TTP1 , 2 ) + 12 * $I )
			If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 100 , @extended , 0 )
		Next
	EndIf
	$ACALL = DllCall ( "advapi32.dll" , "bool" , "AdjustTokenPrivileges" , "handle" , $HTOKEN , "bool" , $BDISABLE , "struct*" , $TTP1 , "dword" , DllStructGetSize ( $TTP2 ) , "struct*" , $TTP2 , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 200 , @extended , 0 )
	Local $IRESULT
	Switch _WINAPI_GETLASTERROR ( )
	Case 1300
		$IRESULT = 1
Case Else
		$IRESULT = 0
	EndSwitch
	$ICOUNT = DllStructGetData ( $TTP2 , 1 )
	If $ICOUNT Then
		Local $TDATA = DllStructCreate ( "wchar[128]" )
		Dim $APRIVILEGES [ $ICOUNT ] [ 2 ]
		For $I = 0 To $ICOUNT + 4294967295
			$ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupPrivilegeNameW" , "ptr" , 0 , "ptr" , DllStructGetPtr ( $TTP2 , 2 ) + 12 * $I , "struct*" , $TDATA , "dword*" , 128 )
			If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 300 , @extended , 0 )
			$APRIVILEGES [ $I ] [ 1 ] = DllStructGetData ( $TTP2 , 2 , 3 * $I + 3 )
			$APRIVILEGES [ $I ] [ 0 ] = DllStructGetData ( $TDATA , 1 )
		Next
		$AADJUST = $APRIVILEGES
	EndIf
	Return SetExtended ( $IRESULT , 1 )
EndFunc
Func _WINAPI_ASSIGNPROCESSTOJOBOBJECT ( $HJOB , $HPROCESS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "AssignProcessToJobObject" , "handle" , $HJOB , "handle" , $HPROCESS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ATTACHCONSOLE ( $IPID = + 4294967295 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "AttachConsole" , "dword" , $IPID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ATTACHTHREADINPUT ( $IATTACH , $IATTACHTO , $BATTACH )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "AttachThreadInput" , "dword" , $IATTACH , "dword" , $IATTACHTO , "bool" , $BATTACH )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEEVENT ( $TATTRIBUTES = 0 , $BMANUALRESET = True , $BINITIALSTATE = True , $SNAME = "" )
	If $SNAME = "" Then $SNAME = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateEventW" , "struct*" , $TATTRIBUTES , "bool" , $BMANUALRESET , "bool" , $BINITIALSTATE , "wstr" , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
	If $ILASTERROR Then Return SetExtended ( $ILASTERROR , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEJOBOBJECT ( $SNAME = "" , $TSECURITY = 0 )
	If Not StringStripWS ( $SNAME , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SNAME = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateJobObjectW" , "struct*" , $TSECURITY , "wstr" , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEMUTEX ( $SMUTEX , $BINITIAL = True , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateMutexW" , "struct*" , $TSECURITY , "bool" , $BINITIAL , "wstr" , $SMUTEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEPROCESS ( $SAPPNAME , $SCOMMAND , $TSECURITY , $TTHREAD , $BINHERIT , $IFLAGS , $PENVIRON , $SDIR , $TSTARTUPINFO , $TPROCESS )
	Local $TCOMMAND = 0
	If $SAPPNAME = "" Then $SAPPNAME = Null
	If $SCOMMAND <> "" Then
		$TCOMMAND = DllStructCreate ( "wchar Text[" & 260 + 1 & "]" )
		DllStructSetData ( $TCOMMAND , "Text" , $SCOMMAND )
	EndIf
	If $SDIR = "" Then $SDIR = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "CreateProcessW" , "wstr" , $SAPPNAME , "struct*" , $TCOMMAND , "struct*" , $TSECURITY , "struct*" , $TTHREAD , "bool" , $BINHERIT , "dword" , $IFLAGS , "struct*" , $PENVIRON , "wstr" , $SDIR , "struct*" , $TSTARTUPINFO , "struct*" , $TPROCESS )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATEPROCESSWITHTOKEN ( $SAPP , $SCMD , $IFLAGS , $TSTARTUPINFO , $TPROCESSINFO , $HTOKEN , $ILOGON = 0 , $PENVIRONMENT = 0 , $SDIR = "" )
	If Not StringStripWS ( $SAPP , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SAPP = Null
	If Not StringStripWS ( $SCMD , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SCMD = Null
	If Not StringStripWS ( $SDIR , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SDIR = Null
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "CreateProcessWithTokenW" , "handle" , $HTOKEN , "dword" , $ILOGON , "wstr" , $SAPP , "wstr" , $SCMD , "dword" , $IFLAGS , "struct*" , $PENVIRONMENT , "wstr" , $SDIR , "struct*" , $TSTARTUPINFO , "struct*" , $TPROCESSINFO )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATESEMAPHORE ( $SSEMAPHORE , $IINITIAL , $IMAXIMUM , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "CreateSemaphoreW" , "struct*" , $TSECURITY , "long" , $IINITIAL , "long" , $IMAXIMUM , "wstr" , $SSEMAPHORE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_DUPLICATETOKENEX ( $HTOKEN , $IACCESS , $ILEVEL , $ITYPE = 1 , $TSECURITY = 0 )
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "DuplicateTokenEx" , "handle" , $HTOKEN , "dword" , $IACCESS , "struct*" , $TSECURITY , "int" , $ILEVEL , "int" , $ITYPE , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _WINAPI_EMPTYWORKINGSET ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1280 : 4352 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EmptyWorkingSet" , "handle" , $HPROCESS [ 0 ] )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HPROCESS [ 0 ] ) Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_ENUMCHILDPROCESS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HSNAPSHOT = DllCall ( "kernel32.dll" , "handle" , "CreateToolhelp32Snapshot" , "dword" , 2 , "dword" , 0 )
	If @error Or ( $HSNAPSHOT [ 0 ] = Ptr ( + 4294967295 ) ) Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TPROCESSENTRY32 = DllStructCreate ( $TAGPROCESSENTRY32 )
	Local $ARET [ 101 ] [ 2 ] = [ [ 0 ] ]
	$HSNAPSHOT = $HSNAPSHOT [ 0 ]
	DllStructSetData ( $TPROCESSENTRY32 , "Size" , DllStructGetSize ( $TPROCESSENTRY32 ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32FirstW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
	Local $IERROR = @error
	While ( Not @error ) And ( $ACALL [ 0 ] )
		If DllStructGetData ( $TPROCESSENTRY32 , "ParentProcessID" ) = $IPID Then
			__INC ( $ARET )
			$ARET [ $ARET [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TPROCESSENTRY32 , "ProcessID" )
			$ARET [ $ARET [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( $TPROCESSENTRY32 , "ExeFile" )
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32NextW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
		$IERROR = @error
	WEnd
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HSNAPSHOT )
	If Not $ARET [ 0 ] [ 0 ] Then Return SetError ( $IERROR + 20 , 0 , 0 )
	__INC ( $ARET , + 4294967295 )
	Return $ARET
EndFunc
Func _WINAPI_ENUMDEVICEDRIVERS ( )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumDeviceDrivers" , "ptr" , 0 , "dword" , 0 , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $ISIZE
	If @AutoItX64 Then
		$ISIZE = $ACALL [ 3 ] / 8
	Else
		$ISIZE = $ACALL [ 3 ] / 4
	EndIf
	Local $TDATA = DllStructCreate ( "ptr[" & $ISIZE & "]" )
	$ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumDeviceDrivers" , "struct*" , $TDATA , "dword" , DllStructGetSize ( $TDATA ) , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ARET [ $ISIZE + 1 ] = [ $ISIZE ]
	For $I = 1 To $ISIZE
		$ARET [ $I ] = DllStructGetData ( $TDATA , 1 , $I )
	Next
	Return $ARET
EndFunc
Func _WINAPI_ENUMPROCESSHANDLES ( $IPID = 0 , $ITYPE = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $ARET [ 101 ] [ 4 ] = [ [ 0 ] ]
	Local $TAGSYSTEM_HANDLE_TABLE_ENTRY_INFO = "ulong ProcessId;byte ObjectTypeNumber;byte Flags;ushort Handle;ptr Object;ulong GrantedAccess"
	Local $THANDLE = DllStructCreate ( $TAGSYSTEM_HANDLE_TABLE_ENTRY_INFO )
	Local $IENTRYSIZE = DllStructGetSize ( $THANDLE )
	Local $IMAXENTRIES = 262143
	Local $TSHI = DllStructCreate ( "ulong_ptr NumberOfHandles;byte Data[" & ( $IMAXENTRIES + 1 ) * $IENTRYSIZE & "]" )
	Local $ACALL = DllCall ( "ntdll.dll" , "long" , "ZwQuerySystemInformation" , "uint" , 16 , "struct*" , $TSHI , "ulong" , DllStructGetSize ( $TSHI ) , "ulong*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $PDATA = DllStructGetPtr ( $TSHI , "Data" )
	Local $I , $INUMBEROFHANDLES = DllStructGetData ( $TSHI , "NumberOfHandles" )
	For $I = 1 To $INUMBEROFHANDLES
		If $I > $IMAXENTRIES Then ExitLoop
		$THANDLE = DllStructCreate ( $TAGSYSTEM_HANDLE_TABLE_ENTRY_INFO , $PDATA + ( $I + 4294967295 ) * $IENTRYSIZE )
		If ( DllStructGetData ( $THANDLE , "ProcessId" ) = $IPID ) And ( ( Not $ITYPE ) Or ( $ITYPE = DllStructGetData ( $THANDLE , "ObjectTypeNumber" ) ) ) Then
			__INC ( $ARET )
			$ARET [ $ARET [ 0 ] [ 0 ] ] [ 0 ] = Ptr ( DllStructGetData ( $THANDLE , "Handle" ) )
			$ARET [ $ARET [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( $THANDLE , "ObjectTypeNumber" )
			$ARET [ $ARET [ 0 ] [ 0 ] ] [ 2 ] = DllStructGetData ( $THANDLE , "Flags" )
			$ARET [ $ARET [ 0 ] [ 0 ] ] [ 3 ] = DllStructGetData ( $THANDLE , "GrantedAccess" )
		EndIf
	Next
	If Not $ARET [ 0 ] [ 0 ] Then Return SetError ( 11 , 0 , 0 )
	__INC ( $ARET , + 4294967295 )
	If $I < $INUMBEROFHANDLES Then Return SetExtended ( $INUMBEROFHANDLES , $ARET )
	Return $ARET
EndFunc
Func _WINAPI_ENUMPROCESSMODULES ( $IPID = 0 , $IFLAG = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1040 : 4112 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ICOUNT , $ACALL , $IERROR = 0
	Do
		If _WINAPI_GETVERSION ( ) >= 6.0 Then
			$ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumProcessModulesEx" , "handle" , $HPROCESS [ 0 ] , "ptr" , 0 , "dword" , 0 , "dword*" , 0 , "dword" , $IFLAG )
		Else
			$ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumProcessModules" , "handle" , $HPROCESS [ 0 ] , "ptr" , 0 , "dword" , 0 , "dword*" , 0 )
		EndIf
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		If @AutoItX64 Then
			$ICOUNT = $ACALL [ 4 ] / 8
		Else
			$ICOUNT = $ACALL [ 4 ] / 4
		EndIf
		Local $TPTR = DllStructCreate ( "ptr[" & $ICOUNT & "]" )
		If @error Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		If _WINAPI_GETVERSION ( ) >= 6.0 Then
			$ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumProcessModulesEx" , "handle" , $HPROCESS [ 0 ] , "struct*" , $TPTR , "dword" , DllStructGetSize ( $TPTR ) , "dword*" , 0 , "dword" , $IFLAG )
		Else
			$ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "EnumProcessModules" , "handle" , $HPROCESS [ 0 ] , "struct*" , $TPTR , "dword" , DllStructGetSize ( $TPTR ) , "dword*" , 0 )
		EndIf
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
		Local $ARET [ $ICOUNT + 1 ] [ 2 ] = [ [ $ICOUNT ] ]
		For $I = 1 To $ICOUNT
			$ARET [ $I ] [ 0 ] = DllStructGetData ( $TPTR , 1 , $I )
			$ARET [ $I ] [ 1 ] = _WINAPI_GETMODULEFILENAMEEX ( $HPROCESS [ 0 ] , $ARET [ $I ] [ 0 ] )
		Next
	Until 1
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS [ 0 ] )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ARET
EndFunc
Func _WINAPI_ENUMPROCESSTHREADS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HSNAPSHOT = DllCall ( "kernel32.dll" , "handle" , "CreateToolhelp32Snapshot" , "dword" , 4 , "dword" , 0 )
	If @error Or Not $HSNAPSHOT [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local Const $TAGTHREADENTRY32 = "dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags"
	Local $TTHREADENTRY32 = DllStructCreate ( $TAGTHREADENTRY32 )
	Local $ARET [ 101 ] = [ 0 ]
	$HSNAPSHOT = $HSNAPSHOT [ 0 ]
	DllStructSetData ( $TTHREADENTRY32 , "Size" , DllStructGetSize ( $TTHREADENTRY32 ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "Thread32First" , "handle" , $HSNAPSHOT , "struct*" , $TTHREADENTRY32 )
	While Not @error And $ACALL [ 0 ]
		If DllStructGetData ( $TTHREADENTRY32 , "OwnerProcessID" ) = $IPID Then
			__INC ( $ARET )
			$ARET [ $ARET [ 0 ] ] = DllStructGetData ( $TTHREADENTRY32 , "ThreadID" )
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "Thread32Next" , "handle" , $HSNAPSHOT , "struct*" , $TTHREADENTRY32 )
	WEnd
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HSNAPSHOT )
	If Not $ARET [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	__INC ( $ARET , + 4294967295 )
	Return $ARET
EndFunc
Func _WINAPI_ENUMPROCESSWINDOWS ( $IPID = 0 , $BVISIBLE = True )
	Local $ATHREADS = _WINAPI_ENUMPROCESSTHREADS ( $IPID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumWindowsProc" , "bool" , "hwnd;lparam" )
	Dim $__G_VENUM [ 101 ] [ 2 ] = [ [ 0 ] ]
	For $I = 1 To $ATHREADS [ 0 ]
		DllCall ( "user32.dll" , "bool" , "EnumThreadWindows" , "dword" , $ATHREADS [ $I ] , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "lparam" , $BVISIBLE )
		If @error Then
			ExitLoop
		EndIf
	Next
	DllCallbackFree ( $HENUMPROC )
	If Not $__G_VENUM [ 0 ] [ 0 ] Then Return SetError ( 11 , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_FATALAPPEXIT ( $SMESSAGE )
	DllCall ( "kernel32.dll" , "none" , "FatalAppExitW" , "uint" , 0 , "wstr" , $SMESSAGE )
	If @error Then Return SetError ( @error , @extended )
EndFunc
Func _WINAPI_GETCURRENTPROCESSEXPLICITAPPUSERMODELID ( )
	Local $ACALL = DllCall ( "shell32.dll" , "long" , "GetCurrentProcessExplicitAppUserModelID" , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Local $SID = _WINAPI_GETSTRING ( $ACALL [ 1 ] )
	_WINAPI_COTASKMEMFREE ( $ACALL [ 1 ] )
	Return $SID
EndFunc
Func _WINAPI_GETCURRENTPROCESSID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetCurrentProcessId" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCURRENTTHREAD ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GetCurrentThread" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETCURRENTTHREADID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetCurrentThreadId" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETDEVICEDRIVERBASENAME ( $PDRIVER )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "dword" , "GetDeviceDriverBaseNameW" , "ptr" , $PDRIVER , "wstr" , "" , "dword" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETDEVICEDRIVERFILENAME ( $PDRIVER )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "dword" , "GetDeviceDriverFileNameW" , "ptr" , $PDRIVER , "wstr" , "" , "dword" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETEXITCODEPROCESS ( $HPROCESS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetExitCodeProcess" , "handle" , $HPROCESS , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETGUIRESOURCES ( $IFLAG = 0 , $HPROCESS = + 4294967295 )
	If $HPROCESS = + 4294967295 Then $HPROCESS = _WINAPI_GETCURRENTPROCESS ( )
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "GetGuiResources" , "handle" , $HPROCESS , "dword" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETMODULEFILENAMEEX ( $HPROCESS , $HMODULE = 0 )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "dword" , "GetModuleFileNameExW" , "handle" , $HPROCESS , "handle" , $HMODULE , "wstr" , "" , "int" , 4096 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETMODULEINFORMATION ( $HPROCESS , $HMODULE = 0 )
	Local $TMODULEINFO = DllStructCreate ( $TAGMODULEINFO )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "GetModuleInformation" , "handle" , $HPROCESS , "handle" , $HMODULE , "struct*" , $TMODULEINFO , "dword" , DllStructGetSize ( $TMODULEINFO ) )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $TMODULEINFO
EndFunc
Func _WINAPI_GETPARENTPROCESS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HSNAPSHOT = DllCall ( "kernel32.dll" , "handle" , "CreateToolhelp32Snapshot" , "dword" , 2 , "dword" , 0 )
	If @error Or Not $HSNAPSHOT [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TPROCESSENTRY32 = DllStructCreate ( $TAGPROCESSENTRY32 )
	Local $IRESULT = 0
	$HSNAPSHOT = $HSNAPSHOT [ 0 ]
	DllStructSetData ( $TPROCESSENTRY32 , "Size" , DllStructGetSize ( $TPROCESSENTRY32 ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32FirstW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
	Local $IERROR = @error
	While ( Not @error ) And ( $ACALL [ 0 ] )
		If DllStructGetData ( $TPROCESSENTRY32 , "ProcessID" ) = $IPID Then
			$IRESULT = DllStructGetData ( $TPROCESSENTRY32 , "ParentProcessID" )
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32NextW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
		$IERROR = @error
	WEnd
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HSNAPSHOT )
	If Not $IRESULT Then Return SetError ( $IERROR , 0 , 0 )
	Return $IRESULT
EndFunc
Func _WINAPI_GETPRIORITYCLASS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1024 : 4096 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $IERROR = 0
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetPriorityClass" , "handle" , $HPROCESS [ 0 ] )
	If @error Then $IERROR = @error
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS [ 0 ] )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPROCESSAFFINITYMASK ( $HPROCESS )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetProcessAffinityMask" , "handle" , $HPROCESS , "dword_ptr*" , 0 , "dword_ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $AMASK [ 3 ]
	$AMASK [ 0 ] = True
	$AMASK [ 1 ] = $ACALL [ 2 ]
	$AMASK [ 2 ] = $ACALL [ 3 ]
	Return $AMASK
EndFunc
Func _WINAPI_GETPROCESSCOMMANDLINE ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1040 : 4112 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	$HPROCESS = $HPROCESS [ 0 ]
	Local $TPBI = DllStructCreate ( "ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId" )
	Local $TPEB = DllStructCreate ( "byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId" )
	Local $TUPP = DllStructCreate ( "ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5" )
	Local $TCMD
	Local $ACALL , $IERROR = 0
	Do
		$ACALL = DllCall ( "ntdll.dll" , "long" , "NtQueryInformationProcess" , "handle" , $HPROCESS , "ulong" , 0 , "struct*" , $TPBI , "ulong" , DllStructGetSize ( $TPBI ) , "ulong*" , 0 )
		If @error Or $ACALL [ 0 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , DllStructGetData ( $TPBI , "PebBaseAddress" ) , "struct*" , $TPEB , "ulong_ptr" , DllStructGetSize ( $TPEB ) , "ulong_ptr*" , 0 )
		If @error Or Not $ACALL [ 0 ] Or ( Not $ACALL [ 5 ] ) Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , DllStructGetData ( $TPEB , "ProcessParameters" ) , "struct*" , $TUPP , "ulong_ptr" , DllStructGetSize ( $TUPP ) , "ulong_ptr*" , 0 )
		If @error Or Not $ACALL [ 0 ] Or ( Not $ACALL [ 5 ] ) Then
			$IERROR = @error + 50
			ExitLoop
		EndIf
		$TCMD = DllStructCreate ( "byte[" & DllStructGetData ( $TUPP , "MaxLengthCommandLine" ) & "]" )
		If @error Then
			$IERROR = @error + 60
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , DllStructGetData ( $TUPP , "CommandLine" ) , "struct*" , $TCMD , "ulong_ptr" , DllStructGetSize ( $TCMD ) , "ulong_ptr*" , 0 )
		If @error Or Not $ACALL [ 0 ] Or ( Not $ACALL [ 5 ] ) Then
			$IERROR = @error + 70
			ExitLoop
		EndIf
	Until 1
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS )
	If $IERROR Then Return SetError ( $IERROR , 0 , "" )
	Return StringStripWS ( _WINAPI_PATHGETARGS ( _WINAPI_GETSTRING ( DllStructGetPtr ( $TCMD , 1 ) ) ) , $STR_STRIPLEADING + $STR_STRIPTRAILING )
EndFunc
Func _WINAPI_GETPROCESSFILENAME ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1040 : 4112 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	Local $SPATH = _WINAPI_GETMODULEFILENAMEEX ( $HPROCESS [ 0 ] )
	Local $IERROR = @error
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS [ 0 ] )
	If $IERROR Then Return SetError ( @error , 0 , "" )
	Return $SPATH
EndFunc
Func _WINAPI_GETPROCESSHANDLECOUNT ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1024 : 4096 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetProcessHandleCount" , "handle" , $HPROCESS [ 0 ] , "dword*" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HPROCESS [ 0 ] ) Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_GETPROCESSID ( $HPROCESS )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetProcessId" , "handle" , $HPROCESS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETPROCESSIOCOUNTERS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1024 : 4096 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TIO_COUNTERS = DllStructCreate ( "uint64[6]" )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetProcessIoCounters" , "handle" , $HPROCESS [ 0 ] , "struct*" , $TIO_COUNTERS )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HPROCESS [ 0 ] ) Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 6 ]
	For $I = 0 To 5
		$ARET [ $I ] = DllStructGetData ( $TIO_COUNTERS , 1 , $I + 1 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETPROCESSMEMORYINFO ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1040 : 4112 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TPMC_EX = DllStructCreate ( "dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr" )
	Local $ACALL = DllCall ( @SystemDir & "\psapi.dll" , "bool" , "GetProcessMemoryInfo" , "handle" , $HPROCESS [ 0 ] , "struct*" , $TPMC_EX , "int" , DllStructGetSize ( $TPMC_EX ) )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HPROCESS [ 0 ] ) Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 10 ]
	For $I = 0 To 9
		$ARET [ $I ] = DllStructGetData ( $TPMC_EX , $I + 2 )
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETPROCESSNAME ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HSNAPSHOT = DllCall ( "kernel32.dll" , "handle" , "CreateToolhelp32Snapshot" , "dword" , 2 , "dword" , 0 )
	If @error Or Not $HSNAPSHOT [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	$HSNAPSHOT = $HSNAPSHOT [ 0 ]
	Local $TPROCESSENTRY32 = DllStructCreate ( $TAGPROCESSENTRY32 )
	DllStructSetData ( $TPROCESSENTRY32 , "Size" , DllStructGetSize ( $TPROCESSENTRY32 ) )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32FirstW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
	Local $IERROR = @error
	While ( Not @error ) And ( $ACALL [ 0 ] )
		If DllStructGetData ( $TPROCESSENTRY32 , "ProcessID" ) = $IPID Then
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "Process32NextW" , "handle" , $HSNAPSHOT , "struct*" , $TPROCESSENTRY32 )
		$IERROR = @error
	WEnd
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HSNAPSHOT )
	If $IERROR Then Return SetError ( $IERROR , 0 , "" )
	If Not $ACALL [ 0 ] Then SetError ( 10 , 0 , "" )
	Return DllStructGetData ( $TPROCESSENTRY32 , "ExeFile" )
EndFunc
Func _WINAPI_GETPROCESSTIMES ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1024 : 4096 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetProcessTimes" , "handle" , $HPROCESS [ 0 ] , "struct*" , $TFILETIME , "uint64*" , 0 , "uint64*" , 0 , "uint64*" , 0 )
	If __CHECKERRORCLOSEHANDLE ( $ACALL , $HPROCESS [ 0 ] ) Then Return SetError ( @error , @extended , 0 )
	Local $ARET [ 3 ]
	$ARET [ 0 ] = $TFILETIME
	$ARET [ 1 ] = $ACALL [ 4 ]
	$ARET [ 2 ] = $ACALL [ 5 ]
	Return $ARET
EndFunc
Func _WINAPI_GETPROCESSUSER ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $TSID , $HTOKEN , $ACALL
	Local $IERROR = 0
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1024 : 4096 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Do
		$HTOKEN = _WINAPI_OPENPROCESSTOKEN ( 8 , $HPROCESS [ 0 ] )
		If Not $HTOKEN Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$TSID = DllStructCreate ( "ptr;byte[1024]" )
		$ACALL = DllCall ( "advapi32.dll" , "bool" , "GetTokenInformation" , "handle" , $HTOKEN , "uint" , 1 , "struct*" , $TSID , "dword" , DllStructGetSize ( $TSID ) , "dword*" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$ACALL = DllCall ( "advapi32.dll" , "bool" , "LookupAccountSidW" , "ptr" , 0 , "ptr" , DllStructGetData ( $TSID , 1 ) , "wstr" , "" , "dword*" , 2048 , "wstr" , "" , "dword*" , 2048 , "uint*" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
	Until 1
	If $HTOKEN Then
		DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HTOKEN )
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS [ 0 ] )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Local $ARET [ 2 ]
	$ARET [ 0 ] = $ACALL [ 3 ]
	$ARET [ 1 ] = $ACALL [ 5 ]
	Return $ARET
EndFunc
Func _WINAPI_GETPROCESSWORKINGDIRECTORY ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $ACALL , $IERROR = 0
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1040 : 4112 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , "" )
	$HPROCESS = $HPROCESS [ 0 ]
	Local $TPBI = DllStructCreate ( "ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId" )
	Local $TPEB = DllStructCreate ( "byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId" )
	Local $TUPP = DllStructCreate ( "ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5" )
	Local $TDIR
	Do
		$ACALL = DllCall ( "ntdll.dll" , "long" , "NtQueryInformationProcess" , "handle" , $HPROCESS , "ulong" , 0 , "struct*" , $TPBI , "ulong" , DllStructGetSize ( $TPBI ) , "ulong*" , 0 )
		If @error Or ( $ACALL [ 0 ] ) Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , DllStructGetData ( $TPBI , "PebBaseAddress" ) , "struct*" , $TPEB , "ulong_ptr" , DllStructGetSize ( $TPEB ) , "ulong_ptr*" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( Not $ACALL [ 5 ] ) Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , DllStructGetData ( $TPEB , "ProcessParameters" ) , "struct*" , $TUPP , "ulong_ptr" , DllStructGetSize ( $TUPP ) , "ulong_ptr*" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( Not $ACALL [ 5 ] ) Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
		$TDIR = DllStructCreate ( "byte[" & DllStructGetData ( $TUPP , "MaxLengthCurrentDirectory" ) & "]" )
		If @error Then
			$IERROR = @error + 50
			ExitLoop
		EndIf
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "ReadProcessMemory" , "handle" , $HPROCESS , "ptr" , DllStructGetData ( $TUPP , "CurrentDirectory" ) , "struct*" , $TDIR , "ulong_ptr" , DllStructGetSize ( $TDIR ) , "ulong_ptr*" , 0 )
		If @error Or ( Not $ACALL [ 0 ] ) Or ( Not $ACALL [ 5 ] ) Then
			$IERROR = @error + 60
			ExitLoop
		EndIf
		$IERROR = 0
	Until 1
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS )
	If $IERROR Then Return SetError ( $IERROR , 0 , "" )
	Return _WINAPI_PATHREMOVEBACKSLASH ( _WINAPI_GETSTRING ( DllStructGetPtr ( $TDIR ) ) )
EndFunc
Func _WINAPI_GETTHREADDESKTOP ( $ITHREADID )
	Local $ACALL = DllCall ( "user32.dll" , "handle" , "GetThreadDesktop" , "dword" , $ITHREADID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTHREADERRORMODE ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetThreadErrorMode" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETWINDOWFILENAME ( $HWND )
	Local $IPID = 0
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "IsWindow" , "hwnd" , $HWND )
	If $ACALL [ 0 ] Then
		$ACALL = DllCall ( "user32.dll" , "dword" , "GetWindowThreadProcessId" , "hwnd" , $HWND , "dword*" , 0 )
		$IPID = $ACALL [ 2 ]
	EndIf
	If Not $IPID Then Return SetError ( 1 , 0 , "" )
	Local $SRESULT = _WINAPI_GETPROCESSFILENAME ( $IPID )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $SRESULT
EndFunc
Func _WINAPI_ISELEVATED ( )
	Local $IELEV , $ACALL , $IERROR = 0
	Local $HTOKEN = _WINAPI_OPENPROCESSTOKEN ( 8 )
	If Not $HTOKEN Then Return SetError ( @error + 10 , @extended , False )
	Do
		$ACALL = DllCall ( "advapi32.dll" , "bool" , "GetTokenInformation" , "handle" , $HTOKEN , "uint" , 20 , "uint*" , 0 , "dword" , 4 , "dword*" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$IELEV = $ACALL [ 3 ]
		$ACALL = DllCall ( "advapi32.dll" , "bool" , "GetTokenInformation" , "handle" , $HTOKEN , "uint" , 18 , "uint*" , 0 , "dword" , 4 , "dword*" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
	Until 1
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HTOKEN )
	If $IERROR Then Return SetError ( $IERROR , 0 , False )
	Return SetExtended ( $ACALL [ 0 ] + 4294967295 , $IELEV )
EndFunc
Func _WINAPI_ISPROCESSINJOB ( $HPROCESS , $HJOB = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsProcessInJob" , "handle" , $HPROCESS , "handle" , $HJOB , "bool*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_OPENJOBOBJECT ( $SNAME , $IACCESS = $JOB_OBJECT_ALL_ACCESS , $BINHERIT = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenJobObjectW" , "dword" , $IACCESS , "bool" , $BINHERIT , "wstr" , $SNAME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENMUTEX ( $SMUTEX , $IACCESS = $MUTEX_ALL_ACCESS , $BINHERIT = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenMutexW" , "dword" , $IACCESS , "bool" , $BINHERIT , "wstr" , $SMUTEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_OPENPROCESS ( $IACCESS , $BINHERIT , $IPID , $BDEBUGPRIV = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return $ACALL [ 0 ]
	If Not $BDEBUGPRIV Then Return SetError ( 100 , 0 , 0 )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKENEX ( BitOR ( $TOKEN_ADJUST_PRIVILEGES , $TOKEN_QUERY ) )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_DEBUG_NAME , True )
	Local $IERROR = @error
	Local $IEXTENDED = @extended
	Local $IRET = 0
	If Not @error Then
		$ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , $IACCESS , "bool" , $BINHERIT , "dword" , $IPID )
		$IERROR = @error
		$IEXTENDED = @extended
		If $ACALL [ 0 ] Then $IRET = $ACALL [ 0 ]
		_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_DEBUG_NAME , False )
		If @error Then
			$IERROR = @error + 20
			$IEXTENDED = @extended
		EndIf
	Else
		$IERROR = @error + 30
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HTOKEN )
	Return SetError ( $IERROR , $IEXTENDED , $IRET )
EndFunc
Func _WINAPI_OPENPROCESSTOKEN ( $IACCESS , $HPROCESS = 0 )
	If Not $HPROCESS Then
		$HPROCESS = DllCall ( "kernel32.dll" , "handle" , "GetCurrentProcess" )
		$HPROCESS = $HPROCESS [ 0 ]
	EndIf
	Local $ACALL = DllCall ( "advapi32.dll" , "bool" , "OpenProcessToken" , "handle" , $HPROCESS , "dword" , $IACCESS , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_OPENSEMAPHORE ( $SSEMAPHORE , $IACCESS = 2031619 , $BINHERIT = False )
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "OpenSemaphoreW" , "dword" , $IACCESS , "bool" , $BINHERIT , "wstr" , $SSEMAPHORE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_QUERYINFORMATIONJOBOBJECT ( $HJOB , $IJOBOBJECTINFOCLASS , ByRef $TJOBOBJECTINFO )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "QueryInformationJobObject" , "handle" , $HJOB , "int" , $IJOBOBJECTINFOCLASS , "struct*" , $TJOBOBJECTINFO , "dword" , DllStructGetSize ( $TJOBOBJECTINFO ) , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_RELEASEMUTEX ( $HMUTEX )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReleaseMutex" , "handle" , $HMUTEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_RELEASESEMAPHORE ( $HSEMAPHORE , $IINCREASE = 1 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ReleaseSemaphore" , "handle" , $HSEMAPHORE , "long" , $IINCREASE , "long*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_RESETEVENT ( $HEVENT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "ResetEvent" , "handle" , $HEVENT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETEVENT ( $HEVENT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetEvent" , "handle" , $HEVENT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETINFORMATIONJOBOBJECT ( $HJOB , $IJOBOBJECTINFOCLASS , $TJOBOBJECTINFO )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetInformationJobObject" , "handle" , $HJOB , "int" , $IJOBOBJECTINFOCLASS , "struct*" , $TJOBOBJECTINFO , "dword" , DllStructGetSize ( $TJOBOBJECTINFO ) )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETPRIORITYCLASS ( $IPRIORITY , $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1536 : 4608 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Local $IERROR = 0
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetPriorityClass" , "handle" , $HPROCESS [ 0 ] , "dword" , $IPRIORITY )
	If @error Then $IERROR = @error
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS [ 0 ] )
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETPROCESSAFFINITYMASK ( $HPROCESS , $IMASK )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetProcessAffinityMask" , "handle" , $HPROCESS , "ulong_ptr" , $IMASK )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTHREADDESKTOP ( $HDESKTOP )
	Local $ACALL = DllCall ( "user32.dll" , "bool" , "SetThreadDesktop" , "handle" , $HDESKTOP )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTHREADERRORMODE ( $IMODE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetThreadErrorMode" , "dword" , $IMODE , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _WINAPI_SETTHREADEXECUTIONSTATE ( $IFLAGS )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "SetThreadExecutionState" , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_TERMINATEJOBOBJECT ( $HJOB , $IEXITCODE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "TerminateJobObject" , "handle" , $HJOB , "uint" , $IEXITCODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_TERMINATEPROCESS ( $HPROCESS , $IEXITCODE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "TerminateProcess" , "handle" , $HPROCESS , "uint" , $IEXITCODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_USERHANDLEGRANTACCESS ( $HOBJECT , $HJOB , $BGRANT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "UserHandleGrantAccess" , "handle" , $HOBJECT , "handle" , $HJOB , "bool" , $BGRANT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WAITFORINPUTIDLE ( $HPROCESS , $ITIMEOUT = + 4294967295 )
	Local $ACALL = DllCall ( "user32.dll" , "dword" , "WaitForInputIdle" , "handle" , $HPROCESS , "dword" , $ITIMEOUT )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WAITFORMULTIPLEOBJECTS ( $ICOUNT , $PAHANDLES , $BWAITALL = False , $ITIMEOUT = + 4294967295 )
	Local $ACALL = DllCall ( "kernel32.dll" , "INT" , "WaitForMultipleObjects" , "dword" , $ICOUNT , "struct*" , $PAHANDLES , "bool" , $BWAITALL , "dword" , $ITIMEOUT )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WAITFORSINGLEOBJECT ( $HHANDLE , $ITIMEOUT = + 4294967295 )
	Local $ACALL = DllCall ( "kernel32.dll" , "INT" , "WaitForSingleObject" , "handle" , $HHANDLE , "dword" , $ITIMEOUT )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_WRITECONSOLE ( $HCONSOLE , $STEXT )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "WriteConsoleW" , "handle" , $HCONSOLE , "wstr" , $STEXT , "dword" , StringLen ( $STEXT ) , "dword*" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
Global Const $DTS_SHORTDATEFORMAT = 0
Global Const $DTS_UPDOWN = 1
Global Const $DTS_SHOWNONE = 2
Global Const $DTS_LONGDATEFORMAT = 4
Global Const $DTS_TIMEFORMAT = 9
Global Const $DTS_RIGHTALIGN = 32
Global Const $DTS_SHORTDATECENTURYFORMAT = 12
Global Const $DTS_APPCANPARSE = 16
Global Const $DMW_LONGNAME = 0
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Global Const $DMW_LOCALE_SHORTNAME = 3
Global Const $GDT_ERROR = + 4294967295
Global Const $GDT_VALID = 0
Global Const $GDT_NONE = 1
Global Const $GDTR_MIN = 1
Global Const $GDTR_MAX = 2
Global Const $MCHT_NOWHERE = 0
Global Const $MCHT_TITLE = 65536
Global Const $MCHT_CALENDAR = 131072
Global Const $MCHT_TODAYLINK = 196608
Global Const $MCHT_NEXT = 16777216
Global Const $MCHT_PREV = 33554432
Global Const $MCHT_TITLEBK = 65536
Global Const $MCHT_TITLEMONTH = 65537
Global Const $MCHT_TITLEYEAR = 65538
Global Const $MCHT_TITLEBTNNEXT = 16842755
Global Const $MCHT_TITLEBTNPREV = 33619971
Global Const $MCHT_CALENDARBK = 131072
Global Const $MCHT_CALENDARDATE = 131073
Global Const $MCHT_CALENDARDAY = 131074
Global Const $MCHT_CALENDARWEEKNUM = 131075
Global Const $MCHT_CALENDARDATENEXT = 16908288
Global Const $MCHT_CALENDARDATEPREV = 33685504
Global Const $MCS_DAYSTATE = 1
Global Const $MCS_MULTISELECT = 2
Global Const $MCS_WEEKNUMBERS = 4
Global Const $MCS_NOTODAYCIRCLE = 8
Global Const $MCS_NOTODAY = 16
Global Const $MCS_NOTRAILINGDATES = 64
Global Const $MCS_SHORTDAYSOFWEEK = 128
Global Const $MCS_NOSELCHANGEONNAV = 256
Global Const $MCM_FIRST = 4096
Global Const $MCM_GETCALENDARBORDER = ( $MCM_FIRST + 31 )
Global Const $MCM_GETCALENDARCOUNT = ( $MCM_FIRST + 23 )
Global Const $MCM_GETCALENDARGRIDINFO = ( $MCM_FIRST + 24 )
Global Const $MCM_GETCALID = ( $MCM_FIRST + 27 )
Global Const $MCM_GETCOLOR = ( $MCM_FIRST + 11 )
Global Const $MCM_GETCURRENTVIEW = ( $MCM_FIRST + 22 )
Global Const $MCM_GETCURSEL = ( $MCM_FIRST + 1 )
Global Const $MCM_GETFIRSTDAYOFWEEK = ( $MCM_FIRST + 16 )
Global Const $MCM_GETMAXSELCOUNT = ( $MCM_FIRST + 3 )
Global Const $MCM_GETMAXTODAYWIDTH = ( $MCM_FIRST + 21 )
Global Const $MCM_GETMINREQRECT = ( $MCM_FIRST + 9 )
Global Const $MCM_GETMONTHDELTA = ( $MCM_FIRST + 19 )
Global Const $MCM_GETMONTHRANGE = ( $MCM_FIRST + 7 )
Global Const $MCM_GETRANGE = ( $MCM_FIRST + 17 )
Global Const $MCM_GETSELRANGE = ( $MCM_FIRST + 5 )
Global Const $MCM_GETTODAY = ( $MCM_FIRST + 13 )
Global Const $MCM_GETUNICODEFORMAT = 8192 + 6
Global Const $MCM_HITTEST = ( $MCM_FIRST + 14 )
Global Const $MCM_SETCALENDARBORDER = ( $MCM_FIRST + 30 )
Global Const $MCM_SETCALID = ( $MCM_FIRST + 28 )
Global Const $MCM_SETCOLOR = ( $MCM_FIRST + 10 )
Global Const $MCM_SETCURRENTVIEW = ( $MCM_FIRST + 32 )
Global Const $MCM_SETCURSEL = ( $MCM_FIRST + 2 )
Global Const $MCM_SETDAYSTATE = ( $MCM_FIRST + 8 )
Global Const $MCM_SETFIRSTDAYOFWEEK = ( $MCM_FIRST + 15 )
Global Const $MCM_SETMAXSELCOUNT = ( $MCM_FIRST + 4 )
Global Const $MCM_SETMONTHDELTA = ( $MCM_FIRST + 20 )
Global Const $MCM_SETRANGE = ( $MCM_FIRST + 18 )
Global Const $MCM_SETSELRANGE = ( $MCM_FIRST + 6 )
Global Const $MCM_SETTODAY = ( $MCM_FIRST + 12 )
Global Const $MCM_SETUNICODEFORMAT = 8192 + 5
Global Const $MCM_SIZERECTTOMIN = ( $MCM_FIRST + 29 )
Global Const $MCN_FIRST = + 4294966550
Global Const $MCN_SELCHANGE = ( $MCN_FIRST + 4294967293 )
Global Const $MCN_GETDAYSTATE = ( $MCN_FIRST + 4294967295 )
Global Const $MCN_SELECT = ( $MCN_FIRST )
Global Const $MCN_VIEWCHANGE = ( $MCN_FIRST + 4294967292 )
Global Const $MCSC_BACKGROUND = 0
Global Const $MCSC_MONTHBK = 4
Global Const $MCSC_TEXT = 1
Global Const $MCSC_TITLEBK = 2
Global Const $MCSC_TITLETEXT = 3
Global Const $MCSC_TRAILINGTEXT = 5
Global Const $DTM_FIRST = 4096
Global Const $DTM_GETSYSTEMTIME = $DTM_FIRST + 1
Global Const $DTM_SETSYSTEMTIME = $DTM_FIRST + 2
Global Const $DTM_GETRANGE = $DTM_FIRST + 3
Global Const $DTM_SETRANGE = $DTM_FIRST + 4
Global Const $DTM_SETFORMAT = $DTM_FIRST + 5
Global Const $DTM_SETMCCOLOR = $DTM_FIRST + 6
Global Const $DTM_GETMCCOLOR = $DTM_FIRST + 7
Global Const $DTM_GETMONTHCAL = $DTM_FIRST + 8
Global Const $DTM_SETMCFONT = $DTM_FIRST + 9
Global Const $DTM_GETMCFONT = $DTM_FIRST + 10
Global Const $DTM_SETFORMATW = $DTM_FIRST + 50
Global Const $DTN_FIRST = + 4294966556
Global Const $DTN_FIRST2 = + 4294966543
Global Const $DTN_DATETIMECHANGE = $DTN_FIRST2 + 4294967290
Global Const $DTN_USERSTRING = $DTN_FIRST2 + 4294967291
Global Const $DTN_WMKEYDOWN = $DTN_FIRST2 + 4294967292
Global Const $DTN_FORMAT = $DTN_FIRST2 + 4294967293
Global Const $DTN_FORMATQUERY = $DTN_FIRST2 + 4294967294
Global Const $DTN_DROPDOWN = $DTN_FIRST2 + 4294967295
Global Const $DTN_CLOSEUP = $DTN_FIRST2 + 0
Global Const $DTN_USERSTRINGW = $DTN_FIRST + 4294967291
Global Const $DTN_WMKEYDOWNW = $DTN_FIRST + 4294967292
Global Const $DTN_FORMATW = $DTN_FIRST + 4294967293
Global Const $DTN_FORMATQUERYW = $DTN_FIRST + 4294967294
Global Const $GUI_SS_DEFAULT_DATE = $DTS_LONGDATEFORMAT
Global Const $GUI_SS_DEFAULT_MONTHCAL = 0
#Region Global Variables and Constants
Global Const $TAGNUMBERFMT = "uint NumDigits;uint LeadingZero;uint Grouping;ptr DecimalSep;ptr ThousandSep;uint NegativeOrder"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_COMPARESTRING ( $ILCID , $SSTRING1 , $SSTRING2 , $IFLAGS = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "CompareStringW" , "dword" , $ILCID , "dword" , $IFLAGS , "wstr" , $SSTRING1 , "int" , + 4294967295 , "wstr" , $SSTRING2 , "int" , + 4294967295 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_CREATENUMBERFORMATINFO ( $INUMDIGITS , $ILEADINGZERO , $IGROUPING , $SDECIMALSEP , $STHOUSANDSEP , $INEGATIVEORDER )
	Local $TFMT = DllStructCreate ( $TAGNUMBERFMT & ";wchar[" & ( StringLen ( $SDECIMALSEP ) + 1 ) & "];wchar[" & ( StringLen ( $STHOUSANDSEP ) + 1 ) & "]" )
	DllStructSetData ( $TFMT , 1 , $INUMDIGITS )
	DllStructSetData ( $TFMT , 2 , $ILEADINGZERO )
	DllStructSetData ( $TFMT , 3 , $IGROUPING )
	DllStructSetData ( $TFMT , 4 , DllStructGetPtr ( $TFMT , 7 ) )
	DllStructSetData ( $TFMT , 5 , DllStructGetPtr ( $TFMT , 8 ) )
	DllStructSetData ( $TFMT , 6 , $INEGATIVEORDER )
	DllStructSetData ( $TFMT , 7 , $SDECIMALSEP )
	DllStructSetData ( $TFMT , 8 , $STHOUSANDSEP )
	Return $TFMT
EndFunc
Func _WINAPI_ENUMSYSTEMGEOID ( )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumGeoIDProc" , "bool" , "long" )
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumSystemGeoID" , "dword" , 16 , "long" , 0 , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMSYSTEMLOCALES ( $IFLAG )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumLocalesProc" , "bool" , "ptr" )
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumSystemLocalesW" , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "dword" , $IFLAG )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_ENUMUILANGUAGES ( $IFLAG = 0 )
	Local $HENUMPROC = DllCallbackRegister ( "__EnumUILanguagesProc" , "bool" , "ptr;long_ptr" )
	Local $IID = 1
	If _WINAPI_GETVERSION ( ) >= 6.0 Then
		If BitAND ( $IFLAG , 8 ) Then
			$IID = 0
		EndIf
	Else
		$IFLAG = 0
	EndIf
	Dim $__G_VENUM [ 101 ] = [ 0 ]
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "EnumUILanguagesW" , "ptr" , DllCallbackGetPtr ( $HENUMPROC ) , "dword" , $IFLAG , "long_ptr" , $IID )
	If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] Then
		$__G_VENUM = @error + 10
	EndIf
	DllCallbackFree ( $HENUMPROC )
	If $__G_VENUM Then Return SetError ( $__G_VENUM , 0 , 0 )
	__INC ( $__G_VENUM , + 4294967295 )
	Return $__G_VENUM
EndFunc
Func _WINAPI_GETDATEFORMAT ( $ILCID = 0 , $TSYSTEMTIME = 0 , $IFLAGS = 0 , $SFORMAT = "" )
	If Not $ILCID Then $ILCID = 1024
	If Not StringStripWS ( $SFORMAT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SFORMAT = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetDateFormatW" , "dword" , $ILCID , "dword" , $IFLAGS , "struct*" , $TSYSTEMTIME , "wstr" , $SFORMAT , "wstr" , "" , "int" , 2048 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_GETDURATIONFORMAT ( $ILCID , $IDURATION , $SFORMAT = "" )
	If Not $ILCID Then $ILCID = 1024
	Local $PST , $IVAL
	If IsDllStruct ( $IDURATION ) Then
		$PST = DllStructGetPtr ( $IDURATION )
		$IVAL = 0
	Else
		$PST = 0
		$IVAL = $IDURATION
	EndIf
	If Not StringStripWS ( $SFORMAT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SFORMAT = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetDurationFormat" , "dword" , $ILCID , "dword" , 0 , "ptr" , $PST , "uint64" , $IVAL , "wstr" , $SFORMAT , "wstr" , "" , "int" , 2048 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 6 ]
EndFunc
Func _WINAPI_GETGEOINFO ( $IGEOID , $ITYPE , $ILANGUAGE = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetGeoInfoW" , "long" , $IGEOID , "dword" , $ITYPE , "wstr" , "" , "int" , 4096 , "word" , $ILANGUAGE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETLOCALEINFO ( $ILCID , $ITYPE )
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetLocaleInfoW" , "dword" , $ILCID , "dword" , $ITYPE , "wstr" , "" , "int" , 2048 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _WINAPI_GETNUMBERFORMAT ( $ILCID , $SNUMBER , $TNUMBERFMT = 0 )
	If Not $ILCID Then $ILCID = 1024
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetNumberFormatW" , "dword" , $ILCID , "dword" , 0 , "wstr" , $SNUMBER , "struct*" , $TNUMBERFMT , "wstr" , "" , "int" , 2048 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , "" )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_GETSYSTEMDEFAULTLANGID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "word" , "GetSystemDefaultLangID" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSYSTEMDEFAULTLCID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetSystemDefaultLCID" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETSYSTEMDEFAULTUILANGUAGE ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "word" , "GetSystemDefaultUILanguage" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTHREADLOCALE ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetThreadLocale" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTHREADUILANGUAGE ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "word" , "GetThreadUILanguage" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETTIMEFORMAT ( $ILCID = 0 , $TSYSTEMTIME = 0 , $IFLAGS = 0 , $SFORMAT = "" )
	If Not $ILCID Then $ILCID = 1024
	If Not StringStripWS ( $SFORMAT , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SFORMAT = Null
	Local $ACALL = DllCall ( "kernel32.dll" , "int" , "GetTimeFormatW" , "dword" , $ILCID , "dword" , $IFLAGS , "struct*" , $TSYSTEMTIME , "wstr" , $SFORMAT , "wstr" , "" , "int" , 2048 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Return $ACALL [ 5 ]
EndFunc
Func _WINAPI_GETUSERDEFAULTLANGID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "word" , "GetUserDefaultLangID" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETUSERDEFAULTLCID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetUserDefaultLCID" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETUSERDEFAULTUILANGUAGE ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "word" , "GetUserDefaultUILanguage" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_GETUSERGEOID ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "long" , "GetUserGeoID" , "uint" , 16 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISVALIDLOCALE ( $ILCID , $IFLAG = 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "IsValidLocale" , "dword" , $ILCID , "dword" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETLOCALEINFO ( $ILCID , $ITYPE , $SDATA )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetLocaleInfoW" , "dword" , $ILCID , "dword" , $ITYPE , "wstr" , $SDATA )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTHREADLOCALE ( $ILCID )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetThreadLocale" , "dword" , $ILCID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_SETTHREADUILANGUAGE ( $ILANGUAGE )
	Local $ACALL = DllCall ( "kernel32.dll" , "word" , "SetThreadUILanguage" , "word" , $ILANGUAGE )
	If @error Then Return SetError ( @error , @extended , False )
	Return ( $ACALL [ 0 ] = $ACALL [ 1 ] )
EndFunc
Func _WINAPI_SETUSERGEOID ( $IGEOID )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetUserGeoID" , "long" , $IGEOID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __ENUMGEOIDPROC ( $IID )
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] ] = $IID
	Return 1
EndFunc
Func __ENUMLOCALESPROC ( $PLOCALE )
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] ] = Dec ( DllStructGetData ( DllStructCreate ( "wchar[" & ( _WINAPI_STRLEN ( $PLOCALE ) + 1 ) & "]" , $PLOCALE ) , 1 ) )
	Return 1
EndFunc
Func __ENUMUILANGUAGESPROC ( $PLANGUAGE , $IID )
	__INC ( $__G_VENUM )
	$__G_VENUM [ $__G_VENUM [ 0 ] ] = DllStructGetData ( DllStructCreate ( "wchar[" & ( _WINAPI_STRLEN ( $PLANGUAGE ) + 1 ) & "]" , $PLANGUAGE ) , 1 )
	If $IID Then
		$__G_VENUM [ $__G_VENUM [ 0 ] ] = Dec ( $__G_VENUM [ $__G_VENUM [ 0 ] ] )
	EndIf
	Return 1
EndFunc
#EndRegion Internal Functions
Func _DATEADD ( $STYPE , $INUMBER , $SDATE )
	Local $ASTIMEPART [ 4 ]
	Local $ASDATEPART [ 4 ]
	Local $IJULIANDATE
	$STYPE = StringLeft ( $STYPE , 1 )
	If StringInStr ( "D,M,Y,w,h,n,s" , $STYPE ) = 0 Or $STYPE = "" Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If Not StringIsInt ( $INUMBER ) Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If Not _DATEISVALID ( $SDATE ) Then
		Return SetError ( 3 , 0 , 0 )
	EndIf
	_DATETIMESPLIT ( $SDATE , $ASDATEPART , $ASTIMEPART )
	If $STYPE = "d" Or $STYPE = "w" Then
		If $STYPE = "w" Then $INUMBER = $INUMBER * 7
		$IJULIANDATE = _DATETODAYVALUE ( $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] ) + $INUMBER
		_DAYVALUETODATE ( $IJULIANDATE , $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] )
	EndIf
	If $STYPE = "m" Then
		$ASDATEPART [ 2 ] = $ASDATEPART [ 2 ] + $INUMBER
		While $ASDATEPART [ 2 ] > 12
			$ASDATEPART [ 2 ] = $ASDATEPART [ 2 ] + 4294967284
			$ASDATEPART [ 1 ] = $ASDATEPART [ 1 ] + 1
		WEnd
		While $ASDATEPART [ 2 ] < 1
			$ASDATEPART [ 2 ] = $ASDATEPART [ 2 ] + 12
			$ASDATEPART [ 1 ] = $ASDATEPART [ 1 ] + 4294967295
		WEnd
	EndIf
	If $STYPE = "y" Then
		$ASDATEPART [ 1 ] = $ASDATEPART [ 1 ] + $INUMBER
	EndIf
	If $STYPE = "h" Or $STYPE = "n" Or $STYPE = "s" Then
		Local $ITIMEVAL = _TIMETOTICKS ( $ASTIMEPART [ 1 ] , $ASTIMEPART [ 2 ] , $ASTIMEPART [ 3 ] ) / 1000
		If $STYPE = "h" Then $ITIMEVAL = $ITIMEVAL + $INUMBER * 3600
		If $STYPE = "n" Then $ITIMEVAL = $ITIMEVAL + $INUMBER * 60
		If $STYPE = "s" Then $ITIMEVAL = $ITIMEVAL + $INUMBER
		Local $IDAY2ADD = Int ( $ITIMEVAL / ( 24 * 60 * 60 ) )
		$ITIMEVAL = $ITIMEVAL - $IDAY2ADD * 24 * 60 * 60
		If $ITIMEVAL < 0 Then
			$IDAY2ADD = $IDAY2ADD + 4294967295
			$ITIMEVAL = $ITIMEVAL + 24 * 60 * 60
		EndIf
		$IJULIANDATE = _DATETODAYVALUE ( $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] ) + $IDAY2ADD
		_DAYVALUETODATE ( $IJULIANDATE , $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] )
		_TICKSTOTIME ( $ITIMEVAL * 1000 , $ASTIMEPART [ 1 ] , $ASTIMEPART [ 2 ] , $ASTIMEPART [ 3 ] )
	EndIf
	Local $INUMDAYS = _DAYSINMONTH ( $ASDATEPART [ 1 ] )
	If $INUMDAYS [ $ASDATEPART [ 2 ] ] < $ASDATEPART [ 3 ] Then $ASDATEPART [ 3 ] = $INUMDAYS [ $ASDATEPART [ 2 ] ]
	$SDATE = $ASDATEPART [ 1 ] & "/" & StringRight ( "0" & $ASDATEPART [ 2 ] , 2 ) & "/" & StringRight ( "0" & $ASDATEPART [ 3 ] , 2 )
	If $ASTIMEPART [ 0 ] > 0 Then
		If $ASTIMEPART [ 0 ] > 2 Then
			$SDATE = $SDATE & " " & StringRight ( "0" & $ASTIMEPART [ 1 ] , 2 ) & ":" & StringRight ( "0" & $ASTIMEPART [ 2 ] , 2 ) & ":" & StringRight ( "0" & $ASTIMEPART [ 3 ] , 2 )
		Else
			$SDATE = $SDATE & " " & StringRight ( "0" & $ASTIMEPART [ 1 ] , 2 ) & ":" & StringRight ( "0" & $ASTIMEPART [ 2 ] , 2 )
		EndIf
	EndIf
	Return $SDATE
EndFunc
Func _DATEDAYOFWEEK ( $IDAYNUM , $IFORMAT = Default )
	Local Const $MONDAY_IS_NO1 = 128
	If $IFORMAT = Default Then $IFORMAT = 0
	$IDAYNUM = Int ( $IDAYNUM )
	If $IDAYNUM < 1 Or $IDAYNUM > 7 Then Return SetError ( 1 , 0 , "" )
	Local $TSYSTEMTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllStructSetData ( $TSYSTEMTIME , "Year" , BitAND ( $IFORMAT , $MONDAY_IS_NO1 ) ? 2007 : 2006 )
	DllStructSetData ( $TSYSTEMTIME , "Month" , 1 )
	DllStructSetData ( $TSYSTEMTIME , "Day" , $IDAYNUM )
	Return _WINAPI_GETDATEFORMAT ( BitAND ( $IFORMAT , $DMW_LOCALE_LONGNAME ) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT , $TSYSTEMTIME , 0 , BitAND ( $IFORMAT , $DMW_SHORTNAME ) ? "ddd" : "dddd" )
EndFunc
Func _DATEDAYSINMONTH ( $IYEAR , $IMONTHNUM )
	$IMONTHNUM = Int ( $IMONTHNUM )
	$IYEAR = Int ( $IYEAR )
	Return __DATEISMONTH ( $IMONTHNUM ) And __DATEISYEAR ( $IYEAR ) ? _DAYSINMONTH ( $IYEAR ) [ $IMONTHNUM ] : SetError ( 1 , 0 , 0 )
EndFunc
Func _DATEDIFF ( $STYPE , $SSTARTDATE , $SENDDATE )
	$STYPE = StringLeft ( $STYPE , 1 )
	If StringInStr ( "d,m,y,w,h,n,s" , $STYPE ) = 0 Or $STYPE = "" Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	If Not _DATEISVALID ( $SSTARTDATE ) Then
		Return SetError ( 2 , 0 , 0 )
	EndIf
	If Not _DATEISVALID ( $SENDDATE ) Then
		Return SetError ( 3 , 0 , 0 )
	EndIf
	Local $ASSTARTDATEPART [ 4 ] , $ASSTARTTIMEPART [ 4 ] , $ASENDDATEPART [ 4 ] , $ASENDTIMEPART [ 4 ]
	_DATETIMESPLIT ( $SSTARTDATE , $ASSTARTDATEPART , $ASSTARTTIMEPART )
	_DATETIMESPLIT ( $SENDDATE , $ASENDDATEPART , $ASENDTIMEPART )
	Local $ADAYSDIFF = _DATETODAYVALUE ( $ASENDDATEPART [ 1 ] , $ASENDDATEPART [ 2 ] , $ASENDDATEPART [ 3 ] ) - _DATETODAYVALUE ( $ASSTARTDATEPART [ 1 ] , $ASSTARTDATEPART [ 2 ] , $ASSTARTDATEPART [ 3 ] )
	Local $ITIMEDIFF , $IYEARDIFF , $ISTARTTIMEINSECS , $IENDTIMEINSECS
	If $ASSTARTTIMEPART [ 0 ] > 1 And $ASENDTIMEPART [ 0 ] > 1 Then
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTIMEPART [ 3 ]
		$IENDTIMEINSECS = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIMEPART [ 3 ]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		If $ITIMEDIFF < 0 Then
			$ADAYSDIFF = $ADAYSDIFF + 4294967295
			$ITIMEDIFF = $ITIMEDIFF + 24 * 60 * 60
		EndIf
	Else
		$ITIMEDIFF = 0
	EndIf
	Select
	Case $STYPE = "d"
		Return $ADAYSDIFF
	Case $STYPE = "m"
		$IYEARDIFF = $ASENDDATEPART [ 1 ] - $ASSTARTDATEPART [ 1 ]
		Local $IMONTHDIFF = $ASENDDATEPART [ 2 ] - $ASSTARTDATEPART [ 2 ] + $IYEARDIFF * 12
		If $ASENDDATEPART [ 3 ] < $ASSTARTDATEPART [ 3 ] Then $IMONTHDIFF = $IMONTHDIFF + 4294967295
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTIMEPART [ 3 ]
		$IENDTIMEINSECS = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIMEPART [ 3 ]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		If $ASENDDATEPART [ 3 ] = $ASSTARTDATEPART [ 3 ] And $ITIMEDIFF < 0 Then $IMONTHDIFF = $IMONTHDIFF + 4294967295
		Return $IMONTHDIFF
	Case $STYPE = "y"
		$IYEARDIFF = $ASENDDATEPART [ 1 ] - $ASSTARTDATEPART [ 1 ]
		If $ASENDDATEPART [ 2 ] < $ASSTARTDATEPART [ 2 ] Then $IYEARDIFF = $IYEARDIFF + 4294967295
		If $ASENDDATEPART [ 2 ] = $ASSTARTDATEPART [ 2 ] And $ASENDDATEPART [ 3 ] < $ASSTARTDATEPART [ 3 ] Then $IYEARDIFF = $IYEARDIFF + 4294967295
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART [ 1 ] * 3600 + $ASSTARTTIMEPART [ 2 ] * 60 + $ASSTARTTIMEPART [ 3 ]
		$IENDTIMEINSECS = $ASENDTIMEPART [ 1 ] * 3600 + $ASENDTIMEPART [ 2 ] * 60 + $ASENDTIMEPART [ 3 ]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		If $ASENDDATEPART [ 2 ] = $ASSTARTDATEPART [ 2 ] And $ASENDDATEPART [ 3 ] = $ASSTARTDATEPART [ 3 ] And $ITIMEDIFF < 0 Then $IYEARDIFF = $IYEARDIFF + 4294967295
		Return $IYEARDIFF
	Case $STYPE = "w"
		Return Int ( $ADAYSDIFF / 7 )
	Case $STYPE = "h"
		Return $ADAYSDIFF * 24 + Int ( $ITIMEDIFF / 3600 )
	Case $STYPE = "n"
		Return $ADAYSDIFF * 24 * 60 + Int ( $ITIMEDIFF / 60 )
	Case $STYPE = "s"
		Return $ADAYSDIFF * 24 * 60 * 60 + $ITIMEDIFF
	EndSelect
EndFunc
Func _DATEISLEAPYEAR ( $IYEAR )
	If StringIsInt ( $IYEAR ) Then
		Select
		Case Mod ( $IYEAR , 4 ) = 0 And Mod ( $IYEAR , 100 ) <> 0
			Return 1
		Case Mod ( $IYEAR , 400 ) = 0
			Return 1
	Case Else
			Return 0
		EndSelect
	EndIf
	Return SetError ( 1 , 0 , 0 )
EndFunc
Func __DATEISMONTH ( $INUMBER )
	$INUMBER = Int ( $INUMBER )
	Return $INUMBER >= 1 And $INUMBER <= 12
EndFunc
Func _DATEISVALID ( $SDATE )
	Local $ASDATEPART [ 4 ] , $ASTIMEPART [ 4 ]
	_DATETIMESPLIT ( $SDATE , $ASDATEPART , $ASTIMEPART )
	If @error Then Return 0
	If Not StringIsInt ( $ASDATEPART [ 1 ] ) Then Return 0
	If Not StringIsInt ( $ASDATEPART [ 2 ] ) Then Return 0
	If Not StringIsInt ( $ASDATEPART [ 3 ] ) Then Return 0
	$ASDATEPART [ 1 ] = Int ( $ASDATEPART [ 1 ] )
	$ASDATEPART [ 2 ] = Int ( $ASDATEPART [ 2 ] )
	$ASDATEPART [ 3 ] = Int ( $ASDATEPART [ 3 ] )
	Local $INUMDAYS = _DAYSINMONTH ( $ASDATEPART [ 1 ] )
	If $ASDATEPART [ 1 ] < 1000 Or $ASDATEPART [ 1 ] > 2999 Then Return 0
	If $ASDATEPART [ 2 ] < 1 Or $ASDATEPART [ 2 ] > 12 Then Return 0
	If $ASDATEPART [ 3 ] < 1 Or $ASDATEPART [ 3 ] > $INUMDAYS [ $ASDATEPART [ 2 ] ] Then Return 0
	If $ASTIMEPART [ 0 ] < 1 Then Return 1
	If $ASTIMEPART [ 0 ] < 2 Then Return 0
	If $ASTIMEPART [ 0 ] = 2 Then $ASTIMEPART [ 3 ] = "00"
	If Not StringIsInt ( $ASTIMEPART [ 1 ] ) Then Return 0
	If Not StringIsInt ( $ASTIMEPART [ 2 ] ) Then Return 0
	If Not StringIsInt ( $ASTIMEPART [ 3 ] ) Then Return 0
	$ASTIMEPART [ 1 ] = Int ( $ASTIMEPART [ 1 ] )
	$ASTIMEPART [ 2 ] = Int ( $ASTIMEPART [ 2 ] )
	$ASTIMEPART [ 3 ] = Int ( $ASTIMEPART [ 3 ] )
	If $ASTIMEPART [ 1 ] < 0 Or $ASTIMEPART [ 1 ] > 23 Then Return 0
	If $ASTIMEPART [ 2 ] < 0 Or $ASTIMEPART [ 2 ] > 59 Then Return 0
	If $ASTIMEPART [ 3 ] < 0 Or $ASTIMEPART [ 3 ] > 59 Then Return 0
	Return 1
EndFunc
Func __DATEISYEAR ( $INUMBER )
	Return StringLen ( $INUMBER ) = 4
EndFunc
Func _DATELASTWEEKDAYNUM ( $IWEEKDAYNUM )
	Select
	Case Not StringIsInt ( $IWEEKDAYNUM )
		Return SetError ( 1 , 0 , 0 )
	Case $IWEEKDAYNUM < 1 Or $IWEEKDAYNUM > 7
		Return SetError ( 2 , 0 , 0 )
Case Else
		Local $ILASTWEEKDAYNUM
		If $IWEEKDAYNUM = 1 Then
			$ILASTWEEKDAYNUM = 7
		Else
			$ILASTWEEKDAYNUM = $IWEEKDAYNUM + 4294967295
		EndIf
		Return $ILASTWEEKDAYNUM
	EndSelect
EndFunc
Func _DATELASTMONTHNUM ( $IMONTHNUM )
	Select
	Case Not StringIsInt ( $IMONTHNUM )
		Return SetError ( 1 , 0 , 0 )
	Case Not __DATEISMONTH ( $IMONTHNUM )
		Return SetError ( 2 , 0 , 0 )
Case Else
		Local $ILASTMONTHNUM
		If $IMONTHNUM = 1 Then
			$ILASTMONTHNUM = 12
		Else
			$ILASTMONTHNUM = $IMONTHNUM + 4294967295
		EndIf
		$ILASTMONTHNUM = StringFormat ( "%02d" , $ILASTMONTHNUM )
		Return $ILASTMONTHNUM
	EndSelect
EndFunc
Func _DATELASTMONTHYEAR ( $IMONTHNUM , $IYEAR )
	Select
	Case Not StringIsInt ( $IMONTHNUM ) Or Not StringIsInt ( $IYEAR )
		Return SetError ( 1 , 0 , 0 )
	Case Not __DATEISMONTH ( $IMONTHNUM )
		Return SetError ( 2 , 0 , 0 )
Case Else
		Local $ILASTYEAR
		If $IMONTHNUM = 1 Then
			$ILASTYEAR = $IYEAR + 4294967295
		Else
			$ILASTYEAR = $IYEAR
		EndIf
		$ILASTYEAR = StringFormat ( "%04d" , $ILASTYEAR )
		Return $ILASTYEAR
	EndSelect
EndFunc
Func _DATENEXTWEEKDAYNUM ( $IWEEKDAYNUM )
	Select
	Case Not StringIsInt ( $IWEEKDAYNUM )
		Return SetError ( 1 , 0 , 0 )
	Case $IWEEKDAYNUM < 1 Or $IWEEKDAYNUM > 7
		Return SetError ( 2 , 0 , 0 )
Case Else
		Local $INEXTWEEKDAYNUM
		If $IWEEKDAYNUM = 7 Then
			$INEXTWEEKDAYNUM = 1
		Else
			$INEXTWEEKDAYNUM = $IWEEKDAYNUM + 1
		EndIf
		Return $INEXTWEEKDAYNUM
	EndSelect
EndFunc
Func _DATENEXTMONTHNUM ( $IMONTHNUM )
	Select
	Case Not StringIsInt ( $IMONTHNUM )
		Return SetError ( 1 , 0 , 0 )
	Case Not __DATEISMONTH ( $IMONTHNUM )
		Return SetError ( 2 , 0 , 0 )
Case Else
		Local $INEXTMONTHNUM
		If $IMONTHNUM = 12 Then
			$INEXTMONTHNUM = 1
		Else
			$INEXTMONTHNUM = $IMONTHNUM + 1
		EndIf
		$INEXTMONTHNUM = StringFormat ( "%02d" , $INEXTMONTHNUM )
		Return $INEXTMONTHNUM
	EndSelect
EndFunc
Func _DATENEXTMONTHYEAR ( $IMONTHNUM , $IYEAR )
	Select
	Case Not StringIsInt ( $IMONTHNUM ) Or Not StringIsInt ( $IYEAR )
		Return SetError ( 1 , 0 , 0 )
	Case Not __DATEISMONTH ( $IMONTHNUM )
		Return SetError ( 2 , 0 , 0 )
Case Else
		Local $INEXTYEAR
		If $IMONTHNUM = 12 Then
			$INEXTYEAR = $IYEAR + 1
		Else
			$INEXTYEAR = $IYEAR
		EndIf
		$INEXTYEAR = StringFormat ( "%04d" , $INEXTYEAR )
		Return $INEXTYEAR
	EndSelect
EndFunc
Func _DATETIMEFORMAT ( $SDATE , $STYPE )
	Local $ASDATEPART [ 4 ] , $ASTIMEPART [ 4 ]
	Local $STEMPDATE = "" , $STEMPTIME = ""
	Local $SAM , $SPM , $STEMPSTRING = ""
	If Not _DATEISVALID ( $SDATE ) Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	If $STYPE < 0 Or $STYPE > 5 Or Not IsInt ( $STYPE ) Then
		Return SetError ( 2 , 0 , "" )
	EndIf
	_DATETIMESPLIT ( $SDATE , $ASDATEPART , $ASTIMEPART )
	Switch $STYPE
	Case 0
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_SSHORTDATE )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$STEMPDATE = $STEMPSTRING
		Else
			$STEMPDATE = "M/d/yyyy"
		EndIf
		If $ASTIMEPART [ 0 ] > 1 Then
			$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_STIMEFORMAT )
			If Not @error And Not ( $STEMPSTRING = "" ) Then
				$STEMPTIME = $STEMPSTRING
			Else
				$STEMPTIME = "h:mm:ss tt"
			EndIf
		EndIf
	Case 1
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_SLONGDATE )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$STEMPDATE = $STEMPSTRING
		Else
			$STEMPDATE = "dddd, MMMM dd, yyyy"
		EndIf
	Case 2
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_SSHORTDATE )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$STEMPDATE = $STEMPSTRING
		Else
			$STEMPDATE = "M/d/yyyy"
		EndIf
	Case 3
		If $ASTIMEPART [ 0 ] > 1 Then
			$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_STIMEFORMAT )
			If Not @error And Not ( $STEMPSTRING = "" ) Then
				$STEMPTIME = $STEMPSTRING
			Else
				$STEMPTIME = "h:mm:ss tt"
			EndIf
		EndIf
	Case 4
		If $ASTIMEPART [ 0 ] > 1 Then
			$STEMPTIME = "hh:mm"
		EndIf
	Case 5
		If $ASTIMEPART [ 0 ] > 1 Then
			$STEMPTIME = "hh:mm:ss"
		EndIf
	EndSwitch
	If $STEMPDATE <> "" Then
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_SDATE )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$STEMPDATE = StringReplace ( $STEMPDATE , "/" , $STEMPSTRING )
		EndIf
		Local $IWDAY = _DATETODAYOFWEEK ( $ASDATEPART [ 1 ] , $ASDATEPART [ 2 ] , $ASDATEPART [ 3 ] )
		$ASDATEPART [ 3 ] = StringRight ( "0" & $ASDATEPART [ 3 ] , 2 )
		$ASDATEPART [ 2 ] = StringRight ( "0" & $ASDATEPART [ 2 ] , 2 )
		$STEMPDATE = StringReplace ( $STEMPDATE , "d" , "@" )
		$STEMPDATE = StringReplace ( $STEMPDATE , "m" , "#" )
		$STEMPDATE = StringReplace ( $STEMPDATE , "y" , "&" )
		$STEMPDATE = StringReplace ( $STEMPDATE , "@@@@" , _DATEDAYOFWEEK ( $IWDAY , 0 ) )
		$STEMPDATE = StringReplace ( $STEMPDATE , "@@@" , _DATEDAYOFWEEK ( $IWDAY , 1 ) )
		$STEMPDATE = StringReplace ( $STEMPDATE , "@@" , $ASDATEPART [ 3 ] )
		$STEMPDATE = StringReplace ( $STEMPDATE , "@" , StringReplace ( StringLeft ( $ASDATEPART [ 3 ] , 1 ) , "0" , "" ) & StringRight ( $ASDATEPART [ 3 ] , 1 ) )
		$STEMPDATE = StringReplace ( $STEMPDATE , "####" , _DATETOMONTH ( $ASDATEPART [ 2 ] , 0 ) )
		$STEMPDATE = StringReplace ( $STEMPDATE , "###" , _DATETOMONTH ( $ASDATEPART [ 2 ] , 1 ) )
		$STEMPDATE = StringReplace ( $STEMPDATE , "##" , $ASDATEPART [ 2 ] )
		$STEMPDATE = StringReplace ( $STEMPDATE , "#" , StringReplace ( StringLeft ( $ASDATEPART [ 2 ] , 1 ) , "0" , "" ) & StringRight ( $ASDATEPART [ 2 ] , 1 ) )
		$STEMPDATE = StringReplace ( $STEMPDATE , "&&&&" , $ASDATEPART [ 1 ] )
		$STEMPDATE = StringReplace ( $STEMPDATE , "&&" , StringRight ( $ASDATEPART [ 1 ] , 2 ) )
	EndIf
	If $STEMPTIME <> "" Then
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_S1159 )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$SAM = $STEMPSTRING
		Else
			$SAM = "AM"
		EndIf
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_S2359 )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$SPM = $STEMPSTRING
		Else
			$SPM = "PM"
		EndIf
		$STEMPSTRING = _WINAPI_GETLOCALEINFO ( $LOCALE_USER_DEFAULT , $LOCALE_STIME )
		If Not @error And Not ( $STEMPSTRING = "" ) Then
			$STEMPTIME = StringReplace ( $STEMPTIME , ":" , $STEMPSTRING )
		EndIf
		If StringInStr ( $STEMPTIME , "tt" ) Then
			If $ASTIMEPART [ 1 ] < 12 Then
				$STEMPTIME = StringReplace ( $STEMPTIME , "tt" , $SAM )
				If $ASTIMEPART [ 1 ] = 0 Then $ASTIMEPART [ 1 ] = 12
			Else
				$STEMPTIME = StringReplace ( $STEMPTIME , "tt" , $SPM )
				If $ASTIMEPART [ 1 ] > 12 Then $ASTIMEPART [ 1 ] = $ASTIMEPART [ 1 ] + 4294967284
			EndIf
		EndIf
		$ASTIMEPART [ 1 ] = StringRight ( "0" & $ASTIMEPART [ 1 ] , 2 )
		$ASTIMEPART [ 2 ] = StringRight ( "0" & $ASTIMEPART [ 2 ] , 2 )
		$ASTIMEPART [ 3 ] = StringRight ( "0" & $ASTIMEPART [ 3 ] , 2 )
		$STEMPTIME = StringReplace ( $STEMPTIME , "hh" , StringFormat ( "%02d" , $ASTIMEPART [ 1 ] ) )
		$STEMPTIME = StringReplace ( $STEMPTIME , "h" , StringReplace ( StringLeft ( $ASTIMEPART [ 1 ] , 1 ) , "0" , "" ) & StringRight ( $ASTIMEPART [ 1 ] , 1 ) )
		$STEMPTIME = StringReplace ( $STEMPTIME , "mm" , StringFormat ( "%02d" , $ASTIMEPART [ 2 ] ) )
		$STEMPTIME = StringReplace ( $STEMPTIME , "ss" , StringFormat ( "%02d" , $ASTIMEPART [ 3 ] ) )
		$STEMPDATE = StringStripWS ( $STEMPDATE & " " & $STEMPTIME , $STR_STRIPLEADING + $STR_STRIPTRAILING )
	EndIf
	Return $STEMPDATE
EndFunc
Func _DATETIMESPLIT ( $SDATE , ByRef $ADATEPART , ByRef $ATIMEPART )
	Local $SDATETIME = StringSplit ( $SDATE , " T" )
	If $SDATETIME [ 0 ] > 0 Then $ADATEPART = StringSplit ( $SDATETIME [ 1 ] , "/-." )
	Local $NFIELDS = UBound ( $ADATEPART )
	If $NFIELDS <> 4 Then Return SetError ( 1 , 0 , 0 )
	If $SDATETIME [ 0 ] > 1 Then
		$ATIMEPART = StringSplit ( $SDATETIME [ 2 ] , ":" )
		$NFIELDS = UBound ( $ATIMEPART )
		If ( $NFIELDS < 3 ) Or ( $NFIELDS > 4 ) Then Return SetError ( 2 , 0 , 0 )
		If $NFIELDS < 4 Then
			ReDim $ATIMEPART [ 4 ]
			$ATIMEPART [ 3 ] = 0
		EndIf
	Else
		Dim $ATIMEPART [ 4 ]
	EndIf
	For $X = 1 To 3
		$ADATEPART [ $X ] = Int ( $ADATEPART [ $X ] )
		$ATIMEPART [ $X ] = Int ( $ATIMEPART [ $X ] )
	Next
	Return 1
EndFunc
Func _DATETODAYOFWEEK ( $IYEAR , $IMONTH , $IDAY )
	If Not _DATEISVALID ( $IYEAR & "/" & $IMONTH & "/" & $IDAY ) Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	Local $I_FACTORA = Int ( ( 14 - $IMONTH ) / 12 )
	Local $I_FACTORY = $IYEAR - $I_FACTORA
	Local $I_FACTORM = $IMONTH + ( 12 * $I_FACTORA ) + 4294967294
	Local $I_FACTORD = Mod ( $IDAY + $I_FACTORY + Int ( $I_FACTORY / 4 ) - Int ( $I_FACTORY / 100 ) + Int ( $I_FACTORY / 400 ) + Int ( ( 31 * $I_FACTORM ) / 12 ) , 7 )
	Return $I_FACTORD + 1
EndFunc
Func _DATETODAYOFWEEKISO ( $IYEAR , $IMONTH , $IDAY )
	Local $IDOW = _DATETODAYOFWEEK ( $IYEAR , $IMONTH , $IDAY )
	If @error Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	If $IDOW >= 2 Then Return $IDOW + 4294967295
	Return 7
EndFunc
Func _DATETODAYVALUE ( $IYEAR , $IMONTH , $IDAY )
	If Not _DATEISVALID ( StringFormat ( "%04d/%02d/%02d" , $IYEAR , $IMONTH , $IDAY ) ) Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	If $IMONTH < 3 Then
		$IMONTH = $IMONTH + 12
		$IYEAR = $IYEAR + 4294967295
	EndIf
	Local $I_FACTORA = Int ( $IYEAR / 100 )
	Local $I_FACTORB = Int ( $I_FACTORA / 4 )
	Local $I_FACTORC = 2 - $I_FACTORA + $I_FACTORB
	Local $I_FACTORE = Int ( 1461 * ( $IYEAR + 4716 ) / 4 )
	Local $I_FACTORF = Int ( 153 * ( $IMONTH + 1 ) / 5 )
	Local $IJULIANDATE = $I_FACTORC + $IDAY + $I_FACTORE + $I_FACTORF - 1524.5
	Return $IJULIANDATE
EndFunc
Func _DATETOMONTH ( $IMONNUM , $IFORMAT = Default )
	If $IFORMAT = Default Then $IFORMAT = 0
	$IMONNUM = Int ( $IMONNUM )
	If Not __DATEISMONTH ( $IMONNUM ) Then Return SetError ( 1 , 0 , "" )
	Local $TSYSTEMTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllStructSetData ( $TSYSTEMTIME , "Year" , @YEAR )
	DllStructSetData ( $TSYSTEMTIME , "Month" , $IMONNUM )
	DllStructSetData ( $TSYSTEMTIME , "Day" , 1 )
	Return _WINAPI_GETDATEFORMAT ( BitAND ( $IFORMAT , $DMW_LOCALE_LONGNAME ) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT , $TSYSTEMTIME , 0 , BitAND ( $IFORMAT , $DMW_SHORTNAME ) ? "MMM" : "MMMM" )
EndFunc
Func _DAYVALUETODATE ( $IJULIANDATE , ByRef $IYEAR , ByRef $IMONTH , ByRef $IDAY )
	If $IJULIANDATE < 0 Or Not IsNumber ( $IJULIANDATE ) Then
		Return SetError ( 1 , 0 , 0 )
	EndIf
	Local $I_FACTORZ = Int ( $IJULIANDATE + 0.5 )
	Local $I_FACTORW = Int ( ( $I_FACTORZ - 1867216.25 ) / 36524.25 )
	Local $I_FACTORX = Int ( $I_FACTORW / 4 )
	Local $I_FACTORA = $I_FACTORZ + 1 + $I_FACTORW - $I_FACTORX
	Local $I_FACTORB = $I_FACTORA + 1524
	Local $I_FACTORC = Int ( ( $I_FACTORB - 122.1 ) / 365.25 )
	Local $I_FACTORD = Int ( 365.25 * $I_FACTORC )
	Local $I_FACTORE = Int ( ( $I_FACTORB - $I_FACTORD ) / 30.6001 )
	Local $I_FACTORF = Int ( 30.6001 * $I_FACTORE )
	$IDAY = $I_FACTORB - $I_FACTORD - $I_FACTORF
	If $I_FACTORE + 4294967295 < 13 Then
		$IMONTH = $I_FACTORE + 4294967295
	Else
		$IMONTH = $I_FACTORE + 4294967283
	EndIf
	If $IMONTH < 3 Then
		$IYEAR = $I_FACTORC + 4294962581
	Else
		$IYEAR = $I_FACTORC + 4294962580
	EndIf
	$IYEAR = StringFormat ( "%04d" , $IYEAR )
	$IMONTH = StringFormat ( "%02d" , $IMONTH )
	$IDAY = StringFormat ( "%02d" , $IDAY )
	Return $IYEAR & "/" & $IMONTH & "/" & $IDAY
EndFunc
Func _DATE_JULIANDAYNO ( $IYEAR , $IMONTH , $IDAY )
	Local $SFULLDATE = StringFormat ( "%04d/%02d/%02d" , $IYEAR , $IMONTH , $IDAY )
	If Not _DATEISVALID ( $SFULLDATE ) Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	Local $IJDAY = 0
	Local $AIDAYSINMONTH = _DAYSINMONTH ( $IYEAR )
	For $ICNTR = 1 To $IMONTH + 4294967295
		$IJDAY = $IJDAY + $AIDAYSINMONTH [ $ICNTR ]
	Next
	$IJDAY = ( $IYEAR * 1000 ) + ( $IJDAY + $IDAY )
	Return $IJDAY
EndFunc
Func _JULIANTODATE ( $IJDAY , $SSEP = "/" )
	Local $IYEAR = Int ( $IJDAY / 1000 )
	Local $IDAYS = Mod ( $IJDAY , 1000 )
	Local $IMAXDAYS = 365
	If _DATEISLEAPYEAR ( $IYEAR ) Then $IMAXDAYS = 366
	If $IDAYS > $IMAXDAYS Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	Local $AIDAYSINMONTH = _DAYSINMONTH ( $IYEAR )
	Local $IMONTH = 1
	While $IDAYS > $AIDAYSINMONTH [ $IMONTH ]
		$IDAYS = $IDAYS - $AIDAYSINMONTH [ $IMONTH ]
		$IMONTH = $IMONTH + 1
	WEnd
	Return StringFormat ( "%04d%s%02d%s%02d" , $IYEAR , $SSEP , $IMONTH , $SSEP , $IDAYS )
EndFunc
Func _NOW ( )
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return _DATETIMEFORMAT ( $TLOCALTIME .Year & "/" & $TLOCALTIME .Month & "/" & $TLOCALTIME .Day & " " & $TLOCALTIME .Hour & ":" & $TLOCALTIME .Minute & ":" & $TLOCALTIME .Second , 0 )
EndFunc
Func _NOWCALC ( )
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $TLOCALTIME .Year & "/" & StringRight ( "00" & $TLOCALTIME .Month , 2 ) & "/" & StringRight ( "00" & $TLOCALTIME .Day , 2 ) & " " & StringRight ( "00" & $TLOCALTIME .Hour , 2 ) & ":" & StringRight ( "00" & $TLOCALTIME .Minute , 2 ) & ":" & StringRight ( "00" & $TLOCALTIME .Second , 2 )
EndFunc
Func _NOWCALCDATE ( )
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , "" )
	Return $TLOCALTIME .Year & "/" & StringRight ( "00" & $TLOCALTIME .Month , 2 ) & "/" & StringRight ( "00" & $TLOCALTIME .Day , 2 )
EndFunc
Func _NOWDATE ( )
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , "" )
	Return _DATETIMEFORMAT ( $TLOCALTIME .Year & "/" & $TLOCALTIME .Month & "/" & $TLOCALTIME .Day , 0 )
EndFunc
Func _NOWTIME ( $STYPE = 3 )
	If $STYPE < 3 Or $STYPE > 5 Then $STYPE = 3
	Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
	If @error Then Return SetError ( @error , @extended , "" )
	Return _DATETIMEFORMAT ( $TLOCALTIME .Year & "/" & $TLOCALTIME .Month & "/" & $TLOCALTIME .Day & " " & $TLOCALTIME .Hour & ":" & $TLOCALTIME .Minute & ":" & $TLOCALTIME .Second , $STYPE )
EndFunc
Func _SETDATE ( $IDAY , $IMONTH = 0 , $IYEAR = 0 )
	If $IYEAR = 0 Then $IYEAR = @YEAR
	If $IMONTH = 0 Then $IMONTH = @MON
	If Not _DATEISVALID ( $IYEAR & "/" & $IMONTH & "/" & $IDAY ) Then Return 1
	Local $TSYSTEMTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllCall ( "kernel32.dll" , "none" , "GetLocalTime" , "struct*" , $TSYSTEMTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	DllStructSetData ( $TSYSTEMTIME , "Day" , $IDAY )
	If $IMONTH > 0 Then DllStructSetData ( $TSYSTEMTIME , "Month" , $IMONTH )
	If $IYEAR > 0 Then DllStructSetData ( $TSYSTEMTIME , "Year" , $IYEAR )
	Local $IRETURN = _DATE_TIME_SETLOCALTIME ( $TSYSTEMTIME )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return Int ( $IRETURN )
EndFunc
Func _SETTIME ( $IHOUR , $IMINUTE , $ISECOND = 0 , $IMSECONDS = 0 )
	If $IHOUR < 0 Or $IHOUR > 23 Then Return 1
	If $IMINUTE < 0 Or $IMINUTE > 59 Then Return 1
	If $ISECOND < 0 Or $ISECOND > 59 Then Return 1
	If $IMSECONDS < 0 Or $IMSECONDS > 999 Then Return 1
	Local $TSYSTEMTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllCall ( "kernel32.dll" , "none" , "GetLocalTime" , "struct*" , $TSYSTEMTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	DllStructSetData ( $TSYSTEMTIME , "Hour" , $IHOUR )
	DllStructSetData ( $TSYSTEMTIME , "Minute" , $IMINUTE )
	If $ISECOND > 0 Then DllStructSetData ( $TSYSTEMTIME , "Second" , $ISECOND )
	If $IMSECONDS > 0 Then DllStructSetData ( $TSYSTEMTIME , "MSeconds" , $IMSECONDS )
	Local $IRETURN = _DATE_TIME_SETLOCALTIME ( $TSYSTEMTIME )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return Int ( $IRETURN )
EndFunc
Func _TICKSTOTIME ( $ITICKS , ByRef $IHOURS , ByRef $IMINS , ByRef $ISECS )
	If Number ( $ITICKS ) > 0 Then
		$ITICKS = Int ( $ITICKS / 1000 )
		$IHOURS = Int ( $ITICKS / 3600 )
		$ITICKS = Mod ( $ITICKS , 3600 )
		$IMINS = Int ( $ITICKS / 60 )
		$ISECS = Mod ( $ITICKS , 60 )
		Return 1
	ElseIf Number ( $ITICKS ) = 0 Then
		$IHOURS = 0
		$ITICKS = 0
		$IMINS = 0
		$ISECS = 0
		Return 1
	Else
		Return SetError ( 1 , 0 , 0 )
	EndIf
EndFunc
Func _TIMETOTICKS ( $IHOURS = Default , $IMINS = Default , $ISECS = Default )
	If $IHOURS = Default Or $IMINS = Default Or $ISECS = Default Then
		Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $IHOURS = Default Then $IHOURS = $TLOCALTIME .Hour
		If $IMINS = Default Then $IMINS = $TLOCALTIME .Minute
		If $ISECS = Default Then $ISECS = $TLOCALTIME .Second
	EndIf
	If StringIsInt ( $IHOURS ) And StringIsInt ( $IMINS ) And StringIsInt ( $ISECS ) Then
		Local $ITICKS = 1000 * ( ( 3600 * $IHOURS ) + ( 60 * $IMINS ) + $ISECS )
		Return $ITICKS
	Else
		Return SetError ( 1 , 0 , 0 )
	EndIf
EndFunc
Func _WEEKNUMBERISO ( $IYEAR = Default , $IMONTH = Default , $IDAY = Default )
	If $IYEAR = Default Or $IMONTH = Default Or $IDAY = Default Then
		Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $IYEAR = Default Then $IYEAR = $TLOCALTIME .Year
		If $IMONTH = Default Then $IMONTH = $TLOCALTIME .Month
		If $IDAY = Default Then $IDAY = $TLOCALTIME .Day
	EndIf
	If $IDAY > 31 Or $IDAY < 1 Then
		Return SetError ( 1 , 0 , + 4294967295 )
	ElseIf Not __DATEISMONTH ( $IMONTH ) Then
		Return SetError ( 2 , 0 , + 4294967295 )
	ElseIf $IYEAR < 1 Or $IYEAR > 2999 Then
		Return SetError ( 3 , 0 , + 4294967295 )
	EndIf
	Local $IDOW = _DATETODAYOFWEEKISO ( $IYEAR , $IMONTH , $IDAY ) + 4294967295
	Local $IDOW0101 = _DATETODAYOFWEEKISO ( $IYEAR , 1 , 1 ) + 4294967295
	If ( $IMONTH = 1 And 3 < $IDOW0101 And $IDOW0101 < 7 - ( $IDAY + 4294967295 ) ) Then
		$IDOW = $IDOW0101 + 4294967295
		$IDOW0101 = _DATETODAYOFWEEKISO ( $IYEAR + 4294967295 , 1 , 1 ) + 4294967295
		$IMONTH = 12
		$IDAY = 31
		$IYEAR = $IYEAR + 4294967295
	ElseIf ( $IMONTH = 12 And 30 - ( $IDAY + 4294967295 ) < _DATETODAYOFWEEKISO ( $IYEAR + 1 , 1 , 1 ) + 4294967295 And _DATETODAYOFWEEKISO ( $IYEAR + 1 , 1 , 1 ) + 4294967295 < 4 ) Then
		Return 1
	EndIf
	Return Int ( ( _DATETODAYOFWEEKISO ( $IYEAR , 1 , 1 ) + 4294967295 < 4 ) + 4 * ( $IMONTH + 4294967295 ) + ( 2 * ( $IMONTH + 4294967295 ) + ( $IDAY + 4294967295 ) + $IDOW0101 - $IDOW + 6 ) * 36 / 256 )
EndFunc
Func _WEEKNUMBER ( $IYEAR = Default , $IMONTH = Default , $IDAY = Default , $IWEEKSTART = 1 )
	If $IYEAR = Default Or $IMONTH = Default Or $IDAY = Default Then
		Local $TLOCALTIME = _DATE_TIME_GETLOCALTIME ( )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $IYEAR = Default Then $IYEAR = $TLOCALTIME .Year
		If $IMONTH = Default Then $IMONTH = $TLOCALTIME .Month
		If $IDAY = Default Then $IDAY = $TLOCALTIME .Day
	EndIf
	If $IWEEKSTART = Default Then $IWEEKSTART = 1
	If $IDAY > 31 Or $IDAY < 1 Then
		Return SetError ( 1 , 0 , + 4294967295 )
	ElseIf Not __DATEISMONTH ( $IMONTH ) Then
		Return SetError ( 3 , 0 , + 4294967295 )
	ElseIf $IYEAR < 1 Or $IYEAR > 2999 Then
		Return SetError ( 4 , 0 , + 4294967295 )
	ElseIf $IWEEKSTART < 1 Or $IWEEKSTART > 2 Then
		Return SetError ( 2 , 0 , + 4294967295 )
	EndIf
	Local $ISTARTWEEK1 , $IENDWEEK1
	Local $IDOW0101 = _DATETODAYOFWEEKISO ( $IYEAR , 1 , 1 )
	Local $IDATE = $IYEAR & "/" & $IMONTH & "/" & $IDAY
	If $IWEEKSTART = 1 Then
		If $IDOW0101 = 6 Then
			$ISTARTWEEK1 = 0
		Else
			$ISTARTWEEK1 = + 4294967295 * $IDOW0101 + 4294967295
		EndIf
		$IENDWEEK1 = $ISTARTWEEK1 + 6
	Else
		$ISTARTWEEK1 = $IDOW0101 * + 4294967295
		$IENDWEEK1 = $ISTARTWEEK1 + 6
	EndIf
	Local $ISTARTWEEK1NY
	Local $IENDWEEK1DATE = _DATEADD ( "d" , $IENDWEEK1 , $IYEAR & "/01/01" )
	Local $IDOW0101NY = _DATETODAYOFWEEKISO ( $IYEAR + 1 , 1 , 1 )
	If $IWEEKSTART = 1 Then
		If $IDOW0101NY = 6 Then
			$ISTARTWEEK1NY = 0
		Else
			$ISTARTWEEK1NY = + 4294967295 * $IDOW0101NY + 4294967295
		EndIf
	Else
		$ISTARTWEEK1NY = $IDOW0101NY * + 4294967295
	EndIf
	Local $ISTARTWEEK1DATENY = _DATEADD ( "d" , $ISTARTWEEK1NY , $IYEAR + 1 & "/01/01" )
	Local $ICURRDATEDIFF = _DATEDIFF ( "d" , $IENDWEEK1DATE , $IDATE ) + 4294967295
	Local $ICURRDATEDIFFNY = _DATEDIFF ( "d" , $ISTARTWEEK1DATENY , $IDATE )
	If $ICURRDATEDIFF >= 0 And $ICURRDATEDIFFNY < 0 Then Return 2 + Int ( $ICURRDATEDIFF / 7 )
	If $ICURRDATEDIFF < 0 Or $ICURRDATEDIFFNY >= 0 Then Return 1
EndFunc
Func _DAYSINMONTH ( $IYEAR )
	Local $ADAYS = [ 12 , 31 , ( _DATEISLEAPYEAR ( $IYEAR ) ? 29 : 28 ) , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ]
	Return $ADAYS
EndFunc
Func __DATE_TIME_CLONESYSTEMTIME ( $PSYSTEMTIME )
	Local $TSYSTEMTIME1 = DllStructCreate ( $TAGSYSTEMTIME , $PSYSTEMTIME )
	Local $TSYSTEMTIME2 = DllStructCreate ( $TAGSYSTEMTIME )
	DllStructSetData ( $TSYSTEMTIME2 , "Month" , DllStructGetData ( $TSYSTEMTIME1 , "Month" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "Day" , DllStructGetData ( $TSYSTEMTIME1 , "Day" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "Year" , DllStructGetData ( $TSYSTEMTIME1 , "Year" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "Hour" , DllStructGetData ( $TSYSTEMTIME1 , "Hour" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "Minute" , DllStructGetData ( $TSYSTEMTIME1 , "Minute" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "Second" , DllStructGetData ( $TSYSTEMTIME1 , "Second" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "MSeconds" , DllStructGetData ( $TSYSTEMTIME1 , "MSeconds" ) )
	DllStructSetData ( $TSYSTEMTIME2 , "DOW" , DllStructGetData ( $TSYSTEMTIME1 , "DOW" ) )
	Return $TSYSTEMTIME2
EndFunc
Func _DATE_TIME_COMPAREFILETIME ( $TFILETIME1 , $TFILETIME2 )
	Local $ACALL = DllCall ( "kernel32.dll" , "long" , "CompareFileTime" , "struct*" , $TFILETIME1 , "struct*" , $TFILETIME2 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _DATE_TIME_DOSDATETIMETOFILETIME ( $IFATDATE , $IFATTIME )
	Local $TTIME = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "DosDateTimeToFileTime" , "word" , $IFATDATE , "word" , $IFATTIME , "struct*" , $TTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TTIME )
EndFunc
Func _DATE_TIME_DOSDATETOARRAY ( $IDOSDATE )
	Local $ADATE [ 3 ]
	$ADATE [ 0 ] = BitAND ( $IDOSDATE , 31 )
	$ADATE [ 1 ] = BitAND ( BitShift ( $IDOSDATE , 5 ) , 15 )
	$ADATE [ 2 ] = BitAND ( BitShift ( $IDOSDATE , 9 ) , 63 ) + 1980
	Return $ADATE
EndFunc
Func _DATE_TIME_DOSDATETIMETOARRAY ( $IDOSDATE , $IDOSTIME )
	Local $ADATE [ 6 ]
	$ADATE [ 0 ] = BitAND ( $IDOSDATE , 31 )
	$ADATE [ 1 ] = BitAND ( BitShift ( $IDOSDATE , 5 ) , 15 )
	$ADATE [ 2 ] = BitAND ( BitShift ( $IDOSDATE , 9 ) , 63 ) + 1980
	$ADATE [ 5 ] = BitAND ( $IDOSTIME , 31 ) * 2
	$ADATE [ 4 ] = BitAND ( BitShift ( $IDOSTIME , 5 ) , 63 )
	$ADATE [ 3 ] = BitAND ( BitShift ( $IDOSTIME , 11 ) , 31 )
	Return $ADATE
EndFunc
Func _DATE_TIME_DOSDATETIMETOSTR ( $IDOSDATE , $IDOSTIME )
	Local $ADATE = _DATE_TIME_DOSDATETIMETOARRAY ( $IDOSDATE , $IDOSTIME )
	Return StringFormat ( "%02d/%02d/%04d %02d:%02d:%02d" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATE [ 2 ] , $ADATE [ 3 ] , $ADATE [ 4 ] , $ADATE [ 5 ] )
EndFunc
Func _DATE_TIME_DOSDATETOSTR ( $IDOSDATE )
	Local $ADATE = _DATE_TIME_DOSDATETOARRAY ( $IDOSDATE )
	Return StringFormat ( "%02d/%02d/%04d" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATE [ 2 ] )
EndFunc
Func _DATE_TIME_DOSTIMETOARRAY ( $IDOSTIME )
	Local $ATIME [ 3 ]
	$ATIME [ 2 ] = BitAND ( $IDOSTIME , 31 ) * 2
	$ATIME [ 1 ] = BitAND ( BitShift ( $IDOSTIME , 5 ) , 63 )
	$ATIME [ 0 ] = BitAND ( BitShift ( $IDOSTIME , 11 ) , 31 )
	Return $ATIME
EndFunc
Func _DATE_TIME_DOSTIMETOSTR ( $IDOSTIME )
	Local $ATIME = _DATE_TIME_DOSTIMETOARRAY ( $IDOSTIME )
	Return StringFormat ( "%02d:%02d:%02d" , $ATIME [ 0 ] , $ATIME [ 1 ] , $ATIME [ 2 ] )
EndFunc
Func _DATE_TIME_ENCODEFILETIME ( $IMONTH , $IDAY , $IYEAR , $IHOUR = 0 , $IMINUTE = 0 , $ISECOND = 0 , $IMSECONDS = 0 )
	Local $TSYSTEMTIME = _DATE_TIME_ENCODESYSTEMTIME ( $IMONTH , $IDAY , $IYEAR , $IHOUR , $IMINUTE , $ISECOND , $IMSECONDS )
	Return _DATE_TIME_SYSTEMTIMETOFILETIME ( $TSYSTEMTIME )
EndFunc
Func _DATE_TIME_ENCODESYSTEMTIME ( $IMONTH , $IDAY , $IYEAR , $IHOUR = 0 , $IMINUTE = 0 , $ISECOND = 0 , $IMSECONDS = 0 )
	Local $TSYSTEMTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllStructSetData ( $TSYSTEMTIME , "Month" , $IMONTH )
	DllStructSetData ( $TSYSTEMTIME , "Day" , $IDAY )
	DllStructSetData ( $TSYSTEMTIME , "Year" , $IYEAR )
	DllStructSetData ( $TSYSTEMTIME , "Hour" , $IHOUR )
	DllStructSetData ( $TSYSTEMTIME , "Minute" , $IMINUTE )
	DllStructSetData ( $TSYSTEMTIME , "Second" , $ISECOND )
	DllStructSetData ( $TSYSTEMTIME , "MSeconds" , $IMSECONDS )
	Return $TSYSTEMTIME
EndFunc
Func _DATE_TIME_FILETIMETOARRAY ( ByRef $TFILETIME )
	If ( ( DllStructGetData ( $TFILETIME , 1 ) + DllStructGetData ( $TFILETIME , 2 ) ) = 0 ) Then Return SetError ( 10 , 0 , 0 )
	Local $TSYSTEMTIME = _DATE_TIME_FILETIMETOSYSTEMTIME ( $TFILETIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return _DATE_TIME_SYSTEMTIMETOARRAY ( $TSYSTEMTIME )
EndFunc
Func _DATE_TIME_FILETIMETOSTR ( ByRef $TFILETIME , $IFMT = 0 )
	Local $ADATE = _DATE_TIME_FILETIMETOARRAY ( $TFILETIME )
	If @error Then Return SetError ( @error , @extended , "" )
	If $IFMT Then
		Return StringFormat ( "%04d/%02d/%02d %02d:%02d:%02d" , $ADATE [ 2 ] , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATE [ 3 ] , $ADATE [ 4 ] , $ADATE [ 5 ] )
	Else
		Return StringFormat ( "%02d/%02d/%04d %02d:%02d:%02d" , $ADATE [ 0 ] , $ADATE [ 1 ] , $ADATE [ 2 ] , $ADATE [ 3 ] , $ADATE [ 4 ] , $ADATE [ 5 ] )
	EndIf
EndFunc
Func _DATE_TIME_FILETIMETODOSDATETIME ( $TFILETIME )
	Local $ADATE [ 2 ]
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FileTimeToDosDateTime" , "struct*" , $TFILETIME , "word*" , 0 , "word*" , 0 )
	If @error Then Return SetError ( @error , @extended , $ADATE )
	$ADATE [ 0 ] = $ACALL [ 2 ]
	$ADATE [ 1 ] = $ACALL [ 3 ]
	Return SetExtended ( $ACALL [ 0 ] , $ADATE )
EndFunc
Func _DATE_TIME_FILETIMETOLOCALFILETIME ( $TFILETIME )
	Local $TLOCAL = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FileTimeToLocalFileTime" , "struct*" , $TFILETIME , "struct*" , $TLOCAL )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TLOCAL )
EndFunc
Func _DATE_TIME_FILETIMETOSYSTEMTIME ( $TFILETIME )
	Local $TSYSTTIME = DllStructCreate ( $TAGSYSTEMTIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "FileTimeToSystemTime" , "struct*" , $TFILETIME , "struct*" , $TSYSTTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TSYSTTIME )
EndFunc
Func _DATE_TIME_GETFILETIME ( $HFILE )
	Local $ADATE [ 3 ]
	$ADATE [ 0 ] = DllStructCreate ( $TAGFILETIME )
	$ADATE [ 1 ] = DllStructCreate ( $TAGFILETIME )
	$ADATE [ 2 ] = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetFileTime" , "handle" , $HFILE , "struct*" , $ADATE [ 0 ] , "struct*" , $ADATE [ 1 ] , "struct*" , $ADATE [ 2 ] )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $ADATE )
EndFunc
Func _DATE_TIME_GETLOCALTIME ( )
	Local $TLOCALTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllCall ( "kernel32.dll" , "none" , "GetLocalTime" , "struct*" , $TLOCALTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $TLOCALTIME
EndFunc
Func _DATE_TIME_GETSYSTEMTIME ( )
	Local $TSYSTTIME = DllStructCreate ( $TAGSYSTEMTIME )
	DllCall ( "kernel32.dll" , "none" , "GetSystemTime" , "struct*" , $TSYSTTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $TSYSTTIME
EndFunc
Func _DATE_TIME_GETSYSTEMTIMEADJUSTMENT ( )
	Local $AINFO [ 3 ]
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetSystemTimeAdjustment" , "dword*" , 0 , "dword*" , 0 , "bool*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	$AINFO [ 0 ] = $ACALL [ 1 ]
	$AINFO [ 1 ] = $ACALL [ 2 ]
	$AINFO [ 2 ] = $ACALL [ 3 ] <> 0
	Return SetExtended ( $ACALL [ 0 ] , $AINFO )
EndFunc
Func _DATE_TIME_GETSYSTEMTIMEASFILETIME ( )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME )
	DllCall ( "kernel32.dll" , "none" , "GetSystemTimeAsFileTime" , "struct*" , $TFILETIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $TFILETIME
EndFunc
Func _DATE_TIME_GETSYSTEMTIMES ( )
	Local $AINFO [ 3 ]
	$AINFO [ 0 ] = DllStructCreate ( $TAGFILETIME )
	$AINFO [ 1 ] = DllStructCreate ( $TAGFILETIME )
	$AINFO [ 2 ] = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "GetSystemTimes" , "struct*" , $AINFO [ 0 ] , "struct*" , $AINFO [ 1 ] , "struct*" , $AINFO [ 2 ] )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $AINFO )
EndFunc
Func _DATE_TIME_GETTICKCOUNT ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetTickCount" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _DATE_TIME_GETTIMEZONEINFORMATION ( )
	Local $TTIMEZONE = DllStructCreate ( $TAGTIME_ZONE_INFORMATION )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "GetTimeZoneInformation" , "struct*" , $TTIMEZONE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] = + 4294967295 Then Return SetError ( 10 , 0 , 0 )
	Local $AINFO [ 8 ]
	$AINFO [ 0 ] = $ACALL [ 0 ]
	$AINFO [ 1 ] = DllStructGetData ( $TTIMEZONE , "Bias" )
	$AINFO [ 2 ] = DllStructGetData ( $TTIMEZONE , "StdName" )
	$AINFO [ 3 ] = __DATE_TIME_CLONESYSTEMTIME ( DllStructGetPtr ( $TTIMEZONE , "StdDate" ) )
	$AINFO [ 4 ] = DllStructGetData ( $TTIMEZONE , "StdBias" )
	$AINFO [ 5 ] = DllStructGetData ( $TTIMEZONE , "DayName" )
	$AINFO [ 6 ] = __DATE_TIME_CLONESYSTEMTIME ( DllStructGetPtr ( $TTIMEZONE , "DayDate" ) )
	$AINFO [ 7 ] = DllStructGetData ( $TTIMEZONE , "DayBias" )
	Return $AINFO
EndFunc
Func _DATE_TIME_LOCALFILETIMETOFILETIME ( $TLOCALTIME )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "LocalFileTimeToFileTime" , "struct*" , $TLOCALTIME , "struct*" , $TFILETIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TFILETIME )
EndFunc
Func _DATE_TIME_SETFILETIME ( $HFILE , $TCREATETIME , $TLASTACCESS , $TLASTWRITE )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetFileTime" , "handle" , $HFILE , "struct*" , $TCREATETIME , "struct*" , $TLASTACCESS , "struct*" , $TLASTWRITE )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _DATE_TIME_SETLOCALTIME ( $TSYSTEMTIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetLocalTime" , "struct*" , $TSYSTEMTIME )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , @extended , False )
	$ACALL = DllCall ( "kernel32.dll" , "bool" , "SetLocalTime" , "struct*" , $TSYSTEMTIME )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _DATE_TIME_SETSYSTEMTIME ( $TSYSTEMTIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetSystemTime" , "struct*" , $TSYSTEMTIME )
	If @error Then Return SetError ( @error , @extended , False )
	Return $ACALL [ 0 ]
EndFunc
Func _DATE_TIME_SETSYSTEMTIMEADJUSTMENT ( $IADJUSTMENT , $BDISABLED )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKENEX ( BitOR ( $TOKEN_ADJUST_PRIVILEGES , $TOKEN_QUERY ) )
	If @error Then Return SetError ( @error + 10 , @extended , False )
	_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_SYSTEMTIME_NAME , True )
	Local $IERROR = @error
	Local $ILASTERROR = @extended
	Local $BRET = False
	If Not @error Then
		Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetSystemTimeAdjustment" , "dword" , $IADJUSTMENT , "bool" , $BDISABLED )
		If @error Then
			$IERROR = @error
			$ILASTERROR = @extended
		ElseIf $ACALL [ 0 ] Then
			$BRET = True
		Else
			$IERROR = 20
			$ILASTERROR = _WINAPI_GETLASTERROR ( )
		EndIf
		_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_SYSTEMTIME_NAME , False )
		If Not $IERROR And @error Then $IERROR = 22
	EndIf
	_WINAPI_CLOSEHANDLE ( $HTOKEN )
	Return SetError ( $IERROR , $ILASTERROR , $BRET )
EndFunc
Func _DATE_TIME_SETTIMEZONEINFORMATION ( $IBIAS , $SSTDNAME , $TSTDDATE , $ISTDBIAS , $SDAYNAME , $TDAYDATE , $IDAYBIAS )
	Local $TZONEINFO = DllStructCreate ( $TAGTIME_ZONE_INFORMATION )
	DllStructSetData ( $TZONEINFO , "Bias" , $IBIAS )
	DllStructSetData ( $TZONEINFO , "StdName" , $SSTDNAME )
	_MEMMOVEMEMORY ( $TSTDDATE , DllStructGetPtr ( $TZONEINFO , "StdDate" ) , DllStructGetSize ( $TSTDDATE ) )
	DllStructSetData ( $TZONEINFO , "StdBias" , $ISTDBIAS )
	DllStructSetData ( $TZONEINFO , "DayName" , $SDAYNAME )
	_MEMMOVEMEMORY ( $TDAYDATE , DllStructGetPtr ( $TZONEINFO , "DayDate" ) , DllStructGetSize ( $TDAYDATE ) )
	DllStructSetData ( $TZONEINFO , "DayBias" , $IDAYBIAS )
	Local $HTOKEN = _SECURITY__OPENTHREADTOKENEX ( BitOR ( $TOKEN_ADJUST_PRIVILEGES , $TOKEN_QUERY ) )
	If @error Then Return SetError ( @error + 10 , @extended , False )
	_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_TIME_ZONE_NAME , True )
	Local $IERROR = @error
	Local $ILASTERROR = @extended
	Local $BRET = False
	If Not @error Then
		Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SetTimeZoneInformation" , "struct*" , $TZONEINFO )
		If @error Then
			$IERROR = @error
			$ILASTERROR = @extended
		ElseIf $ACALL [ 0 ] Then
			$ILASTERROR = 0
			$BRET = True
		Else
			$IERROR = 20
			$ILASTERROR = _WINAPI_GETLASTERROR ( )
		EndIf
		_SECURITY__SETPRIVILEGE ( $HTOKEN , $SE_TIME_ZONE_NAME , False )
		If Not $IERROR And @error Then $IERROR = 22
	EndIf
	_WINAPI_CLOSEHANDLE ( $HTOKEN )
	Return SetError ( $IERROR , $ILASTERROR , $BRET )
EndFunc
Func _DATE_TIME_SYSTEMTIMETOARRAY ( ByRef $TSYSTEMTIME )
	Local $AINFO [ 8 ]
	$AINFO [ 0 ] = DllStructGetData ( $TSYSTEMTIME , "Month" )
	$AINFO [ 1 ] = DllStructGetData ( $TSYSTEMTIME , "Day" )
	$AINFO [ 2 ] = DllStructGetData ( $TSYSTEMTIME , "Year" )
	$AINFO [ 3 ] = DllStructGetData ( $TSYSTEMTIME , "Hour" )
	$AINFO [ 4 ] = DllStructGetData ( $TSYSTEMTIME , "Minute" )
	$AINFO [ 5 ] = DllStructGetData ( $TSYSTEMTIME , "Second" )
	$AINFO [ 6 ] = DllStructGetData ( $TSYSTEMTIME , "MSeconds" )
	$AINFO [ 7 ] = DllStructGetData ( $TSYSTEMTIME , "DOW" )
	Return $AINFO
EndFunc
Func _DATE_TIME_SYSTEMTIMETODATESTR ( ByRef $TSYSTEMTIME , $IFMT = 0 )
	Local $AINFO = _DATE_TIME_SYSTEMTIMETOARRAY ( $TSYSTEMTIME )
	If @error Then Return SetError ( @error , @extended , "" )
	If $IFMT Then
		Return StringFormat ( "%04d/%02d/%02d" , $AINFO [ 2 ] , $AINFO [ 0 ] , $AINFO [ 1 ] )
	Else
		Return StringFormat ( "%02d/%02d/%04d" , $AINFO [ 0 ] , $AINFO [ 1 ] , $AINFO [ 2 ] )
	EndIf
EndFunc
Func _DATE_TIME_SYSTEMTIMETODATETIMESTR ( ByRef $TSYSTEMTIME , $IFMT = 0 , $ITYPE = 0 )
	Local $SRET
	Switch $IFMT
	Case 0
		$SRET = _WINAPI_GETDATEFORMAT ( $LOCALE_INVARIANT , $TSYSTEMTIME , 0 , "MM/dd/yyyy " )
		$SRET &= _WINAPI_GETTIMEFORMAT ( $LOCALE_INVARIANT , $TSYSTEMTIME )
	Case 1
		$SRET = _WINAPI_GETDATEFORMAT ( $LOCALE_INVARIANT , $TSYSTEMTIME , 0 , "yyyy/MM/dd " )
		$SRET &= _WINAPI_GETTIMEFORMAT ( $LOCALE_INVARIANT , $TSYSTEMTIME )
	Case 2
		Local $TTEMP
		If $ITYPE Then
			$TTEMP = $TSYSTEMTIME
		Else
			$TTEMP = _DATE_TIME_TZSPECIFICLOCALTIMETOSYSTEMTIME ( $TSYSTEMTIME )
		EndIf
		$SRET = _WINAPI_GETDATEFORMAT ( $LOCALE_INVARIANT , $TTEMP , 0 , "ddd, dd MMM yyyy" ) & " "
		$SRET &= _WINAPI_GETTIMEFORMAT ( $LOCALE_INVARIANT , $TTEMP ) & " GMT"
	Case 3
		Local $AFLAG = _DATE_TIME_GETTIMEZONEINFORMATION ( )
		Local $IBIAS = $AFLAG [ 1 ] + $AFLAG [ 7 ]
		$SRET = _WINAPI_GETDATEFORMAT ( $LOCALE_INVARIANT , $TSYSTEMTIME , 0 , "yyyy-MM-dd" ) & "T"
		$SRET &= _WINAPI_GETTIMEFORMAT ( $LOCALE_INVARIANT , $TSYSTEMTIME )
		If $ITYPE Then
			$SRET &= "Z"
		Else
			If $IBIAS Then
				Local $IS = Mod ( $IBIAS , 60 )
				Local $IH = ( Abs ( $IBIAS ) + $IS ) / 60
				If $IBIAS < 0 Then
					$SRET &= "-"
					$IS = - $IS
				Else
					$SRET &= "+"
				EndIf
				$SRET &= StringFormat ( "%02d:%02d" , $IH , $IS )
			EndIf
		EndIf
	EndSwitch
	Return $SRET
EndFunc
Func _DATE_TIME_SYSTEMTIMETOFILETIME ( $TSYSTEMTIME )
	Local $TFILETIME = DllStructCreate ( $TAGFILETIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SystemTimeToFileTime" , "struct*" , $TSYSTEMTIME , "struct*" , $TFILETIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TFILETIME )
EndFunc
Func _DATE_TIME_SYSTEMTIMETOTIMESTR ( ByRef $TSYSTEMTIME )
	Local $AINFO = _DATE_TIME_SYSTEMTIMETOARRAY ( $TSYSTEMTIME )
	Return StringFormat ( "%02d:%02d:%02d" , $AINFO [ 3 ] , $AINFO [ 4 ] , $AINFO [ 5 ] )
EndFunc
Func _DATE_TIME_SYSTEMTIMETOTZSPECIFICLOCALTIME ( $TUTC , $TTIMEZONE = 0 )
	Local $TLOCALTIME = DllStructCreate ( $TAGSYSTEMTIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "SystemTimeToTzSpecificLocalTime" , "struct*" , $TTIMEZONE , "struct*" , $TUTC , "struct*" , $TLOCALTIME )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TLOCALTIME )
EndFunc
Func _DATE_TIME_TZSPECIFICLOCALTIMETOSYSTEMTIME ( $TLOCALTIME , $TTIMEZONE = 0 )
	Local $TUTC = DllStructCreate ( $TAGSYSTEMTIME )
	Local $ACALL = DllCall ( "kernel32.dll" , "bool" , "TzSpecificLocalTimeToSystemTime" , "struct*" , $TTIMEZONE , "struct*" , $TLOCALTIME , "struct*" , $TUTC )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return SetExtended ( $ACALL [ 0 ] , $TUTC )
EndFunc
Global Const $PROV_RSA_FULL = 1
Global Const $PROV_RSA_AES = 24
Global Const $CRYPT_VERIFYCONTEXT = 4026531840
Global Const $HP_HASHSIZE = 4
Global Const $HP_HASHVAL = 2
Global Const $CRYPT_EXPORTABLE = 1
Global Const $CRYPT_USERDATA = 1
Global Const $KP_ALGID = 7
Global Const $CALG_MD2 = 32769
Global Const $CALG_MD4 = 32770
Global Const $CALG_MD5 = 32771
Global Const $CALG_SHA1 = 32772
Global Const $CALG_SHA_256 = 32780
Global Const $CALG_SHA_384 = 32781
Global Const $CALG_SHA_512 = 32782
Global Const $CALG_3DES = 26115
Global Const $CALG_AES_128 = 26126
Global Const $CALG_AES_192 = 26127
Global Const $CALG_AES_256 = 26128
Global Const $CALG_DES = 26113
Global Const $CALG_RC2 = 26114
Global Const $CALG_RC4 = 26625
Global Const $CALG_USERKEY = 0
Global $__G_ACRYPTINTERNALDATA [ 3 ]
Func _CRYPT_STARTUP ( )
	If __CRYPT_REFCOUNT ( ) = 0 Then
		Local $HADVAPI32 = DllOpen ( "Advapi32.dll" )
		If $HADVAPI32 = + 4294967295 Then Return SetError ( 1001 , 0 , False )
		__CRYPT_DLLHANDLESET ( $HADVAPI32 )
		Local $IPROVIDERID = $PROV_RSA_AES
		Local $ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptAcquireContext" , "handle*" , 0 , "ptr" , 0 , "ptr" , 0 , "dword" , $IPROVIDERID , "dword" , $CRYPT_VERIFYCONTEXT )
		If @error Or Not $ACALL [ 0 ] Then
			Local $IERROR = @error + 1002 , $IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			DllClose ( __CRYPT_DLLHANDLE ( ) )
			Return SetError ( $IERROR , $IEXTENDED , False )
		Else
			__CRYPT_CONTEXTSET ( $ACALL [ 1 ] )
		EndIf
	EndIf
	__CRYPT_REFCOUNTINC ( )
	Return True
EndFunc
Func _CRYPT_SHUTDOWN ( )
	__CRYPT_REFCOUNTDEC ( )
	If __CRYPT_REFCOUNT ( ) = 0 Then
		DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptReleaseContext" , "handle" , __CRYPT_CONTEXT ( ) , "dword" , 0 )
		DllClose ( __CRYPT_DLLHANDLE ( ) )
	EndIf
EndFunc
Func _CRYPT_DERIVEKEY ( $VPASSWORD , $IALGID , $IHASHPASSWORDID = $CALG_MD5 )
	Local $ACALL , $TBUFF = 0 , $HCRYPTHASH = 0 , $IERROR = 0 , $IEXTENDED = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptCreateHash" , "handle" , __CRYPT_CONTEXT ( ) , "uint" , $IHASHPASSWORDID , "ptr" , 0 , "dword" , 0 , "handle*" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 10
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		$HCRYPTHASH = $ACALL [ 5 ]
		$TBUFF = DllStructCreate ( "byte[" & BinaryLen ( $VPASSWORD ) & "]" )
		DllStructSetData ( $TBUFF , 1 , $VPASSWORD )
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptHashData" , "handle" , $HCRYPTHASH , "struct*" , $TBUFF , "dword" , DllStructGetSize ( $TBUFF ) , "dword" , $CRYPT_USERDATA )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 20
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptDeriveKey" , "handle" , __CRYPT_CONTEXT ( ) , "uint" , $IALGID , "handle" , $HCRYPTHASH , "dword" , $CRYPT_EXPORTABLE , "handle*" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 30
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		$VRETURN = $ACALL [ 5 ]
	Until True
	If $HCRYPTHASH <> 0 Then DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptDestroyHash" , "handle" , $HCRYPTHASH )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func _CRYPT_DESTROYKEY ( $HCRYPTKEY )
	Local $ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptDestroyKey" , "handle" , $HCRYPTKEY )
	Local $IERROR = @error
	If $IERROR Or Not $ACALL [ 0 ] Then
		Return SetError ( $IERROR + 10 , _WINAPI_GETLASTERROR ( ) , False )
	Else
		_CRYPT_SHUTDOWN ( )
		Return True
	EndIf
EndFunc
Func _CRYPT_ENCRYPTDATA ( $VDATA , $VCRYPTKEY , $IALGID , $BFINAL = True )
	Switch $IALGID
	Case $CALG_USERKEY
		Local $ICALGUSED = __CRYPT_GETCALGFROMCRYPTKEY ( $VCRYPTKEY )
		If @error Then Return SetError ( @error , @extended , + 4294967295 )
		If $ICALGUSED = $CALG_RC4 Then ContinueCase
	Case $CALG_RC4
		If BinaryLen ( $VDATA ) = 0 Then Return SetError ( 0 , 0 , Binary ( "" ) )
	EndSwitch
	Local $IREQBUFFSIZE = 0 , $ACALL , $TBUFF = 0 , $IERROR = 0 , $IEXTENDED = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		If $IALGID <> $CALG_USERKEY Then
			$VCRYPTKEY = _CRYPT_DERIVEKEY ( $VCRYPTKEY , $IALGID )
			If @error Then
				$IERROR = @error
				$IEXTENDED = @extended
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
		EndIf
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptEncrypt" , "handle" , $VCRYPTKEY , "handle" , 0 , "bool" , $BFINAL , "dword" , 0 , "ptr" , 0 , "dword*" , BinaryLen ( $VDATA ) , "dword" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 50
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		$IREQBUFFSIZE = $ACALL [ 6 ]
		$TBUFF = DllStructCreate ( "byte[" & $IREQBUFFSIZE + 1 & "]" )
		DllStructSetData ( $TBUFF , 1 , $VDATA )
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptEncrypt" , "handle" , $VCRYPTKEY , "handle" , 0 , "bool" , $BFINAL , "dword" , 0 , "struct*" , $TBUFF , "dword*" , BinaryLen ( $VDATA ) , "dword" , $IREQBUFFSIZE )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 60
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		$VRETURN = BinaryMid ( DllStructGetData ( $TBUFF , 1 ) , 1 , $IREQBUFFSIZE )
	Until True
	If $IALGID <> $CALG_USERKEY Then _CRYPT_DESTROYKEY ( $VCRYPTKEY )
	_CRYPT_SHUTDOWN ( )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func _CRYPT_DECRYPTDATA ( $VDATA , $VCRYPTKEY , $IALGID , $BFINAL = True )
	Switch $IALGID
	Case $CALG_USERKEY
		Local $ICALGUSED = __CRYPT_GETCALGFROMCRYPTKEY ( $VCRYPTKEY )
		If @error Then Return SetError ( @error , @extended , + 4294967295 )
		If $ICALGUSED = $CALG_RC4 Then ContinueCase
	Case $CALG_RC4
		If BinaryLen ( $VDATA ) = 0 Then Return SetError ( 0 , 0 , Binary ( "" ) )
	EndSwitch
	Local $ACALL , $TBUFF = 0 , $TTEMPSTRUCT = 0 , $IERROR = 0 , $IEXTENDED = 0 , $IPLAINTEXTSIZE = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		If $IALGID <> $CALG_USERKEY Then
			$VCRYPTKEY = _CRYPT_DERIVEKEY ( $VCRYPTKEY , $IALGID )
			If @error Then
				$IERROR = @error
				$IEXTENDED = @extended
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
		EndIf
		$TBUFF = DllStructCreate ( "byte[" & BinaryLen ( $VDATA ) + 1000 & "]" )
		If BinaryLen ( $VDATA ) > 0 Then DllStructSetData ( $TBUFF , 1 , $VDATA )
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptDecrypt" , "handle" , $VCRYPTKEY , "handle" , 0 , "bool" , $BFINAL , "dword" , 0 , "struct*" , $TBUFF , "dword*" , BinaryLen ( $VDATA ) )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 70
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		$IPLAINTEXTSIZE = $ACALL [ 6 ]
		$TTEMPSTRUCT = DllStructCreate ( "byte[" & $IPLAINTEXTSIZE + 1 & "]" , DllStructGetPtr ( $TBUFF ) )
		$VRETURN = BinaryMid ( DllStructGetData ( $TTEMPSTRUCT , 1 ) , 1 , $IPLAINTEXTSIZE )
	Until True
	If $IALGID <> $CALG_USERKEY Then _CRYPT_DESTROYKEY ( $VCRYPTKEY )
	_CRYPT_SHUTDOWN ( )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func _CRYPT_HASHDATA ( $VDATA , $IALGID , $BFINAL = True , $HCRYPTHASH = 0 )
	Local $ACALL , $TBUFF = 0 , $IERROR = 0 , $IEXTENDED = 0 , $IHASHSIZE = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		If $HCRYPTHASH = 0 Then
			$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptCreateHash" , "handle" , __CRYPT_CONTEXT ( ) , "uint" , $IALGID , "ptr" , 0 , "dword" , 0 , "handle*" , 0 )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 10
				$IEXTENDED = @extended
				If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
			$HCRYPTHASH = $ACALL [ 5 ]
		EndIf
		$TBUFF = DllStructCreate ( "byte[" & BinaryLen ( $VDATA ) & "]" )
		DllStructSetData ( $TBUFF , 1 , $VDATA )
		$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptHashData" , "handle" , $HCRYPTHASH , "struct*" , $TBUFF , "dword" , DllStructGetSize ( $TBUFF ) , "dword" , $CRYPT_USERDATA )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 20
			$IEXTENDED = @extended
			If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		If $BFINAL Then
			$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptGetHashParam" , "handle" , $HCRYPTHASH , "dword" , $HP_HASHSIZE , "dword*" , 0 , "dword*" , 4 , "dword" , 0 )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 30
				$IEXTENDED = @extended
				If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
			$IHASHSIZE = $ACALL [ 3 ]
			$TBUFF = DllStructCreate ( "byte[" & $IHASHSIZE & "]" )
			$ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptGetHashParam" , "handle" , $HCRYPTHASH , "dword" , $HP_HASHVAL , "struct*" , $TBUFF , "dword*" , $IHASHSIZE , "dword" , 0 )
			If @error Or Not $ACALL [ 0 ] Then
				$IERROR = @error + 40
				$IEXTENDED = @extended
				If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
				$VRETURN = + 4294967295
				ExitLoop
			EndIf
			$VRETURN = DllStructGetData ( $TBUFF , 1 )
		Else
			$VRETURN = $HCRYPTHASH
		EndIf
	Until True
	If $HCRYPTHASH <> 0 And $BFINAL Then DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptDestroyHash" , "handle" , $HCRYPTHASH )
	_CRYPT_SHUTDOWN ( )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func _CRYPT_HASHFILE ( $SFILEPATH , $IALGID )
	Local $DTEMPDATA = 0 , $HFILE = 0 , $HHASHOBJECT = 0 , $IERROR = 0 , $IEXTENDED = 0 , $VRETURN = 0
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		$HFILE = FileOpen ( $SFILEPATH , $FO_BINARY )
		If $HFILE = + 4294967295 Then
			$IERROR = 1
			$IEXTENDED = _WINAPI_GETLASTERROR ( )
			$VRETURN = + 4294967295
			ExitLoop
		EndIf
		Do
			$DTEMPDATA = FileRead ( $HFILE , 512 * 1024 )
			If @error Then
				$VRETURN = _CRYPT_HASHDATA ( $DTEMPDATA , $IALGID , True , $HHASHOBJECT )
				If @error Then
					$IERROR = @error
					$IEXTENDED = @extended
					$VRETURN = + 4294967295
					ExitLoop 2
				EndIf
				ExitLoop 2
			Else
				$HHASHOBJECT = _CRYPT_HASHDATA ( $DTEMPDATA , $IALGID , False , $HHASHOBJECT )
				If @error Then
					$IERROR = @error + 100
					$IEXTENDED = @extended
					$VRETURN = + 4294967295
					ExitLoop 2
				EndIf
			EndIf
		Until False
	Until True
	_CRYPT_SHUTDOWN ( )
	If $HFILE <> + 4294967295 Then FileClose ( $HFILE )
	Return SetError ( $IERROR , $IEXTENDED , $VRETURN )
EndFunc
Func _CRYPT_ENCRYPTFILE ( $SSOURCEFILE , $SDESTINATIONFILE , $VCRYPTKEY , $IALGID )
	Local $DTEMPDATA = 0 , $HINFILE = 0 , $HOUTFILE = 0 , $IERROR = 0 , $IEXTENDED = 0 , $IFILESIZE = FileGetSize ( $SSOURCEFILE ) , $IREAD = 0 , $BRETURN = True
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		If $IALGID <> $CALG_USERKEY Then
			$VCRYPTKEY = _CRYPT_DERIVEKEY ( $VCRYPTKEY , $IALGID )
			If @error Then
				$IERROR = @error
				$IEXTENDED = @extended
				$BRETURN = False
				ExitLoop
			EndIf
		EndIf
		$HINFILE = FileOpen ( $SSOURCEFILE , $FO_BINARY )
		If $HINFILE = + 4294967295 Then
			$IERROR = 2
			$IEXTENDED = _WINAPI_GETLASTERROR ( )
			$BRETURN = False
			ExitLoop
		EndIf
		$HOUTFILE = FileOpen ( $SDESTINATIONFILE , $FO_OVERWRITE + $FO_CREATEPATH + $FO_BINARY )
		If $HOUTFILE = + 4294967295 Then
			$IERROR = 3
			$IEXTENDED = _WINAPI_GETLASTERROR ( )
			$BRETURN = False
			ExitLoop
		EndIf
		Do
			$DTEMPDATA = FileRead ( $HINFILE , 1024 * 1024 )
			$IREAD += BinaryLen ( $DTEMPDATA )
			If $IREAD = $IFILESIZE Then
				$DTEMPDATA = _CRYPT_ENCRYPTDATA ( $DTEMPDATA , $VCRYPTKEY , $CALG_USERKEY , True )
				If @error Then
					$IERROR = @error + 400
					$IEXTENDED = @extended
					$BRETURN = False
				EndIf
				FileWrite ( $HOUTFILE , $DTEMPDATA )
				ExitLoop 2
			Else
				$DTEMPDATA = _CRYPT_ENCRYPTDATA ( $DTEMPDATA , $VCRYPTKEY , $CALG_USERKEY , False )
				If @error Then
					$IERROR = @error + 500
					$IEXTENDED = @extended
					$BRETURN = False
					ExitLoop 2
				EndIf
				FileWrite ( $HOUTFILE , $DTEMPDATA )
			EndIf
		Until False
	Until True
	If $IALGID <> $CALG_USERKEY Then _CRYPT_DESTROYKEY ( $VCRYPTKEY )
	_CRYPT_SHUTDOWN ( )
	If $HINFILE <> + 4294967295 Then FileClose ( $HINFILE )
	If $HOUTFILE <> + 4294967295 Then FileClose ( $HOUTFILE )
	Return SetError ( $IERROR , $IEXTENDED , $BRETURN )
EndFunc
Func _CRYPT_DECRYPTFILE ( $SSOURCEFILE , $SDESTINATIONFILE , $VCRYPTKEY , $IALGID )
	Local $DTEMPDATA = 0 , $HINFILE = 0 , $HOUTFILE = 0 , $IERROR = 0 , $IEXTENDED = 0 , $IFILESIZE = FileGetSize ( $SSOURCEFILE ) , $IREAD = 0 , $BRETURN = True
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Do
		If $IALGID <> $CALG_USERKEY Then
			$VCRYPTKEY = _CRYPT_DERIVEKEY ( $VCRYPTKEY , $IALGID )
			If @error Then
				$IERROR = @error
				$IEXTENDED = @extended
				$BRETURN = False
				ExitLoop
			EndIf
		EndIf
		$HINFILE = FileOpen ( $SSOURCEFILE , $FO_BINARY )
		If $HINFILE = + 4294967295 Then
			$IERROR = 2
			$IEXTENDED = _WINAPI_GETLASTERROR ( )
			$BRETURN = False
			ExitLoop
		EndIf
		$HOUTFILE = FileOpen ( $SDESTINATIONFILE , $FO_OVERWRITE + $FO_CREATEPATH + $FO_BINARY )
		If $HOUTFILE = + 4294967295 Then
			$IERROR = 3
			$IEXTENDED = _WINAPI_GETLASTERROR ( )
			$BRETURN = False
			ExitLoop
		EndIf
		Do
			$DTEMPDATA = FileRead ( $HINFILE , 1024 * 1024 )
			$IREAD += BinaryLen ( $DTEMPDATA )
			If $IREAD = $IFILESIZE Then
				$DTEMPDATA = _CRYPT_DECRYPTDATA ( $DTEMPDATA , $VCRYPTKEY , $CALG_USERKEY , True )
				If @error Then
					$IERROR = @error + 400
					$IEXTENDED = @extended
					$BRETURN = False
				EndIf
				FileWrite ( $HOUTFILE , $DTEMPDATA )
				ExitLoop 2
			Else
				$DTEMPDATA = _CRYPT_DECRYPTDATA ( $DTEMPDATA , $VCRYPTKEY , $CALG_USERKEY , False )
				If @error Then
					$IERROR = @error + 500
					$IEXTENDED = @extended
					$BRETURN = False
					ExitLoop 2
				EndIf
				FileWrite ( $HOUTFILE , $DTEMPDATA )
			EndIf
		Until False
	Until True
	If $IALGID <> $CALG_USERKEY Then _CRYPT_DESTROYKEY ( $VCRYPTKEY )
	_CRYPT_SHUTDOWN ( )
	If $HINFILE <> + 4294967295 Then FileClose ( $HINFILE )
	If $HOUTFILE <> + 4294967295 Then FileClose ( $HOUTFILE )
	Return SetError ( $IERROR , $IEXTENDED , $BRETURN )
EndFunc
Func _CRYPT_GENRANDOM ( $PBUFFER , $ISIZE )
	_CRYPT_STARTUP ( )
	If @error Then Return SetError ( @error , @extended , False )
	Local $ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptGenRandom" , "handle" , __CRYPT_CONTEXT ( ) , "dword" , $ISIZE , "struct*" , $PBUFFER )
	Local $IERROR = @error , $IEXTENDED = @extended
	If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
	_CRYPT_SHUTDOWN ( )
	If $IERROR Or ( Not $ACALL [ 0 ] ) Then
		Return SetError ( $IERROR + 10 , $IEXTENDED , False )
	Else
		Return True
	EndIf
EndFunc
Func __CRYPT_REFCOUNT ( )
	Return $__G_ACRYPTINTERNALDATA [ 0 ]
EndFunc
Func __CRYPT_REFCOUNTINC ( )
	$__G_ACRYPTINTERNALDATA [ 0 ] += 1
EndFunc
Func __CRYPT_REFCOUNTDEC ( )
	If $__G_ACRYPTINTERNALDATA [ 0 ] > 0 Then $__G_ACRYPTINTERNALDATA [ 0 ] -= 1
EndFunc
Func __CRYPT_DLLHANDLE ( )
	Return $__G_ACRYPTINTERNALDATA [ 1 ]
EndFunc
Func __CRYPT_DLLHANDLESET ( $HADVAPI32 )
	$__G_ACRYPTINTERNALDATA [ 1 ] = $HADVAPI32
EndFunc
Func __CRYPT_CONTEXT ( )
	Return $__G_ACRYPTINTERNALDATA [ 2 ]
EndFunc
Func __CRYPT_CONTEXTSET ( $HCRYPTCONTEXT )
	$__G_ACRYPTINTERNALDATA [ 2 ] = $HCRYPTCONTEXT
EndFunc
Func __CRYPT_GETCALGFROMCRYPTKEY ( $VCRYPTKEY )
	Local $TALGID = DllStructCreate ( "uint" )
	Local $ACALL = DllCall ( __CRYPT_DLLHANDLE ( ) , "bool" , "CryptGetKeyParam" , "handle" , $VCRYPTKEY , "dword" , $KP_ALGID , "struct*" , $TALGID , "dword*" , DllStructGetSize ( $TALGID ) , "dword" , 0 )
	Local $IERROR = @error , $IEXTENDED = @extended
	If Not $ACALL [ 0 ] Then $IEXTENDED = _WINAPI_GETLASTERROR ( )
	If $IERROR Or Not $ACALL [ 0 ] Then
		Return SetError ( $IERROR + 80 , $IEXTENDED , $CRYPT_USERDATA )
	Else
		Return DllStructGetData ( $TALGID , 1 )
	EndIf
EndFunc
#Region Settings
#AutoIt3Wrapper_AU3Check_Parameters=-q -d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6 -w 7
#Tidy_Parameters=/tcb=-1 /sf /ewnl /reel /gd
#EndRegion Settings
#Region Include
Global Const $GDIP_DASHCAPFLAT = 0
Global Const $GDIP_DASHCAPROUND = 2
Global Const $GDIP_DASHCAPTRIANGLE = 3
Global Const $GDIP_DASHSTYLESOLID = 0
Global Const $GDIP_DASHSTYLEDASH = 1
Global Const $GDIP_DASHSTYLEDOT = 2
Global Const $GDIP_DASHSTYLEDASHDOT = 3
Global Const $GDIP_DASHSTYLEDASHDOTDOT = 4
Global Const $GDIP_DASHSTYLECUSTOM = 5
Global Const $GDIP_EPGCHROMINANCETABLE = "{F2E455DC-09B3-4316-8260-676ADA32481C}"
Global Const $GDIP_EPGCOLORDEPTH = "{66087055-AD66-4C7C-9A18-38A2310B8337}"
Global Const $GDIP_EPGCOMPRESSION = "{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}"
Global Const $GDIP_EPGLUMINANCETABLE = "{EDB33BCE-0266-4A77-B904-27216099E717}"
Global Const $GDIP_EPGQUALITY = "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}"
Global Const $GDIP_EPGRENDERMETHOD = "{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}"
Global Const $GDIP_EPGSAVEFLAG = "{292266FC-AC40-47BF-8CFC-A85B89A655DE}"
Global Const $GDIP_EPGSCANMETHOD = "{3A4E2661-3109-4E56-8536-42C156E7DCFA}"
Global Const $GDIP_EPGTRANSFORMATION = "{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}"
Global Const $GDIP_EPGVERSION = "{24D18C76-814A-41A4-BF53-1C219CCCF797}"
Global Const $GDIP_EPTBYTE = 1
Global Const $GDIP_EPTASCII = 2
Global Const $GDIP_EPTSHORT = 3
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EPTRATIONAL = 5
Global Const $GDIP_EPTLONGRANGE = 6
Global Const $GDIP_EPTUNDEFINED = 7
Global Const $GDIP_EPTRATIONALRANGE = 8
Global Const $GDIP_ERROK = 0
Global Const $GDIP_ERRGENERICERROR = 1
Global Const $GDIP_ERRINVALIDPARAMETER = 2
Global Const $GDIP_ERROUTOFMEMORY = 3
Global Const $GDIP_ERROBJECTBUSY = 4
Global Const $GDIP_ERRINSUFFICIENTBUFFER = 5
Global Const $GDIP_ERRNOTIMPLEMENTED = 6
Global Const $GDIP_ERRWIN32ERROR = 7
Global Const $GDIP_ERRWRONGSTATE = 8
Global Const $GDIP_ERRABORTED = 9
Global Const $GDIP_ERRFILENOTFOUND = 10
Global Const $GDIP_ERRVALUEOVERFLOW = 11
Global Const $GDIP_ERRACCESSDENIED = 12
Global Const $GDIP_ERRUNKNOWNIMAGEFORMAT = 13
Global Const $GDIP_ERRFONTFAMILYNOTFOUND = 14
Global Const $GDIP_ERRFONTSTYLENOTFOUND = 15
Global Const $GDIP_ERRNOTTRUETYPEFONT = 16
Global Const $GDIP_ERRUNSUPPORTEDGDIVERSION = 17
Global Const $GDIP_ERRGDIPLUSNOTINITIALIZED = 18
Global Const $GDIP_ERRPROPERTYNOTFOUND = 19
Global Const $GDIP_ERRPROPERTYNOTSUPPORTED = 20
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_EVTCOMPRESSIONCCITT3 = 3
Global Const $GDIP_EVTCOMPRESSIONCCITT4 = 4
Global Const $GDIP_EVTCOMPRESSIONRLE = 5
Global Const $GDIP_EVTCOMPRESSIONNONE = 6
Global Const $GDIP_EVTTRANSFORMROTATE90 = 13
Global Const $GDIP_EVTTRANSFORMROTATE180 = 14
Global Const $GDIP_EVTTRANSFORMROTATE270 = 15
Global Const $GDIP_EVTTRANSFORMFLIPHORIZONTAL = 16
Global Const $GDIP_EVTTRANSFORMFLIPVERTICAL = 17
Global Const $GDIP_EVTMULTIFRAME = 18
Global Const $GDIP_EVTLASTFRAME = 19
Global Const $GDIP_EVTFLUSH = 20
Global Const $GDIP_EVTFRAMEDIMENSIONPAGE = 23
Global Const $GDIP_ICFENCODER = 1
Global Const $GDIP_ICFDECODER = 2
Global Const $GDIP_ICFSUPPORTBITMAP = 4
Global Const $GDIP_ICFSUPPORTVECTOR = 8
Global Const $GDIP_ICFSEEKABLEENCODE = 16
Global Const $GDIP_ICFBLOCKINGDECODE = 32
Global Const $GDIP_ICFBUILTIN = 65536
Global Const $GDIP_ICFSYSTEM = 131072
Global Const $GDIP_ICFUSER = 262144
Global Const $GDIP_ILMREAD = 1
Global Const $GDIP_ILMWRITE = 2
Global Const $GDIP_ILMUSERINPUTBUF = 4
Global Const $GDIP_LINECAPFLAT = 0
Global Const $GDIP_LINECAPSQUARE = 1
Global Const $GDIP_LINECAPROUND = 2
Global Const $GDIP_LINECAPTRIANGLE = 3
Global Const $GDIP_LINECAPNOANCHOR = 16
Global Const $GDIP_LINECAPSQUAREANCHOR = 17
Global Const $GDIP_LINECAPROUNDANCHOR = 18
Global Const $GDIP_LINECAPDIAMONDANCHOR = 19
Global Const $GDIP_LINECAPARROWANCHOR = 20
Global Const $GDIP_LINECAPCUSTOM = 255
Global Const $GDIP_PXF01INDEXED = 196865
Global Const $GDIP_PXF04INDEXED = 197634
Global Const $GDIP_PXF08INDEXED = 198659
Global Const $GDIP_PXF16GRAYSCALE = 1052676
Global Const $GDIP_PXF16RGB555 = 135173
Global Const $GDIP_PXF16RGB565 = 135174
Global Const $GDIP_PXF16ARGB1555 = 397319
Global Const $GDIP_PXF24RGB = 137224
Global Const $GDIP_PXF32RGB = 139273
Global Const $GDIP_PXF32ARGB = 2498570
Global Const $GDIP_PXF32PARGB = 925707
Global Const $GDIP_PXF48RGB = 1060876
Global Const $GDIP_PXF64ARGB = 3424269
Global Const $GDIP_PXF64PARGB = 1720334
Global Const $GDIP_IMAGEFORMAT_UNDEFINED = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_MEMORYBMP = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_BMP = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EMF = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_WMF = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_JPEG = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_GIF = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_TIFF = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EXIF = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_ICON = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGETYPE_UNKNOWN = 0
Global Const $GDIP_IMAGETYPE_BITMAP = 1
Global Const $GDIP_IMAGETYPE_METAFILE = 2
Global Const $GDIP_IMAGEFLAGS_NONE = 0
Global Const $GDIP_IMAGEFLAGS_SCALABLE = 1
Global Const $GDIP_IMAGEFLAGS_HASALPHA = 2
Global Const $GDIP_IMAGEFLAGS_HASTRANSLUCENT = 4
Global Const $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE = 8
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_RGB = 16
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_CMYK = 32
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_GRAY = 64
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR = 128
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCCK = 256
Global Const $GDIP_IMAGEFLAGS_HASREALDPI = 4096
Global Const $GDIP_IMAGEFLAGS_HASREALPIXELSIZE = 8192
Global Const $GDIP_IMAGEFLAGS_READONLY = 65536
Global Const $GDIP_IMAGEFLAGS_CACHING = 131072
Global Const $GDIP_SMOOTHINGMODE_INVALID = + 4294967295
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHSPEED = 1
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_NONE = 3
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X4 = 4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS = $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_RLUM = 0.3086
Global Const $GDIP_GLUM = 0.6094
Global Const $GDIP_BLUM = 0.082
Global Const $GDIP_INTERPOLATIONMODE_INVALID = + 4294967295
Global Const $GDIP_INTERPOLATIONMODE_DEFAULT = 0
Global Const $GDIP_INTERPOLATIONMODE_LOWQUALITY = 1
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITY = 2
Global Const $GDIP_INTERPOLATIONMODE_BILINEAR = 3
Global Const $GDIP_INTERPOLATIONMODE_BICUBIC = 4
Global Const $GDIP_INTERPOLATIONMODE_NEARESTNEIGHBOR = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBILINEAR = 6
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global Const $GDIP_PIXELOFFSETMODE_INVALID = + 4294967295
Global Const $GDIP_PIXELOFFSETMODE_DEFAULT = 0
Global Const $GDIP_PIXELOFFSETMODE_HIGHSPEED = 1
Global Const $GDIP_PIXELOFFSETMODE_HIGHQUALITY = 2
Global Const $GDIP_PIXELOFFSETMODE_NONE = 3
Global Const $GDIP_PIXELOFFSETMODE_HALF = 4
Global Const $GDIP_PENSETLINEJOIN_MITER = 0
Global Const $GDIP_PENSETLINEJOIN_BEVEL = 1
Global Const $GDIP_PENSETLINEJOIN_ROUND = 2
Global Const $GDIP_PENSETLINEJOIN_MITERCLIPPED = 3
Global Const $GDIP_FILLMODEALTERNATE = 0
Global Const $GDIP_FILLMODEWINDING = 1
Global Const $GDIP_QUALITYMODEINVALID = + 4294967295
Global Const $GDIP_QUALITYMODEDEFAULT = 0
Global Const $GDIP_QUALITYMODELOW = 1
Global Const $GDIP_QUALITYMODEHIGH = 2
Global Const $GDIP_COMPOSITINGMODESOURCEOVER = 0
Global Const $GDIP_COMPOSITINGMODESOURCECOPY = 1
Global Const $GDIP_COMPOSITINGQUALITY_DEFAULT = 0
Global Const $GDIP_COMPOSITINGQUALITY_HIGHSPEED = 1
Global Const $GDIP_COMPOSITINGQUALITY_HIGHQUALITY = 2
Global Const $GDIP_COMPOSITINGQUALITY_GAMMACORRECTED = 3
Global Const $GDIP_COMPOSITINGQUALITY_ASSUMELINEAR = 4
Global Const $GDIP_HATCHSTYLE_HORIZONTAL = 0
Global Const $GDIP_HATCHSTYLE_VERTICAL = 1
Global Const $GDIP_HATCHSTYLE_FORWARDDIAGONAL = 2
Global Const $GDIP_HATCHSTYLE_BACKWARDDIAGONAL = 3
Global Const $GDIP_HATCHSTYLE_CROSS = 4
Global Const $GDIP_HATCHSTYLE_DIAGONALCROSS = 5
Global Const $GDIP_HATCHSTYLE_05PERCENT = 6
Global Const $GDIP_HATCHSTYLE_10PERCENT = 7
Global Const $GDIP_HATCHSTYLE_20PERCENT = 8
Global Const $GDIP_HATCHSTYLE_25PERCENT = 9
Global Const $GDIP_HATCHSTYLE_30PERCENT = 10
Global Const $GDIP_HATCHSTYLE_40PERCENT = 11
Global Const $GDIP_HATCHSTYLE_50PERCENT = 12
Global Const $GDIP_HATCHSTYLE_60PERCENT = 13
Global Const $GDIP_HATCHSTYLE_70PERCENT = 14
Global Const $GDIP_HATCHSTYLE_75PERCENT = 15
Global Const $GDIP_HATCHSTYLE_80PERCENT = 16
Global Const $GDIP_HATCHSTYLE_90PERCENT = 17
Global Const $GDIP_HATCHSTYLE_LIGHTDOWNWARDDIAGONAL = 18
Global Const $GDIP_HATCHSTYLE_LIGHTUPWARDDIAGONAL = 19
Global Const $GDIP_HATCHSTYLE_DARKDOWNWARDDIAGONAL = 20
Global Const $GDIP_HATCHSTYLE_DARKUPWARDDIAGONAL = 21
Global Const $GDIP_HATCHSTYLE_WIDEDOWNWARDDIAGONAL = 22
Global Const $GDIP_HATCHSTYLE_WIDEUPWARDDIAGONAL = 23
Global Const $GDIP_HATCHSTYLE_LIGHTVERTICAL = 24
Global Const $GDIP_HATCHSTYLE_LIGHTHORIZONTAL = 25
Global Const $GDIP_HATCHSTYLE_NARROWVERTICAL = 26
Global Const $GDIP_HATCHSTYLE_NARROWHORIZONTAL = 27
Global Const $GDIP_HATCHSTYLE_DARKVERTICAL = 28
Global Const $GDIP_HATCHSTYLE_DARKHORIZONTAL = 29
Global Const $GDIP_HATCHSTYLE_DASHEDDOWNWARDDIAGONAL = 30
Global Const $GDIP_HATCHSTYLE_DASHEDUPWARDDIAGONAL = 31
Global Const $GDIP_HATCHSTYLE_DASHEDHORIZONTAL = 32
Global Const $GDIP_HATCHSTYLE_DASHEDVERTICAL = 33
Global Const $GDIP_HATCHSTYLE_SMALLCONFETTI = 34
Global Const $GDIP_HATCHSTYLE_LARGECONFETTI = 35
Global Const $GDIP_HATCHSTYLE_ZIGZAG = 36
Global Const $GDIP_HATCHSTYLE_WAVE = 37
Global Const $GDIP_HATCHSTYLE_DIAGONALBRICK = 38
Global Const $GDIP_HATCHSTYLE_HORIZONTALBRICK = 39
Global Const $GDIP_HATCHSTYLE_WEAVE = 40
Global Const $GDIP_HATCHSTYLE_PLAID = 41
Global Const $GDIP_HATCHSTYLE_DIVOT = 42
Global Const $GDIP_HATCHSTYLE_DOTTEDGRID = 43
Global Const $GDIP_HATCHSTYLE_DOTTEDDIAMOND = 44
Global Const $GDIP_HATCHSTYLE_SHINGLE = 45
Global Const $GDIP_HATCHSTYLE_TRELLIS = 46
Global Const $GDIP_HATCHSTYLE_SPHERE = 47
Global Const $GDIP_HATCHSTYLE_SMALLGRID = 48
Global Const $GDIP_HATCHSTYLE_SMALLCHECKERBOARD = 49
Global Const $GDIP_HATCHSTYLE_LARGECHECKERBOARD = 50
Global Const $GDIP_HATCHSTYLE_OUTLINEDDIAMOND = 51
Global Const $GDIP_HATCHSTYLE_SOLIDDIAMOND = 52
Global Const $GDIP_HATCHSTYLE_TOTAL = 53
Global Const $GDIP_HATCHSTYLE_LARGEGRID = $GDIP_HATCHSTYLE_CROSS
Global Const $GDIP_HATCHSTYLE_MIN = $GDIP_HATCHSTYLE_HORIZONTAL
Global Const $GDIP_HATCHSTYLE_MAX = $GDIP_HATCHSTYLE_TOTAL + 4294967295
Global Const $GDIP_BLUREFFECTGUID = "{633C80A4-1843-482b-9EF2-BE2834C5FDD4}"
Global Const $GDIP_SHARPENEFFECTGUID = "{63CBF3EE-C526-402c-8F71-62C540BF5142}"
Global Const $GDIP_COLORMATRIXEFFECTGUID = "{718F2615-7933-40e3-A511-5F68FE14DD74}"
Global Const $GDIP_COLORLUTEFFECTGUID = "{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}"
Global Const $GDIP_BRIGHTNESSCONTRASTEFFECTGUID = "{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}"
Global Const $GDIP_HUESATURATIONLIGHTNESSEFFECTGUID = "{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}"
Global Const $GDIP_LEVELSEFFECTGUID = "{99C354EC-2A31-4f3a-8C34-17A803B33A25}"
Global Const $GDIP_TINTEFFECTGUID = "{1077AF00-2848-4441-9489-44AD4C2D7A2C}"
Global Const $GDIP_COLORBALANCEEFFECTGUID = "{537E597D-251E-48da-9664-29CA496B70F8}"
Global Const $GDIP_REDEYECORRECTIONEFFECTGUID = "{74D29D05-69A4-4266-9549-3CC52836B632}"
Global Const $GDIP_COLORCURVEEFFECTGUID = "{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}"
Global Const $GDIP_ADJUSTEXPOSURE = 0
Global Const $GDIP_ADJUSTDENSITY = 1
Global Const $GDIP_ADJUSTCONTRAST = 2
Global Const $GDIP_ADJUSTHIGHLIGHT = 3
Global Const $GDIP_ADJUSTSHADOW = 4
Global Const $GDIP_ADJUSTMIDTONE = 5
Global Const $GDIP_ADJUSTWHITESATURATION = 6
Global Const $GDIP_ADJUSTBLACKSATURATION = 7
Global Const $GDIP_CURVECHANNELALL = 0
Global Const $GDIP_CURVECHANNELRED = 1
Global Const $GDIP_CURVECHANNELGREEN = 2
Global Const $GDIP_CURVECHANNELBLUE = 3
Global Const $GDIP_PALETTETYPECUSTOM = 0
Global Const $GDIP_PALETTETYPEOPTIMAL = 1
Global Const $GDIP_PALETTETYPEFIXEDBW = 2
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE8 = 3
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE27 = 4
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE64 = 5
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE125 = 6
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE216 = 7
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE252 = 8
Global Const $GDIP_PALETTETYPEFIXEDHALFTONE256 = 9
Global Const $GDIP_PALETTEFLAGSHASALPHA = 1
Global Const $GDIP_PALETTEFLAGSGRAYSCALE = 2
Global Const $GDIP_PALETTEFLAGSHALFTONE = 4
Global Const $GDIP_DITHERTYPENONE = 0
Global Const $GDIP_DITHERTYPESOLID = 1
Global Const $GDIP_DITHERTYPEORDERED4X4 = 2
Global Const $GDIP_DITHERTYPEORDERED8X8 = 3
Global Const $GDIP_DITHERTYPEORDERED16X16 = 4
Global Const $GDIP_DITHERTYPEORDERED91X91 = 5
Global Const $GDIP_DITHERTYPESPIRAL4X4 = 6
Global Const $GDIP_DITHERTYPESPIRAL8X8 = 7
Global Const $GDIP_DITHERTYPEDUALSPIRAL4X4 = 8
Global Const $GDIP_DITHERTYPEDUALSPIRAL8X8 = 9
Global Const $GDIP_DITHERTYPEERRORDIFFUSION = 10
Global Const $GDIP_DITHERTYPEMAX = 10
Global Const $GDIP_HISTOGRAMFORMATARGB = 0
Global Const $GDIP_HISTOGRAMFORMATPARGB = 1
Global Const $GDIP_HISTOGRAMFORMATRGB = 2
Global Const $GDIP_HISTOGRAMFORMATGRAY = 3
Global Const $GDIP_HISTOGRAMFORMATB = 4
Global Const $GDIP_HISTOGRAMFORMATG = 5
Global Const $GDIP_HISTOGRAMFORMATR = 6
Global Const $GDIP_HISTOGRAMFORMATA = 7
Global Const $GDIP_TEXTRENDERINGHINTSYSTEMDEFAULT = 0
Global Const $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXELGRIDFIT = 1
Global Const $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXEL = 2
Global Const $GDIP_TEXTRENDERINGHINTANTIALIASGRIDFIT = 3
Global Const $GDIP_TEXTRENDERINGHINTANTIALIAS = 4
Global Const $GDIP_TEXTRENDERINGHINTCLEARTYPEGRIDFIT = 5
Global Const $GDIP_ROTATENONEFLIPNONE = 0
Global Const $GDIP_ROTATE90FLIPNONE = 1
Global Const $GDIP_ROTATE180FLIPNONE = 2
Global Const $GDIP_ROTATE270FLIPNONE = 3
Global Const $GDIP_ROTATENONEFLIPX = 4
Global Const $GDIP_ROTATE90FLIPX = 5
Global Const $GDIP_ROTATE180FLIPX = 6
Global Const $GDIP_ROTATE270FLIPX = 7
Global Const $GDIP_ROTATENONEFLIPY = $GDIP_ROTATE180FLIPX
Global Const $GDIP_ROTATE90FLIPY = $GDIP_ROTATE270FLIPX
Global Const $GDIP_ROTATE180FLIPY = $GDIP_ROTATENONEFLIPX
Global Const $GDIP_ROTATE270FLIPY = $GDIP_ROTATE90FLIPX
Global Const $GDIP_ROTATENONEFLIPXY = $GDIP_ROTATE180FLIPNONE
Global Const $GDIP_ROTATE90FLIPXY = $GDIP_ROTATE270FLIPNONE
Global Const $GDIP_ROTATE270FLIPXY = $GDIP_ROTATE90FLIPNONE
Global Const $GDIP_FRAMEDIMENSION_TIME = "{6AEDBD6D-3FB5-418A-83A6-7F45229DC872}"
Global Const $GDIP_FRAMEDIMENSION_RESOLUTION = "{84236F7B-3BD3-428F-8DAB-4EA1439CA315}"
Global Const $GDIP_FRAMEDIMENSION_PAGE = "{7462DC86-6180-4C7E-8E3F-EE7333A7A483}"
Global Const $GDIP_COLORADJUSTTYPE_DEFAULT = 0
Global Const $GDIP_COLORADJUSTTYPE_BITMAP = 1
Global Const $GDIP_COLORADJUSTTYPE_BRUSH = 2
Global Const $GDIP_COLORADJUSTTYPE_PEN = 3
Global Const $GDIP_COLORADJUSTTYPE_TEXT = 4
Global Const $GDIP_COLORADJUSTTYPE_COUNT = 5
Global Const $GDIP_COLORADJUSTTYPE_ANY = 6
Global Enum $GDIP_WRAPMODETILE , $GDIP_WRAPMODETILEFLIPX , $GDIP_WRAPMODETILEFLIPY , $GDIP_WRAPMODETILEFLIPXY , $GDIP_WRAPMODECLAMP
Global $__G_HGDIPBRUSH = 0
Global $__G_HGDIPDLL = 0
Global $__G_HGDIPPEN = 0
Global $__G_IGDIPREF = 0
Global $__G_IGDIPTOKEN = 0
Global $__G_BGDIP_V1_0 = True
Func _GDIPLUS_ARROWCAPCREATE ( $FHEIGHT , $FWIDTH , $BFILLED = True )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateAdjustableArrowCap" , "float" , $FHEIGHT , "float" , $FWIDTH , "bool" , $BFILLED , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_ARROWCAPDISPOSE ( $HCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteCustomLineCap" , "handle" , $HCAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_ARROWCAPGETFILLSTATE ( $HARROWCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetAdjustableArrowCapFillState" , "handle" , $HARROWCAP , "bool*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_ARROWCAPGETHEIGHT ( $HARROWCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetAdjustableArrowCapHeight" , "handle" , $HARROWCAP , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_ARROWCAPGETMIDDLEINSET ( $HARROWCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetAdjustableArrowCapMiddleInset" , "handle" , $HARROWCAP , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_ARROWCAPGETWIDTH ( $HARROWCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetAdjustableArrowCapWidth" , "handle" , $HARROWCAP , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_ARROWCAPSETFILLSTATE ( $HARROWCAP , $BFILLED = True )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetAdjustableArrowCapFillState" , "handle" , $HARROWCAP , "bool" , $BFILLED )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_ARROWCAPSETHEIGHT ( $HARROWCAP , $FHEIGHT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetAdjustableArrowCapHeight" , "handle" , $HARROWCAP , "float" , $FHEIGHT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_ARROWCAPSETMIDDLEINSET ( $HARROWCAP , $FINSET )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetAdjustableArrowCapMiddleInset" , "handle" , $HARROWCAP , "float" , $FINSET )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_ARROWCAPSETWIDTH ( $HARROWCAP , $FWIDTH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetAdjustableArrowCapWidth" , "handle" , $HARROWCAP , "float" , $FWIDTH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPCLONEAREA ( $HBITMAP , $NLEFT , $NTOP , $NWIDTH , $NHEIGHT , $IFORMAT = 137224 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCloneBitmapArea" , "float" , $NLEFT , "float" , $NTOP , "float" , $NWIDTH , "float" , $NHEIGHT , "int" , $IFORMAT , "handle" , $HBITMAP , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 7 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEDIBFROMBITMAP ( $HBITMAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "uint" , "GdipGetImageDimension" , "handle" , $HBITMAP , "float*" , 0 , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $TDATA = _GDIPLUS_BITMAPLOCKBITS ( $HBITMAP , 0 , 0 , $ACALL [ 2 ] , $ACALL [ 3 ] , $GDIP_ILMREAD , $GDIP_PXF32ARGB )
	Local $PBITS = DllStructGetData ( $TDATA , "Scan0" )
	If Not $PBITS Then Return 0
	Local $TBIHDR = DllStructCreate ( $TAGBITMAPV5HEADER )
	DllStructSetData ( $TBIHDR , "bV5Size" , DllStructGetSize ( $TBIHDR ) )
	DllStructSetData ( $TBIHDR , "bV5Width" , $ACALL [ 2 ] )
	DllStructSetData ( $TBIHDR , "bV5Height" , $ACALL [ 3 ] )
	DllStructSetData ( $TBIHDR , "bV5Planes" , 1 )
	DllStructSetData ( $TBIHDR , "bV5BitCount" , 32 )
	DllStructSetData ( $TBIHDR , "bV5Compression" , 0 )
	DllStructSetData ( $TBIHDR , "bV5SizeImage" , $ACALL [ 3 ] * DllStructGetData ( $TDATA , "Stride" ) )
	DllStructSetData ( $TBIHDR , "bV5AlphaMask" , 4278190080 )
	DllStructSetData ( $TBIHDR , "bV5RedMask" , 16711680 )
	DllStructSetData ( $TBIHDR , "bV5GreenMask" , 65280 )
	DllStructSetData ( $TBIHDR , "bV5BlueMask" , 255 )
	DllStructSetData ( $TBIHDR , "bV5CSType" , 2 )
	DllStructSetData ( $TBIHDR , "bV5Intent" , 4 )
	Local $HHBITMAPV5 = DllCall ( "gdi32.dll" , "ptr" , "CreateDIBSection" , "hwnd" , 0 , "struct*" , $TBIHDR , "uint" , 0 , "ptr*" , 0 , "ptr" , 0 , "dword" , 0 )
	If Not @error And $HHBITMAPV5 [ 0 ] Then
		DllCall ( "gdi32.dll" , "dword" , "SetBitmapBits" , "ptr" , $HHBITMAPV5 [ 0 ] , "dword" , $ACALL [ 2 ] * $ACALL [ 3 ] * 4 , "ptr" , DllStructGetData ( $TDATA , "Scan0" ) )
		$HHBITMAPV5 = $HHBITMAPV5 [ 0 ]
	Else
		$HHBITMAPV5 = 0
	EndIf
	_GDIPLUS_BITMAPUNLOCKBITS ( $HBITMAP , $TDATA )
	$TDATA = 0
	$TBIHDR = 0
	Return $HHBITMAPV5
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMFILE ( $SFILENAME )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateBitmapFromFile" , "wstr" , $SFILENAME , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMGRAPHICS ( $IWIDTH , $IHEIGHT , $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateBitmapFromGraphics" , "int" , $IWIDTH , "int" , $IHEIGHT , "handle" , $HGRAPHICS , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMHBITMAP ( $HBITMAP , $HPAL = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateBitmapFromHBITMAP" , "handle" , $HBITMAP , "handle" , $HPAL , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMMEMORY ( $DIMAGE , $BHBITMAP = False )
	If Not IsBinary ( $DIMAGE ) Then Return SetError ( 1 , 0 , 0 )
	Local Const $DMEMBITMAP = Binary ( $DIMAGE )
	Local Const $ILEN = BinaryLen ( $DMEMBITMAP )
	Local Const $GMEM_MOVEABLE = 2
	Local $ACALL = DllCall ( "kernel32.dll" , "handle" , "GlobalAlloc" , "uint" , $GMEM_MOVEABLE , "ulong_ptr" , $ILEN )
	If @error Then Return SetError ( 4 , 0 , 0 )
	Local Const $HDATA = $ACALL [ 0 ]
	$ACALL = DllCall ( "kernel32.dll" , "ptr" , "GlobalLock" , "handle" , $HDATA )
	If @error Then Return SetError ( 5 , 0 , 0 )
	Local $TMEM = DllStructCreate ( "byte[" & $ILEN & "]" , $ACALL [ 0 ] )
	DllStructSetData ( $TMEM , 1 , $DMEMBITMAP )
	DllCall ( "kernel32.dll" , "bool" , "GlobalUnlock" , "handle" , $HDATA )
	If @error Then Return SetError ( 6 , 0 , 0 )
	Local Const $HSTREAM = _WINAPI_CREATESTREAMONHGLOBAL ( $HDATA )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local Const $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSTREAM ( $HSTREAM )
	If @error Then Return SetError ( 3 , 0 , 0 )
	DllCall ( "oleaut32.dll" , "long" , "DispCallFunc" , "ptr" , $HSTREAM , "ulong_ptr" , 8 * ( 1 + @AutoItX64 ) , "uint" , 4 , "ushort" , 23 , "uint" , 0 , "ptr" , 0 , "ptr" , 0 , "str" , "" )
	If $BHBITMAP Then
		Local Const $HHBMP = _GDIPLUS_BITMAPCREATEDIBFROMBITMAP ( $HBITMAP )
		_GDIPLUS_BITMAPDISPOSE ( $HBITMAP )
		Return $HHBMP
	EndIf
	Return $HBITMAP
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMRESOURCE ( $HINST , $VRESOURCENAME )
	Local $STYPE = "int"
	If IsString ( $VRESOURCENAME ) Then $STYPE = "wstr"
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateBitmapFromResource" , "handle" , $HINST , $STYPE , $VRESOURCENAME , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMSCAN0 ( $IWIDTH , $IHEIGHT , $IPIXELFORMAT = $GDIP_PXF32ARGB , $ISTRIDE = 0 , $PSCAN0 = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "uint" , "GdipCreateBitmapFromScan0" , "int" , $IWIDTH , "int" , $IHEIGHT , "int" , $ISTRIDE , "int" , $IPIXELFORMAT , "struct*" , $PSCAN0 , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMSTREAM ( $PSTREAM )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateBitmapFromStream" , "ptr" , $PSTREAM , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $HBITMAP , $IARGB = 4278190080 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateHBITMAPFromBitmap" , "handle" , $HBITMAP , "handle*" , 0 , "dword" , $IARGB )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BITMAPDISPOSE ( $HBITMAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDisposeImage" , "handle" , $HBITMAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMHICON ( $HICON )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateBitmapFromHICON" , "handle" , $HICON , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEFROMHICON32 ( $HICON )
	Local $TSIZE = _WINAPI_GETICONDIMENSION ( $HICON )
	Local $IWIDTH = DllStructGetData ( $TSIZE , "X" )
	Local $IHEIGHT = DllStructGetData ( $TSIZE , "Y" )
	If $IWIDTH <= 0 Or $IHEIGHT <= 0 Then Return SetError ( 10 , + 4294967295 , 0 )
	Local $TBITMAPINFO = DllStructCreate ( "dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad" )
	DllStructSetData ( $TBITMAPINFO , "Size" , DllStructGetSize ( $TBITMAPINFO ) + 4294967292 )
	DllStructSetData ( $TBITMAPINFO , "Width" , $IWIDTH )
	DllStructSetData ( $TBITMAPINFO , "Height" , - $IHEIGHT )
	DllStructSetData ( $TBITMAPINFO , "Planes" , 1 )
	DllStructSetData ( $TBITMAPINFO , "BitCount" , 32 )
	DllStructSetData ( $TBITMAPINFO , "Compression" , 0 )
	DllStructSetData ( $TBITMAPINFO , "SizeImage" , 0 )
	Local $HDC = _WINAPI_CREATECOMPATIBLEDC ( 0 )
	Local $PBITS
	Local $HBMP = _WINAPI_CREATEDIBSECTION ( 0 , $TBITMAPINFO , 0 , $PBITS )
	Local $HORIG = _WINAPI_SELECTOBJECT ( $HDC , $HBMP )
	_WINAPI_DRAWICONEX ( $HDC , 0 , 0 , $HICON , $IWIDTH , $IHEIGHT )
	Local $HBITMAPICON = _GDIPLUS_BITMAPCREATEFROMSCAN0 ( $IWIDTH , $IHEIGHT , $GDIP_PXF32ARGB , $IWIDTH * 4 , $PBITS )
	Local $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0 ( $IWIDTH , $IHEIGHT )
	Local $HCONTEXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $HBITMAP )
	_GDIPLUS_GRAPHICSDRAWIMAGE ( $HCONTEXT , $HBITMAPICON , 0 , 0 )
	_GDIPLUS_GRAPHICSDISPOSE ( $HCONTEXT )
	_GDIPLUS_BITMAPDISPOSE ( $HBITMAPICON )
	_WINAPI_SELECTOBJECT ( $HDC , $HORIG )
	_WINAPI_DELETEDC ( $HDC )
	_WINAPI_DELETEOBJECT ( $HBMP )
	Return $HBITMAP
EndFunc
Func _GDIPLUS_BITMAPGETPIXEL ( $HBITMAP , $IX , $IY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapGetPixel" , "handle" , $HBITMAP , "int" , $IX , "int" , $IY , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_BITMAPLOCKBITS ( $HBITMAP , $ILEFT , $ITOP , $IWIDTH , $IHEIGHT , $IFLAGS = $GDIP_ILMREAD , $IFORMAT = $GDIP_PXF32RGB )
	Local $TDATA = DllStructCreate ( $TAGGDIPBITMAPDATA )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , "Left" , $ILEFT )
	DllStructSetData ( $TRECT , "Top" , $ITOP )
	DllStructSetData ( $TRECT , "Right" , $IWIDTH )
	DllStructSetData ( $TRECT , "Bottom" , $IHEIGHT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapLockBits" , "handle" , $HBITMAP , "struct*" , $TRECT , "uint" , $IFLAGS , "int" , $IFORMAT , "struct*" , $TDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TDATA
EndFunc
Func _GDIPLUS_BITMAPSETPIXEL ( $HBITMAP , $IX , $IY , $IARGB )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapSetPixel" , "handle" , $HBITMAP , "int" , $IX , "int" , $IY , "uint" , $IARGB )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPSETRESOLUTION ( $HBITMAP , $FDPIX , $FDPIY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapSetResolution" , "handle" , $HBITMAP , "float" , $FDPIX , "float" , $FDPIY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPUNLOCKBITS ( $HBITMAP , $TBITMAPDATA )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapUnlockBits" , "handle" , $HBITMAP , "struct*" , $TBITMAPDATA )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BRUSHCLONE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCloneBrush" , "handle" , $HBRUSH , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BRUSHCREATESOLID ( $IARGB = 4278190080 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateSolidFill" , "int" , $IARGB , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BRUSHDISPOSE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteBrush" , "handle" , $HBRUSH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BRUSHGETSOLIDCOLOR ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetSolidFillColor" , "handle" , $HBRUSH , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BRUSHGETTYPE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetBrushType" , "handle" , $HBRUSH , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_BRUSHSETSOLIDCOLOR ( $HBRUSH , $IARGB = 4278190080 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetSolidFillColor" , "handle" , $HBRUSH , "dword" , $IARGB )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_COLORMATRIXCREATE ( )
	Return _GDIPLUS_COLORMATRIXCREATESCALE ( 1 , 1 , 1 , 1 )
EndFunc
Func _GDIPLUS_COLORMATRIXCREATEGRAYSCALE ( )
	Local $II , $IJ , $TCM , $ALUMS [ 4 ] = [ $GDIP_RLUM , $GDIP_GLUM , $GDIP_BLUM , 0 ]
	$TCM = DllStructCreate ( $TAGGDIPCOLORMATRIX )
	For $II = 0 To 3
		For $IJ = 1 To 3
			DllStructSetData ( $TCM , "m" , $ALUMS [ $II ] , $II * 5 + $IJ )
		Next
	Next
	DllStructSetData ( $TCM , "m" , 1 , 19 )
	DllStructSetData ( $TCM , "m" , 1 , 25 )
	Return $TCM
EndFunc
Func _GDIPLUS_COLORMATRIXCREATENEGATIVE ( )
	Local $II , $TCM
	$TCM = _GDIPLUS_COLORMATRIXCREATESCALE ( + 4294967295 , + 4294967295 , + 4294967295 , 1 )
	For $II = 1 To 4
		DllStructSetData ( $TCM , "m" , 1 , 20 + $II )
	Next
	Return $TCM
EndFunc
Func _GDIPLUS_COLORMATRIXCREATESATURATION ( $FSAT )
	Local $FSATCOMP , $TCM
	$TCM = DllStructCreate ( $TAGGDIPCOLORMATRIX )
	$FSATCOMP = ( 1 - $FSAT )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_RLUM + $FSAT , 1 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_RLUM , 2 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_RLUM , 3 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_GLUM , 6 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_GLUM + $FSAT , 7 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_GLUM , 8 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_BLUM , 11 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_BLUM , 12 )
	DllStructSetData ( $TCM , "m" , $FSATCOMP * $GDIP_BLUM + $FSAT , 13 )
	DllStructSetData ( $TCM , "m" , 1 , 19 )
	DllStructSetData ( $TCM , "m" , 1 , 25 )
	Return $TCM
EndFunc
Func _GDIPLUS_COLORMATRIXCREATESCALE ( $FRED , $FGREEN , $FBLUE , $FALPHA = 1 )
	Local $TCM
	$TCM = DllStructCreate ( $TAGGDIPCOLORMATRIX )
	DllStructSetData ( $TCM , "m" , $FRED , 1 )
	DllStructSetData ( $TCM , "m" , $FGREEN , 7 )
	DllStructSetData ( $TCM , "m" , $FBLUE , 13 )
	DllStructSetData ( $TCM , "m" , $FALPHA , 19 )
	DllStructSetData ( $TCM , "m" , 1 , 25 )
	Return $TCM
EndFunc
Func _GDIPLUS_COLORMATRIXCREATETRANSLATE ( $FRED , $FGREEN , $FBLUE , $FALPHA = 0 )
	Local $II , $TCM , $AFACTORS [ 4 ] = [ $FRED , $FGREEN , $FBLUE , $FALPHA ]
	$TCM = _GDIPLUS_COLORMATRIXCREATE ( )
	For $II = 0 To 3
		DllStructSetData ( $TCM , "m" , $AFACTORS [ $II ] , 21 + $II )
	Next
	Return $TCM
EndFunc
Func _GDIPLUS_CUSTOMLINECAPCLONE ( $HCUSTOMLINECAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCloneCustomLineCap" , "handle" , $HCUSTOMLINECAP , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_CUSTOMLINECAPCREATE ( $HPATHFILL , $HPATHSTROKE , $ILINECAP = 0 , $NBASEINSET = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateCustomLineCap" , "handle" , $HPATHFILL , "handle" , $HPATHSTROKE , "int" , $ILINECAP , "float" , $NBASEINSET , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _GDIPLUS_CUSTOMLINECAPDISPOSE ( $HCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteCustomLineCap" , "handle" , $HCAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_CUSTOMLINECAPGETSTROKECAPS ( $HCUSTOMLINECAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetCustomLineCapStrokeCaps" , "hwnd" , $HCUSTOMLINECAP , "ptr*" , 0 , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $ACAPS [ 2 ]
	$ACAPS [ 0 ] = $ACALL [ 2 ]
	$ACAPS [ 1 ] = $ACALL [ 3 ]
	Return $ACAPS
EndFunc
Func _GDIPLUS_CUSTOMLINECAPSETSTROKECAPS ( $HCUSTOMLINECAP , $ISTARTCAP , $IENDCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetCustomLineCapStrokeCaps" , "handle" , $HCUSTOMLINECAP , "int" , $ISTARTCAP , "int" , $IENDCAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_DECODERS ( )
	Local $ICOUNT = _GDIPLUS_DECODERSGETCOUNT ( )
	Local $ISIZE = _GDIPLUS_DECODERSGETSIZE ( )
	Local $TBUFFER = DllStructCreate ( "byte[" & $ISIZE & "]" )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageDecoders" , "uint" , $ICOUNT , "uint" , $ISIZE , "struct*" , $TBUFFER )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $PBUFFER = DllStructGetPtr ( $TBUFFER )
	Local $TCODEC , $AINFO [ $ICOUNT + 1 ] [ 14 ]
	$AINFO [ 0 ] [ 0 ] = $ICOUNT
	For $II = 1 To $ICOUNT
		$TCODEC = DllStructCreate ( $TAGGDIPIMAGECODECINFO , $PBUFFER )
		$AINFO [ $II ] [ 1 ] = _WINAPI_STRINGFROMGUID ( DllStructGetPtr ( $TCODEC , "CLSID" ) )
		$AINFO [ $II ] [ 2 ] = _WINAPI_STRINGFROMGUID ( DllStructGetPtr ( $TCODEC , "FormatID" ) )
		$AINFO [ $II ] [ 3 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "CodecName" ) )
		$AINFO [ $II ] [ 4 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "DllName" ) )
		$AINFO [ $II ] [ 5 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "FormatDesc" ) )
		$AINFO [ $II ] [ 6 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "FileExt" ) )
		$AINFO [ $II ] [ 7 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "MimeType" ) )
		$AINFO [ $II ] [ 8 ] = DllStructGetData ( $TCODEC , "Flags" )
		$AINFO [ $II ] [ 9 ] = DllStructGetData ( $TCODEC , "Version" )
		$AINFO [ $II ] [ 10 ] = DllStructGetData ( $TCODEC , "SigCount" )
		$AINFO [ $II ] [ 11 ] = DllStructGetData ( $TCODEC , "SigSize" )
		$AINFO [ $II ] [ 12 ] = DllStructGetData ( $TCODEC , "SigPattern" )
		$AINFO [ $II ] [ 13 ] = DllStructGetData ( $TCODEC , "SigMask" )
		$PBUFFER += DllStructGetSize ( $TCODEC )
	Next
	Return $AINFO
EndFunc
Func _GDIPLUS_DECODERSGETCOUNT ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageDecodersSize" , "uint*" , 0 , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_DECODERSGETSIZE ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageDecodersSize" , "uint*" , 0 , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_DRAWIMAGEPOINTS ( $HGRAPHIC , $HIMAGE , $NULX , $NULY , $NURX , $NURY , $NLLX , $NLLY , $ICOUNT = 3 )
	Local $TPOINT = DllStructCreate ( "float X;float Y;float X2;float Y2;float X3;float Y3" )
	DllStructSetData ( $TPOINT , "X" , $NULX )
	DllStructSetData ( $TPOINT , "Y" , $NULY )
	DllStructSetData ( $TPOINT , "X2" , $NURX )
	DllStructSetData ( $TPOINT , "Y2" , $NURY )
	DllStructSetData ( $TPOINT , "X3" , $NLLX )
	DllStructSetData ( $TPOINT , "Y3" , $NLLY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawImagePoints" , "handle" , $HGRAPHIC , "handle" , $HIMAGE , "struct*" , $TPOINT , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_ENCODERS ( )
	Local $ICOUNT = _GDIPLUS_ENCODERSGETCOUNT ( )
	Local $ISIZE = _GDIPLUS_ENCODERSGETSIZE ( )
	Local $TBUFFER = DllStructCreate ( "byte[" & $ISIZE & "]" )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageEncoders" , "uint" , $ICOUNT , "uint" , $ISIZE , "struct*" , $TBUFFER )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $PBUFFER = DllStructGetPtr ( $TBUFFER )
	Local $TCODEC , $AINFO [ $ICOUNT + 1 ] [ 14 ]
	$AINFO [ 0 ] [ 0 ] = $ICOUNT
	For $II = 1 To $ICOUNT
		$TCODEC = DllStructCreate ( $TAGGDIPIMAGECODECINFO , $PBUFFER )
		$AINFO [ $II ] [ 1 ] = _WINAPI_STRINGFROMGUID ( DllStructGetPtr ( $TCODEC , "CLSID" ) )
		$AINFO [ $II ] [ 2 ] = _WINAPI_STRINGFROMGUID ( DllStructGetPtr ( $TCODEC , "FormatID" ) )
		$AINFO [ $II ] [ 3 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "CodecName" ) )
		$AINFO [ $II ] [ 4 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "DllName" ) )
		$AINFO [ $II ] [ 5 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "FormatDesc" ) )
		$AINFO [ $II ] [ 6 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "FileExt" ) )
		$AINFO [ $II ] [ 7 ] = _WINAPI_GETSTRING ( DllStructGetData ( $TCODEC , "MimeType" ) )
		$AINFO [ $II ] [ 8 ] = DllStructGetData ( $TCODEC , "Flags" )
		$AINFO [ $II ] [ 9 ] = DllStructGetData ( $TCODEC , "Version" )
		$AINFO [ $II ] [ 10 ] = DllStructGetData ( $TCODEC , "SigCount" )
		$AINFO [ $II ] [ 11 ] = DllStructGetData ( $TCODEC , "SigSize" )
		$AINFO [ $II ] [ 12 ] = DllStructGetData ( $TCODEC , "SigPattern" )
		$AINFO [ $II ] [ 13 ] = DllStructGetData ( $TCODEC , "SigMask" )
		$PBUFFER += DllStructGetSize ( $TCODEC )
	Next
	Return $AINFO
EndFunc
Func _GDIPLUS_ENCODERSGETCLSID ( $SFILEEXTENSION )
	Local $AENCODERS = _GDIPLUS_ENCODERS ( )
	If @error Then Return SetError ( @error , 0 , "" )
	For $II = 1 To $AENCODERS [ 0 ] [ 0 ]
		If StringInStr ( $AENCODERS [ $II ] [ 6 ] , "*." & $SFILEEXTENSION ) > 0 Then Return $AENCODERS [ $II ] [ 1 ]
	Next
	Return SetError ( + 4294967295 , + 4294967295 , "" )
EndFunc
Func _GDIPLUS_ENCODERSGETCOUNT ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageEncodersSize" , "uint*" , 0 , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_ENCODERSGETPARAMLIST ( $HIMAGE , $SENCODER )
	Local $ISIZE = _GDIPLUS_ENCODERSGETPARAMLISTSIZE ( $HIMAGE , $SENCODER )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SENCODER )
	Local $IREMAININGSIZE = $ISIZE + 4294967292 - _GDIPLUS_PARAMSIZE ( )
	Local $TBUFFER
	If $IREMAININGSIZE Then
		$TBUFFER = DllStructCreate ( "dword Count;" & $TAGGDIPENCODERPARAM & ";byte [" & $IREMAININGSIZE & "]" )
	Else
		$TBUFFER = DllStructCreate ( "dword Count;" & $TAGGDIPENCODERPARAM )
	EndIf
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetEncoderParameterList" , "handle" , $HIMAGE , "struct*" , $TGUID , "uint" , $ISIZE , "struct*" , $TBUFFER )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TBUFFER
EndFunc
Func _GDIPLUS_ENCODERSGETPARAMLISTSIZE ( $HIMAGE , $SENCODER )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SENCODER )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetEncoderParameterListSize" , "handle" , $HIMAGE , "struct*" , $TGUID , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_ENCODERSGETSIZE ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageEncodersSize" , "uint*" , 0 , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_FONTCREATE ( $HFAMILY , $FSIZE , $ISTYLE = 0 , $IUNIT = 3 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateFont" , "handle" , $HFAMILY , "float" , $FSIZE , "int" , $ISTYLE , "int" , $IUNIT , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _GDIPLUS_FONTDISPOSE ( $HFONT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteFont" , "handle" , $HFONT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_FONTFAMILYCREATE ( $SFAMILY , $PCOLLECTION = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateFontFamilyFromName" , "wstr" , $SFAMILY , "ptr" , $PCOLLECTION , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTFAMILYCREATEFROMCOLLECTION ( $SFONTNAME , $HFONTCOLLECTION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateFontFamilyFromName" , "wstr" , $SFONTNAME , "ptr" , $HFONTCOLLECTION , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , "" )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTFAMILYDISPOSE ( $HFAMILY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteFontFamily" , "handle" , $HFAMILY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_FONTFAMILYGETCELLASCENT ( $HFONTFAMILY , $ISTYLE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetCellAscent" , "handle" , $HFONTFAMILY , "int" , $ISTYLE , "ushort*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTFAMILYGETCELLDESCENT ( $HFONTFAMILY , $ISTYLE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetCellDescent" , "handle" , $HFONTFAMILY , "int" , $ISTYLE , "ushort*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTFAMILYGETEMHEIGHT ( $HFONTFAMILY , $ISTYLE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetEmHeight" , "handle" , $HFONTFAMILY , "int" , $ISTYLE , "ushort*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTFAMILYGETLINESPACING ( $HFONTFAMILY , $ISTYLE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetLineSpacing" , "handle" , $HFONTFAMILY , "int" , $ISTYLE , "ushort*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTGETHEIGHT ( $HFONT , $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetFontHeight" , "handle" , $HFONT , "handle" , $HGRAPHICS , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_FONTPRIVATEADDFONT ( $HFONTCOLLECTION , $SFONTFILE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipPrivateAddFontFile" , "ptr" , $HFONTCOLLECTION , "wstr" , $SFONTFILE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_FONTPRIVATEADDMEMORYFONT ( $HFONTCOLLECTION , $TFONT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipPrivateAddMemoryFont" , "handle" , $HFONTCOLLECTION , "struct*" , $TFONT , "int" , DllStructGetSize ( $TFONT ) )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_FONTPRIVATECOLLECTIONDISPOSE ( $HFONTCOLLECTION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeletePrivateFontCollection" , "handle*" , $HFONTCOLLECTION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_FONTPRIVATECREATECOLLECTION ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipNewPrivateFontCollection" , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_GRAPHICSCLEAR ( $HGRAPHICS , $IARGB = 4278190080 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGraphicsClear" , "handle" , $HGRAPHICS , "dword" , $IARGB )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSCREATEFROMHDC ( $HDC )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateFromHDC" , "handle" , $HDC , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSCREATEFROMHWND ( $HWND )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateFromHWND" , "hwnd" , $HWND , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSDISPOSE ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteGraphics" , "handle" , $HGRAPHICS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWARC ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $FSTARTANGLE , $FSWEEPANGLE , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawArc" , "handle" , $HGRAPHICS , "handle" , $HPEN , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "float" , $FSTARTANGLE , "float" , $FSWEEPANGLE )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWBEZIER ( $HGRAPHICS , $NX1 , $NY1 , $NX2 , $NY2 , $NX3 , $NY3 , $NX4 , $NY4 , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawBezier" , "handle" , $HGRAPHICS , "handle" , $HPEN , "float" , $NX1 , "float" , $NY1 , "float" , $NX2 , "float" , $NY2 , "float" , $NX3 , "float" , $NY3 , "float" , $NX4 , "float" , $NY4 )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWCLOSEDCURVE ( $HGRAPHICS , $APOINTS , $HPEN = 0 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawClosedCurve" , "handle" , $HGRAPHICS , "handle" , $HPEN , "struct*" , $TPOINTS , "int" , $ICOUNT )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWCLOSEDCURVE2 ( $HGRAPHICS , $APOINTS , $NTENSION , $HPEN = 0 )
	Local $II , $ICOUNT , $TPOINTS , $ACALL
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	$ICOUNT = $APOINTS [ 0 ] [ 0 ]
	$TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawClosedCurve2" , "handle" , $HGRAPHICS , "handle" , $HPEN , "struct*" , $TPOINTS , "int" , $ICOUNT , "float" , $NTENSION )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWCURVE ( $HGRAPHICS , $APOINTS , $HPEN = 0 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawCurve" , "handle" , $HGRAPHICS , "handle" , $HPEN , "struct*" , $TPOINTS , "int" , $ICOUNT )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWCURVE2 ( $HGRAPHICS , $APOINTS , $NTENSION , $HPEN = 0 )
	Local $II , $ICOUNT , $TPOINTS , $ACALL
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	$ICOUNT = $APOINTS [ 0 ] [ 0 ]
	$TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawCurve2" , "handle" , $HGRAPHICS , "handle" , $HPEN , "struct*" , $TPOINTS , "int" , $ICOUNT , "float" , $NTENSION )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWELLIPSE ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawEllipse" , "handle" , $HGRAPHICS , "handle" , $HPEN , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWIMAGE ( $HGRAPHICS , $HIMAGE , $NX , $NY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawImage" , "handle" , $HGRAPHICS , "handle" , $HIMAGE , "float" , $NX , "float" , $NY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWIMAGEPOINTSRECT ( $HGRAPHICS , $HIMAGE , $NULX , $NULY , $NURX , $NURY , $NLLX , $NLLY , $NSRCX , $NSRCY , $NSRCWIDTH , $NSRCHEIGHT , $HIMAGEATTRIBUTES = 0 , $IUNIT = 2 )
	Local $TPOINTS = DllStructCreate ( "float X; float Y; float X2; float Y2; float X3; float Y3;" )
	DllStructSetData ( $TPOINTS , "X" , $NULX )
	DllStructSetData ( $TPOINTS , "Y" , $NULY )
	DllStructSetData ( $TPOINTS , "X2" , $NURX )
	DllStructSetData ( $TPOINTS , "Y2" , $NURY )
	DllStructSetData ( $TPOINTS , "X3" , $NLLX )
	DllStructSetData ( $TPOINTS , "Y3" , $NLLY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawImagePointsRect" , "handle" , $HGRAPHICS , "handle" , $HIMAGE , "struct*" , $TPOINTS , "int" , 3 , "float" , $NSRCX , "float" , $NSRCY , "float" , $NSRCWIDTH , "float" , $NSRCHEIGHT , "int" , $IUNIT , "handle" , $HIMAGEATTRIBUTES , "ptr" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWIMAGERECT ( $HGRAPHICS , $HIMAGE , $NX , $NY , $NW , $NH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawImageRect" , "handle" , $HGRAPHICS , "handle" , $HIMAGE , "float" , $NX , "float" , $NY , "float" , $NW , "float" , $NH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWIMAGERECTRECT ( $HGRAPHICS , $HIMAGE , $NSRCX , $NSRCY , $NSRCWIDTH , $NSRCHEIGHT , $NDSTX , $NDSTY , $NDSTWIDTH , $NDSTHEIGHT , $PATTRIBUTES = 0 , $IUNIT = 2 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawImageRectRect" , "handle" , $HGRAPHICS , "handle" , $HIMAGE , "float" , $NDSTX , "float" , $NDSTY , "float" , $NDSTWIDTH , "float" , $NDSTHEIGHT , "float" , $NSRCX , "float" , $NSRCY , "float" , $NSRCWIDTH , "float" , $NSRCHEIGHT , "int" , $IUNIT , "handle" , $PATTRIBUTES , "ptr" , 0 , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWLINE ( $HGRAPHICS , $NX1 , $NY1 , $NX2 , $NY2 , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawLine" , "handle" , $HGRAPHICS , "handle" , $HPEN , "float" , $NX1 , "float" , $NY1 , "float" , $NX2 , "float" , $NY2 )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWPATH ( $HGRAPHICS , $HPATH , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawPath" , "handle" , $HGRAPHICS , "handle" , $HPEN , "handle" , $HPATH )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWPIE ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $FSTARTANGLE , $FSWEEPANGLE , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawPie" , "handle" , $HGRAPHICS , "handle" , $HPEN , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "float" , $FSTARTANGLE , "float" , $FSWEEPANGLE )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWPOLYGON ( $HGRAPHICS , $APOINTS , $HPEN = 0 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawPolygon" , "handle" , $HGRAPHICS , "handle" , $HPEN , "struct*" , $TPOINTS , "int" , $ICOUNT )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWRECT ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $HPEN = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawRectangle" , "handle" , $HGRAPHICS , "handle" , $HPEN , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSDRAWSTRING ( $HGRAPHICS , $SSTRING , $NX , $NY , $SFONT = Default , $FSIZE = Default , $IFORMAT = Default , $IARGB = Default )
	If $SFONT = Default Then $SFONT = "Arial"
	If $FSIZE = Default Then $FSIZE = 10
	If $IFORMAT = Default Then $IFORMAT = 0
	If $IARGB = Default Then $IARGB = 4278190080
	If BitAND ( $IARGB , 4278190080 ) = 0 Then $IARGB = BitOR ( $IARGB , 4278190080 )
	Local $HBRUSH = _GDIPLUS_BRUSHCREATESOLID ( $IARGB )
	Local $HFORMAT = _GDIPLUS_STRINGFORMATCREATE ( $IFORMAT )
	Local $HFAMILY = _GDIPLUS_FONTFAMILYCREATE ( $SFONT )
	Local $HFONT = _GDIPLUS_FONTCREATE ( $HFAMILY , $FSIZE )
	Local $TLAYOUT = _GDIPLUS_RECTFCREATE ( $NX , $NY , 0.0 , 0.0 )
	Local $AINFO = _GDIPLUS_GRAPHICSMEASURESTRING ( $HGRAPHICS , $SSTRING , $HFONT , $TLAYOUT , $HFORMAT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $ARESULT = _GDIPLUS_GRAPHICSDRAWSTRINGEX ( $HGRAPHICS , $SSTRING , $HFONT , $AINFO [ 0 ] , $HFORMAT , $HBRUSH )
	Local $IERROR = @error , $IEXTENDED = @extended
	_GDIPLUS_FONTDISPOSE ( $HFONT )
	_GDIPLUS_FONTFAMILYDISPOSE ( $HFAMILY )
	_GDIPLUS_STRINGFORMATDISPOSE ( $HFORMAT )
	_GDIPLUS_BRUSHDISPOSE ( $HBRUSH )
	Return SetError ( $IERROR , $IEXTENDED , $ARESULT )
EndFunc
Func _GDIPLUS_GRAPHICSDRAWSTRINGEX ( $HGRAPHICS , $SSTRING , $HFONT , $TLAYOUT , $HFORMAT , $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawString" , "handle" , $HGRAPHICS , "wstr" , $SSTRING , "int" , + 4294967295 , "handle" , $HFONT , "struct*" , $TLAYOUT , "handle" , $HFORMAT , "handle" , $HBRUSH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLCLOSEDCURVE ( $HGRAPHICS , $APOINTS , $HBRUSH = 0 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillClosedCurve" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "struct*" , $TPOINTS , "int" , $ICOUNT )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLCLOSEDCURVE2 ( $HGRAPHICS , $APOINTS , $NTENSION , $HBRUSH = 0 , $IFILLMODE = 0 )
	Local $II , $ICOUNT , $TPOINTS , $ACALL
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	$ICOUNT = $APOINTS [ 0 ] [ 0 ]
	$TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillClosedCurve2" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "struct*" , $TPOINTS , "int" , $ICOUNT , "float" , $NTENSION , "int" , $IFILLMODE )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLELLIPSE ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $HBRUSH = 0 )
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillEllipse" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLPATH ( $HGRAPHICS , $HPATH , $HBRUSH = 0 )
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillPath" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "handle" , $HPATH )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLPIE ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $FSTARTANGLE , $FSWEEPANGLE , $HBRUSH = 0 )
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillPie" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "float" , $FSTARTANGLE , "float" , $FSWEEPANGLE )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLPOLYGON ( $HGRAPHICS , $APOINTS , $HBRUSH = 0 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillPolygon" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "struct*" , $TPOINTS , "int" , $ICOUNT , "int" , "FillModeAlternate" )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLRECT ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $HBRUSH = 0 )
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillRectangle" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSFILLREGION ( $HGRAPHICS , $HREGION , $HBRUSH = 0 )
	__GDIPLUS_BRUSHDEFCREATE ( $HBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFillRegion" , "handle" , $HGRAPHICS , "handle" , $HBRUSH , "handle" , $HREGION )
	__GDIPLUS_BRUSHDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSGETCOMPOSITINGMODE ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetCompositingMode" , "handle" , $HGRAPHICS , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSGETCOMPOSITINGQUALITY ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetCompositingQuality" , "handle" , $HGRAPHICS , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSGETDC ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetDC" , "handle" , $HGRAPHICS , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSGETINTERPOLATIONMODE ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetInterpolationMode" , "handle" , $HGRAPHICS , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSGETSMOOTHINGMODE ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetSmoothingMode" , "handle" , $HGRAPHICS , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Switch $ACALL [ 2 ]
	Case $GDIP_SMOOTHINGMODE_NONE
		Return 0
	Case $GDIP_SMOOTHINGMODE_HIGHQUALITY , $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
		Return 1
	Case $GDIP_SMOOTHINGMODE_ANTIALIAS8X8
		Return 2
Case Else
		Return 0
	EndSwitch
EndFunc
Func _GDIPLUS_GRAPHICSGETTRANSFORM ( $HGRAPHICS , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetWorldTransform" , "handle" , $HGRAPHICS , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSMEASURECHARACTERRANGES ( $HGRAPHICS , $SSTRING , $HFONT , $TLAYOUT , $HSTRINGFORMAT )
	Local $ICOUNT = _GDIPLUS_STRINGFORMATGETMEASURABLECHARACTERRANGECOUNT ( $HSTRINGFORMAT )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $TREGIONS = DllStructCreate ( "handle[" & $ICOUNT & "]" )
	Local $AREGIONS [ $ICOUNT + 1 ] = [ $ICOUNT ]
	For $II = 1 To $ICOUNT
		$AREGIONS [ $II ] = _GDIPLUS_REGIONCREATE ( )
		DllStructSetData ( $TREGIONS , 1 , $AREGIONS [ $II ] , $II )
	Next
	DllCall ( $__G_HGDIPDLL , "int" , "GdipMeasureCharacterRanges" , "handle" , $HGRAPHICS , "wstr" , $SSTRING , "int" , + 4294967295 , "hwnd" , $HFONT , "struct*" , $TLAYOUT , "handle" , $HSTRINGFORMAT , "int" , $ICOUNT , "struct*" , $TREGIONS )
	Local $IERROR = @error , $IEXTENDED = @extended
	If $IERROR Then
		For $II = 1 To $ICOUNT
			_GDIPLUS_REGIONDISPOSE ( $AREGIONS [ $II ] )
		Next
		Return SetError ( $IERROR + 10 , $IEXTENDED , 0 )
	EndIf
	Return $AREGIONS
EndFunc
Func _GDIPLUS_GRAPHICSMEASURESTRING ( $HGRAPHICS , $SSTRING , $HFONT , $TLAYOUT , $HFORMAT )
	Local $TRECTF = DllStructCreate ( $TAGGDIPRECTF )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipMeasureString" , "handle" , $HGRAPHICS , "wstr" , $SSTRING , "int" , + 4294967295 , "handle" , $HFONT , "struct*" , $TLAYOUT , "handle" , $HFORMAT , "struct*" , $TRECTF , "int*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $AINFO [ 3 ]
	$AINFO [ 0 ] = $TRECTF
	$AINFO [ 1 ] = $ACALL [ 8 ]
	$AINFO [ 2 ] = $ACALL [ 9 ]
	Return $AINFO
EndFunc
Func _GDIPLUS_GRAPHICSRELEASEDC ( $HGRAPHICS , $HDC )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipReleaseDC" , "handle" , $HGRAPHICS , "handle" , $HDC )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSRESETCLIP ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipResetClip" , "handle" , $HGRAPHICS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSRESETTRANSFORM ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipResetWorldTransform" , "handle" , $HGRAPHICS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSRESTORE ( $HGRAPHICS , $ISTATE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipRestoreGraphics" , "handle" , $HGRAPHICS , "uint" , $ISTATE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSROTATETRANSFORM ( $HGRAPHICS , $FANGLE , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipRotateWorldTransform" , "handle" , $HGRAPHICS , "float" , $FANGLE , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSAVE ( $HGRAPHICS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSaveGraphics" , "handle" , $HGRAPHICS , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_GRAPHICSSCALETRANSFORM ( $HGRAPHICS , $FSCALEX , $FSCALEY , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipScaleWorldTransform" , "handle" , $HGRAPHICS , "float" , $FSCALEX , "float" , $FSCALEY , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETCLIPPATH ( $HGRAPHICS , $HPATH , $ICOMBINEMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetClipPath" , "handle" , $HGRAPHICS , "handle" , $HPATH , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETCLIPRECT ( $HGRAPHICS , $NX , $NY , $NWIDTH , $NHEIGHT , $ICOMBINEMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetClipRect" , "handle" , $HGRAPHICS , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETCLIPREGION ( $HGRAPHICS , $HREGION , $ICOMBINEMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetClipRegion" , "handle" , $HGRAPHICS , "handle" , $HREGION , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETCOMPOSITINGMODE ( $HGRAPHICS , $ICOMPOSITIONMODE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetCompositingMode" , "handle" , $HGRAPHICS , "int" , $ICOMPOSITIONMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETCOMPOSITINGQUALITY ( $HGRAPHICS , $ICOMPOSITIONQUALITY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetCompositingQuality" , "handle" , $HGRAPHICS , "int" , $ICOMPOSITIONQUALITY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETINTERPOLATIONMODE ( $HGRAPHICS , $IINTERPOLATIONMODE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetInterpolationMode" , "handle" , $HGRAPHICS , "int" , $IINTERPOLATIONMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETPIXELOFFSETMODE ( $HGRAPHICS , $IPIXELOFFSETMODE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPixelOffsetMode" , "handle" , $HGRAPHICS , "int" , $IPIXELOFFSETMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETSMOOTHINGMODE ( $HGRAPHICS , $ISMOOTH )
	If $ISMOOTH < $GDIP_SMOOTHINGMODE_DEFAULT Or $ISMOOTH > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $ISMOOTH = $GDIP_SMOOTHINGMODE_DEFAULT
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetSmoothingMode" , "handle" , $HGRAPHICS , "int" , $ISMOOTH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETTEXTRENDERINGHINT ( $HGRAPHICS , $ITEXTRENDERINGHINT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetTextRenderingHint" , "handle" , $HGRAPHICS , "int" , $ITEXTRENDERINGHINT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSSETTRANSFORM ( $HGRAPHICS , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetWorldTransform" , "handle" , $HGRAPHICS , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSTRANSFORMPOINTS ( $HGRAPHICS , ByRef $APOINTS , $ICOORDSPACETO = 0 , $ICOORDSPACEFROM = 1 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( $II + 4294967295 ) * 2 + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( $II + 4294967295 ) * 2 + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTransformPoints" , "handle" , $HGRAPHICS , "int" , $ICOORDSPACETO , "int" , $ICOORDSPACEFROM , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	For $II = 1 To $ICOUNT
		$APOINTS [ $II ] [ 0 ] = DllStructGetData ( $TPOINTS , 1 , ( $II + 4294967295 ) * 2 + 1 )
		$APOINTS [ $II ] [ 1 ] = DllStructGetData ( $TPOINTS , 1 , ( $II + 4294967295 ) * 2 + 2 )
	Next
	Return True
EndFunc
Func _GDIPLUS_GRAPHICSTRANSLATETRANSFORM ( $HGRAPHICS , $NDX , $NDY , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTranslateWorldTransform" , "handle" , $HGRAPHICS , "float" , $NDX , "float" , $NDY , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_HATCHBRUSHCREATE ( $IHATCHSTYLE = 0 , $IARGBFOREGROUND = 4294967295 , $IARGBBACKGROUND = 4294967295 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateHatchBrush" , "int" , $IHATCHSTYLE , "uint" , $IARGBFOREGROUND , "uint" , $IARGBBACKGROUND , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_HICONCREATEFROMBITMAP ( $HBITMAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateHICONFromBitmap" , "handle" , $HBITMAP , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEATTRIBUTESCREATE ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateImageAttributes" , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_IMAGEATTRIBUTESDISPOSE ( $HIMAGEATTRIBUTES )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDisposeImageAttributes" , "handle" , $HIMAGEATTRIBUTES )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGEATTRIBUTESSETCOLORKEYS ( $HIMAGEATTRIBUTES , $ICOLORADJUSTTYPE = 0 , $BENABLE = False , $IARGBLOW = 0 , $IARGBHIGH = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetImageAttributesColorKeys" , "handle" , $HIMAGEATTRIBUTES , "int" , $ICOLORADJUSTTYPE , "int" , $BENABLE , "uint" , $IARGBLOW , "uint" , $IARGBHIGH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGEATTRIBUTESSETCOLORMATRIX ( $HIMAGEATTRIBUTES , $ICOLORADJUSTTYPE = 0 , $BENABLE = False , $TCLRMATRIX = 0 , $TGRAYMATRIX = 0 , $ICOLORMATRIXFLAGS = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetImageAttributesColorMatrix" , "handle" , $HIMAGEATTRIBUTES , "int" , $ICOLORADJUSTTYPE , "int" , $BENABLE , "struct*" , $TCLRMATRIX , "struct*" , $TGRAYMATRIX , "int" , $ICOLORMATRIXFLAGS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGEATTRIBUTESSETREMAPTABLE ( $HIMAGEATTRIBUTES , $ACOLORMAP = 0 , $ICOLORADJUSTTYPE = 0 , $BENABLE = True )
	Local $ACALL
	If IsArray ( $ACOLORMAP ) Then
		Local $ICOUNT = $ACOLORMAP [ 0 ] [ 0 ]
		Local $TCOLORMAP = DllStructCreate ( "uint[" & $ICOUNT * 2 & "]" )
		For $I = 1 To $ICOUNT
			DllStructSetData ( $TCOLORMAP , 1 , $ACOLORMAP [ $I ] [ 0 ] , ( $I + 4294967295 ) * 2 + 1 )
			DllStructSetData ( $TCOLORMAP , 1 , $ACOLORMAP [ $I ] [ 1 ] , ( $I + 4294967295 ) * 2 + 2 )
		Next
		$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetImageAttributesRemapTable" , "handle" , $HIMAGEATTRIBUTES , "int" , $ICOLORADJUSTTYPE , "int" , $BENABLE , "int" , $ICOUNT , "struct*" , $TCOLORMAP )
	Else
		$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetImageAttributesRemapTable" , "handle" , $HIMAGEATTRIBUTES , "int" , $ICOLORADJUSTTYPE , "int" , $BENABLE , "int" , 0 , "struct*" , 0 )
	EndIf
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGEATTRIBUTESSETTHRESHOLD ( $HIMAGEATTRIBUTES , $FTHRESHOLD , $ICOLORADJUSTTYPE = $GDIP_COLORADJUSTTYPE_DEFAULT , $BENABLE = True )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetImageAttributesThreshold" , "handle" , $HIMAGEATTRIBUTES , "int" , $ICOLORADJUSTTYPE , "bool" , $BENABLE , "float" , $FTHRESHOLD )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGECLONE ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCloneImage" , "handle" , $HIMAGE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDisposeImage" , "handle" , $HIMAGE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGEGETDIMENSION ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageDimension" , "handle" , $HIMAGE , "float*" , 0 , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Local $AIMGDIM [ 2 ] = [ $ACALL [ 2 ] , $ACALL [ 3 ] ]
	Return $AIMGDIM
EndFunc
Func _GDIPLUS_IMAGEGETFLAGS ( $HIMAGE )
	Local $AFLAG [ 2 ] = [ 0 , "" ]
	If ( $HIMAGE = + 4294967295 ) Or ( Not $HIMAGE ) Then Return SetError ( 11 , 0 , $AFLAG )
	Local $AIMAGEFLAGS [ 13 ] [ 2 ] = [ [ "Pixel data Cacheable" , $GDIP_IMAGEFLAGS_CACHING ] , [ "Pixel data read-only" , $GDIP_IMAGEFLAGS_READONLY ] , [ "Pixel size in image" , $GDIP_IMAGEFLAGS_HASREALPIXELSIZE ] , [ "DPI info in image" , $GDIP_IMAGEFLAGS_HASREALDPI ] , [ "YCCK color space" , $GDIP_IMAGEFLAGS_COLORSPACE_YCCK ] , [ "YCBCR color space" , $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR ] , [ "Grayscale image" , $GDIP_IMAGEFLAGS_COLORSPACE_GRAY ] , [ "CMYK color space" , $GDIP_IMAGEFLAGS_COLORSPACE_CMYK ] , [ "RGB color space" , $GDIP_IMAGEFLAGS_COLORSPACE_RGB ] , [ "Partially scalable" , $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE ] , [ "Alpha values other than 0 (transparent) and 255 (opaque)" , $GDIP_IMAGEFLAGS_HASTRANSLUCENT ] , [ "Alpha values" , $GDIP_IMAGEFLAGS_HASALPHA ] , [ "Scalable" , $GDIP_IMAGEFLAGS_SCALABLE ] ]
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageFlags" , "handle" , $HIMAGE , "long*" , 0 )
	If @error Then Return SetError ( @error , @extended , $AFLAG )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , $AFLAG )
	If $ACALL [ 2 ] = $GDIP_IMAGEFLAGS_NONE Then
		$AFLAG [ 1 ] = "No pixel data"
		Return SetError ( 12 , $ACALL [ 2 ] , $AFLAG )
	EndIf
	$AFLAG [ 0 ] = $ACALL [ 2 ]
	For $I = 0 To 12
		If BitAND ( $ACALL [ 2 ] , $AIMAGEFLAGS [ $I ] [ 1 ] ) = $AIMAGEFLAGS [ $I ] [ 1 ] Then
			If StringLen ( $AFLAG [ 1 ] ) Then $AFLAG [ 1 ] &= "|"
			$ACALL [ 2 ] -= $AIMAGEFLAGS [ $I ] [ 1 ]
			$AFLAG [ 1 ] &= $AIMAGEFLAGS [ $I ] [ 0 ]
		EndIf
	Next
	Return $AFLAG
EndFunc
Func _GDIPLUS_IMAGEGETFRAMECOUNT ( $HIMAGE , $SDIMENSIONID )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SDIMENSIONID )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipImageGetFrameCount" , "handle" , $HIMAGE , "struct*" , $TGUID , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageGraphicsContext" , "handle" , $HIMAGE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageHeight" , "handle" , $HIMAGE , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEGETHORIZONTALRESOLUTION ( $HIMAGE )
	If ( $HIMAGE = + 4294967295 ) Or ( Not $HIMAGE ) Then Return SetError ( 11 , 0 , 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageHorizontalResolution" , "handle" , $HIMAGE , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return Round ( $ACALL [ 2 ] )
EndFunc
Func _GDIPLUS_IMAGEGETPIXELFORMAT ( $HIMAGE )
	Local $AFORMAT [ 2 ] = [ 0 , "" ]
	If ( $HIMAGE = + 4294967295 ) Or ( Not $HIMAGE ) Then Return SetError ( 11 , 0 , $AFORMAT )
	Local $APIXELFORMAT [ 14 ] [ 2 ] = [ [ "1 Bpp Indexed" , $GDIP_PXF01INDEXED ] , [ "4 Bpp Indexed" , $GDIP_PXF04INDEXED ] , [ "8 Bpp Indexed" , $GDIP_PXF08INDEXED ] , [ "16 Bpp Grayscale" , $GDIP_PXF16GRAYSCALE ] , [ "16 Bpp RGB 555" , $GDIP_PXF16RGB555 ] , [ "16 Bpp RGB 565" , $GDIP_PXF16RGB565 ] , [ "16 Bpp ARGB 1555" , $GDIP_PXF16ARGB1555 ] , [ "24 Bpp RGB" , $GDIP_PXF24RGB ] , [ "32 Bpp RGB" , $GDIP_PXF32RGB ] , [ "32 Bpp ARGB" , $GDIP_PXF32ARGB ] , [ "32 Bpp PARGB" , $GDIP_PXF32PARGB ] , [ "48 Bpp RGB" , $GDIP_PXF48RGB ] , [ "64 Bpp ARGB" , $GDIP_PXF64ARGB ] , [ "64 Bpp PARGB" , $GDIP_PXF64PARGB ] ]
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImagePixelFormat" , "handle" , $HIMAGE , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , $AFORMAT )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , $AFORMAT )
	For $I = 0 To 13
		If $APIXELFORMAT [ $I ] [ 1 ] = $ACALL [ 2 ] Then
			$AFORMAT [ 0 ] = $APIXELFORMAT [ $I ] [ 1 ]
			$AFORMAT [ 1 ] = $APIXELFORMAT [ $I ] [ 0 ]
			Return $AFORMAT
		EndIf
	Next
	Return SetError ( 12 , 0 , $AFORMAT )
EndFunc
Func __GDIPLUS_IMAGEGETPROPERTYCOUNT ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPropertyCount" , "handle" , $HIMAGE , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEGETPROPERTYIDLIST ( $HIMAGE )
	Local $ICOUNT = __GDIPLUS_IMAGEGETPROPERTYCOUNT ( $HIMAGE )
	If @error Then Return SetError ( @error , @extended , False )
	Local $TPROPERTIES = DllStructCreate ( "uint[" & $ICOUNT & "]" )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPropertyIdList" , "handle" , $HIMAGE , "int" , $ICOUNT , "struct*" , $TPROPERTIES )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Local $SPROPERTYTAGINFO = _
		"0x0000=GpsVer;0x0001=GpsLatitudeRef;0x0002=GpsLatitude;0x0003=GpsLongitudeRef;0x0004=GpsLongitude;0x0005=GpsAltitudeRef;0x0006=GpsAltitude;0x0007=GpsGpsTime;0x0008=GpsGpsSatellites;0x0009=GpsGpsStatus;0x000A=GpsGpsMeasureMode;0x000B=GpsGpsDop;0x000C=GpsSpeedRef;0x000D=GpsSpeed;0x000E=GpsTrackRef;0x000F=GpsTrack;0x0010=GpsImgDirRef;0x0011=GpsImgDir;0x0012=GpsMapDatum;0x0013=GpsDestLatRef;0x0014=GpsDestLat;0x0015=GpsDestLongRef;0x0016=GpsDestLong;0x0017=GpsDestBearRef;0x0018=GpsDestBear;0x0019=GpsDestDistRef;0x001A=GpsDestDist;0x00FE=NewSubfileType;0x00FF=SubfileType;0x0100=ImageWidth;0x0101=ImageHeight;0x0102=BitsPerSample;0x0103=Compression;0x0106=PhotometricInterp;0x0107=ThreshHolding;0x0108=CellWidth;0x0109=CellHeight;0x010A=FillOrder;0x010D=DocumentName;0x010E=ImageDescription;0x010F=EquipMake;0x0110=EquipModel;0x0111=StripOffsets;0x0112=Orientation;0x0115=SamplesPerPixel;0x0116=RowsPerStrip;0x0117=StripBytesCount;0x0118=MinSampleValue;0x0119=MaxSampleValue;0x011A=XResolution;0x011B=YResolution;0x011C=PlanarConfig;0x011D=PageName;0x011E=XPosition;0x011F=YPosition;0x0120=FreeOffset;0x0121=FreeByteCounts;0x0122=GrayResponseUnit;0x0123=GrayResponseCurve;0x0124=T4Option;0x0125=T6Option;0x0128=ResolutionUnit;0x0129=PageNumber;0x012D=TransferFunction;0x0131=SoftwareUsed;0x0132=DateTime;0x013B=Artist;0x013C=HostComputer;0x013D=Predictor;0x013E=WhitePoint;0x013F=PrimaryChromaticities;0x0140=ColorMap;0x0141=HalftoneHints;0x0142=TileWidth;0x0143=TileLength;0x0144=TileOffset;0x0145=TileByteCounts;0x014C=InkSet;0x014D=InkNames;0x014E=NumberOfInks;0x0150=DotRange;0x0151=TargetPrinter;0x0152=ExtraSamples;0x0153=SampleFormat;0x0154=SMinSampleValue;0x0155=SMaxSampleValue;0x0156=TransferRange;0x0200=JPEGProc;0x0201=JPEGInterFormat;0x0202=JPEGInterLength;0x0203=JPEGRestartInterval;0x0205=JPEGLosslessPredictors;0x0206=JPEGPointTransforms;0x0207=JPEGQTables;0x0208=JPEGDCTables;0x0209=JPEGACTables;0x0211=YCbCrCoefficients;0x0212=YCbCrSubsampling;0x0213=YCbCrPositioning;0x0214=REFBlackWhite;0x0301=Gamma;0x0302=ICCProfileDescriptor;0x0303=SRGBRenderingIntent;0x0320=ImageTitle;0x5001=ResolutionXUnit;0x5002=ResolutionYUnit;0x5003=ResolutionXLengthUnit;0x5004=ResolutionYLengthUnit;0x5005=PrintFlags;0x5006=PrintFlagsVersion;0x5007=PrintFlagsCrop;0x5008=PrintFlagsBleedWidth;0x5009=PrintFlagsBleedWidthScale;0x500A=HalftoneLPI;0x500B=HalftoneLPIUnit;0x500C=HalftoneDegree;" & _
		"0x500D=HalftoneShape;0x500E=HalftoneMisc;0x500F=HalftoneScreen;0x5010=JPEGQuality;0x5011=GridSize;0x5012=ThumbnailFormat;0x5013=ThumbnailWidth;0x5014=ThumbnailHeight;0x5015=ThumbnailColorDepth;0x5016=ThumbnailPlanes;0x5017=ThumbnailRawBytes;0x5018=ThumbnailSize;0x5019=ThumbnailCompressedSize;0x501A=ColorTransferFunction;0x501B=ThumbnailData;0x5020=ThumbnailImageWidth;0x5021=ThumbnailImageHeight;0x5022=ThumbnailBitsPerSample;0x5023=ThumbnailCompression;0x5024=ThumbnailPhotometricInterp;0x5025=ThumbnailImageDescription;0x5026=ThumbnailEquipMake;0x5027=ThumbnailEquipModel;0x5028=ThumbnailStripOffsets;0x5029=ThumbnailOrientation;0x502A=ThumbnailSamplesPerPixel;0x502B=ThumbnailRowsPerStrip;0x502C=ThumbnailStripBytesCount;0x502D=ThumbnailResolutionX;0x502E=ThumbnailResolutionY;0x502F=ThumbnailPlanarConfig;0x5030=ThumbnailResolutionUnit;0x5031=ThumbnailTransferFunction;0x5032=ThumbnailSoftwareUsed;0x5033=ThumbnailDateTime;0x5034=ThumbnailArtist;0x5035=ThumbnailWhitePoint;0x5036=ThumbnailPrimaryChromaticities;0x5037=ThumbnailYCbCrCoefficients;0x5038=ThumbnailYCbCrSubsampling;0x5039=ThumbnailYCbCrPositioning;0x503A=ThumbnailRefBlackWhite;0x503B=ThumbnailCopyRight;0x5090=LuminanceTable;0x5091=ChrominanceTable;0x5100=FrameDelay;0x5101=LoopCount;0x5102=GlobalPalette;0x5103=IndexBackground;0x5104=IndexTransparent;0x5110=PixelUnit;0x5111=PixelPerUnitX;0x5112=PixelPerUnitY;0x5113=PaletteHistogram;0x8298=Copyright;0x829A=ExifExposureTime;0x829D=ExifFNumber;0x8769=ExifIFD;0x8773=ICCProfile;0x8822=ExifExposureProg;0x8824=ExifSpectralSense;0x8825=GpsIFD;0x8827=ExifISOSpeed;0x8828=ExifOECF;0x9000=ExifVer;0x9003=ExifDTOrig;0x9004=ExifDTDigitized;0x9101=ExifCompConfig;0x9102=ExifCompBPP;0x9201=ExifShutterSpeed;0x9202=ExifAperture;0x9203=ExifBrightness;0x9204=ExifExposureBias;0x9205=ExifMaxAperture;0x9206=ExifSubjectDist;0x9207=ExifMeteringMode;0x9208=ExifLightSource;0x9209=ExifFlash;0x920A=ExifFocalLength;0x927C=ExifMakerNote;0x9286=ExifUserComment;0x9290=ExifDTSubsec;0x9291=ExifDTOrigSS;0x9292=ExifDTDigSS;0xA000=ExifFPXVer;0xA001=ExifColorSpace;0xA002=ExifPixXDim;0xA003=ExifPixYDim;0xA004=ExifRelatedWav;0xA005=ExifInterop;0xA20B=ExifFlashEnergy;0xA20C=ExifSpatialFR;0xA20E=ExifFocalXRes;0xA20F=ExifFocalYRes;0xA210=ExifFocalResUnit;0xA214=ExifSubjectLoc;0xA215=ExifExposureIndex;0xA217=ExifSensingMethod;0xA300=ExifFileSource;0xA301=ExifSceneType;0xA302=ExifCfaPattern"
	Local $APROPERTIES [ $ICOUNT + 1 ] [ 2 ] = [ [ $ICOUNT ] ]
	Local $AREGEXP
	For $I = 1 To $ICOUNT
		$APROPERTIES [ $I ] [ 0 ] = DllStructGetData ( $TPROPERTIES , 1 , $I )
		$AREGEXP = StringRegExp ( $SPROPERTYTAGINFO , "(?i)" & Hex ( DllStructGetData ( $TPROPERTIES , 1 , $I ) , 4 ) & "=(\w+)" , $STR_REGEXPARRAYGLOBALMATCH )
		Switch IsArray ( $AREGEXP )
		Case True
			$APROPERTIES [ $I ] [ 1 ] = $AREGEXP [ 0 ]
	Case Else
			$APROPERTIES [ $I ] [ 1 ] = "PropertyTagUnKnown"
		EndSwitch
	Next
	Return $APROPERTIES
EndFunc
Func __GDIPLUS_IMAGEGETPROPERTYITEMSIZE ( $HIMAGE , $IPROPID )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPropertyItemSize" , "handle" , $HIMAGE , "uint" , $IPROPID , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_IMAGEGETPROPERTYITEM ( $HIMAGE , $IPROPID )
	Local $ISIZE = __GDIPLUS_IMAGEGETPROPERTYITEMSIZE ( $HIMAGE , $IPROPID )
	If @error Then Return SetError ( @error , @extended , False )
	Local $TBUFFER = DllStructCreate ( "byte[" & $ISIZE & "];" )
	Local $PBUFFER = DllStructGetPtr ( $TBUFFER )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPropertyItem" , "handle" , $HIMAGE , "uint" , $IPROPID , "uint" , $ISIZE , "struct*" , $TBUFFER )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Local $TPROPERTYITEM = DllStructCreate ( "int id; int length; short type; ptr value;" , $PBUFFER )
	Local $IBYTES = DllStructGetData ( $TPROPERTYITEM , "length" )
	Local $PVALUE = DllStructGetData ( $TPROPERTYITEM , "value" )
	Local $TVALUES , $IVALUES
	Switch DllStructGetData ( $TPROPERTYITEM , "type" )
	Case 2
		$IVALUES = 1
		$TVALUES = DllStructCreate ( "char[" & $IBYTES & "];" , $PVALUE )
	Case 3
		$IVALUES = Int ( $IBYTES / 2 )
		$TVALUES = DllStructCreate ( "ushort[" & $IVALUES & "];" , $PVALUE )
	Case 4 , 5
		$IVALUES = Int ( $IBYTES / 4 )
		$TVALUES = DllStructCreate ( "uint[" & $IVALUES & "];" , $PVALUE )
	Case 9 , 10
		$IVALUES = Int ( $IBYTES / 4 )
		$TVALUES = DllStructCreate ( "int[" & $IVALUES & "];" , $PVALUE )
Case Else
		$IVALUES = 1
		$TVALUES = DllStructCreate ( "byte[" & $IBYTES & "];" , $PVALUE )
	EndSwitch
	Local $AVALUES [ $IVALUES + 1 ] = [ $IVALUES ]
	Switch DllStructGetData ( $TPROPERTYITEM , "type" )
	Case 5 , 10
		$IVALUES = Int ( $IVALUES / 2 )
		ReDim $AVALUES [ $IVALUES + 1 ]
		$AVALUES [ 0 ] = $IVALUES
		For $J = 1 To $IVALUES
			$AVALUES [ $J ] = DllStructGetData ( $TVALUES , 1 , ( $J + 4294967295 ) * 2 + 1 ) / DllStructGetData ( $TVALUES , 1 , ( $J + 4294967295 ) * 2 + 2 )
		Next
	Case 3 , 4 , 9
		For $J = 1 To $IVALUES
			$AVALUES [ $J ] = DllStructGetData ( $TVALUES , 1 , $J )
		Next
Case Else
		$AVALUES [ 1 ] = DllStructGetData ( $TVALUES , 1 )
	EndSwitch
	Return $AVALUES
EndFunc
Func _GDIPLUS_IMAGEGETRAWFORMAT ( $HIMAGE )
	Local $AGUID [ 2 ]
	If ( $HIMAGE = + 4294967295 ) Or ( Not $HIMAGE ) Then Return SetError ( 11 , 0 , $AGUID )
	Local $AIMAGETYPE [ 11 ] [ 2 ] = [ [ "UNDEFINED" , $GDIP_IMAGEFORMAT_UNDEFINED ] , [ "MEMORYBMP" , $GDIP_IMAGEFORMAT_MEMORYBMP ] , [ "BMP" , $GDIP_IMAGEFORMAT_BMP ] , [ "EMF" , $GDIP_IMAGEFORMAT_EMF ] , [ "WMF" , $GDIP_IMAGEFORMAT_WMF ] , [ "JPEG" , $GDIP_IMAGEFORMAT_JPEG ] , [ "PNG" , $GDIP_IMAGEFORMAT_PNG ] , [ "GIF" , $GDIP_IMAGEFORMAT_GIF ] , [ "TIFF" , $GDIP_IMAGEFORMAT_TIFF ] , [ "EXIF" , $GDIP_IMAGEFORMAT_EXIF ] , [ "ICON" , $GDIP_IMAGEFORMAT_ICON ] ]
	Local $TSTRUCT = DllStructCreate ( "byte[16]" )
	Local $ACALL1 = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageRawFormat" , "handle" , $HIMAGE , "struct*" , $TSTRUCT )
	If @error Then Return SetError ( @error , @extended , $AGUID )
	If $ACALL1 [ 0 ] Then Return SetError ( 10 , $ACALL1 [ 0 ] , $AGUID )
	Local $SRESULT2 = _WINAPI_STRINGFROMGUID ( $ACALL1 [ 2 ] )
	If @error Then Return SetError ( @error + 20 , @extended , $AGUID )
	If $SRESULT2 = "" Then Return SetError ( 12 , 0 , $AGUID )
	For $I = 0 To 10
		If $AIMAGETYPE [ $I ] [ 1 ] == $SRESULT2 Then
			$AGUID [ 0 ] = $AIMAGETYPE [ $I ] [ 1 ]
			$AGUID [ 1 ] = $AIMAGETYPE [ $I ] [ 0 ]
			Return $AGUID
		EndIf
	Next
	Return SetError ( 13 , 0 , $AGUID )
EndFunc
Func _GDIPLUS_IMAGEGETTHUMBNAIL ( $HIMAGE , $IWIDTH = 0 , $IHEIGHT = 0 , $BKEEPRATIO = True , $HCALLBACK = Null , $HCALLBACKDATA = Null )
	If $BKEEPRATIO Then
		Local $AIMGDIM = _GDIPLUS_IMAGEGETDIMENSION ( $HIMAGE )
		If @error Then Return SetError ( @error + 20 , @extended , False )
		Local $F
		If $IWIDTH < 1 Or $IHEIGHT < 1 Then
			$IWIDTH = 0
			$IHEIGHT = 0
		Else
			If ( $AIMGDIM [ 0 ] / $AIMGDIM [ 1 ] ) > 1 Then
				$F = $AIMGDIM [ 0 ] / $IWIDTH
			Else
				$F = $AIMGDIM [ 1 ] / $IHEIGHT
			EndIf
			$IWIDTH = Int ( $AIMGDIM [ 0 ] / $F )
			$IHEIGHT = Int ( $AIMGDIM [ 1 ] / $F )
		EndIf
	EndIf
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageThumbnail" , "handle" , $HIMAGE , "uint" , $IWIDTH , "uint" , $IHEIGHT , "ptr*" , 0 , "ptr" , $HCALLBACK , "ptr" , $HCALLBACKDATA )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_IMAGEGETTYPE ( $HIMAGE )
	If ( $HIMAGE = + 4294967295 ) Or ( Not $HIMAGE ) Then Return SetError ( 11 , 0 , + 4294967295 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageType" , "handle" , $HIMAGE , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEGETVERTICALRESOLUTION ( $HIMAGE )
	If ( $HIMAGE = + 4294967295 ) Or ( Not $HIMAGE ) Then Return SetError ( 11 , 0 , 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageVerticalResolution" , "handle" , $HIMAGE , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return Round ( $ACALL [ 2 ] )
EndFunc
Func _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetImageWidth" , "handle" , $HIMAGE , "uint*" , + 4294967295 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGELOADFROMFILE ( $SFILENAME )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipLoadImageFromFile" , "wstr" , $SFILENAME , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGELOADFROMSTREAM ( $PSTREAM )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipLoadImageFromStream" , "ptr" , $PSTREAM , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_IMAGEROTATEFLIP ( $HIMAGE , $IROTATEFLIPTYPE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipImageRotateFlip" , "handle" , $HIMAGE , "int" , $IROTATEFLIPTYPE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGESAVEADD ( $HIMAGE , $TPARAMS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSaveAdd" , "handle" , $HIMAGE , "struct*" , $TPARAMS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGESAVEADDIMAGE ( $HIMAGE , $HIMAGENEW , $TPARAMS )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSaveAddImage" , "handle" , $HIMAGE , "handle" , $HIMAGENEW , "struct*" , $TPARAMS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGESAVETOFILE ( $HIMAGE , $SFILENAME )
	Local $SEXT = __GDIPLUS_EXTRACTFILEEXT ( $SFILENAME )
	Local $SCLSID = _GDIPLUS_ENCODERSGETCLSID ( $SEXT )
	If $SCLSID = "" Then Return SetError ( + 4294967295 , 0 , False )
	Local $BRET = _GDIPLUS_IMAGESAVETOFILEEX ( $HIMAGE , $SFILENAME , $SCLSID , 0 )
	Return SetError ( @error , @extended , $BRET )
EndFunc
Func _GDIPLUS_IMAGESAVETOFILEEX ( $HIMAGE , $SFILENAME , $SENCODER , $TPARAMS = 0 )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SENCODER )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSaveImageToFile" , "handle" , $HIMAGE , "wstr" , $SFILENAME , "struct*" , $TGUID , "struct*" , $TPARAMS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGESAVETOSTREAM ( $HIMAGE , $PSTREAM , $TENCODER , $TPARAMS = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSaveImageToStream" , "handle" , $HIMAGE , "ptr" , $PSTREAM , "struct*" , $TENCODER , "struct*" , $TPARAMS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGESCALE ( $HIMAGE , $ISCALEW , $ISCALEH , $IINTERPOLATIONMODE = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC )
	Local $IWIDTH = _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Local $IHEIGHT = _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local $INEWWIDTH = $IWIDTH * $ISCALEW
	Local $INEWHEIGHT = $IHEIGHT * $ISCALEH
	Local $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0 ( $INEWWIDTH , $INEWHEIGHT )
	If @error Then Return SetError ( 3 , 0 , 0 )
	Local $HBMPCTXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $HBITMAP )
	_GDIPLUS_GRAPHICSSETINTERPOLATIONMODE ( $HBMPCTXT , $IINTERPOLATIONMODE )
	_GDIPLUS_GRAPHICSSETPIXELOFFSETMODE ( $HBMPCTXT , $GDIP_PIXELOFFSETMODE_HIGHQUALITY )
	Local $HIA = _GDIPLUS_IMAGEATTRIBUTESCREATE ( )
	__GDIPLUS_IMAGEATTRIBUTESSETIMAGEWRAPMODE ( $HIA )
	If @error Then
		_GDIPLUS_IMAGEATTRIBUTESDISPOSE ( $HIA )
		_GDIPLUS_GRAPHICSDISPOSE ( $HBMPCTXT )
		_GDIPLUS_BITMAPDISPOSE ( $HBITMAP )
		Return SetError ( 4 , 0 , 0 )
	EndIf
	_GDIPLUS_GRAPHICSDRAWIMAGERECTRECT ( $HBMPCTXT , $HIMAGE , 0 , 0 , $IWIDTH , $IHEIGHT , 0 , 0 , $INEWWIDTH , $INEWHEIGHT , $HIA )
	_GDIPLUS_IMAGEATTRIBUTESDISPOSE ( $HIA )
	_GDIPLUS_GRAPHICSDISPOSE ( $HBMPCTXT )
	Return $HBITMAP
EndFunc
Func __GDIPLUS_IMAGEATTRIBUTESSETIMAGEWRAPMODE ( $HIMAGEATTRIBUTES , $IWRAPMODE = $GDIP_WRAPMODETILEFLIPXY , $ICOLOR = 4278190080 )
	Local $ARESULT = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetImageAttributesWrapMode" , "handle" , $HIMAGEATTRIBUTES , "long" , $IWRAPMODE , "uint" , $ICOLOR , "bool" , False )
	If @error Then Return SetError ( @error , @extended , False )
	If $ARESULT [ 0 ] Then Return SetError ( 10 , $ARESULT [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGESELECTACTIVEFRAME ( $HIMAGE , $SDIMENSIONID , $IFRAMEINDEX )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SDIMENSIONID )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipImageSelectActiveFrame" , "handle" , $HIMAGE , "struct*" , $TGUID , "uint" , $IFRAMEINDEX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_IMAGERESIZE ( $HIMAGE , $INEWWIDTH , $INEWHEIGHT , $IINTERPOLATIONMODE = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC )
	Local $IWIDTH = _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Local $IHEIGHT = _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE )
	If @error Then Return SetError ( 2 , 0 , 0 )
	Local $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0 ( $INEWWIDTH , $INEWHEIGHT )
	If @error Then Return SetError ( 3 , 0 , 0 )
	Local $HBMPCTXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $HBITMAP )
	_GDIPLUS_GRAPHICSSETINTERPOLATIONMODE ( $HBMPCTXT , $IINTERPOLATIONMODE )
	_GDIPLUS_GRAPHICSSETPIXELOFFSETMODE ( $HBMPCTXT , $GDIP_PIXELOFFSETMODE_HIGHQUALITY )
	Local $HIA = _GDIPLUS_IMAGEATTRIBUTESCREATE ( )
	__GDIPLUS_IMAGEATTRIBUTESSETIMAGEWRAPMODE ( $HIA )
	If @error Then
		_GDIPLUS_IMAGEATTRIBUTESDISPOSE ( $HIA )
		_GDIPLUS_GRAPHICSDISPOSE ( $HBMPCTXT )
		_GDIPLUS_BITMAPDISPOSE ( $HBITMAP )
		Return SetError ( 4 , 0 , 0 )
	EndIf
	_GDIPLUS_GRAPHICSDRAWIMAGERECTRECT ( $HBMPCTXT , $HIMAGE , 0 , 0 , $IWIDTH , $IHEIGHT , 0 , 0 , $INEWWIDTH , $INEWHEIGHT , $HIA )
	_GDIPLUS_GRAPHICSDISPOSE ( $HBMPCTXT )
	Return $HBITMAP
EndFunc
Func _GDIPLUS_LINEBRUSHCREATE ( $NX1 , $NY1 , $NX2 , $NY2 , $IARGBCLR1 , $IARGBCLR2 , $IWRAPMODE = 0 )
	Local $TPOINTF1 , $TPOINTF2 , $ACALL
	$TPOINTF1 = DllStructCreate ( "float;float" )
	$TPOINTF2 = DllStructCreate ( "float;float" )
	DllStructSetData ( $TPOINTF1 , 1 , $NX1 )
	DllStructSetData ( $TPOINTF1 , 2 , $NY1 )
	DllStructSetData ( $TPOINTF2 , 1 , $NX2 )
	DllStructSetData ( $TPOINTF2 , 2 , $NY2 )
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateLineBrush" , "struct*" , $TPOINTF1 , "struct*" , $TPOINTF2 , "uint" , $IARGBCLR1 , "uint" , $IARGBCLR2 , "int" , $IWRAPMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _GDIPLUS_LINEBRUSHCREATEFROMRECT ( $TRECTF , $IARGBCLR1 , $IARGBCLR2 , $IGRADIENTMODE = 0 , $IWRAPMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateLineBrushFromRect" , "struct*" , $TRECTF , "uint" , $IARGBCLR1 , "uint" , $IARGBCLR2 , "int" , $IGRADIENTMODE , "int" , $IWRAPMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _GDIPLUS_LINEBRUSHCREATEFROMRECTWITHANGLE ( $TRECTF , $IARGBCLR1 , $IARGBCLR2 , $FANGLE , $BISANGLESCALABLE = True , $IWRAPMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateLineBrushFromRectWithAngle" , "struct*" , $TRECTF , "uint" , $IARGBCLR1 , "uint" , $IARGBCLR2 , "float" , $FANGLE , "int" , $BISANGLESCALABLE , "int" , $IWRAPMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 7 ]
EndFunc
Func _GDIPLUS_LINEBRUSHGETCOLORS ( $HLINEGRADIENTBRUSH )
	Local $TARGBS , $AARGBS [ 2 ] , $ACALL
	$TARGBS = DllStructCreate ( "uint;uint" )
	$ACALL = DllCall ( $__G_HGDIPDLL , "uint" , "GdipGetLineColors" , "handle" , $HLINEGRADIENTBRUSH , "struct*" , $TARGBS )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	$AARGBS [ 0 ] = DllStructGetData ( $TARGBS , 1 )
	$AARGBS [ 1 ] = DllStructGetData ( $TARGBS , 2 )
	Return $AARGBS
EndFunc
Func _GDIPLUS_LINEBRUSHGETRECT ( $HLINEGRADIENTBRUSH )
	Local $TRECTF = DllStructCreate ( $TAGGDIPRECTF )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetLineRect" , "handle" , $HLINEGRADIENTBRUSH , "struct*" , $TRECTF )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $ARECTF [ 4 ]
	For $II = 1 To 4
		$ARECTF [ $II + 4294967295 ] = DllStructGetData ( $TRECTF , $II )
	Next
	Return $ARECTF
EndFunc
Func _GDIPLUS_LINEBRUSHMULTIPLYTRANSFORM ( $HLINEGRADIENTBRUSH , $HMATRIX , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipMultiplyLineTransform" , "handle" , $HLINEGRADIENTBRUSH , "handle" , $HMATRIX , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHRESETTRANSFORM ( $HLINEGRADIENTBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipResetLineTransform" , "handle" , $HLINEGRADIENTBRUSH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETBLEND ( $HLINEGRADIENTBRUSH , $ABLENDS )
	Local $II , $ICOUNT , $TFACTORS , $TPOSITIONS , $ACALL
	$ICOUNT = $ABLENDS [ 0 ] [ 0 ]
	$TFACTORS = DllStructCreate ( "float[" & $ICOUNT & "]" )
	$TPOSITIONS = DllStructCreate ( "float[" & $ICOUNT & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TFACTORS , 1 , $ABLENDS [ $II ] [ 0 ] , $II )
		DllStructSetData ( $TPOSITIONS , 1 , $ABLENDS [ $II ] [ 1 ] , $II )
	Next
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLineBlend" , "handle" , $HLINEGRADIENTBRUSH , "struct*" , $TFACTORS , "struct*" , $TPOSITIONS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETCOLORS ( $HLINEGRADIENTBRUSH , $IARGBSTART , $IARGBEND )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLineColors" , "handle" , $HLINEGRADIENTBRUSH , "uint" , $IARGBSTART , "uint" , $IARGBEND )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETGAMMACORRECTION ( $HLINEGRADIENTBRUSH , $BUSEGAMMACORRECTION = True )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLineGammaCorrection" , "handle" , $HLINEGRADIENTBRUSH , "int" , $BUSEGAMMACORRECTION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETLINEARBLEND ( $HLINEGRADIENTBRUSH , $FFOCUS , $FSCALE = 1 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLineLinearBlend" , "handle" , $HLINEGRADIENTBRUSH , "float" , $FFOCUS , "float" , $FSCALE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETPRESETBLEND ( $HLINEGRADIENTBRUSH , $AINTERPOLATIONS )
	Local $II , $ICOUNT , $TCOLORS , $TPOSITIONS , $ACALL
	$ICOUNT = $AINTERPOLATIONS [ 0 ] [ 0 ]
	$TCOLORS = DllStructCreate ( "uint[" & $ICOUNT & "]" )
	$TPOSITIONS = DllStructCreate ( "float[" & $ICOUNT & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TCOLORS , 1 , $AINTERPOLATIONS [ $II ] [ 0 ] , $II )
		DllStructSetData ( $TPOSITIONS , 1 , $AINTERPOLATIONS [ $II ] [ 1 ] , $II )
	Next
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLinePresetBlend" , "handle" , $HLINEGRADIENTBRUSH , "struct*" , $TCOLORS , "struct*" , $TPOSITIONS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETSIGMABLEND ( $HLINEGRADIENTBRUSH , $FFOCUS , $FSCALE = 1 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLineSigmaBlend" , "handle" , $HLINEGRADIENTBRUSH , "float" , $FFOCUS , "float" , $FSCALE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_LINEBRUSHSETTRANSFORM ( $HLINEGRADIENTBRUSH , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetLineTransform" , "handle" , $HLINEGRADIENTBRUSH , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXCREATE ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateMatrix" , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_MATRIXCREATE2 ( $NM11 = 1 , $NM12 = 1 , $NM21 = 1 , $NM22 = 1 , $NDX = 0 , $NDY = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateMatrix2" , "float" , $NM11 , "float" , $NM12 , "float" , $NM21 , "float" , $NM22 , "float" , $NDX , "float" , $NDY , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 7 ]
EndFunc
Func _GDIPLUS_MATRIXCLONE ( $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCloneMatrix" , "handle" , $HMATRIX , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_MATRIXDISPOSE ( $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteMatrix" , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXGETELEMENTS ( $HMATRIX )
	Local $TELEMENTS = DllStructCreate ( "float[6]" )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetMatrixElements" , "handle" , $HMATRIX , "struct*" , $TELEMENTS )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $AELEMENTS [ 6 ]
	For $II = 1 To 6
		$AELEMENTS [ $II + 4294967295 ] = DllStructGetData ( $TELEMENTS , 1 , $II )
	Next
	Return $AELEMENTS
EndFunc
Func _GDIPLUS_MATRIXINVERT ( $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipInvertMatrix" , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXMULTIPLY ( $HMATRIX1 , $HMATRIX2 , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipMultiplyMatrix" , "handle" , $HMATRIX1 , "handle" , $HMATRIX2 , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXROTATE ( $HMATRIX , $FANGLE , $BAPPEND = False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipRotateMatrix" , "handle" , $HMATRIX , "float" , $FANGLE , "int" , $BAPPEND )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXSCALE ( $HMATRIX , $FSCALEX , $FSCALEY , $BORDER = False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipScaleMatrix" , "handle" , $HMATRIX , "float" , $FSCALEX , "float" , $FSCALEY , "int" , $BORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXSETELEMENTS ( $HMATRIX , $NM11 = 1 , $NM12 = 0 , $NM21 = 0 , $NM22 = 1 , $NDX = 0 , $NDY = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetMatrixElements" , "handle" , $HMATRIX , "float" , $NM11 , "float" , $NM12 , "float" , $NM21 , "float" , $NM22 , "float" , $NDX , "float" , $NDY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXSHEAR ( $HMATRIX , $FSHEARX , $FSHEARY , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipShearMatrix" , "handle" , $HMATRIX , "float" , $FSHEARX , "float" , $FSHEARY , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_MATRIXTRANSFORMPOINTS ( $HMATRIX , ByRef $APOINTS )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( $II + 4294967295 ) * 2 + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( $II + 4294967295 ) * 2 + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTransformMatrixPoints" , "handle" , $HMATRIX , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	For $II = 1 To $ICOUNT
		$APOINTS [ $II ] [ 0 ] = DllStructGetData ( $TPOINTS , 1 , ( $II + 4294967295 ) * 2 + 1 )
		$APOINTS [ $II ] [ 1 ] = DllStructGetData ( $TPOINTS , 1 , ( $II + 4294967295 ) * 2 + 2 )
	Next
	Return True
EndFunc
Func _GDIPLUS_MATRIXTRANSLATE ( $HMATRIX , $FOFFSETX , $FOFFSETY , $BAPPEND = False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTranslateMatrix" , "handle" , $HMATRIX , "float" , $FOFFSETX , "float" , $FOFFSETY , "int" , $BAPPEND )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PARAMADD ( ByRef $TPARAMS , $SGUID , $INBOFVALUES , $ITYPE , $PVALUES )
	Local $ICOUNT = DllStructGetData ( $TPARAMS , "Count" )
	Local $PGUID = DllStructGetPtr ( $TPARAMS , "GUID" ) + ( $ICOUNT * _GDIPLUS_PARAMSIZE ( ) )
	Local $TPARAM = DllStructCreate ( $TAGGDIPENCODERPARAM , $PGUID )
	_WINAPI_GUIDFROMSTRINGEX ( $SGUID , $PGUID )
	DllStructSetData ( $TPARAM , "Type" , $ITYPE )
	DllStructSetData ( $TPARAM , "NumberOfValues" , $INBOFVALUES )
	DllStructSetData ( $TPARAM , "Values" , $PVALUES )
	DllStructSetData ( $TPARAMS , "Count" , $ICOUNT + 1 )
EndFunc
Func _GDIPLUS_PARAMINIT ( $ICOUNT )
	Local $SSTRUCT = $TAGGDIPENCODERPARAMS
	For $I = 2 To $ICOUNT
		$SSTRUCT &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
	Next
	Return DllStructCreate ( $SSTRUCT )
EndFunc
Func _GDIPLUS_PARAMSIZE ( )
	Local $TPARAM = DllStructCreate ( $TAGGDIPENCODERPARAM )
	Return DllStructGetSize ( $TPARAM )
EndFunc
Func _GDIPLUS_PATHADDARC ( $HPATH , $NX , $NY , $NWIDTH , $NHEIGHT , $FSTARTANGLE , $FSWEEPANGLE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathArc" , "handle" , $HPATH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "float" , $FSTARTANGLE , "float" , $FSWEEPANGLE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDBEZIER ( $HPATH , $NX1 , $NY1 , $NX2 , $NY2 , $NX3 , $NY3 , $NX4 , $NY4 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathBezier" , "handle" , $HPATH , "float" , $NX1 , "float" , $NY1 , "float" , $NX2 , "float" , $NY2 , "float" , $NX3 , "float" , $NY3 , "float" , $NX4 , "float" , $NY4 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDCLOSEDCURVE ( $HPATH , $APOINTS )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathClosedCurve" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDCLOSEDCURVE2 ( $HPATH , $APOINTS , $NTENSION = 0.5 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathClosedCurve2" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT , "float" , $NTENSION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDCURVE ( $HPATH , $APOINTS )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathCurve" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDCURVE2 ( $HPATH , $APOINTS , $NTENSION = 0.5 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathCurve2" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT , "float" , $NTENSION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDCURVE3 ( $HPATH , $APOINTS , $IOFFSET , $INUMOFSEGMENTS , $NTENSION = 0.5 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathCurve3" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT , "int" , $IOFFSET , "int" , $INUMOFSEGMENTS , "float" , $NTENSION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDELLIPSE ( $HPATH , $NX , $NY , $NWIDTH , $NHEIGHT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathEllipse" , "handle" , $HPATH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDLINE ( $HPATH , $NX1 , $NY1 , $NX2 , $NY2 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathLine" , "handle" , $HPATH , "float" , $NX1 , "float" , $NY1 , "float" , $NX2 , "float" , $NY2 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDLINE2 ( $HPATH , $APOINTS )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathLine2" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDPATH ( $HPATH1 , $HPATH2 , $BCONNECT = True )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathPath" , "handle" , $HPATH1 , "handle" , $HPATH2 , "int" , $BCONNECT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDPIE ( $HPATH , $NX , $NY , $NWIDTH , $NHEIGHT , $FSTARTANGLE , $FSWEEPANGLE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathPie" , "handle" , $HPATH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "float" , $FSTARTANGLE , "float" , $FSWEEPANGLE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDPOLYGON ( $HPATH , $APOINTS )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathPolygon" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDRECTANGLE ( $HPATH , $NX , $NY , $NWIDTH , $NHEIGHT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathRectangle" , "handle" , $HPATH , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHADDSTRING ( $HPATH , $SSTRING , $TLAYOUT , $HFAMILY , $ISTYLE = 0 , $FSIZE = 8.5 , $HFORMAT = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipAddPathString" , "handle" , $HPATH , "wstr" , $SSTRING , "int" , + 4294967295 , "handle" , $HFAMILY , "int" , $ISTYLE , "float" , $FSIZE , "struct*" , $TLAYOUT , "handle" , $HFORMAT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHCREATE ( $APOINTS , $IWRAPMODE = 0 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePathGradient" , "struct*" , $TPOINTS , "int" , $ICOUNT , "int" , $IWRAPMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_PATHBRUSHCREATEFROMPATH ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePathGradientFromPath" , "handle" , $HPATH , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHBRUSHGETCENTERPOINT ( $HPATHGRADIENTBRUSH )
	Local $TPOINTF = DllStructCreate ( "float;float" )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathGradientCenterPoint" , "handle" , $HPATHGRADIENTBRUSH , "struct*" , $TPOINTF )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $APOINTF [ 2 ]
	$APOINTF [ 0 ] = DllStructGetData ( $TPOINTF , 1 )
	$APOINTF [ 1 ] = DllStructGetData ( $TPOINTF , 2 )
	Return $APOINTF
EndFunc
Func _GDIPLUS_PATHBRUSHGETFOCUSSCALES ( $HPATHGRADIENTBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathGradientFocusScales" , "handle" , $HPATHGRADIENTBRUSH , "float*" , 0 , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $ASCALES [ 2 ]
	$ASCALES [ 0 ] = $ACALL [ 2 ]
	$ASCALES [ 1 ] = $ACALL [ 3 ]
	Return $ASCALES
EndFunc
Func _GDIPLUS_PATHBRUSHGETPOINTCOUNT ( $HPATHGRADIENTBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathGradientPointCount" , "handle" , $HPATHGRADIENTBRUSH , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHBRUSHGETRECT ( $HPATHGRADIENTBRUSH )
	Local $TRECTF = DllStructCreate ( $TAGGDIPRECTF )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathGradientRect" , "handle" , $HPATHGRADIENTBRUSH , "struct*" , $TRECTF )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $ARECTF [ 4 ]
	For $II = 1 To 4
		$ARECTF [ $II + 4294967295 ] = DllStructGetData ( $TRECTF , $II )
	Next
	Return $ARECTF
EndFunc
Func _GDIPLUS_PATHBRUSHGETWRAPMODE ( $HPATHGRADIENTBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathGradientWrapMode" , "handle" , $HPATHGRADIENTBRUSH , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHBRUSHMULTIPLYTRANSFORM ( $HPATHGRADIENTBRUSH , $HMATRIX , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipMultiplyPathGradientTransform" , "handle" , $HPATHGRADIENTBRUSH , "handle" , $HMATRIX , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHRESETTRANSFORM ( $HPATHGRADIENTBRUSH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipResetPathGradientTransform" , "handle" , $HPATHGRADIENTBRUSH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETBLEND ( $HPATHGRADIENTBRUSH , $ABLENDS )
	Local $ICOUNT = $ABLENDS [ 0 ] [ 0 ]
	Local $TFACTORS = DllStructCreate ( "float[" & $ICOUNT & "]" )
	Local $TPOSITIONS = DllStructCreate ( "float[" & $ICOUNT & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TFACTORS , 1 , $ABLENDS [ $II ] [ 0 ] , $II )
		DllStructSetData ( $TPOSITIONS , 1 , $ABLENDS [ $II ] [ 1 ] , $II )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientBlend" , "handle" , $HPATHGRADIENTBRUSH , "struct*" , $TFACTORS , "struct*" , $TPOSITIONS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETCENTERCOLOR ( $HPATHGRADIENTBRUSH , $IARGB )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientCenterColor" , "handle" , $HPATHGRADIENTBRUSH , "uint" , $IARGB )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETCENTERPOINT ( $HPATHGRADIENTBRUSH , $NX , $NY )
	Local $TPOINTF = DllStructCreate ( "float;float" )
	DllStructSetData ( $TPOINTF , 1 , $NX )
	DllStructSetData ( $TPOINTF , 2 , $NY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientCenterPoint" , "handle" , $HPATHGRADIENTBRUSH , "struct*" , $TPOINTF )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETFOCUSSCALES ( $HPATHGRADIENTBRUSH , $FSCALEX , $FSCALEY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientFocusScales" , "handle" , $HPATHGRADIENTBRUSH , "float" , $FSCALEX , "float" , $FSCALEY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETGAMMACORRECTION ( $HPATHGRADIENTBRUSH , $BUSEGAMMACORRECTION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientGammaCorrection" , "handle" , $HPATHGRADIENTBRUSH , "int" , $BUSEGAMMACORRECTION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETLINEARBLEND ( $HPATHGRADIENTBRUSH , $FFOCUS , $FSCALE = 1 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientLinearBlend" , "handle" , $HPATHGRADIENTBRUSH , "float" , $FFOCUS , "float" , $FSCALE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETPRESETBLEND ( $HPATHGRADIENTBRUSH , $AINTERPOLATIONS )
	Local $ICOUNT = $AINTERPOLATIONS [ 0 ] [ 0 ]
	Local $TCOLORS = DllStructCreate ( "uint[" & $ICOUNT & "]" )
	Local $TPOSITIONS = DllStructCreate ( "float[" & $ICOUNT & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TCOLORS , 1 , $AINTERPOLATIONS [ $II ] [ 0 ] , $II )
		DllStructSetData ( $TPOSITIONS , 1 , $AINTERPOLATIONS [ $II ] [ 1 ] , $II )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientPresetBlend" , "handle" , $HPATHGRADIENTBRUSH , "struct*" , $TCOLORS , "struct*" , $TPOSITIONS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETSIGMABLEND ( $HPATHGRADIENTBRUSH , $FFOCUS , $FSCALE = 1 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientSigmaBlend" , "handle" , $HPATHGRADIENTBRUSH , "float" , $FFOCUS , "float" , $FSCALE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETSURROUNDCOLOR ( $HPATHGRADIENTBRUSH , $IARGB )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientSurroundColorsWithCount" , "handle" , $HPATHGRADIENTBRUSH , "uint*" , $IARGB , "int*" , 1 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETSURROUNDCOLORSWITHCOUNT ( $HPATHGRADIENTBRUSH , $ACOLORS )
	Local $ICOUNT = $ACOLORS [ 0 ]
	Local $ICOLORS = _GDIPLUS_PATHBRUSHGETPOINTCOUNT ( $HPATHGRADIENTBRUSH )
	If $ICOLORS < $ICOUNT Then $ICOUNT = $ICOLORS
	Local $TCOLORS = DllStructCreate ( "uint[" & $ICOUNT & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TCOLORS , 1 , $ACOLORS [ $II ] , $II )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientSurroundColorsWithCount" , "handle" , $HPATHGRADIENTBRUSH , "struct*" , $TCOLORS , "int*" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_PATHBRUSHSETTRANSFORM ( $HPATHGRADIENTBRUSH , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientTransform" , "handle" , $HPATHGRADIENTBRUSH , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHBRUSHSETWRAPMODE ( $HPATHGRADIENTBRUSH , $IWRAPMODE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathGradientWrapMode" , "handle" , $HPATHGRADIENTBRUSH , "int" , $IWRAPMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHCLONE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipClonePath" , "handle" , $HPATH , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHCLOSEFIGURE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipClosePathFigure" , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHCREATE ( $IFILLMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePath" , "int" , $IFILLMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHCREATE2 ( $APATHDATA , $IFILLMODE = 0 )
	Local $ICOUNT = $APATHDATA [ 0 ] [ 0 ]
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	Local $TTYPES = DllStructCreate ( "byte[" & $ICOUNT & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APATHDATA [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APATHDATA [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
		DllStructSetData ( $TTYPES , 1 , $APATHDATA [ $II ] [ 2 ] , $II )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePath2" , "struct*" , $TPOINTS , "struct*" , $TTYPES , "int" , $ICOUNT , "int" , $IFILLMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 5 ]
EndFunc
Func _GDIPLUS_PATHDISPOSE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeletePath" , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHFLATTEN ( $HPATH , $FFLATNESS = 0.25 , $HMATRIX = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipFlattenPath" , "handle" , $HPATH , "handle" , $HMATRIX , "float" , $FFLATNESS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHGETDATA ( $HPATH )
	Local $ICOUNT = _GDIPLUS_PATHGETPOINTCOUNT ( $HPATH )
	Local $TPATHDATA = DllStructCreate ( "int Count; ptr Points; ptr Types;" )
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	Local $TTYPES = DllStructCreate ( "byte[" & $ICOUNT & "]" )
	DllStructSetData ( $TPATHDATA , "Count" , $ICOUNT )
	DllStructSetData ( $TPATHDATA , "Points" , DllStructGetPtr ( $TPOINTS ) )
	DllStructSetData ( $TPATHDATA , "Types" , DllStructGetPtr ( $TTYPES ) )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathData" , "handle" , $HPATH , "struct*" , $TPATHDATA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( $ACALL [ 0 ] , $ACALL [ 0 ] , + 4294967295 )
	Local $ADATA [ $ICOUNT + 1 ] [ 3 ]
	$ADATA [ 0 ] [ 0 ] = $ICOUNT
	For $II = 1 To $ICOUNT
		$ADATA [ $II ] [ 0 ] = DllStructGetData ( $TPOINTS , 1 , ( ( $II + 4294967295 ) * 2 ) + 1 )
		$ADATA [ $II ] [ 1 ] = DllStructGetData ( $TPOINTS , 1 , ( ( $II + 4294967295 ) * 2 ) + 2 )
		$ADATA [ $II ] [ 2 ] = DllStructGetData ( $TTYPES , 1 , $II )
	Next
	Return $ADATA
EndFunc
Func _GDIPLUS_PATHGETFILLMODE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathFillMode" , "handle" , $HPATH , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHGETLASTPOINT ( $HPATH )
	Local $TPOINTF = DllStructCreate ( "float;float" )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathLastPoint" , "handle" , $HPATH , "struct*" , $TPOINTF )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $APOINTF [ 2 ]
	$APOINTF [ 0 ] = DllStructGetData ( $TPOINTF , 1 )
	$APOINTF [ 1 ] = DllStructGetData ( $TPOINTF , 2 )
	Return $APOINTF
EndFunc
Func _GDIPLUS_PATHGETPOINTCOUNT ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPointCount" , "handle" , $HPATH , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHGETPOINTS ( $HPATH )
	Local $II , $ICOUNT , $TPOINTS , $APOINTS [ 1 ] [ 1 ] , $ACALL
	$ICOUNT = _GDIPLUS_PATHGETPOINTCOUNT ( $HPATH )
	If @error Then Return SetError ( @error + 10 , @extended , + 4294967295 )
	$TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathPoints" , "handle" , $HPATH , "struct*" , $TPOINTS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $APOINTS [ $ICOUNT + 1 ] [ 2 ]
	$APOINTS [ 0 ] [ 0 ] = $ICOUNT
	For $II = 1 To $ICOUNT
		$APOINTS [ $II ] [ 0 ] = DllStructGetData ( $TPOINTS , 1 , ( ( $II + 4294967295 ) * 2 ) + 1 )
		$APOINTS [ $II ] [ 1 ] = DllStructGetData ( $TPOINTS , 1 , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Return $APOINTS
EndFunc
Func _GDIPLUS_PATHGETWORLDBOUNDS ( $HPATH , $HMATRIX = 0 , $HPEN = 0 )
	Local $TRECTF = DllStructCreate ( $TAGGDIPRECTF )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPathWorldBounds" , "handle" , $HPATH , "struct*" , $TRECTF , "handle" , $HMATRIX , "handle" , $HPEN )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $ARECTF [ 4 ]
	For $II = 1 To 4
		$ARECTF [ $II + 4294967295 ] = DllStructGetData ( $TRECTF , $II )
	Next
	Return $ARECTF
EndFunc
Func _GDIPLUS_PATHISOUTLINEVISIBLEPOINT ( $HPATH , $NX , $NY , $HPEN = 0 , $HGRAPHICS = 0 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipIsOutlineVisiblePathPoint" , "handle" , $HPATH , "float" , $NX , "float" , $NY , "handle" , $HPEN , "handle" , $HGRAPHICS , "int*" , 0 )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return $ACALL [ 6 ] <> 0
EndFunc
Func _GDIPLUS_PATHISVISIBLEPOINT ( $HPATH , $NX , $NY , $HGRAPHICS = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipIsVisiblePathPoint" , "handle" , $HPATH , "float" , $NX , "float" , $NY , "handle" , $HGRAPHICS , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return $ACALL [ 5 ] <> 0
EndFunc
Func _GDIPLUS_PATHITERCREATE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePathIter" , "handle*" , 0 , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_PATHITERDISPOSE ( $HPATHITER )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeletePathIter" , "handle" , $HPATHITER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHITERGETSUBPATHCOUNT ( $HPATHITER )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipPathIterGetSubpathCount" , "handle" , $HPATHITER , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHITERNEXTMARKERPATH ( $HPATHITER , $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipPathIterNextMarkerPath" , "handle" , $HPATHITER , "int*" , 0 , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PATHITERNEXTSUBPATHPATH ( $HPATHITER , $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipPathIterNextSubpathPath" , "handle" , $HPATHITER , "int*" , 0 , "handle" , $HPATH , "bool*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $ARET [ 2 ]
	$ARET [ 0 ] = $ACALL [ 2 ]
	$ARET [ 1 ] = $ACALL [ 4 ]
	Return $ARET
EndFunc
Func _GDIPLUS_PATHITERREWIND ( $HPATHITER )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipPathIterRewind" , "handle" , $HPATHITER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHRESET ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipResetPath" , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHREVERSE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipReversePath" , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHSETFILLMODE ( $HPATH , $IFILLMODE )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathFillMode" , "handle" , $HPATH , "int" , $IFILLMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHSETMARKER ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPathMarker" , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHSTARTFIGURE ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipStartPathFigure" , "handle" , $HPATH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHTRANSFORM ( $HPATH , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTransformPath" , "handle" , $HPATH , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHWARP ( $HPATH , $HMATRIX , $APOINTS , $NX , $NY , $NWIDTH , $NHEIGHT , $IWARPMODE = 0 , $FFLATNESS = 0.25 )
	Local $ICOUNT = $APOINTS [ 0 ] [ 0 ]
	If $ICOUNT <> 3 And $ICOUNT <> 4 Then Return SetError ( 11 , 0 , False )
	Local $TPOINTS = DllStructCreate ( "float[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 0 ] , ( $II + 4294967295 ) * 2 + 1 )
		DllStructSetData ( $TPOINTS , 1 , $APOINTS [ $II ] [ 1 ] , ( $II + 4294967295 ) * 2 + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipWarpPath" , "handle" , $HPATH , "handle" , $HMATRIX , "struct*" , $TPOINTS , "int" , $ICOUNT , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "int" , $IWARPMODE , "float" , $FFLATNESS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHWIDEN ( $HPATH , $HPEN , $HMATRIX = 0 , $FFLATNESS = 0.25 )
	__GDIPLUS_PENDEFCREATE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipWidenPath" , "handle" , $HPATH , "handle" , $HPEN , "handle" , $HMATRIX , "float" , $FFLATNESS )
	__GDIPLUS_PENDEFDISPOSE ( )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PATHWINDINGMODEOUTLINE ( $HPATH , $HMATRIX = 0 , $FFLATNESS = 0.25 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipWindingModeOutline" , "handle" , $HPATH , "handle" , $HMATRIX , "float" , $FFLATNESS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENCREATE ( $IARGB = 4278190080 , $NWIDTH = 1 , $IUNIT = 2 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePen1" , "dword" , $IARGB , "float" , $NWIDTH , "int" , $IUNIT , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_PENCREATE2 ( $HBRUSH , $NWIDTH = 1 , $IUNIT = 2 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreatePen2" , "handle" , $HBRUSH , "float" , $NWIDTH , "int" , $IUNIT , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func _GDIPLUS_PENDISPOSE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeletePen" , "handle" , $HPEN )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENGETALIGNMENT ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenMode" , "handle" , $HPEN , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETCOLOR ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenColor" , "handle" , $HPEN , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETCUSTOMENDCAP ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenCustomEndCap" , "handle" , $HPEN , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETDASHCAP ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenDashCap197819" , "handle" , $HPEN , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETDASHSTYLE ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenDashStyle" , "handle" , $HPEN , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETENDCAP ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenEndCap" , "handle" , $HPEN , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETMITERLIMIT ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenMiterLimit" , "handle" , $HPEN , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENGETWIDTH ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetPenWidth" , "handle" , $HPEN , "float*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_PENRESETTRANSFORM ( $HPEN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipResetPenTransform" , "handle" , $HPEN )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENROTATETRANSFORM ( $HPEN , $FANGLE , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipRotatePenTransform" , "handle" , $HPEN , "float" , $FANGLE , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSCALETRANSFORM ( $HPEN , $FSCALEX , $FSCALEY , $IORDER = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipScalePenTransform" , "handle" , $HPEN , "float" , $FSCALEX , "float" , $FSCALEY , "int" , $IORDER )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETALIGNMENT ( $HPEN , $IALIGNMENT = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenMode" , "handle" , $HPEN , "int" , $IALIGNMENT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETCOLOR ( $HPEN , $IARGB )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenColor" , "handle" , $HPEN , "dword" , $IARGB )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETCOMPOUND ( $HPEN , $ACOMPOUNDS )
	Local $ICOUNT = $ACOMPOUNDS [ 0 ]
	Local $TCOMPOUNDS = DllStructCreate ( "float[" & $ICOUNT & "];" )
	For $I = 1 To $ICOUNT
		DllStructSetData ( $TCOMPOUNDS , 1 , $ACOMPOUNDS [ $I ] , $I )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenCompoundArray" , "handle" , $HPEN , "struct*" , $TCOMPOUNDS , "int" , $ICOUNT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETCUSTOMENDCAP ( $HPEN , $HENDCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenCustomEndCap" , "handle" , $HPEN , "handle" , $HENDCAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETDASHCAP ( $HPEN , $IDASH = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenDashCap197819" , "handle" , $HPEN , "int" , $IDASH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETDASHSTYLE ( $HPEN , $ISTYLE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenDashStyle" , "handle" , $HPEN , "int" , $ISTYLE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETENDCAP ( $HPEN , $IENDCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenEndCap" , "handle" , $HPEN , "int" , $IENDCAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETLINECAP ( $HPEN , $ISTARTCAP , $IENDCAP , $IDASHCAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenLineCap197819" , "handle" , $HPEN , "int" , $ISTARTCAP , "int" , $IENDCAP , "int" , $IDASHCAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETLINEJOIN ( $HPEN , $ILINEJOIN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenLineJoin" , "handle" , $HPEN , "int" , $ILINEJOIN )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETMITERLIMIT ( $HPEN , $FMITERLIMIT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenMiterLimit" , "handle" , $HPEN , "float" , $FMITERLIMIT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETSTARTCAP ( $HPEN , $ILINECAP )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenStartCap" , "handle" , $HPEN , "int" , $ILINECAP )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETTRANSFORM ( $HPEN , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenTransform" , "handle" , $HPEN , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PENSETWIDTH ( $HPEN , $FWIDTH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetPenWidth" , "handle" , $HPEN , "float" , $FWIDTH )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_RECTFCREATE ( $NX = 0 , $NY = 0 , $NWIDTH = 0 , $NHEIGHT = 0 )
	Local $TRECTF = DllStructCreate ( $TAGGDIPRECTF )
	DllStructSetData ( $TRECTF , "X" , $NX )
	DllStructSetData ( $TRECTF , "Y" , $NY )
	DllStructSetData ( $TRECTF , "Width" , $NWIDTH )
	DllStructSetData ( $TRECTF , "Height" , $NHEIGHT )
	Return $TRECTF
EndFunc
Func _GDIPLUS_REGIONCLONE ( $HREGION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCloneRegion" , "handle" , $HREGION , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_REGIONCOMBINEPATH ( $HREGION , $HPATH , $ICOMBINEMODE = 2 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCombineRegionPath" , "handle" , $HREGION , "handle" , $HPATH , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONCOMBINERECT ( $HREGION , $NX , $NY , $NWIDTH , $NHEIGHT , $ICOMBINEMODE = 2 )
	Local $TRECTF = _GDIPLUS_RECTFCREATE ( $NX , $NY , $NWIDTH , $NHEIGHT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCombineRegionRect" , "handle" , $HREGION , "struct*" , $TRECTF , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONCOMBINEREGION ( $HREGIONDST , $HREGIONSRC , $ICOMBINEMODE = 2 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCombineRegionRegion" , "handle" , $HREGIONDST , "handle" , $HREGIONSRC , "int" , $ICOMBINEMODE )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONCREATE ( )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateRegion" , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _GDIPLUS_REGIONCREATEFROMPATH ( $HPATH )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateRegionPath" , "handle" , $HPATH , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_REGIONCREATEFROMRECT ( $NX , $NY , $NWIDTH , $NHEIGHT )
	Local $TRECTF = _GDIPLUS_RECTFCREATE ( $NX , $NY , $NWIDTH , $NHEIGHT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateRegionRect" , "struct*" , $TRECTF , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_REGIONDISPOSE ( $HREGION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteRegion" , "handle" , $HREGION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONGETBOUNDS ( $HREGION , $HGRAPHICS )
	Local $TRECTF = DllStructCreate ( $TAGGDIPRECTF )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetRegionBounds" , "handle" , $HREGION , "handle" , $HGRAPHICS , "struct*" , $TRECTF )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Local $ABOUNDS [ 4 ]
	For $II = 1 To 4
		$ABOUNDS [ $II + 4294967295 ] = DllStructGetData ( $TRECTF , $II )
	Next
	Return $ABOUNDS
EndFunc
Func _GDIPLUS_REGIONGETHRGN ( $HREGION , $HGRAPHICS = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetRegionHRgn" , "handle" , $HREGION , "handle" , $HGRAPHICS , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_REGIONSETEMPTY ( $HREGION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetEmpty" , "handle" , $HREGION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONSETINFINITE ( $HREGION )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetInfinite" , "handle" , $HREGION )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONTRANSFORM ( $HREGION , $HMATRIX )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTransformRegion" , "handle" , $HREGION , "handle" , $HMATRIX )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_REGIONTRANSLATE ( $HREGION , $NDX , $NDY )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipTranslateRegion" , "handle" , $HREGION , "float" , $NDX , "float" , $NDY )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_SHUTDOWN ( )
	If $__G_HGDIPDLL = 0 Then Return SetError ( + 4294967295 , + 4294967295 , False )
	$__G_IGDIPREF -= 1
	If $__G_IGDIPREF = 0 Then
		DllCall ( $__G_HGDIPDLL , "none" , "GdiplusShutdown" , "ulong_ptr" , $__G_IGDIPTOKEN )
		DllClose ( $__G_HGDIPDLL )
		$__G_HGDIPDLL = 0
	EndIf
	Return True
EndFunc
Func _GDIPLUS_STARTUP ( $SGDIPDLL = Default , $BRETDLLHANDLE = False )
	$__G_IGDIPREF += 1
	If $__G_IGDIPREF > 1 Then Return True
	If $SGDIPDLL = Default Then $SGDIPDLL = "gdiplus.dll"
	$__G_HGDIPDLL = DllOpen ( $SGDIPDLL )
	If $__G_HGDIPDLL = + 4294967295 Then
		$__G_IGDIPREF = 0
		Return SetError ( 1 , 2 , False )
	EndIf
	Local $SVER = FileGetVersion ( $SGDIPDLL )
	$SVER = StringSplit ( $SVER , "." )
	If $SVER [ 1 ] > 5 Then $__G_BGDIP_V1_0 = False
	Local $TINPUT = DllStructCreate ( $TAGGDIPSTARTUPINPUT )
	Local $TTOKEN = DllStructCreate ( "ulong_ptr Data" )
	DllStructSetData ( $TINPUT , "Version" , 1 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdiplusStartup" , "struct*" , $TTOKEN , "struct*" , $TINPUT , "ptr" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	$__G_IGDIPTOKEN = DllStructGetData ( $TTOKEN , "Data" )
	If $BRETDLLHANDLE Then Return $__G_HGDIPDLL
	Return SetExtended ( $SVER [ 1 ] , True )
EndFunc
Func _GDIPLUS_STRINGFORMATCREATE ( $IFORMAT = 0 , $ILANGID = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateStringFormat" , "int" , $IFORMAT , "word" , $ILANGID , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_STRINGFORMATDISPOSE ( $HFORMAT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteStringFormat" , "handle" , $HFORMAT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_STRINGFORMATGETMEASURABLECHARACTERRANGECOUNT ( $HSTRINGFORMAT )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetStringFormatMeasurableCharacterRangeCount" , "handle" , $HSTRINGFORMAT , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_STRINGFORMATSETALIGN ( $HSTRINGFORMAT , $IFLAG )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetStringFormatAlign" , "handle" , $HSTRINGFORMAT , "int" , $IFLAG )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_STRINGFORMATSETLINEALIGN ( $HSTRINGFORMAT , $ISTRINGALIGN )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetStringFormatLineAlign" , "handle" , $HSTRINGFORMAT , "int" , $ISTRINGALIGN )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_STRINGFORMATSETMEASURABLECHARACTERRANGES ( $HSTRINGFORMAT , $ARANGES )
	Local $ICOUNT = $ARANGES [ 0 ] [ 0 ]
	Local $TCHARACTERRANGES = DllStructCreate ( "int[" & $ICOUNT * 2 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TCHARACTERRANGES , 1 , $ARANGES [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 2 ) + 1 )
		DllStructSetData ( $TCHARACTERRANGES , 1 , $ARANGES [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 2 ) + 2 )
	Next
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetStringFormatMeasurableCharacterRanges" , "handle" , $HSTRINGFORMAT , "int" , $ICOUNT , "struct*" , $TCHARACTERRANGES )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_TEXTURECREATE ( $HIMAGE , $IWRAPMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateTexture" , "handle" , $HIMAGE , "int" , $IWRAPMODE , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_TEXTURECREATE2 ( $HIMAGE , $NX , $NY , $NWIDTH , $NHEIGHT , $IWRAPMODE = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateTexture2" , "handle" , $HIMAGE , "int" , $IWRAPMODE , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 7 ]
EndFunc
Func _GDIPLUS_TEXTURECREATEIA ( $HIMAGE , $NX , $NY , $NWIDTH , $NHEIGHT , $PIMAGEATTRIBUTES = 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateTextureIA" , "handle" , $HIMAGE , "handle" , $PIMAGEATTRIBUTES , "float" , $NX , "float" , $NY , "float" , $NWIDTH , "float" , $NHEIGHT , "ptr*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 7 ]
EndFunc
Func __GDIPLUS_BRUSHDEFCREATE ( ByRef $HBRUSH )
	If $HBRUSH = 0 Then
		$__G_HGDIPBRUSH = _GDIPLUS_BRUSHCREATESOLID ( )
		$HBRUSH = $__G_HGDIPBRUSH
	EndIf
EndFunc
Func __GDIPLUS_BRUSHDEFDISPOSE ( $ICURERROR = @error , $ICUREXTENDED = @extended )
	If $__G_HGDIPBRUSH <> 0 Then
		_GDIPLUS_BRUSHDISPOSE ( $__G_HGDIPBRUSH )
		$__G_HGDIPBRUSH = 0
	EndIf
	Return SetError ( $ICURERROR , $ICUREXTENDED )
EndFunc
Func __GDIPLUS_EXTRACTFILEEXT ( $SFILENAME , $BNODOT = True )
	Local $IINDEX = __GDIPLUS_LASTDELIMITER ( ".\:" , $SFILENAME )
	If ( $IINDEX > 0 ) And ( StringMid ( $SFILENAME , $IINDEX , 1 ) = "." ) Then
		If $BNODOT Then
			Return StringMid ( $SFILENAME , $IINDEX + 1 )
		Else
			Return StringMid ( $SFILENAME , $IINDEX )
		EndIf
	Else
		Return ""
	EndIf
EndFunc
Func __GDIPLUS_LASTDELIMITER ( $SDELIMITERS , $SSTRING )
	Local $SDELIMITER , $IN
	For $II = 1 To StringLen ( $SDELIMITERS )
		$SDELIMITER = StringMid ( $SDELIMITERS , $II , 1 )
		$IN = StringInStr ( $SSTRING , $SDELIMITER , $STR_NOCASESENSEBASIC , + 4294967295 )
		If $IN > 0 Then Return $IN
	Next
EndFunc
Func __GDIPLUS_PENDEFCREATE ( ByRef $HPEN )
	If $HPEN = 0 Then
		$__G_HGDIPPEN = _GDIPLUS_PENCREATE ( )
		$HPEN = $__G_HGDIPPEN
	EndIf
EndFunc
Func __GDIPLUS_PENDEFDISPOSE ( $ICURERROR = @error , $ICUREXTENDED = @extended )
	If $__G_HGDIPPEN <> 0 Then
		_GDIPLUS_PENDISPOSE ( $__G_HGDIPPEN )
		$__G_HGDIPPEN = 0
	EndIf
	Return SetError ( $ICURERROR , $ICUREXTENDED )
EndFunc
Func _GDIPLUS_BITMAPAPPLYEFFECT ( $HBITMAP , $HEFFECT , $TRECT = Null )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	If Not IsPtr ( $HEFFECT ) Then Return SetError ( 10 , 0 , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapApplyEffect" , "handle" , $HBITMAP , "handle" , $HEFFECT , "struct*" , $TRECT , "int" , 0 , "ptr*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPAPPLYEFFECTEX ( $HBITMAP , $HEFFECT , $IX = 0 , $IY = 0 , $IW = 0 , $IH = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $TRECT = 0
	If BitOR ( $IX , $IY , $IW , $IH ) Then
		$TRECT = DllStructCreate ( "int Left; int Top; int Right; int Bottom;" )
		DllStructSetData ( $TRECT , "Right" , $IW + DllStructSetData ( $TRECT , "Left" , $IX ) )
		DllStructSetData ( $TRECT , "Bottom" , $IH + DllStructSetData ( $TRECT , "Top" , $IY ) )
	EndIf
	Local $ISTATUS = _GDIPLUS_BITMAPAPPLYEFFECT ( $HBITMAP , $HEFFECT , $TRECT )
	If Not $ISTATUS Then Return SetError ( @error , @extended , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPCONVERTFORMAT ( $HBITMAP , $IPIXELFORMAT , $IDITHERTYPE , $IPALETTETYPE , $TPALETTE , $FALPHATHRESHOLDPERCENT = 0.0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapConvertFormat" , "handle" , $HBITMAP , "uint" , $IPIXELFORMAT , "uint" , $IDITHERTYPE , "uint" , $IPALETTETYPE , "struct*" , $TPALETTE , "float" , $FALPHATHRESHOLDPERCENT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPCREATEAPPLYEFFECT ( $HBITMAP , $HEFFECT , $TRECT = Null , $TOUTRECT = Null )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapCreateApplyEffect" , "handle*" , $HBITMAP , "int" , 1 , "handle" , $HEFFECT , "struct*" , $TRECT , "struct*" , $TOUTRECT , "handle*" , 0 , "int" , 0 , "ptr*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 6 ]
EndFunc
Func _GDIPLUS_BITMAPCREATEAPPLYEFFECTEX ( $HBITMAP , $HEFFECT , $IX = 0 , $IY = 0 , $IW = 0 , $IH = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TRECT = 0
	If BitOR ( $IX , $IY , $IW , $IH ) Then
		$TRECT = DllStructCreate ( "int Left; int Top; int Right; int Bottom;" )
		DllStructSetData ( $TRECT , "Right" , $IW + DllStructSetData ( $TRECT , "Left" , $IX ) )
		DllStructSetData ( $TRECT , "Bottom" , $IH + DllStructSetData ( $TRECT , "Top" , $IY ) )
	EndIf
	Local $HBITMAP_FX = _GDIPLUS_BITMAPCREATEAPPLYEFFECT ( $HBITMAP , $HEFFECT , $TRECT , Null )
	Return SetError ( @error , @extended , $HBITMAP_FX )
EndFunc
Func _GDIPLUS_BITMAPGETHISTOGRAM ( $HBITMAP , $IHISTOGRAMFORMAT , $IHISTOGRAMSIZE , $TCHANNEL_0 , $TCHANNEL_1 = 0 , $TCHANNEL_2 = 0 , $TCHANNEL_3 = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapGetHistogram" , "handle" , $HBITMAP , "uint" , $IHISTOGRAMFORMAT , "uint" , $IHISTOGRAMSIZE , "struct*" , $TCHANNEL_0 , "struct*" , $TCHANNEL_1 , "struct*" , $TCHANNEL_2 , "struct*" , $TCHANNEL_3 )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_BITMAPGETHISTOGRAMEX ( $HBITMAP )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $ISIZE = _GDIPLUS_BITMAPGETHISTOGRAMSIZE ( $GDIP_HISTOGRAMFORMATARGB )
	Local $THISTOGRAM = DllStructCreate ( "int Size; uint Red[" & $ISIZE & "]; uint MaxRed; uint Green[" & $ISIZE & "]; uint MaxGreen; uint Blue[" & $ISIZE & "]; uint MaxBlue; uint Alpha[" & $ISIZE & "]; uint MaxAlpha; uint Grey[" & $ISIZE & "]; uint MaxGrey;" )
	DllStructSetData ( $THISTOGRAM , "Size" , $ISIZE )
	Local $ISTATUS = _GDIPLUS_BITMAPGETHISTOGRAM ( $HBITMAP , $GDIP_HISTOGRAMFORMATARGB , $ISIZE , DllStructGetPtr ( $THISTOGRAM , "Alpha" ) , DllStructGetPtr ( $THISTOGRAM , "Red" ) , DllStructGetPtr ( $THISTOGRAM , "Green" ) , DllStructGetPtr ( $THISTOGRAM , "Blue" ) )
	If Not $ISTATUS Then Return SetError ( @error , @extended , 0 )
	$ISTATUS = _GDIPLUS_BITMAPGETHISTOGRAM ( $HBITMAP , $GDIP_HISTOGRAMFORMATGRAY , $ISIZE , DllStructGetPtr ( $THISTOGRAM , "Grey" ) )
	If Not $ISTATUS Then Return SetError ( @error + 10 , @extended , 0 )
	Local $IMAXRED = 0 , $IMAXGREEN = 0 , $IMAXBLUE = 0 , $IMAXALPHA = 0 , $IMAXGREY = 0
	For $I = 1 To $ISIZE
		If DllStructGetData ( $THISTOGRAM , "Red" , $I ) > $IMAXRED Then $IMAXRED = DllStructGetData ( $THISTOGRAM , "Red" , $I )
		If DllStructGetData ( $THISTOGRAM , "Green" , $I ) > $IMAXGREEN Then $IMAXGREEN = DllStructGetData ( $THISTOGRAM , "Green" , $I )
		If DllStructGetData ( $THISTOGRAM , "Blue" , $I ) > $IMAXBLUE Then $IMAXBLUE = DllStructGetData ( $THISTOGRAM , "Blue" , $I )
		If DllStructGetData ( $THISTOGRAM , "Alpha" , $I ) > $IMAXALPHA Then $IMAXALPHA = DllStructGetData ( $THISTOGRAM , "Alpha" , $I )
		If DllStructGetData ( $THISTOGRAM , "Grey" , $I ) > $IMAXGREY Then $IMAXGREY = DllStructGetData ( $THISTOGRAM , "Grey" , $I )
	Next
	DllStructSetData ( $THISTOGRAM , "MaxRed" , $IMAXRED )
	DllStructSetData ( $THISTOGRAM , "MaxGreen" , $IMAXGREEN )
	DllStructSetData ( $THISTOGRAM , "MaxBlue" , $IMAXBLUE )
	DllStructSetData ( $THISTOGRAM , "MaxAlpha" , $IMAXALPHA )
	DllStructSetData ( $THISTOGRAM , "MaxGrey" , $IMAXGREY )
	Return $THISTOGRAM
EndFunc
Func _GDIPLUS_BITMAPGETHISTOGRAMSIZE ( $IFORMAT )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipBitmapGetHistogramSize" , "uint" , $IFORMAT , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_DRAWIMAGEFX ( $HGRAPHICS , $HIMAGE , $HEFFECT , $TRECTF = 0 , $HMATRIX = 0 , $HIMGATTRIBUTES = 0 , $IUNIT = 2 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDrawImageFX" , "handle" , $HGRAPHICS , "handle" , $HIMAGE , "struct*" , $TRECTF , "handle" , $HMATRIX , "handle" , $HEFFECT , "handle" , $HIMGATTRIBUTES , "uint" , $IUNIT )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_DRAWIMAGEFXEX ( $HGRAPHICS , $HIMAGE , $HEFFECT , $NX = 0 , $NY = 0 , $NW = 0 , $NH = 0 , $HMATRIX = 0 , $HIMGATTRIBUTES = 0 , $IUNIT = 2 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $TRECTF = 0
	If BitOR ( $NX , $NY , $NW , $NH ) Then $TRECTF = _GDIPLUS_RECTFCREATE ( $NX , $NY , $NW , $NH )
	Local $ISTATUS = _GDIPLUS_DRAWIMAGEFX ( $HGRAPHICS , $HIMAGE , $HEFFECT , $TRECTF , $HMATRIX , $HIMGATTRIBUTES , $IUNIT )
	Return SetError ( @error , @extended , $ISTATUS )
EndFunc
Func _GDIPLUS_EFFECTCREATE ( $SEFFECTGUID )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SEFFECTGUID )
	Local $ACALL
	If @AutoItX64 Then
		$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateEffect" , "struct*" , $TGUID , "handle*" , 0 )
		If @error Then Return SetError ( @error , @extended , 0 )
		If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
		Return $ACALL [ 2 ]
	EndIf
	Local $TELEM = DllStructCreate ( "uint64[2];" , DllStructGetPtr ( $TGUID ) )
	$ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipCreateEffect" , "uint64" , DllStructGetData ( $TELEM , 1 , 1 ) , "uint64" , DllStructGetData ( $TELEM , 1 , 2 ) , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func _GDIPLUS_EFFECTCREATEBLUR ( $FRADIUS = 10.0 , $BEXPANDEDGE = False )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_BLUR )
	DllStructSetData ( $TEFFECTPARAMETERS , "Radius" , $FRADIUS )
	DllStructSetData ( $TEFFECTPARAMETERS , "ExpandEdge" , $BEXPANDEDGE )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_BLUREFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATEBRIGHTNESSCONTRAST ( $IBRIGHTNESSLEVEL = 0 , $ICONTRASTLEVEL = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST )
	DllStructSetData ( $TEFFECTPARAMETERS , "BrightnessLevel" , $IBRIGHTNESSLEVEL )
	DllStructSetData ( $TEFFECTPARAMETERS , "ContrastLevel" , $ICONTRASTLEVEL )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_BRIGHTNESSCONTRASTEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATECOLORBALANCE ( $ICYANRED = 0 , $IMAGENTAGREEN = 0 , $IYELLOWBLUE = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_COLORBALANCE )
	DllStructSetData ( $TEFFECTPARAMETERS , "CyanRed" , $ICYANRED )
	DllStructSetData ( $TEFFECTPARAMETERS , "MagentaGreen" , $IMAGENTAGREEN )
	DllStructSetData ( $TEFFECTPARAMETERS , "YellowBlue" , $IYELLOWBLUE )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_COLORBALANCEEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATECOLORCURVE ( $IADJUSTMENT , $ICHANNEL , $IADJUSTVALUE )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_COLORCURVE )
	DllStructSetData ( $TEFFECTPARAMETERS , "Adjustment" , $IADJUSTMENT )
	DllStructSetData ( $TEFFECTPARAMETERS , "Channel" , $ICHANNEL )
	DllStructSetData ( $TEFFECTPARAMETERS , "AdjustValue" , $IADJUSTVALUE )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_COLORCURVEEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATECOLORLUT ( $ACOLORLUT )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_COLORLUT )
	For $II = 0 To 255
		DllStructSetData ( $TEFFECTPARAMETERS , "LutA" , $ACOLORLUT [ $II ] [ 0 ] , $II + 1 )
		DllStructSetData ( $TEFFECTPARAMETERS , "LutR" , $ACOLORLUT [ $II ] [ 1 ] , $II + 1 )
		DllStructSetData ( $TEFFECTPARAMETERS , "LutG" , $ACOLORLUT [ $II ] [ 2 ] , $II + 1 )
		DllStructSetData ( $TEFFECTPARAMETERS , "LutB" , $ACOLORLUT [ $II ] [ 3 ] , $II + 1 )
	Next
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_COLORLUTEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATECOLORMATRIX ( $TCOLORMATRIX )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_COLORMATRIXEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TCOLORMATRIX )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATEHUESATURATIONLIGHTNESS ( $IHUELEVEL = 0 , $ISATURATIONLEVEL = 0 , $ILIGHTNESSLEVEL = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS )
	DllStructSetData ( $TEFFECTPARAMETERS , "HueLevel" , $IHUELEVEL )
	DllStructSetData ( $TEFFECTPARAMETERS , "SaturationLevel" , $ISATURATIONLEVEL )
	DllStructSetData ( $TEFFECTPARAMETERS , "LightnessLevel" , $ILIGHTNESSLEVEL )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_HUESATURATIONLIGHTNESSEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATELEVELS ( $IHIGHLIGHT = 100 , $IMIDTONE = 0 , $ISHADOW = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_LEVELS )
	DllStructSetData ( $TEFFECTPARAMETERS , "Highlight" , $IHIGHLIGHT )
	DllStructSetData ( $TEFFECTPARAMETERS , "Midtone" , $IMIDTONE )
	DllStructSetData ( $TEFFECTPARAMETERS , "Shadow" , $ISHADOW )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_LEVELSEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATEREDEYECORRECTION ( $AAREAS )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $ICOUNT = $AAREAS [ 0 ] [ 0 ]
	Local $TAREAS = DllStructCreate ( "long[" & $ICOUNT * 4 & "]" )
	For $II = 1 To $ICOUNT
		DllStructSetData ( $TAREAS , 1 , DllStructSetData ( $TAREAS , 1 , $AAREAS [ $II ] [ 0 ] , ( ( $II + 4294967295 ) * 4 ) + 1 ) + $AAREAS [ $II ] [ 2 ] , ( ( $II + 4294967295 ) * 4 ) + 3 )
		DllStructSetData ( $TAREAS , 1 , DllStructSetData ( $TAREAS , 1 , $AAREAS [ $II ] [ 1 ] , ( ( $II + 4294967295 ) * 4 ) + 2 ) + $AAREAS [ $II ] [ 3 ] , ( ( $II + 4294967295 ) * 4 ) + 4 )
	Next
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_REDEYECORRECTION )
	DllStructSetData ( $TEFFECTPARAMETERS , "NumberOfAreas" , $ICOUNT )
	DllStructSetData ( $TEFFECTPARAMETERS , "Areas" , DllStructGetPtr ( $TAREAS ) )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_REDEYECORRECTIONEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS , ( DllStructGetSize ( $TAREAS ) + DllStructGetSize ( $TEFFECTPARAMETERS ) ) / DllStructGetSize ( $TEFFECTPARAMETERS ) )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATESHARPEN ( $FRADIUS = 10.0 , $FAMOUNT = 50.0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_SHARPEN )
	DllStructSetData ( $TEFFECTPARAMETERS , "Radius" , $FRADIUS )
	DllStructSetData ( $TEFFECTPARAMETERS , "Amount" , $FAMOUNT )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_SHARPENEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTCREATETINT ( $IHUE = 0 , $IAMOUNT = 0 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	Local $TEFFECTPARAMETERS = DllStructCreate ( $TAGGDIP_EFFECTPARAMS_TINT )
	DllStructSetData ( $TEFFECTPARAMETERS , "Hue" , $IHUE )
	DllStructSetData ( $TEFFECTPARAMETERS , "Amount" , $IAMOUNT )
	Local $HEFFECT = _GDIPLUS_EFFECTCREATE ( $GDIP_TINTEFFECTGUID )
	If @error Then Return SetError ( @error , @extended , 0 )
	_GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error + 10 , @extended , 0 )
	Return $HEFFECT
EndFunc
Func _GDIPLUS_EFFECTDISPOSE ( $HEFFECT )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipDeleteEffect" , "handle" , $HEFFECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_EFFECTGETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	If DllStructGetSize ( $TEFFECTPARAMETERS ) < __GDIPLUS_EFFECTGETPARAMETERSIZE ( $HEFFECT ) Then Return SetError ( 2 , 5 , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetEffectParameters" , "handle" , $HEFFECT , "uint*" , DllStructGetSize ( $TEFFECTPARAMETERS ) , "struct*" , $TEFFECTPARAMETERS )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func __GDIPLUS_EFFECTGETPARAMETERSIZE ( $HEFFECT )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , + 4294967295 )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipGetEffectParameterSize" , "handle" , $HEFFECT , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , + 4294967295 )
	Return $ACALL [ 2 ]
EndFunc
Func _GDIPLUS_EFFECTSETPARAMETERS ( $HEFFECT , $TEFFECTPARAMETERS , $ISIZEADJUST = 1 )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , False )
	Local $ISIZE = __GDIPLUS_EFFECTGETPARAMETERSIZE ( $HEFFECT )
	If @error Then Return SetError ( @error , @extended , False )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipSetEffectParameters" , "handle" , $HEFFECT , "struct*" , $TEFFECTPARAMETERS , "uint" , $ISIZE * $ISIZEADJUST )
	If @error Then Return SetError ( @error , @extended , False )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , False )
	Return True
EndFunc
Func _GDIPLUS_PALETTEINITIALIZE ( $IENTRIES , $IPALETTETYPE = $GDIP_PALETTETYPEOPTIMAL , $IOPTIMALCOLORS = 0 , $BUSETRANSPARENTCOLOR = True , $HBITMAP = Null )
	If $__G_BGDIP_V1_0 Then Return SetError ( + 4294967295 , 0 , 0 )
	If $IOPTIMALCOLORS > 0 Then $IPALETTETYPE = $GDIP_PALETTETYPEOPTIMAL
	Local $TPALETTE = DllStructCreate ( "uint Flags; uint Count; uint ARGB[" & $IENTRIES & "];" )
	DllStructSetData ( $TPALETTE , "Flags" , $IPALETTETYPE )
	DllStructSetData ( $TPALETTE , "Count" , $IENTRIES )
	Local $ACALL = DllCall ( $__G_HGDIPDLL , "int" , "GdipInitializePalette" , "struct*" , $TPALETTE , "uint" , $IPALETTETYPE , "uint" , $IOPTIMALCOLORS , "bool" , $BUSETRANSPARENTCOLOR , "handle" , $HBITMAP )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return $TPALETTE
EndFunc
#EndRegion Include
#Region - Internal Variables
Global $__G_OLANGUAGEFACTORY = 0
Global $__G_OBITMAPDECODERSTATICS = 0
Global $__G_OOCRENGINESTATICS = 0
Global $__G_OGLOBALIZATIONPREFERENCESSTATICS = 0
Global $__G_ALANGUAGEINFO2D [ 0 ] [ 2 ]
#EndRegion - Internal Variables
#Region - Public Constants
#Region Interfaces
Global Const $STAG_IINSPECTABLE = "GetIids hresult();GetRuntimeClassName hresult();GetTrustLevel hresult(int*);"
Global Const $SIID_ILANGUAGEFACTORY = "{9B0252AC-0C27-44F8-B792-9793FB66C63E}"
Global Const $STAG_ILANGUAGEFACTORY = $STAG_IINSPECTABLE & "CreateLanguage hresult(ptr;ptr*)"
Global Const $SIID_IBITMAPDECODERSTATICS = "{438CCB26-BCEF-4E95-BAD6-23A822E58D01}"
Global Const $STAG_IBITMAPDECODERSTATICS = $STAG_IINSPECTABLE & "BmpDecoderId hresult(ptr*);JpegDecoderId hresult(ptr*);PngDecoderId hresult(ptr*);" & "TiffDecoderId hresult(ptr*);GifDecoderId hresult(ptr*);JpegXRDecoderId hresult(ptr*);IcoDecoderId hresult(ptr*);" & "GetDecoderInformationEnumerator hresult();CreateAsync hresult(ptr;ptr*);CreateWithIdAsync hresult();"
Global Const $SIID_IOCRENGINESTATICS = "{5BFFA85A-3384-3540-9940-699120D428A8}"
Global Const $STAG_IOCRENGINESTATICS = $STAG_IINSPECTABLE & "MaxImageDimension hresult(uint*);AvailableRecognizerLanguages hresult(ptr*);" & "IsLanguageSupported hresult(ptr;bool*);TryCreateFromLanguage hresult(ptr;ptr*);TryCreateFromUserProfileLanguages hresult(ptr*);"
Global Const $SIID_IGLOBALIZATIONPREFERENCESSTATICS = "{01BF4326-ED37-4E96-B0E9-C1340D1EA158}"
Global Const $STAG_IGLOBALIZATIONPREFERENCESSTATICS = $STAG_IINSPECTABLE & "GetCalendars hresult(ptr*);GetClocks hresult(ptr*);GetCurrencies hresult(ptr*);" & "GetLanguages hresult(ptr*);GetHomeGeographicRegion hresult(ptr*);GetWeekStartsOn hresult(ptr*);"
Global Const $SIID___FIVECTORVIEW_1_HSTRING = "{2f13c006-a03a-5f69-b090-75a43e33423e}"
Global Const $STAG___FIVECTORVIEW_1_HSTRING = $STAG_IINSPECTABLE & "GetAt hresult(int;ptr*);GetSize hresult(uint*);IndexOf hresult(ptr;uint*;bool*);" & "GetMany hresult(uint;uint;ptr*;uint*);"
Global Const $SIID___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRLINE = "{60c76eac-8875-5ddb-a19b-65a3936279ea}"
Global Const $STAG___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRLINE = $STAG___FIVECTORVIEW_1_HSTRING
Global Const $SIID___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRWORD = "{805a60c7-df4f-527c-86b2-e29e439a83d2}"
Global Const $STAG___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRWORD = $STAG___FIVECTORVIEW_1_HSTRING
Global Const $SIID_ILANGUAGE = "{EA79A752-F7C2-4265-B1BD-C4DEC4E4F080}"
Global Const $STAG_ILANGUAGE = $STAG_IINSPECTABLE & "GetLanguageTag hresult(ptr*);GetDisplayName hresult(ptr*);GetNativeName hresult(ptr*);GetScript hresult(ptr*);"
Global Const $SIID_IOCRENGINE = "{5A14BC41-5B76-3140-B680-8825562683AC}"
Global Const $STAG_IOCRENGINE = $STAG_IINSPECTABLE & "RecognizeAsync hresult(ptr;ptr*);RecognizerLanguage hresult(ptr*);"
Global Const $SIID_IRANDOMACCESSSTREAM = "{905A0FE1-BC53-11DF-8C49-001E4FC686DA}"
Global Const $SIID_IASYNCINFO = "{00000036-0000-0000-C000-000000000046}"
Global Const $STAG_IASYNCINFO = $STAG_IINSPECTABLE & "GetID hresult(int*);GetStatus hresult(int*);GetErrorCode hresult(long*)Cancel hresult();Close hresult();"
Global Const $SIID_IBITMAPDECODER = "{ACEF22BA-1D74-4C91-9DFC-9620745233E6}"
Global Const $STAG_IBITMAPDECODER = $STAG_IINSPECTABLE & "BitmapContainerProperties hresult(ptr*);DecoderInformation hresult(ptr*);FrameCount hresult(uint*);" & "GetPreviewAsync  hresult(ptr*);GetFrameAsync hresult(uint;ptr*);"
Global Const $SIID_IBITMAPFRAME = "{72A49A1C-8081-438D-91BC-94ECFC8185C6}"
Global Const $STAG_IBITMAPFRAME = $STAG_IINSPECTABLE & "GetThumbnailAsync hresult();BitmapProperties hresult();BitmapPixelFormat hresult();BitmapAlphaMode hresult();" & "DpiX hresult();DpiX hresult();PixelWidth hresult(uint*);PixelHeight hresult(uint*);OrientedPixelWidth hresult(uint*);OrientedPixelHeight hresult(uint*);" & "GetPixelDataAsync hresult();GetPixelDataTransformedAsync hresult();"
Global Const $SIID_IBITMAPFRAMEWITHSOFTWAREBITMAP = "{FE287C9A-420C-4963-87AD-691436E08383}"
Global Const $STAG_IBITMAPFRAMEWITHSOFTWAREBITMAP = $STAG_IINSPECTABLE & "GetSoftwareBitmapAsync hresult(ptr*);GetSoftwareBitmapConvertedAsync hresult();" & "GetSoftwareBitmapTransformedAsync  hresult();"
Global Const $SIID_ISOFTWAREBITMAP = "{689E0708-7EEF-483F-963F-DA938818E073}"
Global Const $STAG_ISOFTWAREBITMAP = $STAG_IINSPECTABLE & ""
Global Const $SIID_IOCRRESULT = "{9BD235B2-175B-3D6A-92E2-388C206E2F63}"
Global Const $STAG_IOCRRESULT = $STAG_IINSPECTABLE & "Lines hresult(ptr*);TextAngle hresult(double*);Text hresult(ptr*);"
Global Const $SIID_IOCRLINE = "{0043A16F-E31F-3A24-899C-D444BD088124}"
Global Const $STAG_IOCRLINE = $STAG_IINSPECTABLE & "GetWords hreulst(ptr*);GetText hreulst(ptr*);"
Global Const $SIID_IOCRWORD = "{3C2A477A-5CD9-3525-BA2A-23D1E0A68A1D}"
Global Const $STAG_IOCRWORD = $STAG_IINSPECTABLE & "GetBoundingRect hresult(struct*);GetText hresult(ptr*);"
Global Const $SIID_IPICTURE = "{7BF80980-BF32-101A-8BBB-00AA00300CAB}"
Global Const $STAG_IPICTURE = "GetHandle hresult();GethPal hresult();GetType hresult();GetWidth hresult();GetHeight hresult();Render hresult();SethPal hresult();" & "GetCurDC hresult();SelectPicture hresult();GetKeepOriginalFormat hresult();PutKeepOriginalFormat hresult();" & "PictureChanged hresult();SaveAsFile hresult(ptr;bool;int*);GetAttributes hresult(ptr;bool;int);"
#EndRegion Interfaces
#EndRegion - Public Constants
#Region - Internal Constants
Global Const $__G_HUWPOCR_COMBASE = DllOpen ( "Combase.dll" )
Global Const $__G_HUWPOCR_SHCORE = DllOpen ( "SHCore.dll" )
#EndRegion - Internal Constants
#Region Public Functions
Func _UWPOCR_GETSUPPORTEDLANGUAGES ( )
	Local $OERRORHANDLER = ObjEvent ( "AutoIt.Error" , __UWPOCR_ERRORHANDLER )
	#forceref $oErrorHandler
	If Not __UWPOCR_INITIALIZE ( ) Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_Initialize" )
		Return SetError ( @error , @extended , 0 )
	EndIf
	_UWPOCR_LOG ( "OK __UWPOCR_Initialize" )
	Return $__G_ALANGUAGEINFO2D
EndFunc
Func _UWPOCR_GETTEXT ( $SIMAGEFILEPATHORHBITMAP , $SLANGUAGETAGTOUSE = Default , $BUSEOCRLINE = False )
	Local $OERRORHANDLER = ObjEvent ( "AutoIt.Error" , __UWPOCR_ERRORHANDLER )
	#forceref $oErrorHandler
	_UWPOCR_LOG ( "_UWPOCR_GetText" )
	Return __UWPOCR_GETTEXT ( $SIMAGEFILEPATHORHBITMAP , $SLANGUAGETAGTOUSE , $BUSEOCRLINE )
EndFunc
Func _UWPOCR_GETWORDSRECTTO2DARRAY ( $SIMAGEFILEPATHORHBITMAP , $SLANGUAGETAGTOUSE = Default )
	Local $OERRORHANDLER = ObjEvent ( "AutoIt.Error" , "__UWPOCR_ErrorHandler" )
	#forceref $oErrorHandler
	_UWPOCR_LOG ( "_UWPOCR_GetWordsRectTo2DArray" )
	Return __UWPOCR_GETTEXT ( $SIMAGEFILEPATHORHBITMAP , $SLANGUAGETAGTOUSE , False , True )
EndFunc
Func _UWPOCR_LOG ( $PCALLFUNCTION = Default , Const $ICURRENTERROR = @error , Const $ICURRENTEXTENDED = @extended , Const $ISCRIPTLINENUMBER = @ScriptLineNumber )
	Local Static $PFUNCTION = Default
	If @NumParams And IsFunc ( $PCALLFUNCTION ) Then $PFUNCTION = $PCALLFUNCTION
	If IsFunc ( $PFUNCTION ) And Not IsFunc ( $PCALLFUNCTION ) Then Call ( $PFUNCTION , $PCALLFUNCTION , $ISCRIPTLINENUMBER )
	SetError ( $ICURRENTERROR , $ICURRENTEXTENDED )
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __UWPOCR_CREATERUNTIMECLASS ( $SACTIVATABLECLASSID , $SGUID , $SINTERFACEDESCRIPTION )
	Local $PFACTORY = __UWPOCR_ROGETACTIVATIONFACTORY ( $SACTIVATABLECLASSID , $SGUID )
	Local $OINTERFACE = ObjCreateInterface ( $PFACTORY , $SGUID , $SINTERFACEDESCRIPTION )
	Return $OINTERFACE
EndFunc
Func __UWPOCR_ERRORHANDLER ( $OERROR )
	_UWPOCR_LOG ( "UWPOCR UDF (" & $OERROR .scriptline & ") : ==> COM Error intercepted !" & @CRLF & @TAB & "err.number is: " & @TAB & @TAB & "0x" & Hex ( $OERROR .number ) & @CRLF & @TAB & "err.windescription:" & @TAB & $OERROR .windescription & @CRLF & @TAB & "err.description is: " & @TAB & $OERROR .description & @CRLF & @TAB & "err.source is: " & @TAB & @TAB & $OERROR .source & @CRLF & @TAB & "err.helpfile is: " & @TAB & $OERROR .helpfile & @CRLF & @TAB & "err.helpcontext is: " & @TAB & $OERROR .helpcontext & @CRLF & @TAB & "err.lastdllerror is: " & @TAB & $OERROR .lastdllerror & @CRLF & @TAB & "err.scriptline is: " & @TAB & $OERROR .scriptline & @CRLF & @TAB & "err.retcode is: " & @TAB & "0x" & Hex ( $OERROR .retcode ) & @CRLF & @CRLF )
EndFunc
Func __UWPOCR_GETSTRINGFROMHSTRING ( $HSTRING )
	Local $ACALL = DllCall ( $__G_HUWPOCR_COMBASE , "wstr" , "WindowsGetStringRawBuffer" , "ptr" , $HSTRING , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	Local $ISIZE = $ACALL [ 2 ]
	$ACALL = DllCall ( $__G_HUWPOCR_COMBASE , "wstr" , "WindowsGetStringRawBuffer" , "ptr" , $HSTRING , "uint*" , $ISIZE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func __UWPOCR_GETTEXT ( $SIMAGEFILEPATHORHBITMAP , $SLANGUAGETAGTOUSE , $BUSEOCRLINE = False , $BRETURNWORDSRECT2DARRAY = False )
	Local $STEXTRESULT = ""
	If Not __UWPOCR_INITIALIZE ( ) Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_Initialize" )
		Return SetError ( @error , @extended , $STEXTRESULT )
	EndIf
	_UWPOCR_LOG ( "OK __UWPOCR_Initialize" )
	Local $BISBITMAP = False
	Local $SIMAGEFILEPATH = ""
	Local $HBITMAP = 0
	If IsString ( $SIMAGEFILEPATHORHBITMAP ) Then
		If Not FileExists ( $SIMAGEFILEPATHORHBITMAP ) Then
			_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> Image File not found" )
			Return SetError ( @error , @extended , $STEXTRESULT )
		EndIf
		$SIMAGEFILEPATH = $SIMAGEFILEPATHORHBITMAP
	Else
		$HBITMAP = $SIMAGEFILEPATHORHBITMAP
		$BISBITMAP = True
		If Not $HBITMAP Then
			_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> Invalid hBitmap" )
			Return SetError ( @error , @extended , $STEXTRESULT )
		EndIf
	EndIf
	If $SLANGUAGETAGTOUSE = Default Then $SLANGUAGETAGTOUSE = $__G_ALANGUAGEINFO2D [ 0 ] [ 0 ]
	Local $ILANGUAGESUPPORTED = False
	For $I = 0 To UBound ( $__G_ALANGUAGEINFO2D ) + 4294967295
		If $__G_ALANGUAGEINFO2D [ $I ] [ 0 ] = $SLANGUAGETAGTOUSE Then
			$ILANGUAGESUPPORTED = True
		EndIf
	Next
	If Not $ILANGUAGESUPPORTED Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> Unsupported Language [" & $SLANGUAGETAGTOUSE & "]" )
		SetError ( 1 , 1 , $STEXTRESULT )
	EndIf
	_UWPOCR_LOG ( "OK __UWPOCR_GetText -> Supported Language [" & $SLANGUAGETAGTOUSE & "]" )
	Local $PHSTRINGLANGUAGE = __UWPOCR_CREATEHSTRING ( $SLANGUAGETAGTOUSE )
	Local $PILANGUAGE = 0
	$__G_OLANGUAGEFACTORY .CreateLanguage ( $PHSTRINGLANGUAGE , $PILANGUAGE )
	Local $OLENGUAGE = ObjCreateInterface ( $PILANGUAGE , $SIID_ILANGUAGE , $STAG_ILANGUAGE )
	Local $PIOCRENGINE = 0
	$__G_OOCRENGINESTATICS .TryCreateFromLanguage ( $OLENGUAGE ( ) , $PIOCRENGINE )
	Local $OOCRENGINE = ObjCreateInterface ( $PIOCRENGINE , $SIID_IOCRENGINE , $STAG_IOCRENGINE )
	Local $PIRANDOMACCESSSTREAM = 0
	If $BISBITMAP Then
		Local $SIMGCLSID = _GDIPLUS_ENCODERSGETCLSID ( "jpg" )
		Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SIMGCLSID )
		Local $TPARAMS = _GDIPLUS_PARAMINIT ( 1 )
		Local $TDATA = DllStructCreate ( "int Quality" )
		DllStructSetData ( $TDATA , "Quality" , 100 )
		Local $PDATA = DllStructGetPtr ( $TDATA )
		_GDIPLUS_PARAMADD ( $TPARAMS , $GDIP_EPGQUALITY , 1 , $GDIP_EPTLONG , $PDATA )
		Local $PSTREAM = _WINAPI_CREATESTREAMONHGLOBAL ( )
		_GDIPLUS_IMAGESAVETOSTREAM ( $HBITMAP , $PSTREAM , $TGUID , $TPARAMS )
		$PIRANDOMACCESSSTREAM = __UWPOCR_CREATERANDOMACCESSSTREAMOVERSTREAM ( $PSTREAM )
		_WINAPI_RELEASESTREAM ( $PSTREAM )
	Else
		$PIRANDOMACCESSSTREAM = __UWPOCR_CREATERANDOMACCESSSTREAMONFILE ( $SIMAGEFILEPATH )
	EndIf
	If Not $PIRANDOMACCESSSTREAM Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> IRandomAccessStream" )
		Return SetError ( 2 , 2 , $STEXTRESULT )
	EndIf
	Local $PIBITMAPDECODER = 0
	$__G_OBITMAPDECODERSTATICS .CreateAsync ( $PIRANDOMACCESSSTREAM , $PIBITMAPDECODER )
	If Not __UWPOCR_WAITFORASYNCINTERFACE ( $PIBITMAPDECODER ) Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> WaitForAsync IBitmapDecoder" )
		Return SetError ( 3 , 3 , $STEXTRESULT )
	EndIf
	Local $OBITMAPDECODER = ObjCreateInterface ( $PIBITMAPDECODER , $SIID_IBITMAPDECODER , $STAG_IBITMAPDECODER )
	Local $OBITMAPFRAME = ObjCreateInterface ( $OBITMAPDECODER ( ) , $SIID_IBITMAPFRAME , $STAG_IBITMAPFRAME )
	Local $IWIDTH = 0
	Local $IHEIGHT = 0
	Local $IMAXDIMENSIONS = 0
	$OBITMAPFRAME .PixelWidth ( $IWIDTH )
	$OBITMAPFRAME .PixelHeight ( $IHEIGHT )
	$__G_OOCRENGINESTATICS .MaxImageDimension ( $IMAXDIMENSIONS )
	If $IWIDTH > $IMAXDIMENSIONS Or $IHEIGHT > $IMAXDIMENSIONS Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> OcrEngine MaxDimension" )
		Return SetError ( 4 , 4 , $STEXTRESULT )
	EndIf
	Local $PBITMAPFRAMEWITHSOFTWAREBITMAP = 0
	$OBITMAPDECODER .QueryInterface ( $SIID_IBITMAPFRAMEWITHSOFTWAREBITMAP , $PBITMAPFRAMEWITHSOFTWAREBITMAP )
	Local $OBITMAPFRAMEWITHSOFTWAREBITMAP = ObjCreateInterface ( $PBITMAPFRAMEWITHSOFTWAREBITMAP , $SIID_IBITMAPFRAMEWITHSOFTWAREBITMAP , $STAG_IBITMAPFRAMEWITHSOFTWAREBITMAP )
	If Not IsObj ( $OBITMAPFRAMEWITHSOFTWAREBITMAP ) Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> IBitmapFrameWithSoftwareBitmap" )
		Return SetError ( 5 , 5 , $STEXTRESULT )
	EndIf
	Local $PISOFTWAREBITMAP = 0
	$OBITMAPFRAMEWITHSOFTWAREBITMAP .GetSoftwareBitmapAsync ( $PISOFTWAREBITMAP )
	If Not __UWPOCR_WAITFORASYNCINTERFACE ( $PISOFTWAREBITMAP ) Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> WaitForAsync ISoftwareBitmap" )
		Return SetError ( 6 , 6 , $STEXTRESULT )
	EndIf
	Local $OSOFTWAREBITMAP = ObjCreateInterface ( $PISOFTWAREBITMAP , $SIID_ISOFTWAREBITMAP , $STAG_ISOFTWAREBITMAP )
	Local $PIOCRRESULT = 0
	$OOCRENGINE .RecognizeAsync ( $OSOFTWAREBITMAP ( ) , $PIOCRRESULT )
	If Not __UWPOCR_WAITFORASYNCINTERFACE ( $PIOCRRESULT ) Then
		_UWPOCR_LOG ( "FAIL __UWPOCR_GetText -> WaitForAsync IOcrResult" )
		Return SetError ( 7 , 7 , $STEXTRESULT )
	EndIf
	Local $OOCRRESULT = ObjCreateInterface ( $PIOCRRESULT , $SIID_IOCRRESULT , $STAG_IOCRRESULT )
	Local $IANGLE = 0
	$OOCRRESULT .TextAngle ( $IANGLE )
	If $BRETURNWORDSRECT2DARRAY = True Then $BUSEOCRLINE = True
	Local $AOCRRESULTWORDS [ 0 ] [ 5 ]
	If $BUSEOCRLINE Then
		Local $PFIVOCRLINES = 0
		$OOCRRESULT .Lines ( $PFIVOCRLINES )
		Local $OFIVOCRLINES = ObjCreateInterface ( $PFIVOCRLINES , $SIID___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRLINE , $STAG___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRLINE )
		Local $ICOUNTLINES = 0
		$OFIVOCRLINES .GetSize ( $ICOUNTLINES )
		Local $PIOCRLINE = 0
		Local $OIOCRLINE = 0
		Local $PHSTRINGLINE = ""
		Local $PFIVOCRWORDS = 0
		Local $OFIVOCRWORDS = 0
		Local $ICOUNTWORDS = 0
		Local $PIOCRWORD = 0
		Local $OIOCRWORD = 0
		Local $TWORDRECT = ""
		Local $PHSTRINGWORD = ""
		Local $ICOUNTWORDSINDEX = 0
		For $I = 0 To $ICOUNTLINES + 4294967295
			$OFIVOCRLINES .GetAt ( $I , $PIOCRLINE )
			$OIOCRLINE = ObjCreateInterface ( $PIOCRLINE , $SIID_IOCRLINE , $STAG_IOCRLINE )
			$OIOCRLINE .GetText ( $PHSTRINGLINE )
			$STEXTRESULT &= __UWPOCR_GETSTRINGFROMHSTRING ( $PHSTRINGLINE ) & @CRLF
			If $BRETURNWORDSRECT2DARRAY Then
				$OIOCRLINE .GetWords ( $PFIVOCRWORDS )
				$OFIVOCRWORDS = ObjCreateInterface ( $PFIVOCRWORDS , $SIID___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRWORD , $STAG___FIVECTORVIEW_1_WINDOWS__CMEDIA__COCR__COCRWORD )
				$OFIVOCRWORDS .GetSize ( $ICOUNTWORDS )
				If $ICOUNTWORDS Then
					ReDim $AOCRRESULTWORDS [ UBound ( $AOCRRESULTWORDS ) + $ICOUNTWORDS ] [ 5 ]
					For $X = 0 To $ICOUNTWORDS + 4294967295
						$OFIVOCRWORDS .GetAt ( $X , $PIOCRWORD )
						$OIOCRWORD = ObjCreateInterface ( $PIOCRWORD , $SIID_IOCRWORD , $STAG_IOCRWORD )
						$TWORDRECT = DllStructCreate ( "FLOAT X;FLOAT Y;FLOAT Width;FLOAT Height;" )
						$OIOCRWORD .GetBoundingRect ( $TWORDRECT )
						$OIOCRWORD .GetText ( $PHSTRINGWORD )
						$AOCRRESULTWORDS [ $ICOUNTWORDSINDEX ] [ 0 ] = __UWPOCR_GETSTRINGFROMHSTRING ( $PHSTRINGWORD )
						$AOCRRESULTWORDS [ $ICOUNTWORDSINDEX ] [ 1 ] = $TWORDRECT .X
						$AOCRRESULTWORDS [ $ICOUNTWORDSINDEX ] [ 2 ] = $TWORDRECT .Y
						$AOCRRESULTWORDS [ $ICOUNTWORDSINDEX ] [ 3 ] = $TWORDRECT .Width
						$AOCRRESULTWORDS [ $ICOUNTWORDSINDEX ] [ 4 ] = $TWORDRECT .Height
						$ICOUNTWORDSINDEX += 1
						__UWPOCR_DELETEHSTRING ( $PHSTRINGWORD )
						$OIOCRWORD = 0
						$TWORDRECT = 0
					Next
				EndIf
			EndIf
			__UWPOCR_DELETEHSTRING ( $PHSTRINGLINE )
			$OIOCRLINE = 0
		Next
	Else
		Local $PHRESULTTEXT = ""
		$OOCRRESULT .Text ( $PHRESULTTEXT )
		$STEXTRESULT = __UWPOCR_GETSTRINGFROMHSTRING ( $PHRESULTTEXT )
		__UWPOCR_DELETEHSTRING ( $PHRESULTTEXT )
	EndIf
	If $BRETURNWORDSRECT2DARRAY Then
		Return SetError ( @error , $IANGLE , $AOCRRESULTWORDS )
	Else
		Return SetError ( @error , $IANGLE , $STEXTRESULT )
	EndIf
EndFunc
Func __UWPOCR_INITIALIZE ( )
	If ( Not IsObj ( $__G_OLANGUAGEFACTORY ) ) Or ( Not IsObj ( $__G_OBITMAPDECODERSTATICS ) ) Or ( Not IsObj ( $__G_OOCRENGINESTATICS ) ) Or ( Not IsObj ( $__G_OGLOBALIZATIONPREFERENCESSTATICS ) ) Then
		_GDIPLUS_STARTUP ( )
		$__G_OLANGUAGEFACTORY = __UWPOCR_CREATERUNTIMECLASS ( "Windows.Globalization.Language" , $SIID_ILANGUAGEFACTORY , $STAG_ILANGUAGEFACTORY )
		$__G_OBITMAPDECODERSTATICS = __UWPOCR_CREATERUNTIMECLASS ( "Windows.Graphics.Imaging.BitmapDecoder" , $SIID_IBITMAPDECODERSTATICS , $STAG_IBITMAPDECODERSTATICS )
		$__G_OOCRENGINESTATICS = __UWPOCR_CREATERUNTIMECLASS ( "Windows.Media.Ocr.OcrEngine" , $SIID_IOCRENGINESTATICS , $STAG_IOCRENGINESTATICS )
		$__G_OGLOBALIZATIONPREFERENCESSTATICS = __UWPOCR_CREATERUNTIMECLASS ( "Windows.System.UserProfile.GlobalizationPreferences" , $SIID_IGLOBALIZATIONPREFERENCESSTATICS , $STAG_IGLOBALIZATIONPREFERENCESSTATICS )
		If Not __UWPOCR_LOADLANGUAGELIST2DARRAY ( ) Then Return SetError ( @error , @extended , 0 )
	EndIf
	If IsObj ( $__G_OLANGUAGEFACTORY ) And IsObj ( $__G_OBITMAPDECODERSTATICS ) And IsObj ( $__G_OOCRENGINESTATICS ) And IsObj ( $__G_OGLOBALIZATIONPREFERENCESSTATICS ) Then Return SetError ( 0 , 0 , 1 )
	Return SetError ( 1 , 0 , 0 )
EndFunc
Func __UWPOCR_LOADLANGUAGELIST2DARRAY ( )
	Local $PFIVLANGUAGES = 0
	$__G_OGLOBALIZATIONPREFERENCESSTATICS .GetLanguages ( $PFIVLANGUAGES )
	Local $OFIVLANGUAGES = ObjCreateInterface ( $PFIVLANGUAGES , $SIID___FIVECTORVIEW_1_HSTRING , $STAG___FIVECTORVIEW_1_HSTRING )
	If Not IsObj ( $OFIVLANGUAGES ) Then Return SetError ( @error , @extended , 0 )
	Local $ICOUNTLANGUAGES = 0
	$OFIVLANGUAGES .GetSize ( $ICOUNTLANGUAGES )
	ReDim $__G_ALANGUAGEINFO2D [ $ICOUNTLANGUAGES ] [ 2 ]
	Local $PHSTRINGLANGUAGE = 0
	Local $PILANGUAGE = 0
	Local $OLANGUAGE = 0
	Local $PHSTRINGLANGUAGETAG = 0
	Local $PHSTRINGDISPLAYNAME = 0
	Local $BISLANGUAGESUPPORTED = False
	Local $ICOUNTLANGUAGESUPPORTED = 0
	For $I = 0 To $ICOUNTLANGUAGES + 4294967295
		$OFIVLANGUAGES .GetAt ( $I , $PHSTRINGLANGUAGE )
		$__G_OLANGUAGEFACTORY .CreateLanguage ( $PHSTRINGLANGUAGE , $PILANGUAGE )
		$OLANGUAGE = ObjCreateInterface ( $PILANGUAGE , $SIID_ILANGUAGE , $STAG_ILANGUAGE )
		If IsObj ( $OLANGUAGE ) Then
			$OLANGUAGE .GetLanguageTag ( $PHSTRINGLANGUAGETAG )
			$OLANGUAGE .GetDisplayName ( $PHSTRINGDISPLAYNAME )
			$__G_OOCRENGINESTATICS .IsLanguageSupported ( $OLANGUAGE ( ) , $BISLANGUAGESUPPORTED )
			If $BISLANGUAGESUPPORTED Then
				$__G_ALANGUAGEINFO2D [ $ICOUNTLANGUAGESUPPORTED ] [ 0 ] = __UWPOCR_GETSTRINGFROMHSTRING ( $PHSTRINGLANGUAGETAG )
				$__G_ALANGUAGEINFO2D [ $ICOUNTLANGUAGESUPPORTED ] [ 1 ] = __UWPOCR_GETSTRINGFROMHSTRING ( $PHSTRINGDISPLAYNAME )
				$ICOUNTLANGUAGESUPPORTED += 1
			EndIf
			__UWPOCR_DELETEHSTRING ( $PHSTRINGLANGUAGETAG )
			__UWPOCR_DELETEHSTRING ( $PHSTRINGDISPLAYNAME )
		EndIf
		$OLANGUAGE = 0
	Next
	$OFIVLANGUAGES = 0
	ReDim $__G_ALANGUAGEINFO2D [ $ICOUNTLANGUAGESUPPORTED ] [ 2 ]
	If $ICOUNTLANGUAGESUPPORTED Then Return SetError ( 0 , 0 , 1 )
	Return SetError ( 1 , 0 , 0 )
EndFunc
Func __UWPOCR_LOG ( $SSTRING , $ISCRIPTLINENUMBER )
	ConsoleWrite ( StringFormat ( ( StringInStr ( $SSTRING , "FAIL" ) ? "!" : ">" ) & "[%s-L%04s]\t%s" , "Debug" , $ISCRIPTLINENUMBER , $SSTRING ) & @CRLF )
EndFunc
Func __UWPOCR_ROGETACTIVATIONFACTORY ( $SHSTRING , $SGUID )
	Local $HSTRING = __UWPOCR_CREATEHSTRING ( $SHSTRING )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SGUID )
	Local $ACALL = DllCall ( $__G_HUWPOCR_COMBASE , "long" , "RoGetActivationFactory" , "ptr" , $HSTRING , "struct*" , $TGUID , "ptr*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	__UWPOCR_DELETEHSTRING ( $HSTRING )
	Return $ACALL [ 3 ]
EndFunc
Func __UWPOCR_WAITFORASYNCINTERFACE ( ByRef $POUTINTERFACE )
	Local $OASYNCINFO = ObjCreateInterface ( $POUTINTERFACE , $SIID_IASYNCINFO , $STAG_IASYNCINFO )
	If Not IsObj ( $OASYNCINFO ) Then Return False
	Local $ISTATUS = 0
	Local $IERRORCODE = 0
	$OASYNCINFO .GetStatus ( $ISTATUS )
	Local $BERROR = 0
	While True
		$OASYNCINFO .GetStatus ( $ISTATUS )
		If $ISTATUS <> 0 Then
			If $ISTATUS <> 1 Then
				$OASYNCINFO .GetErrorCode ( $IERRORCODE )
				$BERROR = $IERRORCODE
				ExitLoop
			EndIf
			$OASYNCINFO .GetErrorCode ( $IERRORCODE )
			ExitLoop
		EndIf
		Sleep ( 10 )
	WEnd
	If $BERROR Then Return SetError ( 1 , $IERRORCODE , 0 )
	Local $LPINTERFACE = $POUTINTERFACE
	Local $TPINTERFACE = DllStructCreate ( "ptr" , $LPINTERFACE )
	Local $PINTERFACE = DllStructGetData ( $TPINTERFACE , 1 )
	Local $TINTERFACEFUNCTIONTABLE = DllStructCreate ( "ptr Methods[9]" , $PINTERFACE )
	Local $ACALL = DllCallAddress ( "long" , DllStructGetData ( $TINTERFACEFUNCTIONTABLE , "Methods" , 9 ) , "ptr" , $LPINTERFACE , "ptr*" , 0 )
	If Not @error And $ACALL [ 2 ] Then
		$POUTINTERFACE = $ACALL [ 2 ]
		Return 1
	EndIf
	$POUTINTERFACE = 0
	Return 0
EndFunc
#EndRegion Internal Functions
#Region Internal Utils Functions
Func __UWPOCR_CREATEHSTRING ( $SSTRING )
	Local $ACALL = DllCall ( $__G_HUWPOCR_COMBASE , "long" , "WindowsCreateString" , "wstr" , $SSTRING , "uint" , StringLen ( $SSTRING ) , "ptr*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 3 ]
EndFunc
Func __UWPOCR_CREATERANDOMACCESSSTREAMONFILE ( $SIMAGEFILEPATH )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SIID_IRANDOMACCESSSTREAM )
	Local $ACALL = DllCall ( $__G_HUWPOCR_SHCORE , "long" , "CreateRandomAccessStreamOnFile" , "wstr" , $SIMAGEFILEPATH , "int" , 0 , "struct*" , $TGUID , "ptr*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func __UWPOCR_CREATERANDOMACCESSSTREAMOVERSTREAM ( $PSTREAM )
	Local $TGUID = _WINAPI_GUIDFROMSTRING ( $SIID_IRANDOMACCESSSTREAM )
	Local $ACALL = DllCall ( $__G_HUWPOCR_SHCORE , "long" , "CreateRandomAccessStreamOverStream" , "ptr" , $PSTREAM , "int" , 0 , "struct*" , $TGUID , "ptr*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 4 ]
EndFunc
Func __UWPOCR_DELETEHSTRING ( $HSTRING )
	Local $ACALL = DllCall ( $__G_HUWPOCR_COMBASE , "long" , "WindowsDeleteString" , "ptr" , $HSTRING )
	If @error Or $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
#EndRegion Internal Utils Functions
Global $CURRFUNCNAME = ""
Global $MAXLENFUNCNAME = 0
Opt ( "GUIOnEventMode" , 1 )
#Region ### START Koda GUI section ### Form=C:\EVE\Form1.kxf
$FORM1 = GUICreate ( "EVE Echoes miner by Dru4" , 267 , 632 , 409 , 148 )
GUISetOnEvent ( $GUI_EVENT_CLOSE , "Form1Close" )
GUISetOnEvent ( $GUI_EVENT_MINIMIZE , "Form1Minimize" )
GUISetOnEvent ( $GUI_EVENT_MAXIMIZE , "Form1Maximize" )
GUISetOnEvent ( $GUI_EVENT_RESTORE , "Form1Restore" )
$BUTTON_ADBINJECT = GUICtrlCreateButton ( "Inject ADB" , 176 , 48 , 83 , 25 )
GUICtrlSetOnEvent ( + 4294967295 , "Button_ADBInjectClick" )
$BUTTON_STOP = GUICtrlCreateButton ( "STOP" , 8 , 48 , 163 , 25 )
GUICtrlSetColor ( + 4294967295 , 16711680 )
GUICtrlSetOnEvent ( + 4294967295 , "Button_STOPClick" )
$BUTTON_START = GUICtrlCreateButton ( "START" , 8 , 8 , 251 , 33 )
GUICtrlSetState ( $BUTTON_START , $GUI_DISABLE )
GUICtrlSetOnEvent ( + 4294967295 , "Button_STARTClick" )
$GROUP_STATISTICS = GUICtrlCreateGroup ( "Statistics" , 8 , 216 , 249 , 57 )
$LABEL_ASTEROIDWIPED = GUICtrlCreateLabel ( "Asteroid wiped: 0" , 16 , 232 , 117 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Label_AsteroidWipedClick" )
$LABEL_UNLOADINGCOUNT = GUICtrlCreateLabel ( "Unloading count: 0" , 16 , 248 , 126 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Label_UnloadingCountClick" )
$LABEL_CARGO = GUICtrlCreateLabel ( "Cargo: -" , 130 , 232 , 92 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Label_CargoClick" )
$LABEL_RATE = GUICtrlCreateLabel ( "Minutes for cycle: -" , 130 , 248 , 250 , 17 )
GUICtrlCreateGroup ( "" , + 4294967197 , + 4294967197 , 1 , 1 )
$GROUP1 = GUICtrlCreateGroup ( "doing" , 8 , 272 , 249 , 41 )
$LABEL_DOING = GUICtrlCreateLabel ( "" , 10 , 287 , 237 , 24 , $SS_CENTER )
GUICtrlSetOnEvent ( + 4294967295 , "Label_doingClick" )
GUICtrlCreateGroup ( "" , + 4294967197 , + 4294967197 , 1 , 1 )
$LABEL_LINK = GUICtrlCreateLabel ( "http://eve.dru4.ru/" , 128 , 553 , 126 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Label_linkClick" )
$LABEL_TIMELEFT = GUICtrlCreateLabel ( "" , 8 , 552 , 117 , 17 , $SS_CENTER )
GUICtrlSetOnEvent ( + 4294967295 , "Label_TimeLeftClick" )
$LABEL_ADBSTATUS = GUICtrlCreateLabel ( "ADB status: -" , 8 , 312 , 244 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Label_adbStatusClick" )
$CLV = GUICtrlCreateListView ( "Minerals priority" , 8 , 330 , 250 , 213 )
GUICtrlSendMsg ( + 4294967295 , $LVM_SETCOLUMNWIDTH , 0 , 50 )
$GROUPCONFIG = GUICtrlCreateGroup ( "Configuration" , 8 , 72 , 249 , 145 )
$CHECKBOX_NEEDCHECKOTHERSHIPS = GUICtrlCreateCheckbox ( "Check other ships" , 16 , 88 , 233 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Checkbox_NeedCheckOtherShipsClick" )
$CHECKBOX_NEEDCHECKLOCAL = GUICtrlCreateCheckbox ( "Check local chat" , 16 , 104 , 233 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Checkbox_NeedCheckLocalClick" )
$CHECKBOX_JUSTEYE = GUICtrlCreateCheckbox ( "JustEYE" , 16 , 144 , 233 , 17 )
GUICtrlSetState ( $CHECKBOX_JUSTEYE , $GUI_DISABLE )
$CHECKBOX_HIDINGNOWAIT = GUICtrlCreateCheckbox ( "No wait when hiding" , 16 , 160 , 233 , 17 )
GUICtrlSetOnEvent ( + 4294967295 , "Checkbox_HidingNoWaitClick" )
$COMBO1 = GUICtrlCreateCombo ( "go dock when finded" , 16 , 120 , 233 , 25 , BitOR ( $CBS_DROPDOWN , $CBS_AUTOHSCROLL ) )
GUICtrlSetData ( + 4294967295 , "neutrals + crime + enemy|crime + enemy|enemy" )
GUICtrlSetOnEvent ( + 4294967295 , "Combo1Change" )
$LABEL_THINGSONSHIP = GUICtrlCreateLabel ( "" , 16 , 192 , 236 , 20 )
GUICtrlCreateGroup ( "" , + 4294967197 , + 4294967197 , 1 , 1 )
$LABEL_LINKDISCORD = GUICtrlCreateLabel ( "https://discord.gg/PHbsW6FFFA" , 7 , 574 , 254 , 17 , $SS_CENTER )
GUICtrlSetOnEvent ( + 4294967295 , "Label_linkDiscordClick" )
$LABEL_PLAYERID = GUICtrlCreateLabel ( "Saved Player ID" , 7 , 591 , 254 , 17 , $SS_CENTER )
GUICtrlSetOnEvent ( + 4294967295 , "Label_linkDiscordClick" )
$LABEL_BOTSTATUS = GUICtrlCreateLabel ( "Click to buy" , 7 , 608 , 254 , 17 , $SS_CENTER )
GUICtrlSetOnEvent ( + 4294967295 , "Label_linkDiscordClick" )
GUISetState ( @SW_SHOW )
#EndRegion ### END Koda GUI section ###
GUISetState ( @SW_SHOW )
#EndRegion ### END Koda GUI section ###
_GUICTRLLISTVIEW_SETCOLUMNWIDTH ( $CLV , 0 , 175 )
Global $ATOM [ 17 ]
_GUILISTVIEWEX_MSGREGISTER ( )
#RequireAdmin
Opt ( "MouseClickDownDelay" , 80 )
Global $OMYERROR = ObjEvent ( "AutoIt.Error" , "MyErrFunc" )
Global $LOGFILE = @ScriptDir & "\logs\"
FileDelete ( @ScriptDir & "\OpenCV_Error.log" )
FileDelete ( @ScriptDir & "\OpenCV_Match.log" )
Global Const $INIFILE = @ScriptDir & "\conf.ini"
Global $DRAWRECT = 0
Global $HCONSOLEPID = 0
Global $CONSOLETYPE = 0
Global $ADB_SCREENSHOT = 1
Global $ADB_CLICK = 2
Global $ADB_TESTPASSED = 0
Global $SCREENSHOTINGTYPE = 0
Global $SCREENSHOTSIZECHECKDISABLE = 0
Global $CLICKTYPE = 0
Global $ADBCHECKTIMER = 0
Global $ADBTRANSPORTSERIAL = 0
Global $ADBFOLDER = "adb\adb.exe"
Global $EMULATORTYPE = 0
Global $SDKVER
Global $EMULATORPID = 0
Global $LESSSCREENSHOTSAVE = 1
Global $ADBERROR = 0
Global $SSTATMIN = 10000
Global $SSTATMAX = 0
Global $SSTATCOUNT = 0
Global $SSTATTOTALTIME = 0
Global $SSTATMAXTRYCOUNT = 0
Global $BOTTYPE = 0
Global $EYETIMER = 0
Global $EYETIMER_TIMEOUT = 0
Global $EYECYCLETIME = 15
Global $EYECYCLETIMEOUT = 10
Global $EYEPREVCHECKLOCAL = 0
Global $EYECHECKNEEDSEND = 1
Global $OBSTYPE = 0
Global $CHECKOTHERSHIPSTYPE = 1
Global $GETDOCKDIRECTIONTYPE = 0
Global $XBASE , $YBASE
Global $XBASE_REAL , $YBASE_REAL
Global $XWIDTH , $YHEIGHT
Global $USERID = 0
Global $BOT_STATUS = 0
Global $HIDING = 0
Global $CHECKLOCALRETREAT = 0
Global $FASTMINING = 1
Global $HIDINGNOWAIT = 0
Global $SETMAXCARGO = 97
Global $NEED_DOCKING = 0
Global $NEEDCHECKOTHERSHIPS = 0
Global $DONTNEEDCHECKOTHERSHIPS = 0
Global $NEEDCHECKLOCAL = 0
Global $CHECKLOCALPANICLEVEL = 0
Global $CHECKLOCALCOUNTER = 0
Global $CHECKLOCALCOUNTER_RND = 10
Global $CHECKNEEDSEND = 1
Global $FIRSTSWIPEASTER = 0
Global $BELTWARPFROMBELT = 0
Global $LASTASTEROIDCLUSTERNUMBER = 0
Global $NETEASEPID = 0
Global $GOHOMEPREPAREFIRSTRUN = 1
Global $TIMETOWARPCURRENT = 10660
Global $HIDE_COUNTER = 0
Global $USEMININGIMPLANT = 0
Global $STOPAFTERUNDOCK = 1
Global $USEMININGIMPLANTCONDENSED = 0
Global $PREFERBELTNUMBER = 0
Global $ADDITIONALHIDINGMIN = 2
Global $ADDITIONALHIDINGMAX = 5
Global $LOGDONTSAVEINFO = 0
Global $SHIP_ICO [ 12 ]
Global $SHIP_ICO_FILENAME [ 12 ]
Global $ANOMALYSMALL [ 12 ]
Global $ANOMALYMEDIUM [ 12 ]
Global $ANOMALYLARGE [ 12 ]
Global $ANOMALYANOMALY [ 12 ]
Global $CURRENTSCREENSHOTBITMAP
Global $JUSTUNDOCKED = 1
Global $CONDENSEDBELT = 0
Global $FAKE = 0
Global $FAKE1 = 0
Global $AN_IGNORELEVELS = 1
Global $AN_SECONDSWIPE = 0
Global $MAXTRYANOMALY = 22
Global $WEAPONTYPE = + 4294967295
Global $WEAPONSTATE = + 4294967295
Global $WEAPONCOORD [ 2 ]
Global $REPAIRTYPE = + 4294967295
Global $REPAIRSTATE = + 4294967295
Global $REPAIRCOORD [ 2 ]
Global $SHIPSHIELD = 100
Global $SHIPARMOR = 100
Global $SHIPHULL = 100
Global $SHIPENERGY = 100
Global $ALWAYSON [ 8 ] [ 2 ]
$ALWAYSON [ 0 ] [ 0 ] = + 4294967295
Global $ALWAYSONSTATE = + 4294967295
Global $WEBCOORD [ 8 ] [ 3 ]
$WEBCOORD [ 0 ] [ 0 ] = + 4294967295
Global $WEAPONBOOSTCOORD [ 8 ] [ 3 ]
$WEAPONBOOSTCOORD [ 0 ] [ 0 ] = + 4294967295
Global $WEAPONBOOSTREACTIVATIONTIME = 135
Global $WEAPONBOOSTACTIVATIONTIME = 22
Global $WEAPONBOOSTLASTACTIVATION = 0
Global $WEAPONBOOSTTIMER = 0
Global $BATTERYCOORD [ 2 ]
$BATTERYCOORD [ 0 ] = + 4294967295
Global $BATTERYREACTIVATIONTIME = 90
Global $BATTERYACTIVATIONTIME = 25
Global $BATTERYLASTACTIVATION = 0
Global $BATTERYTIMER = 0
Global $TRACKERCOMPCOORD [ 2 ]
$TRACKERCOMPCOORD [ 0 ] = + 4294967295
Global $TRACKERCOMPREACTIVATIONTIME = 60
Global $TRACKERCOMPACTIVATIONTIME = 10
Global $TRACKERCOMPLASTACTIVATION = 0
Global $TRACKERCOMPTIMER = 0
Global $WARPDISTANCE = 100
Global $SELECTANOMALYSIZE = 3
Global $MINERS_STATUS [ 3 ]
$MINERS_STATUS [ 0 ] = + 4294967295
$MINERS_STATUS [ 1 ] = + 4294967295
$MINERS_STATUS [ 2 ] = + 4294967295
Global $MINERS_COORD [ 3 ] [ 2 ]
Global $MINERS_SIZE = 0
Global $ASTEROIDS_LIST [ 12 ] [ 3 ]
Global $SHIP_LIST [ 18 ] [ 3 ]
Global $ASTEROIDS_BELT_LIST [ 12 ] [ 2 ]
Global $TELEGRAMTOKEN = ""
Global $TELEGRAMCHATID = 0
Global $DISCORDHOOK = ""
Global $CHECKLOCALPANELCOORD [ 2 ]
$CHECKLOCALPANELCOORD [ 0 ] = 0
$CHECKLOCALPANELCOORD [ 1 ] = 0
Global $LOCAL_IDS = 0
Global $ASTEROID_WIPED = 0
Global $ASTEROID_WIPED_LAST_SEND = 0
Global $UNLOADCOUNT = 0
Global $ASTEROIDRATE = 0
Global $TIMERFOR1CYCLE = 0
Global $LASTTIMEFOR1CYCLE = 0
Global $CURRENTTREASURE = 0
Global $TOTALTREASURE = 0
Global $STATTEXT = @CRLF & "Cycle #" & @TAB & "Time for it" & @TAB & "ISK in it" & @CRLF
Global $AFTERBURNER [ 3 ]
$AFTERBURNER [ 0 ] = + 4294967295
$AFTERBURNER [ 1 ] = + 4294967295
$AFTERBURNER [ 2 ] = + 4294967295
Global $BOTWINDOWMOVE = 0
Global $WARPSTABS [ 5 ] [ 2 ]
Global $GYROSTABS [ 5 ] [ 2 ]
Global $BLUESTACKFOLDER = RegRead ( "HKLM64\SOFTWARE\BlueStacks" , "InstallDir" )
Global $TESSERACTFOLDER = "Tesseract-OCR\"
Global $CURLFOLDER = "Curl\"
Global $REV
#AutoIt3Wrapper_UseX64=y
Global $__G_IBMPFORMAT = $GDIP_PXF24RGB
Global $__G_IJPGQUALITY = 100
Global $__G_ITIFCOLORDEPTH = 24
Global $__G_ITIFCOMPRESSION = $GDIP_EVTCOMPRESSIONLZW
Global Const $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0
Global Const $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 1
Global Const $__SCREENCAPTURECONSTANT_SRCCOPY = 13369376
Func _SCREENCAPTURE_CAPTURE ( $SFILENAME = "" , $ILEFT = 0 , $ITOP = 0 , $IRIGHT = + 4294967295 , $IBOTTOM = + 4294967295 , $BCURSOR = True )
	Local $BRET = False
	If $IRIGHT = + 4294967295 Then $IRIGHT = _WINAPI_GETSYSTEMMETRICS ( $__SCREENCAPTURECONSTANT_SM_CXSCREEN ) + 4294967295
	If $IBOTTOM = + 4294967295 Then $IBOTTOM = _WINAPI_GETSYSTEMMETRICS ( $__SCREENCAPTURECONSTANT_SM_CYSCREEN ) + 4294967295
	If $IRIGHT < $ILEFT Then Return SetError ( + 4294967295 , 0 , $BRET )
	If $IBOTTOM < $ITOP Then Return SetError ( + 4294967294 , 0 , $BRET )
	Local $IW = ( $IRIGHT - $ILEFT ) + 1
	Local $IH = ( $IBOTTOM - $ITOP ) + 1
	Local $HWND = _WINAPI_GETDESKTOPWINDOW ( )
	Local $HDDC = _WINAPI_GETDC ( $HWND )
	Local $HCDC = _WINAPI_CREATECOMPATIBLEDC ( $HDDC )
	Local $HBMP = _WINAPI_CREATECOMPATIBLEBITMAP ( $HDDC , $IW , $IH )
	_WINAPI_SELECTOBJECT ( $HCDC , $HBMP )
	_WINAPI_BITBLT ( $HCDC , 0 , 0 , $IW , $IH , $HDDC , $ILEFT , $ITOP , $__SCREENCAPTURECONSTANT_SRCCOPY )
	If $BCURSOR Then
		Local $ACURSOR = _WINAPI_GETCURSORINFO ( )
		If Not @error And $ACURSOR [ 1 ] Then
			$BCURSOR = True
			Local $HICON = _WINAPI_COPYICON ( $ACURSOR [ 2 ] )
			Local $AICON = _WINAPI_GETICONINFO ( $HICON )
			If Not @error Then
				_WINAPI_DELETEOBJECT ( $AICON [ 4 ] )
				If $AICON [ 5 ] <> 0 Then _WINAPI_DELETEOBJECT ( $AICON [ 5 ] )
				_WINAPI_DRAWICON ( $HCDC , $ACURSOR [ 3 ] - $AICON [ 2 ] - $ILEFT , $ACURSOR [ 4 ] - $AICON [ 3 ] - $ITOP , $HICON )
			EndIf
			_WINAPI_DESTROYICON ( $HICON )
		EndIf
	EndIf
	_WINAPI_RELEASEDC ( $HWND , $HDDC )
	_WINAPI_DELETEDC ( $HCDC )
	If $SFILENAME = "" Then Return $HBMP
	$BRET = _SCREENCAPTURE_SAVEIMAGE ( $SFILENAME , $HBMP , True )
	Return SetError ( @error , @extended , $BRET )
EndFunc
Func _SCREENCAPTURE_CAPTUREWND ( $SFILENAME , $HWND , $ILEFT = 0 , $ITOP = 0 , $IRIGHT = + 4294967295 , $IBOTTOM = + 4294967295 , $BCURSOR = True )
	If Not IsHWnd ( $HWND ) Then $HWND = WinGetHandle ( $HWND )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
	Local $BRET = DllCall ( "dwmapi.dll" , "long" , "DwmGetWindowAttribute" , "hwnd" , $HWND , "dword" , $DWMWA_EXTENDED_FRAME_BOUNDS , "struct*" , $TRECT , "dword" , DllStructGetSize ( $TRECT ) )
	If ( @error Or $BRET [ 0 ] Or ( Abs ( DllStructGetData ( $TRECT , "Left" ) ) + Abs ( DllStructGetData ( $TRECT , "Top" ) ) + Abs ( DllStructGetData ( $TRECT , "Right" ) ) + Abs ( DllStructGetData ( $TRECT , "Bottom" ) ) ) = 0 ) Then
		$TRECT = _WINAPI_GETWINDOWRECT ( $HWND )
		If @error Then Return SetError ( @error + 10 , @extended , False )
	EndIf
	$ILEFT += DllStructGetData ( $TRECT , "Left" )
	$ITOP += DllStructGetData ( $TRECT , "Top" )
	If $IRIGHT = + 4294967295 Then $IRIGHT = DllStructGetData ( $TRECT , "Right" ) - DllStructGetData ( $TRECT , "Left" ) + 4294967295
	If $IBOTTOM = + 4294967295 Then $IBOTTOM = DllStructGetData ( $TRECT , "Bottom" ) - DllStructGetData ( $TRECT , "Top" ) + 4294967295
	$IRIGHT += DllStructGetData ( $TRECT , "Left" )
	$IBOTTOM += DllStructGetData ( $TRECT , "Top" )
	If $ILEFT > DllStructGetData ( $TRECT , "Right" ) Then $ILEFT = DllStructGetData ( $TRECT , "Left" )
	If $ITOP > DllStructGetData ( $TRECT , "Bottom" ) Then $ITOP = DllStructGetData ( $TRECT , "Top" )
	If $IRIGHT > DllStructGetData ( $TRECT , "Right" ) Then $IRIGHT = DllStructGetData ( $TRECT , "Right" ) + 4294967295
	If $IBOTTOM > DllStructGetData ( $TRECT , "Bottom" ) Then $IBOTTOM = DllStructGetData ( $TRECT , "Bottom" ) + 4294967295
	$BRET = _SCREENCAPTURE_CAPTURE ( $SFILENAME , $ILEFT , $ITOP , $IRIGHT , $IBOTTOM , $BCURSOR )
	Return SetError ( @error , @extended , $BRET )
EndFunc
Func _SCREENCAPTURE_SAVEIMAGE ( $SFILENAME , $HBITMAP , $BFREEBMP = True )
	_GDIPLUS_STARTUP ( )
	If @error Then Return SetError ( + 4294967295 , + 4294967295 , False )
	Local $SEXT = StringUpper ( __GDIPLUS_EXTRACTFILEEXT ( $SFILENAME ) )
	Local $SCLSID = _GDIPLUS_ENCODERSGETCLSID ( $SEXT )
	If $SCLSID = "" Then Return SetError ( + 4294967294 , + 4294967294 , False )
	Local $HIMAGE = _GDIPLUS_BITMAPCREATEFROMHBITMAP ( $HBITMAP )
	If @error Then Return SetError ( + 4294967293 , + 4294967293 , False )
	Local $TDATA , $TPARAMS
	Switch $SEXT
	Case "BMP"
		Local $IX = _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE )
		Local $IY = _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE )
		Local $HCLONE = _GDIPLUS_BITMAPCLONEAREA ( $HIMAGE , 0 , 0 , $IX , $IY , $__G_IBMPFORMAT )
		_GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
		$HIMAGE = $HCLONE
	Case "JPG" , "JPEG"
		$TPARAMS = _GDIPLUS_PARAMINIT ( 1 )
		$TDATA = DllStructCreate ( "int Quality" )
		DllStructSetData ( $TDATA , "Quality" , $__G_IJPGQUALITY )
		_GDIPLUS_PARAMADD ( $TPARAMS , $GDIP_EPGQUALITY , 1 , $GDIP_EPTLONG , DllStructGetPtr ( $TDATA ) )
	Case "TIF" , "TIFF"
		$TPARAMS = _GDIPLUS_PARAMINIT ( 2 )
		$TDATA = DllStructCreate ( "int ColorDepth;int Compression" )
		DllStructSetData ( $TDATA , "ColorDepth" , $__G_ITIFCOLORDEPTH )
		DllStructSetData ( $TDATA , "Compression" , $__G_ITIFCOMPRESSION )
		_GDIPLUS_PARAMADD ( $TPARAMS , $GDIP_EPGCOLORDEPTH , 1 , $GDIP_EPTLONG , DllStructGetPtr ( $TDATA , "ColorDepth" ) )
		_GDIPLUS_PARAMADD ( $TPARAMS , $GDIP_EPGCOMPRESSION , 1 , $GDIP_EPTLONG , DllStructGetPtr ( $TDATA , "Compression" ) )
	EndSwitch
	Local $PPARAMS = 0
	If IsDllStruct ( $TPARAMS ) Then $PPARAMS = $TPARAMS
	Local $BRET = _GDIPLUS_IMAGESAVETOFILEEX ( $HIMAGE , $SFILENAME , $SCLSID , $PPARAMS )
	_GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
	If $BFREEBMP Then _WINAPI_DELETEOBJECT ( $HBITMAP )
	_GDIPLUS_SHUTDOWN ( )
	Return SetError ( $BRET = False , 0 , $BRET )
EndFunc
Func _SCREENCAPTURE_SETBMPFORMAT ( $IFORMAT )
	Switch $IFORMAT
	Case 0
		$__G_IBMPFORMAT = $GDIP_PXF16RGB555
	Case 1
		$__G_IBMPFORMAT = $GDIP_PXF16RGB565
	Case 2
		$__G_IBMPFORMAT = $GDIP_PXF24RGB
	Case 3
		$__G_IBMPFORMAT = $GDIP_PXF32RGB
	Case 4
		$__G_IBMPFORMAT = $GDIP_PXF32ARGB
Case Else
		$__G_IBMPFORMAT = $GDIP_PXF24RGB
	EndSwitch
EndFunc
Func _SCREENCAPTURE_SETJPGQUALITY ( $IQUALITY )
	If $IQUALITY < 0 Then $IQUALITY = 0
	If $IQUALITY > 100 Then $IQUALITY = 100
	$__G_IJPGQUALITY = $IQUALITY
EndFunc
Func _SCREENCAPTURE_SETTIFCOLORDEPTH ( $IDEPTH )
	Switch $IDEPTH
	Case 24
		$__G_ITIFCOLORDEPTH = 24
	Case 32
		$__G_ITIFCOLORDEPTH = 32
Case Else
		$__G_ITIFCOLORDEPTH = 0
	EndSwitch
EndFunc
Func _SCREENCAPTURE_SETTIFCOMPRESSION ( $ICOMPRESS )
	Switch $ICOMPRESS
	Case 1
		$__G_ITIFCOMPRESSION = $GDIP_EVTCOMPRESSIONNONE
	Case 2
		$__G_ITIFCOMPRESSION = $GDIP_EVTCOMPRESSIONLZW
Case Else
		$__G_ITIFCOMPRESSION = 0
	EndSwitch
EndFunc
Global $OPENCV_MATCHLOGGING = False , $OPENCV_ERRORLOGGING = False , $OPENCV_AUTOITCONSOLELOGGING = False
Global $_OPENCV_CORE , $_OPENCV_HIGHGUI , $_OPENCV_IMGPROC
_GDIPLUS_STARTUP ( )
Func _CLICKMOUSE ( $COORDINATES , $MOUSE_BUTTON = "left" , $NUMBER_OF_CLICKS = 1 )
	MouseUp ( "" )
	BlockInput ( 1 )
	MouseClick ( $MOUSE_BUTTON , ( $COORDINATES [ 0 ] + $COORDINATES [ 2 ] ) / 2 , ( $COORDINATES [ 1 ] + $COORDINATES [ 3 ] ) / 2 , $NUMBER_OF_CLICKS , 0 )
	BlockInput ( 0 )
EndFunc
Func _MATCHPICTURE ( $MATCH_PIC , $THRESHOLD = 0.9 , $CUSTOMCORDS = False , $LOOPCOUNT = 1 , $LOOPWAIT = 2000 , $LOAD_PIC = 0 )
	If $LESSSCREENSHOTSAVE = 1 Then $LOAD_PIC = 0
	If IsArray ( $CUSTOMCORDS ) Then
		If $CUSTOMCORDS [ 0 ] >= $CUSTOMCORDS [ 2 ] Or $CUSTOMCORDS [ 1 ] >= $CUSTOMCORDS [ 3 ] Then
			_INTERNAL_ERRORLOGGER ( "Negative coords found! " )
			Return SetError ( 1 )
		EndIf
	EndIf
	If Not FileExists ( $MATCH_PIC ) Then
		_INTERNAL_ERRORLOGGER ( "Match Image not found: " & $MATCH_PIC )
		LOGFATAL ( "!!! Match Image not found: " & $MATCH_PIC & @CRLF )
		Return SetError ( 1 )
	EndIf
	If $LOOPCOUNT <= 0 Then
		LOGFATAL ( "Error: $LoopCount Variable set to 0. At least 1 is required." )
		Return SetError ( 1 )
	EndIf
	Local $HBITMAP
	Local $PERF = TimerInit ( )
	Local $HMATCH_PIC = _CVLOADIMAGE ( $MATCH_PIC )
	Local $HMATCH_SIZE = _CVGETSIZE ( $HMATCH_PIC )
	Local $WIDTH2 = DllStructGetData ( $HMATCH_SIZE , "width" )
	Local $HEIGHT2 = DllStructGetData ( $HMATCH_SIZE , "height" )
	Local $SCREENSIZE = _SCREENSIZE ( )
	For $ITRIES = 1 To $LOOPCOUNT Step + 1
		If Not $LOAD_PIC Then
			If 0 Then ConsoleWrite ( "Load from memory start ... " )
			Local $BITMAP = $CURRENTSCREENSHOTBITMAP
			If 0 Then ConsoleWrite ( "complete." & @CRLF )
		Else
			If Not FileExists ( $LOAD_PIC ) Then
				LOGFATAL ( "Load Image not found: " & $LOAD_PIC & @CRLF )
				_INTERNAL_ERRORLOGGER ( "Load Image not found: " & $LOAD_PIC )
				Return SetError ( 1 )
			EndIf
			Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( $LOAD_PIC )
		EndIf
		If 0 Then ConsoleWrite ( "WLo:" & _GDIPLUS_IMAGEGETWIDTH ( $BITMAP ) & " HLo:" & _GDIPLUS_IMAGEGETHEIGHT ( $BITMAP ) & @CRLF )
		If IsArray ( $CUSTOMCORDS ) Then
			Local $TMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , $CUSTOMCORDS [ 0 ] , $CUSTOMCORDS [ 1 ] , $CUSTOMCORDS [ 2 ] - $CUSTOMCORDS [ 0 ] , $CUSTOMCORDS [ 3 ] - $CUSTOMCORDS [ 1 ] )
			Local $HMAIN_PIC = _OPENCV_BMP2IPL ( $TMPBITMAP )
			_GDIPLUS_BITMAPDISPOSE ( $TMPBITMAP )
		Else
			Local $HMAIN_PIC = _OPENCV_BMP2IPL ( $BITMAP )
		EndIf
		Local $HMAIN_SIZE = _CVGETSIZE ( $HMAIN_PIC )
		Local $WIDTH = DllStructGetData ( $HMAIN_SIZE , "width" )
		Local $HEIGHT = DllStructGetData ( $HMAIN_SIZE , "height" )
		Local $RW = $WIDTH - $WIDTH2 + 1
		Local $RH = $HEIGHT - $HEIGHT2 + 1
		Local $TMAXLOC = DllStructCreate ( "int x;" & "int y;" )
		Local $TMINLOC = DllStructCreate ( "int x;" & "int y;" )
		Local $TMAXVAL = DllStructCreate ( "double max;" )
		Local $TMINVAL = DllStructCreate ( "double min;" )
		Local $PMAXLOC = DllStructGetPtr ( $TMAXLOC )
		Local $PMINLOC = DllStructGetPtr ( $TMINLOC )
		Local $PMAXVAL = DllStructGetPtr ( $TMAXVAL )
		Local $PMINVAL = DllStructGetPtr ( $TMINVAL )
		Local $PRESULT = _CVCREATEMAT ( $RH , $RW , 5 )
		_CVMATCHTEMPLATE ( $HMAIN_PIC , $HMATCH_PIC , $PRESULT , 5 )
		_CVTHRESHOLD ( $PRESULT , $PRESULT , $THRESHOLD , 1 , 0 )
		_CVMINMAXLOC ( $PRESULT , $PMINVAL , $PMAXVAL , $PMINLOC , $PMAXLOC , Null )
		Local $COORDINATES [ 4 ]
		If IsArray ( $CUSTOMCORDS ) Then
			$COORDINATES [ 0 ] = DllStructGetData ( $TMAXLOC , "x" ) + $CUSTOMCORDS [ 0 ]
			$COORDINATES [ 1 ] = DllStructGetData ( $TMAXLOC , "y" ) + $CUSTOMCORDS [ 1 ]
			$COORDINATES [ 2 ] = DllStructGetData ( $TMAXLOC , "x" ) + $WIDTH2 + $CUSTOMCORDS [ 0 ]
			$COORDINATES [ 3 ] = DllStructGetData ( $TMAXLOC , "y" ) + $HEIGHT2 + $CUSTOMCORDS [ 1 ]
		Else
			$COORDINATES [ 0 ] = DllStructGetData ( $TMAXLOC , "x" )
			$COORDINATES [ 1 ] = DllStructGetData ( $TMAXLOC , "y" )
			$COORDINATES [ 2 ] = DllStructGetData ( $TMAXLOC , "x" ) + $WIDTH2
			$COORDINATES [ 3 ] = DllStructGetData ( $TMAXLOC , "y" ) + $HEIGHT2
		EndIf
		_CVRELEASEMAT ( $PRESULT )
		_CVRELEASEIMAGE ( $HMAIN_PIC )
		If Not ( DllStructGetData ( $TMAXLOC , "x" ) = 0 And DllStructGetData ( $TMAXLOC , "y" ) = 0 And $WIDTH2 = DllStructGetData ( $TMAXLOC , "x" ) + $WIDTH2 And $HEIGHT2 = DllStructGetData ( $TMAXLOC , "y" ) + $HEIGHT2 ) Then
			_CVRELEASEIMAGE ( $HMATCH_PIC )
			_INTERNAL_MATCHLOGGER ( "Match found at: " & $COORDINATES [ 0 ] & "|" & $COORDINATES [ 1 ] & "|" & $COORDINATES [ 2 ] & "|" & $COORDINATES [ 3 ] & " // Threshold: " & $THRESHOLD & " // Total check time: " & Round ( TimerDiff ( $PERF ) , 0 ) & " ms" )
			Return $COORDINATES
		EndIf
		Sleep ( $LOOPWAIT )
	Next
	_CVRELEASEIMAGE ( $HMATCH_PIC )
	_INTERNAL_ERRORLOGGER ( "No match found. Loop counter: " & $LOOPCOUNT & ". // Total check time: " & Round ( TimerDiff ( $PERF ) , 0 ) & " ms // Threshold: " & $THRESHOLD & " // Match Image: " & $MATCH_PIC )
	Return SetError ( 2 )
EndFunc
Func _OPENCV_ENABLELOGGING ( $MATCHLOGGING = True , $ERRORLOGGING = False , $AUTOITCONSOLELOGGING = False )
	$OPENCV_MATCHLOGGING = $MATCHLOGGING
	$OPENCV_ERRORLOGGING = $ERRORLOGGING
	$OPENCV_AUTOITCONSOLELOGGING = $AUTOITCONSOLELOGGING
EndFunc
Func _MARKMATCH ( $COORDINATES , $ICOLOR = 255 )
	Local $START_X = $COORDINATES [ 0 ] , $START_Y = $COORDINATES [ 1 ] , $IWIDTH = $COORDINATES [ 2 ] , $IHEIGHT = $COORDINATES [ 3 ]
	Local $HDC = _WINAPI_GETWINDOWDC ( 0 )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , 1 , $START_X )
	DllStructSetData ( $TRECT , 2 , $START_Y )
	DllStructSetData ( $TRECT , 3 , $IWIDTH )
	DllStructSetData ( $TRECT , 4 , $IHEIGHT )
	Local $HBRUSH = _WINAPI_CREATESOLIDBRUSH ( $ICOLOR )
	_WINAPI_FRAMERECT ( $HDC , DllStructGetPtr ( $TRECT ) , $HBRUSH )
	_WINAPI_DELETEOBJECT ( $HBRUSH )
	_WINAPI_RELEASEDC ( 0 , $HDC )
EndFunc
Func _SCREENSIZE ( )
	Local $MONSIZEPOS [ 2 ] , $MONNUMB = 1
	$MONSIZEPOS [ 0 ] = @DesktopWidth
	$MONSIZEPOS [ 1 ] = @DesktopHeight
	Local $APOS , $MONLIST = _WINAPI_ENUMDISPLAYMONITORS ( )
	If @error Then Return $MONSIZEPOS
	If IsArray ( $MONLIST ) Then
		ReDim $MONLIST [ $MONLIST [ 0 ] [ 0 ] + 1 ] [ 5 ]
		For $I = 1 To $MONLIST [ 0 ] [ 0 ]
			$APOS = _WINAPI_GETPOSFROMRECT ( $MONLIST [ $I ] [ 1 ] )
			For $J = 0 To 3
				$MONLIST [ $I ] [ $J + 1 ] = $APOS [ $J ]
			Next
			Local $WIDTH = $MONLIST [ $I ] [ 1 ] + $MONLIST [ $I ] [ 3 ]
			Local $HEIGHT = ( $MONLIST [ $I ] [ 2 ] + $MONLIST [ $I ] [ 4 ] )
			If $MONSIZEPOS [ 0 ] < ( $WIDTH ) Then $MONSIZEPOS [ 0 ] = $WIDTH
			If $MONSIZEPOS [ 1 ] < ( $HEIGHT ) Then $MONSIZEPOS [ 1 ] = $HEIGHT
		Next
	EndIf
	Return $MONSIZEPOS
EndFunc
Func _INTERNAL_MATCHLOGGER ( $MESSAGE )
	Local $TIMESTAMP = @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " - "
	If $OPENCV_AUTOITCONSOLELOGGING Then ConsoleWrite ( $TIMESTAMP & $MESSAGE & @CRLF )
	If $OPENCV_MATCHLOGGING Then
		Local $MATCHLOGFILE = FileOpen ( @ScriptDir & "\OpenCV_Match.log" , 1 )
		FileWrite ( $MATCHLOGFILE , $TIMESTAMP & $MESSAGE & @CRLF )
		FileClose ( $MATCHLOGFILE )
	EndIf
EndFunc
Func _INTERNAL_ERRORLOGGER ( $MESSAGE )
	Local $TIMESTAMP = @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " - "
	If $OPENCV_AUTOITCONSOLELOGGING Then ConsoleWrite ( $TIMESTAMP & $MESSAGE & @CRLF )
	If $OPENCV_ERRORLOGGING Then
		Local $ERRORLOGFILE = FileOpen ( @ScriptDir & "\OpenCV_Error.log" , 1 )
		FileWrite ( $ERRORLOGFILE , $TIMESTAMP & $MESSAGE & @CRLF )
		FileClose ( $ERRORLOGFILE )
	EndIf
EndFunc
Func _OPENCV_BMP2IPL ( $PBMPIMAGE )
	Local $IW = _GDIPLUS_IMAGEGETWIDTH ( $PBMPIMAGE ) , $IH = _GDIPLUS_IMAGEGETHEIGHT ( $PBMPIMAGE )
	Local $TBITMAPDATA = _GDIPLUS_BITMAPLOCKBITS ( $PBMPIMAGE , 0 , 0 , $IW , $IH , $GDIP_ILMREAD , $GDIP_PXF32ARGB )
	Local $PIPL = _CVCREATEIMAGEHEADER ( _CVSIZE ( $IW , $IH ) , 8 , 4 )
	_CVSETDATA ( $PIPL , DllStructGetData ( $TBITMAPDATA , "scan0" ) , DllStructGetData ( $TBITMAPDATA , "stride" ) )
	Local $PIPLDST = _CVCLONEIMAGE ( $PIPL )
	_CVRELEASEIMAGEHEADER ( $PIPL )
	_GDIPLUS_BITMAPUNLOCKBITS ( $PBMPIMAGE , $TBITMAPDATA )
	Local $PIPLDST2 = _CVCREATEIMAGE ( _CVSIZE ( $IW , $IH ) , 8 , 3 )
	_CVCVTCOLOR ( $PIPLDST , $PIPLDST2 , 1 )
	_CVRELEASEIMAGE ( $PIPLDST )
	Return $PIPLDST2
EndFunc
Func _CVCVTCOLOR ( $CVSRC , $CVDST , $CVCODE )
	DllCall ( $_OPENCV_IMGPROC , "none:cdecl" , "cvCvtColor" , "ptr" , $CVSRC , "ptr" , $CVDST , "int" , $CVCODE )
	If @error Then ConsoleWrite ( "error in cvCvtColor" )
	Return
EndFunc
Func _CVCREATEIMAGE ( $CVSIZE , $CVDEPTH , $CVCHANNELS )
	Local $_ARESULT = DllCall ( $_OPENCV_CORE , "ptr:cdecl" , "cvCreateImage" , "struct" , $CVSIZE , "int" , $CVDEPTH , "int" , $CVCHANNELS )
	If @error Then ConsoleWrite ( "error in cvCreateImage" )
	Return $_ARESULT [ 0 ]
EndFunc
Func _CVRELEASEIMAGEHEADER ( $CVIMAGE )
	DllCall ( $_OPENCV_CORE , "none:cdecl" , "cvReleaseImageHeader" , "ptr*" , $CVIMAGE )
	If @error Then ConsoleWrite ( "error in cvReleaseImageHeader" )
	Return
EndFunc
Func _CVCLONEIMAGE ( $CVIMAGE )
	Local $_ARESULT = DllCall ( $_OPENCV_CORE , "ptr:cdecl" , "cvCloneImage" , "ptr" , $CVIMAGE )
	If @error Then ConsoleWrite ( "error in cvCloneImage" )
	Return $_ARESULT [ 0 ]
EndFunc
Func _CVSETDATA ( $CVARR , $CVDATA , $CVSTEP )
	DllCall ( $_OPENCV_CORE , "none:cdecl" , "cvSetData" , "ptr" , $CVARR , "ptr" , $CVDATA , "int" , $CVSTEP )
	If @error Then ConsoleWrite ( "error in cvSetData" )
	Return
EndFunc
Func _CVSIZE ( $WIDTH , $HEIGHT )
	Local $VSIZE = DllStructCreate ( "int width;" & "int height;" )
	DllStructSetData ( $VSIZE , "width" , $WIDTH )
	DllStructSetData ( $VSIZE , "height" , $HEIGHT )
	Return $VSIZE
EndFunc
Func _CVCREATEIMAGEHEADER ( $CVSIZE , $CVDEPTH , $CVCHANNELS )
	Local $_ARESULT = DllCall ( $_OPENCV_CORE , "ptr:cdecl" , "cvCreateImageHeader" , "struct" , $CVSIZE , "int" , $CVDEPTH , "int" , $CVCHANNELS )
	If @error Then ConsoleWrite ( "error in cvCreateImageHeader" )
	Return $_ARESULT [ 0 ]
EndFunc
Func _CVMINMAXLOC ( $CVARR , $CVMIN_VAL , $CVMAX_VAL , $CVMIN_LOC , $CVMAX_LOC , $CVMASK = "" )
	DllCall ( $_OPENCV_CORE , "none:cdecl" , "cvMinMaxLoc" , "ptr" , $CVARR , "ptr" , $CVMIN_VAL , "ptr" , $CVMAX_VAL , "ptr" , $CVMIN_LOC , "ptr" , $CVMAX_LOC , "ptr" , $CVMASK )
	If @error Then ConsoleWrite ( "error in cvMinMaxLoc" )
	Return
EndFunc
Func _CVMATCHTEMPLATE ( $CVIMAGE , $CVTEMPL , $CVRESULT , $CVMETHOD )
	DllCall ( $_OPENCV_IMGPROC , "none:cdecl" , "cvMatchTemplate" , "ptr" , $CVIMAGE , "ptr" , $CVTEMPL , "ptr" , $CVRESULT , "int" , $CVMETHOD )
	If @error Then ConsoleWrite ( "error in cvMatchTemplate" )
	Return
EndFunc
Func _CVTHRESHOLD ( $CVSRC , $CVDST , $CVTHRESHOLD , $CVMAX_VALUE , $CVTHRESHOLD_TYPE )
	Local $_ARESULT = DllCall ( $_OPENCV_IMGPROC , "double:cdecl" , "cvThreshold" , "ptr" , $CVSRC , "ptr" , $CVDST , "double" , $CVTHRESHOLD , "double" , $CVMAX_VALUE , "int" , $CVTHRESHOLD_TYPE )
	If @error Then ConsoleWrite ( "error in cvThreshold" )
	Return
EndFunc
Func _CVCREATEMAT ( $CVROWS , $CVCOLS , $CVTYPE )
	Local $_ARESULT = DllCall ( $_OPENCV_CORE , "ptr:cdecl" , "cvCreateMat" , "int" , $CVROWS , "int" , $CVCOLS , "int" , $CVTYPE )
	If @error Then ConsoleWrite ( "error in cvCreateMat" )
	Return $_ARESULT [ 0 ]
EndFunc
Func _CVGETSIZE ( $PIMAGE )
	Local $_ARESULT = DllCall ( $_OPENCV_CORE , "int64:cdecl" , "cvGetSize" , "ptr" , $PIMAGE )
	If @error Then ConsoleWrite ( "error csize image " )
	Local $WIDTH = BitAND ( 4294967295 , $_ARESULT [ 0 ] )
	Local $HEIGHT = Int ( $_ARESULT [ 0 ] / 2 ^ 32 )
	Local $VSIZE = DllStructCreate ( "int width;" & "int height;" )
	DllStructSetData ( $VSIZE , "width" , $WIDTH )
	DllStructSetData ( $VSIZE , "height" , $HEIGHT )
	Return $VSIZE
EndFunc
Func _CVRELEASEMAT ( $CVMAT )
	DllCall ( $_OPENCV_CORE , "none:cdecl" , "cvReleaseMat" , "ptr*" , $CVMAT )
	If @error Then ConsoleWrite ( "error in cvReleaseMat" )
	Return
EndFunc
Func _CVRELEASEIMAGE ( $PIMAGE )
	DllCall ( $_OPENCV_CORE , "none:cdecl" , "cvReleaseImage" , "ptr*" , $PIMAGE )
	If @error Then ConsoleWrite ( "error image release" )
EndFunc
Func _CVLOADIMAGE ( $FILENAME , $ISCOLOR = 1 )
	If $FILENAME = "" Then
		ConsoleWrite ( "File not loading: " & $FILENAME & @CRLF )
		Return SetError ( 1 )
	EndIf
	$_ARESULT = DllCall ( $_OPENCV_HIGHGUI , "int:cdecl" , "cvLoadImage" , "str" , $FILENAME , "int" , $ISCOLOR )
	If @error Then ConsoleWrite ( "File not loading: " & @error )
	If Not IsArray ( $_ARESULT ) Then
		MsgBox ( 16 , "Error" , "Failed loading OpenCV DLLs." )
		_OPENCV_SHUTDOWN ( )
		Exit
	EndIf
	Return $_ARESULT [ 0 ]
EndFunc
Func _CVHOUGHCIRCLES ( $CVIMAGE , $CVRESULT , $CVMETHOD , $DP , $MINDIST , $PARAM1 = 100 , $PARAM2 = 100 , $MINRADIUS = 0 , $MAXRADIUS = 0 )
	DllCall ( $_OPENCV_IMGPROC , "none:cdecl" , "cvHoughCircles" , "ptr" , $CVIMAGE , "ptr" , $CVRESULT , "int" , $CVMETHOD , "double" , $DP , "double" , $MINDIST , "double" , $PARAM1 , "double" , $PARAM2 , "int" , $MINRADIUS , "int" , $MAXRADIUS )
	If @error Then ConsoleWrite ( "error in cvHoughCircles" )
	Return
EndFunc
Func _OPENCV_SHUTDOWN ( )
	DllClose ( $_OPENCV_CORE )
	DllClose ( $_OPENCV_HIGHGUI )
	DllClose ( $_OPENCV_IMGPROC )
	_GDIPLUS_SHUTDOWN ( )
EndFunc
Func _OPENCV_STARTUP ( )
	$_OPENCV_CORE = DllOpen ( "OpenCV\DLLs\opencv_core2413.dll" )
	$_OPENCV_HIGHGUI = DllOpen ( "OpenCV\DLLs\opencv_highgui2413.dll" )
	$_OPENCV_IMGPROC = DllOpen ( "OpenCV\DLLs\opencv_imgproc2413.dll" )
EndFunc
Func OPENCVFIND ( $MATCH_PIC , $XS , $YS , $XE , $YE , ByRef $X1 , ByRef $Y1 , $THRESHOLD = 0.9 , $LOOPCOUNT = 1 , $LOOPWAIT = 2000 , $LOAD_PIC = 0 )
	Local $MATCH [ 2 ]
	Local $SCOORDS [ 4 ] = [ $XS , $YS , $XE , $YE ]
	$MATCH = _MATCHPICTURE ( $MATCH_PIC , $THRESHOLD , $SCOORDS , $LOOPCOUNT , $LOOPWAIT , $LOAD_PIC )
	If Not @error Then
		$X1 = ( $MATCH [ 0 ] + $MATCH [ 2 ] ) / 2
		$Y1 = ( $MATCH [ 1 ] + $MATCH [ 3 ] ) / 2
		Return 1
	Else
		Return 0
	EndIf
EndFunc
Func OPENCVFINDPIC ( $MATCH_PIC , ByRef $X1 , ByRef $Y1 , $THRESHOLD = 0.9 , $LOAD_PIC = 0 , $XS = 0 , $YS = 0 , $XE = 0 , $YE = 0 )
	Local $MATCH [ 2 ]
	Local $SCOORDS [ 4 ] = [ $XS , $YS , $XE , $YE ]
	If ( $XS = 0 And $YS = 0 And $XE = 0 And $YE = 0 ) Then
		$MATCH = _MATCHPICTURE ( $MATCH_PIC , $THRESHOLD , "" , 1 , 0 , $LOAD_PIC )
	Else
		$MATCH = _MATCHPICTURE ( $MATCH_PIC , $THRESHOLD , $SCOORDS , 1 , 0 , $LOAD_PIC )
	EndIf
	If Not @error Then
		$X1 = ( $MATCH [ 0 ] + $MATCH [ 2 ] ) / 2
		$Y1 = ( $MATCH [ 1 ] + $MATCH [ 3 ] ) / 2
		Return 1
	Else
		Return 0
	EndIf
EndFunc
Global Const $INTERNET_DEFAULT_PORT = 0
Global Const $INTERNET_DEFAULT_HTTP_PORT = 80
Global Const $INTERNET_DEFAULT_HTTPS_PORT = 443
Global Const $INTERNET_SCHEME_HTTP = 1
Global Const $INTERNET_SCHEME_HTTPS = 2
Global Const $INTERNET_SCHEME_FTP = 3
Global Const $ICU_ESCAPE = 2147483648
Global Const $WINHTTP_FLAG_ASYNC = 268435456
Global Const $WINHTTP_FLAG_ESCAPE_PERCENT = 4
Global Const $WINHTTP_FLAG_NULL_CODEPAGE = 8
Global Const $WINHTTP_FLAG_ESCAPE_DISABLE = 64
Global Const $WINHTTP_FLAG_ESCAPE_DISABLE_QUERY = 128
Global Const $WINHTTP_FLAG_BYPASS_PROXY_CACHE = 256
Global Const $WINHTTP_FLAG_REFRESH = $WINHTTP_FLAG_BYPASS_PROXY_CACHE
Global Const $WINHTTP_FLAG_SECURE = 8388608
Global Const $WINHTTP_ACCESS_TYPE_DEFAULT_PROXY = 0
Global Const $WINHTTP_ACCESS_TYPE_NO_PROXY = 1
Global Const $WINHTTP_ACCESS_TYPE_NAMED_PROXY = 3
Global Const $WINHTTP_NO_PROXY_NAME = ""
Global Const $WINHTTP_NO_PROXY_BYPASS = ""
Global Const $WINHTTP_NO_REFERER = ""
Global Const $WINHTTP_DEFAULT_ACCEPT_TYPES = 0
Global Const $WINHTTP_NO_ADDITIONAL_HEADERS = ""
Global Const $WINHTTP_NO_REQUEST_DATA = ""
Global Const $WINHTTP_HEADER_NAME_BY_INDEX = ""
Global Const $WINHTTP_NO_OUTPUT_BUFFER = 0
Global Const $WINHTTP_NO_HEADER_INDEX = 0
Global Const $WINHTTP_ADDREQ_INDEX_MASK = 65535
Global Const $WINHTTP_ADDREQ_FLAGS_MASK = 4294901760
Global Const $WINHTTP_ADDREQ_FLAG_ADD_IF_NEW = 268435456
Global Const $WINHTTP_ADDREQ_FLAG_ADD = 536870912
Global Const $WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA = 1073741824
Global Const $WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON = 16777216
Global Const $WINHTTP_ADDREQ_FLAG_COALESCE = $WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
Global Const $WINHTTP_ADDREQ_FLAG_REPLACE = 2147483648
Global Const $WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH = 0
Global Const $WINHTTP_OPTION_CALLBACK = 1
Global Const $WINHTTP_FIRST_OPTION = $WINHTTP_OPTION_CALLBACK
Global Const $WINHTTP_OPTION_RESOLVE_TIMEOUT = 2
Global Const $WINHTTP_OPTION_CONNECT_TIMEOUT = 3
Global Const $WINHTTP_OPTION_CONNECT_RETRIES = 4
Global Const $WINHTTP_OPTION_SEND_TIMEOUT = 5
Global Const $WINHTTP_OPTION_RECEIVE_TIMEOUT = 6
Global Const $WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT = 7
Global Const $WINHTTP_OPTION_HANDLE_TYPE = 9
Global Const $WINHTTP_OPTION_READ_BUFFER_SIZE = 12
Global Const $WINHTTP_OPTION_WRITE_BUFFER_SIZE = 13
Global Const $WINHTTP_OPTION_PARENT_HANDLE = 21
Global Const $WINHTTP_OPTION_EXTENDED_ERROR = 24
Global Const $WINHTTP_OPTION_SECURITY_FLAGS = 31
Global Const $WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT = 32
Global Const $WINHTTP_OPTION_URL = 34
Global Const $WINHTTP_OPTION_SECURITY_KEY_BITNESS = 36
Global Const $WINHTTP_OPTION_PROXY = 38
Global Const $WINHTTP_OPTION_USER_AGENT = 41
Global Const $WINHTTP_OPTION_CONTEXT_VALUE = 45
Global Const $WINHTTP_OPTION_CLIENT_CERT_CONTEXT = 47
Global Const $WINHTTP_OPTION_REQUEST_PRIORITY = 58
Global Const $WINHTTP_OPTION_HTTP_VERSION = 59
Global Const $WINHTTP_OPTION_DISABLE_FEATURE = 63
Global Const $WINHTTP_OPTION_CODEPAGE = 68
Global Const $WINHTTP_OPTION_MAX_CONNS_PER_SERVER = 73
Global Const $WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER = 74
Global Const $WINHTTP_OPTION_AUTOLOGON_POLICY = 77
Global Const $WINHTTP_OPTION_SERVER_CERT_CONTEXT = 78
Global Const $WINHTTP_OPTION_ENABLE_FEATURE = 79
Global Const $WINHTTP_OPTION_WORKER_THREAD_COUNT = 80
Global Const $WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT = 81
Global Const $WINHTTP_OPTION_PASSPORT_COBRANDING_URL = 82
Global Const $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH = 83
Global Const $WINHTTP_OPTION_SECURE_PROTOCOLS = 84
Global Const $WINHTTP_OPTION_ENABLETRACING = 85
Global Const $WINHTTP_OPTION_PASSPORT_SIGN_OUT = 86
Global Const $WINHTTP_OPTION_PASSPORT_RETURN_URL = 87
Global Const $WINHTTP_OPTION_REDIRECT_POLICY = 88
Global Const $WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS = 89
Global Const $WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE = 90
Global Const $WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE = 91
Global Const $WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE = 92
Global Const $WINHTTP_OPTION_CONNECTION_INFO = 93
Global Const $WINHTTP_OPTION_CLIENT_CERT_ISSUER_LIST = 94
Global Const $WINHTTP_OPTION_SPN = 96
Global Const $WINHTTP_OPTION_GLOBAL_PROXY_CREDS = 97
Global Const $WINHTTP_OPTION_GLOBAL_SERVER_CREDS = 98
Global Const $WINHTTP_OPTION_UNLOAD_NOTIFY_EVENT = 99
Global Const $WINHTTP_OPTION_REJECT_USERPWD_IN_URL = 100
Global Const $WINHTTP_OPTION_USE_GLOBAL_SERVER_CREDENTIALS = 101
Global Const $WINHTTP_OPTION_RECEIVE_PROXY_CONNECT_RESPONSE = 103
Global Const $WINHTTP_OPTION_IS_PROXY_CONNECT_RESPONSE = 104
Global Const $WINHTTP_OPTION_SERVER_SPN_USED = 106
Global Const $WINHTTP_OPTION_PROXY_SPN_USED = 107
Global Const $WINHTTP_OPTION_SERVER_CBT = 108
Global Const $WINHTTP_OPTION_UNSAFE_HEADER_PARSING = 110
Global Const $WINHTTP_OPTION_DECOMPRESSION = 118
Global Const $WINHTTP_LAST_OPTION = $WINHTTP_OPTION_DECOMPRESSION
Global Const $WINHTTP_OPTION_USERNAME = 4096
Global Const $WINHTTP_OPTION_PASSWORD = 4097
Global Const $WINHTTP_OPTION_PROXY_USERNAME = 4098
Global Const $WINHTTP_OPTION_PROXY_PASSWORD = 4099
Global Const $WINHTTP_CONNS_PER_SERVER_UNLIMITED = 4294967295
Global Const $WINHTTP_DECOMPRESSION_FLAG_GZIP = 1
Global Const $WINHTTP_DECOMPRESSION_FLAG_DEFLATE = 2
Global Const $WINHTTP_DECOMPRESSION_FLAG_ALL = 3
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM = 0
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW = 1
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH = 2
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_DEFAULT = $WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_NEVER = 0
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP = 1
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_ALWAYS = 2
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_LAST = $WINHTTP_OPTION_REDIRECT_POLICY_ALWAYS
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_DEFAULT = $WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP
Global Const $WINHTTP_DISABLE_PASSPORT_AUTH = 0
Global Const $WINHTTP_ENABLE_PASSPORT_AUTH = 268435456
Global Const $WINHTTP_DISABLE_PASSPORT_KEYRING = 536870912
Global Const $WINHTTP_ENABLE_PASSPORT_KEYRING = 1073741824
Global Const $WINHTTP_DISABLE_COOKIES = 1
Global Const $WINHTTP_DISABLE_REDIRECTS = 2
Global Const $WINHTTP_DISABLE_AUTHENTICATION = 4
Global Const $WINHTTP_DISABLE_KEEP_ALIVE = 8
Global Const $WINHTTP_ENABLE_SSL_REVOCATION = 1
Global Const $WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION = 2
Global Const $WINHTTP_DISABLE_SPN_SERVER_PORT = 0
Global Const $WINHTTP_ENABLE_SPN_SERVER_PORT = 1
Global Const $WINHTTP_OPTION_SPN_MASK = $WINHTTP_ENABLE_SPN_SERVER_PORT
Global Const $WINHTTP_ERROR_BASE = 12000
Global Const $ERROR_WINHTTP_OUT_OF_HANDLES = 12001
Global Const $ERROR_WINHTTP_TIMEOUT = 12002
Global Const $ERROR_WINHTTP_INTERNAL_ERROR = 12004
Global Const $ERROR_WINHTTP_INVALID_URL = 12005
Global Const $ERROR_WINHTTP_UNRECOGNIZED_SCHEME = 12006
Global Const $ERROR_WINHTTP_NAME_NOT_RESOLVED = 12007
Global Const $ERROR_WINHTTP_INVALID_OPTION = 12009
Global Const $ERROR_WINHTTP_OPTION_NOT_SETTABLE = 12011
Global Const $ERROR_WINHTTP_SHUTDOWN = 12012
Global Const $ERROR_WINHTTP_LOGIN_FAILURE = 12015
Global Const $ERROR_WINHTTP_OPERATION_CANCELLED = 12017
Global Const $ERROR_WINHTTP_INCORRECT_HANDLE_TYPE = 12018
Global Const $ERROR_WINHTTP_INCORRECT_HANDLE_STATE = 12019
Global Const $ERROR_WINHTTP_CANNOT_CONNECT = 12029
Global Const $ERROR_WINHTTP_CONNECTION_ERROR = 12030
Global Const $ERROR_WINHTTP_RESEND_REQUEST = 12032
Global Const $ERROR_WINHTTP_SECURE_CERT_DATE_INVALID = 12037
Global Const $ERROR_WINHTTP_SECURE_CERT_CN_INVALID = 12038
Global Const $ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED = 12044
Global Const $ERROR_WINHTTP_SECURE_INVALID_CA = 12045
Global Const $ERROR_WINHTTP_SECURE_CERT_REV_FAILED = 12057
Global Const $ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN = 12100
Global Const $ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND = 12101
Global Const $ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND = 12102
Global Const $ERROR_WINHTTP_CANNOT_CALL_AFTER_OPEN = 12103
Global Const $ERROR_WINHTTP_HEADER_NOT_FOUND = 12150
Global Const $ERROR_WINHTTP_INVALID_SERVER_RESPONSE = 12152
Global Const $ERROR_WINHTTP_INVALID_HEADER = 12153
Global Const $ERROR_WINHTTP_INVALID_QUERY_REQUEST = 12154
Global Const $ERROR_WINHTTP_HEADER_ALREADY_EXISTS = 12155
Global Const $ERROR_WINHTTP_REDIRECT_FAILED = 12156
Global Const $ERROR_WINHTTP_SECURE_CHANNEL_ERROR = 12157
Global Const $ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT = 12166
Global Const $ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT = 12167
Global Const $ERROR_WINHTTP_SECURE_INVALID_CERT = 12169
Global Const $ERROR_WINHTTP_SECURE_CERT_REVOKED = 12170
Global Const $ERROR_WINHTTP_NOT_INITIALIZED = 12172
Global Const $ERROR_WINHTTP_SECURE_FAILURE = 12175
Global Const $ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR = 12178
Global Const $ERROR_WINHTTP_SECURE_CERT_WRONG_USAGE = 12179
Global Const $ERROR_WINHTTP_AUTODETECTION_FAILED = 12180
Global Const $ERROR_WINHTTP_HEADER_COUNT_EXCEEDED = 12181
Global Const $ERROR_WINHTTP_HEADER_SIZE_OVERFLOW = 12182
Global Const $ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW = 12183
Global Const $ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW = 12184
Global Const $ERROR_WINHTTP_CLIENT_CERT_NO_PRIVATE_KEY = 12185
Global Const $ERROR_WINHTTP_CLIENT_CERT_NO_ACCESS_PRIVATE_KEY = 12186
Global Const $WINHTTP_ERROR_LAST = 12186
Global Const $HTTP_STATUS_CONTINUE = 100
Global Const $HTTP_STATUS_SWITCH_PROTOCOLS = 101
Global Const $HTTP_STATUS_OK = 200
Global Const $HTTP_STATUS_CREATED = 201
Global Const $HTTP_STATUS_ACCEPTED = 202
Global Const $HTTP_STATUS_PARTIAL = 203
Global Const $HTTP_STATUS_NO_CONTENT = 204
Global Const $HTTP_STATUS_RESET_CONTENT = 205
Global Const $HTTP_STATUS_PARTIAL_CONTENT = 206
Global Const $HTTP_STATUS_WEBDAV_MULTI_STATUS = 207
Global Const $HTTP_STATUS_AMBIGUOUS = 300
Global Const $HTTP_STATUS_MOVED = 301
Global Const $HTTP_STATUS_REDIRECT = 302
Global Const $HTTP_STATUS_REDIRECT_METHOD = 303
Global Const $HTTP_STATUS_NOT_MODIFIED = 304
Global Const $HTTP_STATUS_USE_PROXY = 305
Global Const $HTTP_STATUS_REDIRECT_KEEP_VERB = 307
Global Const $HTTP_STATUS_BAD_REQUEST = 400
Global Const $HTTP_STATUS_DENIED = 401
Global Const $HTTP_STATUS_PAYMENT_REQ = 402
Global Const $HTTP_STATUS_FORBIDDEN = 403
Global Const $HTTP_STATUS_NOT_FOUND = 404
Global Const $HTTP_STATUS_BAD_METHOD = 405
Global Const $HTTP_STATUS_NONE_ACCEPTABLE = 406
Global Const $HTTP_STATUS_PROXY_AUTH_REQ = 407
Global Const $HTTP_STATUS_REQUEST_TIMEOUT = 408
Global Const $HTTP_STATUS_CONFLICT = 409
Global Const $HTTP_STATUS_GONE = 410
Global Const $HTTP_STATUS_LENGTH_REQUIRED = 411
Global Const $HTTP_STATUS_PRECOND_FAILED = 412
Global Const $HTTP_STATUS_REQUEST_TOO_LARGE = 413
Global Const $HTTP_STATUS_URI_TOO_LONG = 414
Global Const $HTTP_STATUS_UNSUPPORTED_MEDIA = 415
Global Const $HTTP_STATUS_RETRY_WITH = 449
Global Const $HTTP_STATUS_SERVER_ERROR = 500
Global Const $HTTP_STATUS_NOT_SUPPORTED = 501
Global Const $HTTP_STATUS_BAD_GATEWAY = 502
Global Const $HTTP_STATUS_SERVICE_UNAVAIL = 503
Global Const $HTTP_STATUS_GATEWAY_TIMEOUT = 504
Global Const $HTTP_STATUS_VERSION_NOT_SUP = 505
Global Const $HTTP_STATUS_FIRST = $HTTP_STATUS_CONTINUE
Global Const $HTTP_STATUS_LAST = $HTTP_STATUS_VERSION_NOT_SUP
Global Const $SECURITY_FLAG_IGNORE_UNKNOWN_CA = 256
Global Const $SECURITY_FLAG_IGNORE_CERT_DATE_INVALID = 8192
Global Const $SECURITY_FLAG_IGNORE_CERT_CN_INVALID = 4096
Global Const $SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE = 512
Global Const $SECURITY_FLAG_SECURE = 1
Global Const $SECURITY_FLAG_STRENGTH_WEAK = 268435456
Global Const $SECURITY_FLAG_STRENGTH_MEDIUM = 1073741824
Global Const $SECURITY_FLAG_STRENGTH_STRONG = 536870912
Global Const $ICU_NO_ENCODE = 536870912
Global Const $ICU_DECODE = 268435456
Global Const $ICU_NO_META = 134217728
Global Const $ICU_ENCODE_SPACES_ONLY = 67108864
Global Const $ICU_BROWSER_MODE = 33554432
Global Const $ICU_ENCODE_PERCENT = 4096
Global Const $WINHTTP_QUERY_MIME_VERSION = 0
Global Const $WINHTTP_QUERY_CONTENT_TYPE = 1
Global Const $WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING = 2
Global Const $WINHTTP_QUERY_CONTENT_ID = 3
Global Const $WINHTTP_QUERY_CONTENT_DESCRIPTION = 4
Global Const $WINHTTP_QUERY_CONTENT_LENGTH = 5
Global Const $WINHTTP_QUERY_CONTENT_LANGUAGE = 6
Global Const $WINHTTP_QUERY_ALLOW = 7
Global Const $WINHTTP_QUERY_PUBLIC = 8
Global Const $WINHTTP_QUERY_DATE = 9
Global Const $WINHTTP_QUERY_EXPIRES = 10
Global Const $WINHTTP_QUERY_LAST_MODIFIED = 11
Global Const $WINHTTP_QUERY_MESSAGE_ID = 12
Global Const $WINHTTP_QUERY_URI = 13
Global Const $WINHTTP_QUERY_DERIVED_FROM = 14
Global Const $WINHTTP_QUERY_COST = 15
Global Const $WINHTTP_QUERY_LINK = 16
Global Const $WINHTTP_QUERY_PRAGMA = 17
Global Const $WINHTTP_QUERY_VERSION = 18
Global Const $WINHTTP_QUERY_STATUS_CODE = 19
Global Const $WINHTTP_QUERY_STATUS_TEXT = 20
Global Const $WINHTTP_QUERY_RAW_HEADERS = 21
Global Const $WINHTTP_QUERY_RAW_HEADERS_CRLF = 22
Global Const $WINHTTP_QUERY_CONNECTION = 23
Global Const $WINHTTP_QUERY_ACCEPT = 24
Global Const $WINHTTP_QUERY_ACCEPT_CHARSET = 25
Global Const $WINHTTP_QUERY_ACCEPT_ENCODING = 26
Global Const $WINHTTP_QUERY_ACCEPT_LANGUAGE = 27
Global Const $WINHTTP_QUERY_AUTHORIZATION = 28
Global Const $WINHTTP_QUERY_CONTENT_ENCODING = 29
Global Const $WINHTTP_QUERY_FORWARDED = 30
Global Const $WINHTTP_QUERY_FROM = 31
Global Const $WINHTTP_QUERY_IF_MODIFIED_SINCE = 32
Global Const $WINHTTP_QUERY_LOCATION = 33
Global Const $WINHTTP_QUERY_ORIG_URI = 34
Global Const $WINHTTP_QUERY_REFERER = 35
Global Const $WINHTTP_QUERY_RETRY_AFTER = 36
Global Const $WINHTTP_QUERY_SERVER = 37
Global Const $WINHTTP_QUERY_TITLE = 38
Global Const $WINHTTP_QUERY_USER_AGENT = 39
Global Const $WINHTTP_QUERY_WWW_AUTHENTICATE = 40
Global Const $WINHTTP_QUERY_PROXY_AUTHENTICATE = 41
Global Const $WINHTTP_QUERY_ACCEPT_RANGES = 42
Global Const $WINHTTP_QUERY_SET_COOKIE = 43
Global Const $WINHTTP_QUERY_COOKIE = 44
Global Const $WINHTTP_QUERY_REQUEST_METHOD = 45
Global Const $WINHTTP_QUERY_REFRESH = 46
Global Const $WINHTTP_QUERY_CONTENT_DISPOSITION = 47
Global Const $WINHTTP_QUERY_AGE = 48
Global Const $WINHTTP_QUERY_CACHE_CONTROL = 49
Global Const $WINHTTP_QUERY_CONTENT_BASE = 50
Global Const $WINHTTP_QUERY_CONTENT_LOCATION = 51
Global Const $WINHTTP_QUERY_CONTENT_MD5 = 52
Global Const $WINHTTP_QUERY_CONTENT_RANGE = 53
Global Const $WINHTTP_QUERY_ETAG = 54
Global Const $WINHTTP_QUERY_HOST = 55
Global Const $WINHTTP_QUERY_IF_MATCH = 56
Global Const $WINHTTP_QUERY_IF_NONE_MATCH = 57
Global Const $WINHTTP_QUERY_IF_RANGE = 58
Global Const $WINHTTP_QUERY_IF_UNMODIFIED_SINCE = 59
Global Const $WINHTTP_QUERY_MAX_FORWARDS = 60
Global Const $WINHTTP_QUERY_PROXY_AUTHORIZATION = 61
Global Const $WINHTTP_QUERY_RANGE = 62
Global Const $WINHTTP_QUERY_TRANSFER_ENCODING = 63
Global Const $WINHTTP_QUERY_UPGRADE = 64
Global Const $WINHTTP_QUERY_VARY = 65
Global Const $WINHTTP_QUERY_VIA = 66
Global Const $WINHTTP_QUERY_WARNING = 67
Global Const $WINHTTP_QUERY_EXPECT = 68
Global Const $WINHTTP_QUERY_PROXY_CONNECTION = 69
Global Const $WINHTTP_QUERY_UNLESS_MODIFIED_SINCE = 70
Global Const $WINHTTP_QUERY_PROXY_SUPPORT = 75
Global Const $WINHTTP_QUERY_AUTHENTICATION_INFO = 76
Global Const $WINHTTP_QUERY_PASSPORT_URLS = 77
Global Const $WINHTTP_QUERY_PASSPORT_CONFIG = 78
Global Const $WINHTTP_QUERY_MAX = 78
Global Const $WINHTTP_QUERY_CUSTOM = 65535
Global Const $WINHTTP_QUERY_FLAG_REQUEST_HEADERS = 2147483648
Global Const $WINHTTP_QUERY_FLAG_SYSTEMTIME = 1073741824
Global Const $WINHTTP_QUERY_FLAG_NUMBER = 536870912
Global Const $WINHTTP_CALLBACK_STATUS_RESOLVING_NAME = 1
Global Const $WINHTTP_CALLBACK_STATUS_NAME_RESOLVED = 2
Global Const $WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER = 4
Global Const $WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER = 8
Global Const $WINHTTP_CALLBACK_STATUS_SENDING_REQUEST = 16
Global Const $WINHTTP_CALLBACK_STATUS_REQUEST_SENT = 32
Global Const $WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE = 64
Global Const $WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED = 128
Global Const $WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION = 256
Global Const $WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED = 512
Global Const $WINHTTP_CALLBACK_STATUS_HANDLE_CREATED = 1024
Global Const $WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING = 2048
Global Const $WINHTTP_CALLBACK_STATUS_DETECTING_PROXY = 4096
Global Const $WINHTTP_CALLBACK_STATUS_REDIRECT = 16384
Global Const $WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE = 32768
Global Const $WINHTTP_CALLBACK_STATUS_SECURE_FAILURE = 65536
Global Const $WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE = 131072
Global Const $WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE = 262144
Global Const $WINHTTP_CALLBACK_STATUS_READ_COMPLETE = 524288
Global Const $WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE = 1048576
Global Const $WINHTTP_CALLBACK_STATUS_REQUEST_ERROR = 2097152
Global Const $WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE = 4194304
Global Const $WINHTTP_CALLBACK_FLAG_RESOLVE_NAME = 3
Global Const $WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER = 12
Global Const $WINHTTP_CALLBACK_FLAG_SEND_REQUEST = 48
Global Const $WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE = 192
Global Const $WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION = 768
Global Const $WINHTTP_CALLBACK_FLAG_HANDLES = 3072
Global Const $WINHTTP_CALLBACK_FLAG_DETECTING_PROXY = $WINHTTP_CALLBACK_STATUS_DETECTING_PROXY
Global Const $WINHTTP_CALLBACK_FLAG_REDIRECT = $WINHTTP_CALLBACK_STATUS_REDIRECT
Global Const $WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE = $WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE
Global Const $WINHTTP_CALLBACK_FLAG_SECURE_FAILURE = $WINHTTP_CALLBACK_STATUS_SECURE_FAILURE
Global Const $WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE = $WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE
Global Const $WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE = $WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
Global Const $WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE = $WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
Global Const $WINHTTP_CALLBACK_FLAG_READ_COMPLETE = $WINHTTP_CALLBACK_STATUS_READ_COMPLETE
Global Const $WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE = $WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
Global Const $WINHTTP_CALLBACK_FLAG_REQUEST_ERROR = $WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
Global Const $WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS = 8257536
Global Const $WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS = 4294967295
Global Const $API_RECEIVE_RESPONSE = 1
Global Const $API_QUERY_DATA_AVAILABLE = 2
Global Const $API_READ_DATA = 3
Global Const $API_WRITE_DATA = 4
Global Const $API_SEND_REQUEST = 5
Global Const $WINHTTP_HANDLE_TYPE_SESSION = 1
Global Const $WINHTTP_HANDLE_TYPE_CONNECT = 2
Global Const $WINHTTP_HANDLE_TYPE_REQUEST = 3
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED = 1
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT = 2
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED = 4
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA = 8
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID = 16
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID = 32
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_WRONG_USAGE = 64
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR = 2147483648
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_SSL2 = 8
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_SSL3 = 32
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_TLS1 = 128
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1 = 512
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2 = 2048
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_ALL = 168
Global Const $WINHTTP_AUTH_SCHEME_BASIC = 1
Global Const $WINHTTP_AUTH_SCHEME_NTLM = 2
Global Const $WINHTTP_AUTH_SCHEME_PASSPORT = 4
Global Const $WINHTTP_AUTH_SCHEME_DIGEST = 8
Global Const $WINHTTP_AUTH_SCHEME_NEGOTIATE = 16
Global Const $WINHTTP_AUTH_TARGET_SERVER = 0
Global Const $WINHTTP_AUTH_TARGET_PROXY = 1
Global Const $WINHTTP_AUTOPROXY_AUTO_DETECT = 1
Global Const $WINHTTP_AUTOPROXY_CONFIG_URL = 2
Global Const $WINHTTP_AUTOPROXY_RUN_INPROCESS = 65536
Global Const $WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY = 131072
Global Const $WINHTTP_AUTO_DETECT_TYPE_DHCP = 1
Global Const $WINHTTP_AUTO_DETECT_TYPE_DNS_A = 2
Global Const $HWINHTTPDLL__WINHTTP = DllOpen ( "winhttp.dll" )
DllOpen ( "winhttp.dll" )
Func _WINHTTPADDREQUESTHEADERS ( $HREQUEST , $SHEADER , $IMODIFIER = Default )
	__WINHTTPDEFAULT ( $IMODIFIER , $WINHTTP_ADDREQ_FLAG_ADD_IF_NEW )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpAddRequestHeaders" , "handle" , $HREQUEST , "wstr" , $SHEADER , "dword" , + 4294967295 , "dword" , $IMODIFIER )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPCHECKPLATFORM ( )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpCheckPlatform" )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINHTTPCLOSEHANDLE ( $HINTERNET )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpCloseHandle" , "handle" , $HINTERNET )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPCONNECT ( $HSESSION , $SSERVERNAME , $ISERVERPORT = Default )
	Local $AURL = _WINHTTPCRACKURL ( $SSERVERNAME ) , $ISCHEME = 0
	If @error Then
		__WINHTTPDEFAULT ( $ISERVERPORT , $INTERNET_DEFAULT_PORT )
	Else
		$SSERVERNAME = $AURL [ 2 ]
		$ISERVERPORT = $AURL [ 3 ]
		$ISCHEME = $AURL [ 1 ]
	EndIf
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "handle" , "WinHttpConnect" , "handle" , $HSESSION , "wstr" , $SSERVERNAME , "dword" , $ISERVERPORT , "dword" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	_WINHTTPSETOPTION ( $ACALL [ 0 ] , $WINHTTP_OPTION_CONTEXT_VALUE , $ISCHEME )
	Return $ACALL [ 0 ]
EndFunc
Func _WINHTTPCRACKURL ( $SURL , $IFLAG = Default )
	__WINHTTPDEFAULT ( $IFLAG , $ICU_ESCAPE )
	Local $TURL_COMPONENTS = DllStructCreate ( "dword StructSize;" & "ptr SchemeName;" & "dword SchemeNameLength;" & "int Scheme;" & "ptr HostName;" & "dword HostNameLength;" & "word Port;" & "ptr UserName;" & "dword UserNameLength;" & "ptr Password;" & "dword PasswordLength;" & "ptr UrlPath;" & "dword UrlPathLength;" & "ptr ExtraInfo;" & "dword ExtraInfoLength" )
	DllStructSetData ( $TURL_COMPONENTS , 1 , DllStructGetSize ( $TURL_COMPONENTS ) )
	Local $TBUFFERS [ 6 ]
	Local $IURLLEN = StringLen ( $SURL )
	For $I = 0 To 5
		$TBUFFERS [ $I ] = DllStructCreate ( "wchar[" & $IURLLEN + 1 & "]" )
	Next
	DllStructSetData ( $TURL_COMPONENTS , "SchemeNameLength" , $IURLLEN )
	DllStructSetData ( $TURL_COMPONENTS , "SchemeName" , DllStructGetPtr ( $TBUFFERS [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "HostNameLength" , $IURLLEN )
	DllStructSetData ( $TURL_COMPONENTS , "HostName" , DllStructGetPtr ( $TBUFFERS [ 1 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "UserNameLength" , $IURLLEN )
	DllStructSetData ( $TURL_COMPONENTS , "UserName" , DllStructGetPtr ( $TBUFFERS [ 2 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "PasswordLength" , $IURLLEN )
	DllStructSetData ( $TURL_COMPONENTS , "Password" , DllStructGetPtr ( $TBUFFERS [ 3 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "UrlPathLength" , $IURLLEN )
	DllStructSetData ( $TURL_COMPONENTS , "UrlPath" , DllStructGetPtr ( $TBUFFERS [ 4 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "ExtraInfoLength" , $IURLLEN )
	DllStructSetData ( $TURL_COMPONENTS , "ExtraInfo" , DllStructGetPtr ( $TBUFFERS [ 5 ] ) )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpCrackUrl" , "wstr" , $SURL , "dword" , $IURLLEN , "dword" , $IFLAG , "struct*" , $TURL_COMPONENTS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $ARET [ 8 ] = [ DllStructGetData ( $TBUFFERS [ 0 ] , 1 ) , DllStructGetData ( $TURL_COMPONENTS , "Scheme" ) , DllStructGetData ( $TBUFFERS [ 1 ] , 1 ) , DllStructGetData ( $TURL_COMPONENTS , "Port" ) , DllStructGetData ( $TBUFFERS [ 2 ] , 1 ) , DllStructGetData ( $TBUFFERS [ 3 ] , 1 ) , DllStructGetData ( $TBUFFERS [ 4 ] , 1 ) , DllStructGetData ( $TBUFFERS [ 5 ] , 1 ) ]
	Return $ARET
EndFunc
Func _WINHTTPCREATEURL ( $AURLARRAY )
	If UBound ( $AURLARRAY ) + 4294967288 Then Return SetError ( 1 , 0 , "" )
	Local $TURL_COMPONENTS = DllStructCreate ( "dword StructSize;" & "ptr SchemeName;" & "dword SchemeNameLength;" & "int Scheme;" & "ptr HostName;" & "dword HostNameLength;" & "word Port;" & "ptr UserName;" & "dword UserNameLength;" & "ptr Password;" & "dword PasswordLength;" & "ptr UrlPath;" & "dword UrlPathLength;" & "ptr ExtraInfo;" & "dword ExtraInfoLength;" )
	DllStructSetData ( $TURL_COMPONENTS , 1 , DllStructGetSize ( $TURL_COMPONENTS ) )
	Local $TBUFFERS [ 6 ] [ 2 ]
	$TBUFFERS [ 0 ] [ 1 ] = StringLen ( $AURLARRAY [ 0 ] )
	If $TBUFFERS [ 0 ] [ 1 ] Then
		$TBUFFERS [ 0 ] [ 0 ] = DllStructCreate ( "wchar[" & $TBUFFERS [ 0 ] [ 1 ] + 1 & "]" )
		DllStructSetData ( $TBUFFERS [ 0 ] [ 0 ] , 1 , $AURLARRAY [ 0 ] )
	EndIf
	$TBUFFERS [ 1 ] [ 1 ] = StringLen ( $AURLARRAY [ 2 ] )
	If $TBUFFERS [ 1 ] [ 1 ] Then
		$TBUFFERS [ 1 ] [ 0 ] = DllStructCreate ( "wchar[" & $TBUFFERS [ 1 ] [ 1 ] + 1 & "]" )
		DllStructSetData ( $TBUFFERS [ 1 ] [ 0 ] , 1 , $AURLARRAY [ 2 ] )
	EndIf
	$TBUFFERS [ 2 ] [ 1 ] = StringLen ( $AURLARRAY [ 4 ] )
	If $TBUFFERS [ 2 ] [ 1 ] Then
		$TBUFFERS [ 2 ] [ 0 ] = DllStructCreate ( "wchar[" & $TBUFFERS [ 2 ] [ 1 ] + 1 & "]" )
		DllStructSetData ( $TBUFFERS [ 2 ] [ 0 ] , 1 , $AURLARRAY [ 4 ] )
	EndIf
	$TBUFFERS [ 3 ] [ 1 ] = StringLen ( $AURLARRAY [ 5 ] )
	If $TBUFFERS [ 3 ] [ 1 ] Then
		$TBUFFERS [ 3 ] [ 0 ] = DllStructCreate ( "wchar[" & $TBUFFERS [ 3 ] [ 1 ] + 1 & "]" )
		DllStructSetData ( $TBUFFERS [ 3 ] [ 0 ] , 1 , $AURLARRAY [ 5 ] )
	EndIf
	$TBUFFERS [ 4 ] [ 1 ] = StringLen ( $AURLARRAY [ 6 ] )
	If $TBUFFERS [ 4 ] [ 1 ] Then
		$TBUFFERS [ 4 ] [ 0 ] = DllStructCreate ( "wchar[" & $TBUFFERS [ 4 ] [ 1 ] + 1 & "]" )
		DllStructSetData ( $TBUFFERS [ 4 ] [ 0 ] , 1 , $AURLARRAY [ 6 ] )
	EndIf
	$TBUFFERS [ 5 ] [ 1 ] = StringLen ( $AURLARRAY [ 7 ] )
	If $TBUFFERS [ 5 ] [ 1 ] Then
		$TBUFFERS [ 5 ] [ 0 ] = DllStructCreate ( "wchar[" & $TBUFFERS [ 5 ] [ 1 ] + 1 & "]" )
		DllStructSetData ( $TBUFFERS [ 5 ] [ 0 ] , 1 , $AURLARRAY [ 7 ] )
	EndIf
	DllStructSetData ( $TURL_COMPONENTS , "SchemeNameLength" , $TBUFFERS [ 0 ] [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "SchemeName" , DllStructGetPtr ( $TBUFFERS [ 0 ] [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "HostNameLength" , $TBUFFERS [ 1 ] [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "HostName" , DllStructGetPtr ( $TBUFFERS [ 1 ] [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "UserNameLength" , $TBUFFERS [ 2 ] [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "UserName" , DllStructGetPtr ( $TBUFFERS [ 2 ] [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "PasswordLength" , $TBUFFERS [ 3 ] [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "Password" , DllStructGetPtr ( $TBUFFERS [ 3 ] [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "UrlPathLength" , $TBUFFERS [ 4 ] [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "UrlPath" , DllStructGetPtr ( $TBUFFERS [ 4 ] [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "ExtraInfoLength" , $TBUFFERS [ 5 ] [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "ExtraInfo" , DllStructGetPtr ( $TBUFFERS [ 5 ] [ 0 ] ) )
	DllStructSetData ( $TURL_COMPONENTS , "Scheme" , $AURLARRAY [ 1 ] )
	DllStructSetData ( $TURL_COMPONENTS , "Port" , $AURLARRAY [ 3 ] )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpCreateUrl" , "struct*" , $TURL_COMPONENTS , "dword" , $ICU_ESCAPE , "ptr" , 0 , "dword*" , 0 )
	If @error Then Return SetError ( 2 , 0 , "" )
	Local $IURLLEN = $ACALL [ 4 ]
	Local $URLBUFFER = DllStructCreate ( "wchar[" & ( $IURLLEN + 1 ) & "]" )
	$ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpCreateUrl" , "struct*" , $TURL_COMPONENTS , "dword" , $ICU_ESCAPE , "struct*" , $URLBUFFER , "dword*" , $IURLLEN )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 3 , 0 , "" )
	Return DllStructGetData ( $URLBUFFER , 1 )
EndFunc
Func _WINHTTPDETECTAUTOPROXYCONFIGURL ( $IAUTODETECTFLAGS )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpDetectAutoProxyConfigUrl" , "dword" , $IAUTODETECTFLAGS , "ptr*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , "" )
	Local $PSTR = $ACALL [ 2 ]
	If $PSTR Then
		Local $ILEN = __WINHTTPPTRSTRINGLENW ( $PSTR )
		If @error Then Return SetError ( 2 , 0 , "" )
		Local $TSTRING = DllStructCreate ( "wchar[" & $ILEN + 1 & "]" , $PSTR )
		Local $SSTRING = DllStructGetData ( $TSTRING , 1 )
		__WINHTTPMEMGLOBALFREE ( $PSTR )
		Return $SSTRING
	EndIf
	Return ""
EndFunc
Func _WINHTTPGETDEFAULTPROXYCONFIGURATION ( )
	Local $TWINHTTP_PROXY_INFO = DllStructCreate ( "dword AccessType;" & "ptr Proxy;" & "ptr ProxyBypass" )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpGetDefaultProxyConfiguration" , "struct*" , $TWINHTTP_PROXY_INFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $IACCESSTYPE = DllStructGetData ( $TWINHTTP_PROXY_INFO , "AccessType" )
	Local $PPROXY = DllStructGetData ( $TWINHTTP_PROXY_INFO , "Proxy" )
	Local $PPROXYBYPASS = DllStructGetData ( $TWINHTTP_PROXY_INFO , "ProxyBypass" )
	Local $SPROXY
	If $PPROXY Then
		Local $IPROXYLEN = __WINHTTPPTRSTRINGLENW ( $PPROXY )
		If Not @error Then
			Local $TPROXY = DllStructCreate ( "wchar[" & $IPROXYLEN + 1 & "]" , $PPROXY )
			$SPROXY = DllStructGetData ( $TPROXY , 1 )
			__WINHTTPMEMGLOBALFREE ( $PPROXY )
		EndIf
	EndIf
	Local $SPROXYBYPASS
	If $PPROXYBYPASS Then
		Local $IPROXYBYPASSLEN = __WINHTTPPTRSTRINGLENW ( $PPROXYBYPASS )
		If Not @error Then
			Local $TPROXYBYPASS = DllStructCreate ( "wchar[" & $IPROXYBYPASSLEN + 1 & "]" , $PPROXYBYPASS )
			$SPROXYBYPASS = DllStructGetData ( $TPROXYBYPASS , 1 )
			__WINHTTPMEMGLOBALFREE ( $PPROXYBYPASS )
		EndIf
	EndIf
	Local $ARET [ 3 ] = [ $IACCESSTYPE , $SPROXY , $SPROXYBYPASS ]
	Return $ARET
EndFunc
Func _WINHTTPGETIEPROXYCONFIGFORCURRENTUSER ( )
	Local $TWINHTTP_CURRENT_USER_IE_PROXY_CONFIG = DllStructCreate ( "int AutoDetect;" & "ptr AutoConfigUrl;" & "ptr Proxy;" & "ptr ProxyBypass;" )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpGetIEProxyConfigForCurrentUser" , "struct*" , $TWINHTTP_CURRENT_USER_IE_PROXY_CONFIG )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Local $IAUTODETECT = DllStructGetData ( $TWINHTTP_CURRENT_USER_IE_PROXY_CONFIG , "AutoDetect" )
	Local $PAUTOCONFIGURL = DllStructGetData ( $TWINHTTP_CURRENT_USER_IE_PROXY_CONFIG , "AutoConfigUrl" )
	Local $PPROXY = DllStructGetData ( $TWINHTTP_CURRENT_USER_IE_PROXY_CONFIG , "Proxy" )
	Local $PPROXYBYPASS = DllStructGetData ( $TWINHTTP_CURRENT_USER_IE_PROXY_CONFIG , "ProxyBypass" )
	Local $SAUTOCONFIGURL
	If $PAUTOCONFIGURL Then
		Local $IAUTOCONFIGURLLEN = __WINHTTPPTRSTRINGLENW ( $PAUTOCONFIGURL )
		If Not @error Then
			Local $TAUTOCONFIGURL = DllStructCreate ( "wchar[" & $IAUTOCONFIGURLLEN + 1 & "]" , $PAUTOCONFIGURL )
			$SAUTOCONFIGURL = DllStructGetData ( $TAUTOCONFIGURL , 1 )
			__WINHTTPMEMGLOBALFREE ( $PAUTOCONFIGURL )
		EndIf
	EndIf
	Local $SPROXY
	If $PPROXY Then
		Local $IPROXYLEN = __WINHTTPPTRSTRINGLENW ( $PPROXY )
		If Not @error Then
			Local $TPROXY = DllStructCreate ( "wchar[" & $IPROXYLEN + 1 & "]" , $PPROXY )
			$SPROXY = DllStructGetData ( $TPROXY , 1 )
			__WINHTTPMEMGLOBALFREE ( $PPROXY )
		EndIf
	EndIf
	Local $SPROXYBYPASS
	If $PPROXYBYPASS Then
		Local $IPROXYBYPASSLEN = __WINHTTPPTRSTRINGLENW ( $PPROXYBYPASS )
		If Not @error Then
			Local $TPROXYBYPASS = DllStructCreate ( "wchar[" & $IPROXYBYPASSLEN + 1 & "]" , $PPROXYBYPASS )
			$SPROXYBYPASS = DllStructGetData ( $TPROXYBYPASS , 1 )
			__WINHTTPMEMGLOBALFREE ( $PPROXYBYPASS )
		EndIf
	EndIf
	Local $AOUTPUT [ 4 ] = [ $IAUTODETECT , $SAUTOCONFIGURL , $SPROXY , $SPROXYBYPASS ]
	Return $AOUTPUT
EndFunc
Func _WINHTTPOPEN ( $SUSERAGENT = Default , $IACCESSTYPE = Default , $SPROXYNAME = Default , $SPROXYBYPASS = Default , $IFLAG = Default )
	__WINHTTPDEFAULT ( $SUSERAGENT , __WINHTTPUA ( ) )
	__WINHTTPDEFAULT ( $IACCESSTYPE , $WINHTTP_ACCESS_TYPE_NO_PROXY )
	__WINHTTPDEFAULT ( $SPROXYNAME , $WINHTTP_NO_PROXY_NAME )
	__WINHTTPDEFAULT ( $SPROXYBYPASS , $WINHTTP_NO_PROXY_BYPASS )
	__WINHTTPDEFAULT ( $IFLAG , 0 )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "handle" , "WinHttpOpen" , "wstr" , $SUSERAGENT , "dword" , $IACCESSTYPE , "wstr" , $SPROXYNAME , "wstr" , $SPROXYBYPASS , "dword" , $IFLAG )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	If $IFLAG = $WINHTTP_FLAG_ASYNC Then _WINHTTPSETOPTION ( $ACALL [ 0 ] , $WINHTTP_OPTION_CONTEXT_VALUE , $WINHTTP_FLAG_ASYNC )
	Return $ACALL [ 0 ]
EndFunc
Func _WINHTTPOPENREQUEST ( $HCONNECT , $SVERB = Default , $SOBJECTNAME = Default , $SVERSION = Default , $SREFERRER = Default , $SACCEPTTYPES = Default , $IFLAGS = Default )
	__WINHTTPDEFAULT ( $SVERB , "GET" )
	__WINHTTPDEFAULT ( $SOBJECTNAME , "" )
	__WINHTTPDEFAULT ( $SVERSION , "HTTP/1.1" )
	__WINHTTPDEFAULT ( $SREFERRER , $WINHTTP_NO_REFERER )
	__WINHTTPDEFAULT ( $IFLAGS , $WINHTTP_FLAG_ESCAPE_DISABLE )
	Local $PACCEPTTYPES
	If $SACCEPTTYPES = Default Or Number ( $SACCEPTTYPES ) = + 4294967295 Then
		$PACCEPTTYPES = $WINHTTP_DEFAULT_ACCEPT_TYPES
	Else
		Local $ATYPES = StringSplit ( $SACCEPTTYPES , "," , 2 )
		Local $TACCEPTTYPES = DllStructCreate ( "ptr[" & UBound ( $ATYPES ) + 1 & "]" )
		Local $TTYPE [ UBound ( $ATYPES ) ]
		For $I = 0 To UBound ( $ATYPES ) + 4294967295
			$TTYPE [ $I ] = DllStructCreate ( "wchar[" & StringLen ( $ATYPES [ $I ] ) + 1 & "]" )
			DllStructSetData ( $TTYPE [ $I ] , 1 , $ATYPES [ $I ] )
			DllStructSetData ( $TACCEPTTYPES , 1 , DllStructGetPtr ( $TTYPE [ $I ] ) , $I + 1 )
		Next
		$PACCEPTTYPES = DllStructGetPtr ( $TACCEPTTYPES )
	EndIf
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "handle" , "WinHttpOpenRequest" , "handle" , $HCONNECT , "wstr" , StringUpper ( $SVERB ) , "wstr" , $SOBJECTNAME , "wstr" , StringUpper ( $SVERSION ) , "wstr" , $SREFERRER , "ptr" , $PACCEPTTYPES , "dword" , $IFLAGS )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINHTTPQUERYAUTHSCHEMES ( $HREQUEST , ByRef $ISUPPORTEDSCHEMES , ByRef $IFIRSTSCHEME , ByRef $IAUTHTARGET )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpQueryAuthSchemes" , "handle" , $HREQUEST , "dword*" , 0 , "dword*" , 0 , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	$ISUPPORTEDSCHEMES = $ACALL [ 2 ]
	$IFIRSTSCHEME = $ACALL [ 3 ]
	$IAUTHTARGET = $ACALL [ 4 ]
	Return 1
EndFunc
Func _WINHTTPQUERYDATAAVAILABLE ( $HREQUEST )
	Local $SREADTYPE = "dword*"
	If BitAND ( _WINHTTPQUERYOPTION ( _WINHTTPQUERYOPTION ( _WINHTTPQUERYOPTION ( $HREQUEST , $WINHTTP_OPTION_PARENT_HANDLE ) , $WINHTTP_OPTION_PARENT_HANDLE ) , $WINHTTP_OPTION_CONTEXT_VALUE ) , $WINHTTP_FLAG_ASYNC ) Then $SREADTYPE = "ptr"
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpQueryDataAvailable" , "handle" , $HREQUEST , $SREADTYPE , 0 )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return SetExtended ( $ACALL [ 2 ] , $ACALL [ 0 ] )
EndFunc
Func _WINHTTPQUERYHEADERS ( $HREQUEST , $IINFOLEVEL = Default , $SNAME = Default , $IINDEX = Default )
	__WINHTTPDEFAULT ( $IINFOLEVEL , $WINHTTP_QUERY_RAW_HEADERS_CRLF )
	__WINHTTPDEFAULT ( $SNAME , $WINHTTP_HEADER_NAME_BY_INDEX )
	__WINHTTPDEFAULT ( $IINDEX , $WINHTTP_NO_HEADER_INDEX )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpQueryHeaders" , "handle" , $HREQUEST , "dword" , $IINFOLEVEL , "wstr" , $SNAME , "wstr" , "" , "dword*" , 65536 , "dword*" , $IINDEX )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , "" )
	Return SetExtended ( $ACALL [ 6 ] , $ACALL [ 4 ] )
EndFunc
Func _WINHTTPQUERYOPTION ( $HINTERNET , $IOPTION )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpQueryOption" , "handle" , $HINTERNET , "dword" , $IOPTION , "ptr" , 0 , "dword*" , 0 )
	If @error Or $ACALL [ 0 ] Then Return SetError ( 1 , 0 , "" )
	Local $ISIZE = $ACALL [ 4 ]
	Local $TBUFFER
	Switch $IOPTION
	Case $WINHTTP_OPTION_CONNECTION_INFO , $WINHTTP_OPTION_PASSWORD , $WINHTTP_OPTION_PROXY_PASSWORD , $WINHTTP_OPTION_PROXY_USERNAME , $WINHTTP_OPTION_URL , $WINHTTP_OPTION_USERNAME , $WINHTTP_OPTION_USER_AGENT , $WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT , $WINHTTP_OPTION_PASSPORT_COBRANDING_URL
		$TBUFFER = DllStructCreate ( "wchar[" & $ISIZE + 1 & "]" )
	Case $WINHTTP_OPTION_PARENT_HANDLE , $WINHTTP_OPTION_CALLBACK , $WINHTTP_OPTION_SERVER_CERT_CONTEXT
		$TBUFFER = DllStructCreate ( "ptr" )
	Case $WINHTTP_OPTION_CONNECT_TIMEOUT , $WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH , $WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW , $WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM , $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH , $WINHTTP_OPTION_CONNECT_RETRIES , $WINHTTP_OPTION_EXTENDED_ERROR , $WINHTTP_OPTION_HANDLE_TYPE , $WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER , $WINHTTP_OPTION_MAX_CONNS_PER_SERVER , $WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS , $WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT , $WINHTTP_OPTION_RECEIVE_TIMEOUT , $WINHTTP_OPTION_RESOLVE_TIMEOUT , $WINHTTP_OPTION_SECURITY_FLAGS , $WINHTTP_OPTION_SECURITY_KEY_BITNESS , $WINHTTP_OPTION_SEND_TIMEOUT
		$TBUFFER = DllStructCreate ( "int" )
	Case $WINHTTP_OPTION_CONTEXT_VALUE
		$TBUFFER = DllStructCreate ( "dword_ptr" )
Case Else
		$TBUFFER = DllStructCreate ( "byte[" & $ISIZE & "]" )
	EndSwitch
	$ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpQueryOption" , "handle" , $HINTERNET , "dword" , $IOPTION , "struct*" , $TBUFFER , "dword*" , $ISIZE )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 2 , 0 , "" )
	Return DllStructGetData ( $TBUFFER , 1 )
EndFunc
Func _WINHTTPREADDATA ( $HREQUEST , $IMODE = Default , $INUMBEROFBYTESTOREAD = Default , $PBUFFER = Default )
	__WINHTTPDEFAULT ( $IMODE , 0 )
	__WINHTTPDEFAULT ( $INUMBEROFBYTESTOREAD , 8192 )
	Local $TBUFFER , $VOUTONERROR = ""
	If $IMODE = 2 Then $VOUTONERROR = Binary ( $VOUTONERROR )
	Switch $IMODE
	Case 1 , 2
		If $PBUFFER And $PBUFFER <> Default Then
			$TBUFFER = DllStructCreate ( "byte[" & $INUMBEROFBYTESTOREAD & "]" , $PBUFFER )
		Else
			$TBUFFER = DllStructCreate ( "byte[" & $INUMBEROFBYTESTOREAD & "]" )
		EndIf
Case Else
		$IMODE = 0
		If $PBUFFER And $PBUFFER <> Default Then
			$TBUFFER = DllStructCreate ( "char[" & $INUMBEROFBYTESTOREAD & "]" , $PBUFFER )
		Else
			$TBUFFER = DllStructCreate ( "char[" & $INUMBEROFBYTESTOREAD & "]" )
		EndIf
	EndSwitch
	Local $SREADTYPE = "dword*"
	If BitAND ( _WINHTTPQUERYOPTION ( _WINHTTPQUERYOPTION ( _WINHTTPQUERYOPTION ( $HREQUEST , $WINHTTP_OPTION_PARENT_HANDLE ) , $WINHTTP_OPTION_PARENT_HANDLE ) , $WINHTTP_OPTION_CONTEXT_VALUE ) , $WINHTTP_FLAG_ASYNC ) Then $SREADTYPE = "ptr"
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpReadData" , "handle" , $HREQUEST , "struct*" , $TBUFFER , "dword" , $INUMBEROFBYTESTOREAD , $SREADTYPE , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , "" )
	If Not $ACALL [ 4 ] Then Return SetError ( + 4294967295 , 0 , $VOUTONERROR )
	If $ACALL [ 4 ] < $INUMBEROFBYTESTOREAD Then
		Switch $IMODE
		Case 0
			Return SetExtended ( $ACALL [ 4 ] , StringLeft ( DllStructGetData ( $TBUFFER , 1 ) , $ACALL [ 4 ] ) )
		Case 1
			Return SetExtended ( $ACALL [ 4 ] , BinaryToString ( BinaryMid ( DllStructGetData ( $TBUFFER , 1 ) , 1 , $ACALL [ 4 ] ) , 4 ) )
		Case 2
			Return SetExtended ( $ACALL [ 4 ] , BinaryMid ( DllStructGetData ( $TBUFFER , 1 ) , 1 , $ACALL [ 4 ] ) )
		EndSwitch
	Else
		Switch $IMODE
		Case 0 , 2
			Return SetExtended ( $ACALL [ 4 ] , DllStructGetData ( $TBUFFER , 1 ) )
		Case 1
			Return SetExtended ( $ACALL [ 4 ] , BinaryToString ( DllStructGetData ( $TBUFFER , 1 ) , 4 ) )
		EndSwitch
	EndIf
EndFunc
Func _WINHTTPRECEIVERESPONSE ( $HREQUEST )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpReceiveResponse" , "handle" , $HREQUEST , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPSENDREQUEST ( $HREQUEST , $SHEADERS = Default , $VOPTIONAL = Default , $ITOTALLENGTH = Default , $ICONTEXT = Default )
	__WINHTTPDEFAULT ( $SHEADERS , $WINHTTP_NO_ADDITIONAL_HEADERS )
	__WINHTTPDEFAULT ( $VOPTIONAL , $WINHTTP_NO_REQUEST_DATA )
	__WINHTTPDEFAULT ( $ITOTALLENGTH , 0 )
	__WINHTTPDEFAULT ( $ICONTEXT , 0 )
	Local $POPTIONAL = 0 , $IOPTIONALLENGTH = 0
	If @NumParams > 2 Then
		Local $TOPTIONAL
		$IOPTIONALLENGTH = BinaryLen ( $VOPTIONAL )
		$TOPTIONAL = DllStructCreate ( "byte[" & $IOPTIONALLENGTH & "]" )
		If $IOPTIONALLENGTH Then $POPTIONAL = DllStructGetPtr ( $TOPTIONAL )
		DllStructSetData ( $TOPTIONAL , 1 , $VOPTIONAL )
	EndIf
	If Not $ITOTALLENGTH Or $ITOTALLENGTH < $IOPTIONALLENGTH Then $ITOTALLENGTH += $IOPTIONALLENGTH
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpSendRequest" , "handle" , $HREQUEST , "wstr" , $SHEADERS , "dword" , 0 , "ptr" , $POPTIONAL , "dword" , $IOPTIONALLENGTH , "dword" , $ITOTALLENGTH , "dword_ptr" , $ICONTEXT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPSETCREDENTIALS ( $HREQUEST , $IAUTHTARGETS , $IAUTHSCHEME , $SUSERNAME , $SPASSWORD )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpSetCredentials" , "handle" , $HREQUEST , "dword" , $IAUTHTARGETS , "dword" , $IAUTHSCHEME , "wstr" , $SUSERNAME , "wstr" , $SPASSWORD , "ptr" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPSETDEFAULTPROXYCONFIGURATION ( $IACCESSTYPE , $SPROXY = "" , $SPROXYBYPASS = "" )
	Local $TPROXY = DllStructCreate ( "wchar[" & StringLen ( $SPROXY ) + 1 & "]" )
	DllStructSetData ( $TPROXY , 1 , $SPROXY )
	Local $TPROXYBYPASS = DllStructCreate ( "wchar[" & StringLen ( $SPROXYBYPASS ) + 1 & "]" )
	DllStructSetData ( $TPROXYBYPASS , 1 , $SPROXYBYPASS )
	Local $TWINHTTP_PROXY_INFO = DllStructCreate ( "dword AccessType;" & "ptr Proxy;" & "ptr ProxyBypass" )
	DllStructSetData ( $TWINHTTP_PROXY_INFO , "AccessType" , $IACCESSTYPE )
	If $IACCESSTYPE <> $WINHTTP_ACCESS_TYPE_NO_PROXY Then
		DllStructSetData ( $TWINHTTP_PROXY_INFO , "Proxy" , DllStructGetPtr ( $TPROXY ) )
		DllStructSetData ( $TWINHTTP_PROXY_INFO , "ProxyBypass" , DllStructGetPtr ( $TPROXYBYPASS ) )
	EndIf
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpSetDefaultProxyConfiguration" , "struct*" , $TWINHTTP_PROXY_INFO )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPSETOPTION ( $HINTERNET , $IOPTION , $VSETTING , $ISIZE = Default )
	If $ISIZE = Default Then $ISIZE = + 4294967295
	If IsBinary ( $VSETTING ) Then
		$ISIZE = DllStructCreate ( "byte[" & BinaryLen ( $VSETTING ) & "]" )
		DllStructSetData ( $ISIZE , 1 , $VSETTING )
		$VSETTING = $ISIZE
		$ISIZE = DllStructGetSize ( $VSETTING )
	EndIf
	Local $STYPE
	Switch $IOPTION
	Case $WINHTTP_OPTION_AUTOLOGON_POLICY , $WINHTTP_OPTION_CODEPAGE , $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH , $WINHTTP_OPTION_CONNECT_RETRIES , $WINHTTP_OPTION_CONNECT_TIMEOUT , $WINHTTP_OPTION_DISABLE_FEATURE , $WINHTTP_OPTION_ENABLE_FEATURE , $WINHTTP_OPTION_ENABLETRACING , $WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER , $WINHTTP_OPTION_MAX_CONNS_PER_SERVER , $WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS , $WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE , $WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE , $WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE , $WINHTTP_OPTION_READ_BUFFER_SIZE , $WINHTTP_OPTION_RECEIVE_TIMEOUT , $WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT , $WINHTTP_OPTION_REDIRECT_POLICY , $WINHTTP_OPTION_REJECT_USERPWD_IN_URL , $WINHTTP_OPTION_REQUEST_PRIORITY , $WINHTTP_OPTION_RESOLVE_TIMEOUT , $WINHTTP_OPTION_SECURE_PROTOCOLS , $WINHTTP_OPTION_SECURITY_FLAGS , $WINHTTP_OPTION_SECURITY_KEY_BITNESS , $WINHTTP_OPTION_SEND_TIMEOUT , $WINHTTP_OPTION_SPN , $WINHTTP_OPTION_USE_GLOBAL_SERVER_CREDENTIALS , $WINHTTP_OPTION_WORKER_THREAD_COUNT , $WINHTTP_OPTION_WRITE_BUFFER_SIZE , $WINHTTP_OPTION_DECOMPRESSION , $WINHTTP_OPTION_UNSAFE_HEADER_PARSING
		$STYPE = "dword*"
		$ISIZE = 4
	Case $WINHTTP_OPTION_CALLBACK , $WINHTTP_OPTION_PASSPORT_SIGN_OUT
		$STYPE = "ptr*"
		$ISIZE = 4
		If @AutoItX64 Then $ISIZE = 8
		If Not IsPtr ( $VSETTING ) Then Return SetError ( 3 , 0 , 0 )
	Case $WINHTTP_OPTION_CONTEXT_VALUE
		$STYPE = "dword_ptr*"
		$ISIZE = 4
		If @AutoItX64 Then $ISIZE = 8
	Case $WINHTTP_OPTION_PASSWORD , $WINHTTP_OPTION_PROXY_PASSWORD , $WINHTTP_OPTION_PROXY_USERNAME , $WINHTTP_OPTION_USER_AGENT , $WINHTTP_OPTION_USERNAME
		$STYPE = "wstr"
		If ( IsDllStruct ( $VSETTING ) Or IsPtr ( $VSETTING ) ) Then Return SetError ( 3 , 0 , 0 )
		If $ISIZE < 1 Then $ISIZE = StringLen ( $VSETTING )
	Case $WINHTTP_OPTION_CLIENT_CERT_CONTEXT , $WINHTTP_OPTION_GLOBAL_PROXY_CREDS , $WINHTTP_OPTION_GLOBAL_SERVER_CREDS , $WINHTTP_OPTION_HTTP_VERSION , $WINHTTP_OPTION_PROXY
		$STYPE = "ptr"
		If Not ( IsDllStruct ( $VSETTING ) Or IsPtr ( $VSETTING ) ) Then Return SetError ( 3 , 0 , 0 )
Case Else
		Return SetError ( 1 , 0 , 0 )
	EndSwitch
	If $ISIZE < 1 Then
		If IsDllStruct ( $VSETTING ) Then
			$ISIZE = DllStructGetSize ( $VSETTING )
		Else
			Return SetError ( 2 , 0 , 0 )
		EndIf
	EndIf
	Local $ACALL
	If IsDllStruct ( $VSETTING ) Then
		$ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpSetOption" , "handle" , $HINTERNET , "dword" , $IOPTION , $STYPE , DllStructGetPtr ( $VSETTING ) , "dword" , $ISIZE )
	Else
		$ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpSetOption" , "handle" , $HINTERNET , "dword" , $IOPTION , $STYPE , $VSETTING , "dword" , $ISIZE )
	EndIf
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 4 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPSETSTATUSCALLBACK ( $HINTERNET , $HINTERNETCALLBACK , $INOTIFICATIONFLAGS = Default )
	__WINHTTPDEFAULT ( $INOTIFICATIONFLAGS , $WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "ptr" , "WinHttpSetStatusCallback" , "handle" , $HINTERNET , "ptr" , DllCallbackGetPtr ( $HINTERNETCALLBACK ) , "dword" , $INOTIFICATIONFLAGS , "ptr" , 0 )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINHTTPSETTIMEOUTS ( $HINTERNET , $IRESOLVETIMEOUT = Default , $ICONNECTTIMEOUT = Default , $ISENDTIMEOUT = Default , $IRECEIVETIMEOUT = Default )
	__WINHTTPDEFAULT ( $IRESOLVETIMEOUT , 0 )
	__WINHTTPDEFAULT ( $ICONNECTTIMEOUT , 60000 )
	__WINHTTPDEFAULT ( $ISENDTIMEOUT , 30000 )
	__WINHTTPDEFAULT ( $IRECEIVETIMEOUT , 30000 )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpSetTimeouts" , "handle" , $HINTERNET , "int" , $IRESOLVETIMEOUT , "int" , $ICONNECTTIMEOUT , "int" , $ISENDTIMEOUT , "int" , $IRECEIVETIMEOUT )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func _WINHTTPSIMPLEBINARYCONCAT ( ByRef $BBINARY1 , ByRef $BBINARY2 )
	Switch IsBinary ( $BBINARY1 ) + 2 * IsBinary ( $BBINARY2 )
	Case 0
		Return SetError ( 1 , 0 , Binary ( "" ) )
	Case 1
		Return $BBINARY1
	Case 2
		Return $BBINARY2
	EndSwitch
	Local $TAUXILIARY = DllStructCreate ( "byte[" & BinaryLen ( $BBINARY1 ) & "];byte[" & BinaryLen ( $BBINARY2 ) & "]" )
	DllStructSetData ( $TAUXILIARY , 1 , $BBINARY1 )
	DllStructSetData ( $TAUXILIARY , 2 , $BBINARY2 )
	Local $TOUTPUT = DllStructCreate ( "byte[" & DllStructGetSize ( $TAUXILIARY ) & "]" , DllStructGetPtr ( $TAUXILIARY ) )
	Return DllStructGetData ( $TOUTPUT , 1 )
EndFunc
Func _WINHTTPSIMPLEFORMFILL ( ByRef $HINTERNET , $SACTIONPAGE = Default , $SFORMID = Default , $SFLDID1 = Default , $SDTA1 = Default , $SFLDID2 = Default , $SDTA2 = Default , $SFLDID3 = Default , $SDTA3 = Default , $SFLDID4 = Default , $SDTA4 = Default , $SFLDID5 = Default , $SDTA5 = Default , $SFLDID6 = Default , $SDTA6 = Default , $SFLDID7 = Default , $SDTA7 = Default , $SFLDID8 = Default , $SDTA8 = Default , $SFLDID9 = Default , $SDTA9 = Default , $SFLDID10 = Default , $SDTA10 = Default , $SFLDID11 = Default , $SDTA11 = Default , $SFLDID12 = Default , $SDTA12 = Default , $SFLDID13 = Default , $SDTA13 = Default , $SFLDID14 = Default , $SDTA14 = Default , $SFLDID15 = Default , $SDTA15 = Default , $SFLDID16 = Default , $SDTA16 = Default , $SFLDID17 = Default , $SDTA17 = Default , $SFLDID18 = Default , $SDTA18 = Default , $SFLDID19 = Default , $SDTA19 = Default , $SFLDID20 = Default , $SDTA20 = Default , $SFLDID21 = Default , $SDTA21 = Default , $SFLDID22 = Default , $SDTA22 = Default , $SFLDID23 = Default , $SDTA23 = Default , $SFLDID24 = Default , $SDTA24 = Default , $SFLDID25 = Default , $SDTA25 = Default , $SFLDID26 = Default , $SDTA26 = Default , $SFLDID27 = Default , $SDTA27 = Default , $SFLDID28 = Default , $SDTA28 = Default , $SFLDID29 = Default , $SDTA29 = Default , $SFLDID30 = Default , $SDTA30 = Default , $SFLDID31 = Default , $SDTA31 = Default , $SFLDID32 = Default , $SDTA32 = Default , $SFLDID33 = Default , $SDTA33 = Default , $SFLDID34 = Default , $SDTA34 = Default , $SFLDID35 = Default , $SDTA35 = Default , $SFLDID36 = Default , $SDTA36 = Default , $SFLDID37 = Default , $SDTA37 = Default , $SFLDID38 = Default , $SDTA38 = Default , $SFLDID39 = Default , $SDTA39 = Default , $SFLDID40 = Default , $SDTA40 = Default )
	__WINHTTPDEFAULT ( $SACTIONPAGE , "" )
	Local $INUMARGS = @NumParams , $SADDITIONALHEADERS , $SCREDNAME , $SCREDPASS , $IIGNORECERTERR , $IRETARR
	Local $ADTAS [ 41 ] = [ 0 , $SDTA1 , $SDTA2 , $SDTA3 , $SDTA4 , $SDTA5 , $SDTA6 , $SDTA7 , $SDTA8 , $SDTA9 , $SDTA10 , $SDTA11 , $SDTA12 , $SDTA13 , $SDTA14 , $SDTA15 , $SDTA16 , $SDTA17 , $SDTA18 , $SDTA19 , $SDTA20 , $SDTA21 , $SDTA22 , $SDTA23 , $SDTA24 , $SDTA25 , $SDTA26 , $SDTA27 , $SDTA28 , $SDTA29 , $SDTA30 , $SDTA31 , $SDTA32 , $SDTA33 , $SDTA34 , $SDTA35 , $SDTA36 , $SDTA37 , $SDTA38 , $SDTA39 , $SDTA40 ]
	Local $AFLDS [ 41 ] = [ 0 , $SFLDID1 , $SFLDID2 , $SFLDID3 , $SFLDID4 , $SFLDID5 , $SFLDID6 , $SFLDID7 , $SFLDID8 , $SFLDID9 , $SFLDID10 , $SFLDID11 , $SFLDID12 , $SFLDID13 , $SFLDID14 , $SFLDID15 , $SFLDID16 , $SFLDID17 , $SFLDID18 , $SFLDID19 , $SFLDID20 , $SFLDID21 , $SFLDID22 , $SFLDID23 , $SFLDID24 , $SFLDID25 , $SFLDID26 , $SFLDID27 , $SFLDID28 , $SFLDID29 , $SFLDID30 , $SFLDID31 , $SFLDID32 , $SFLDID33 , $SFLDID34 , $SFLDID35 , $SFLDID36 , $SFLDID37 , $SFLDID38 , $SFLDID39 , $SFLDID40 ]
	If Not Mod ( $INUMARGS , 2 ) Then
		$SADDITIONALHEADERS = $AFLDS [ $INUMARGS / 2 + 4294967295 ]
		$AFLDS [ $INUMARGS / 2 + 4294967295 ] = 0
		$IIGNORECERTERR = StringInStr ( $SADDITIONALHEADERS , "[IGNORE_CERT_ERRORS]" )
		If $IIGNORECERTERR Then $SADDITIONALHEADERS = StringReplace ( $SADDITIONALHEADERS , "[IGNORE_CERT_ERRORS]" , "" , 1 )
		$IRETARR = StringInStr ( $SADDITIONALHEADERS , "[RETURN_ARRAY]" )
		If $IRETARR Then $SADDITIONALHEADERS = StringReplace ( $SADDITIONALHEADERS , "[RETURN_ARRAY]" , "" , 1 )
		Local $ACRED = StringRegExp ( $SADDITIONALHEADERS , "\[CRED:(.*?)\]" , 2 )
		If Not @error Then
			Local $SCREDDELIM = ":"
			If Not StringInStr ( $ACRED [ 1 ] , $SCREDDELIM ) Then $SCREDDELIM = ","
			Local $ASTRSPLIT = StringSplit ( $ACRED [ 1 ] , $SCREDDELIM , 3 )
			If Not @error Then
				$SCREDNAME = $ASTRSPLIT [ 0 ]
				$SCREDPASS = $ASTRSPLIT [ 1 ]
			EndIf
			$SADDITIONALHEADERS = StringReplace ( $SADDITIONALHEADERS , $ACRED [ 0 ] , "" , 1 )
		EndIf
	EndIf
	Local $HOPEN , $AHTML , $SHTML , $SURL , $FVARFORM , $ISCHEME = $INTERNET_SCHEME_HTTP
	If IsString ( $HINTERNET ) Then
		$SHTML = $HINTERNET
		If _WINHTTPQUERYOPTION ( $SACTIONPAGE , $WINHTTP_OPTION_HANDLE_TYPE ) <> $WINHTTP_HANDLE_TYPE_SESSION Then Return SetError ( 6 , 0 , "" )
		$HOPEN = $SACTIONPAGE
		$FVARFORM = True
	Else
		$ISCHEME = _WINHTTPQUERYOPTION ( $HINTERNET , $WINHTTP_OPTION_CONTEXT_VALUE )
		Local $SACCPT = "Accept: text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5"
		If $ISCHEME = $INTERNET_SCHEME_HTTPS Then
			$AHTML = _WINHTTPSIMPLESSLREQUEST ( $HINTERNET , Default , $SACTIONPAGE , Default , Default , $SACCPT , 1 , Default , $SCREDNAME , $SCREDPASS , $IIGNORECERTERR )
		ElseIf $ISCHEME = $INTERNET_SCHEME_HTTP Then
			$AHTML = _WINHTTPSIMPLEREQUEST ( $HINTERNET , Default , $SACTIONPAGE , Default , Default , $SACCPT , 1 , Default , $SCREDNAME , $SCREDPASS )
		Else
			$AHTML = _WINHTTPSIMPLEREQUEST ( $HINTERNET , Default , $SACTIONPAGE , Default , Default , $SACCPT , 1 , Default , $SCREDNAME , $SCREDPASS )
			If @error Or @extended >= $HTTP_STATUS_BAD_REQUEST Then
				$AHTML = _WINHTTPSIMPLESSLREQUEST ( $HINTERNET , Default , $SACTIONPAGE , Default , Default , $SACCPT , 1 , Default , $SCREDNAME , $SCREDPASS , $IIGNORECERTERR )
				$ISCHEME = $INTERNET_SCHEME_HTTPS
			Else
				$ISCHEME = $INTERNET_SCHEME_HTTP
			EndIf
		EndIf
		If Not @error Then
			$SHTML = $AHTML [ 1 ]
			$SURL = $AHTML [ 2 ]
		EndIf
	EndIf
	$SHTML = StringRegExpReplace ( $SHTML , "(?s)<!--.*?-->" , "" )
	$SHTML = StringRegExpReplace ( $SHTML , "(?s)<!\[CDATA\[.*?\]\]>" , "" )
	Local $FSEND = False
	Local $AFORM = StringRegExp ( $SHTML , "(?si)<\s*form(?:[^\w])\s*(.*?)(?:(?:<\s*/form\s*>)|\Z)" , 3 )
	If @error Then Return SetError ( 1 , 0 , "" )
	Local $FGETFORMBYNAME , $SFORMNAME , $FGETFORMBYINDEX , $FGETFORMBYID , $IFORMINDEX
	Local $ASPLITFORM = StringSplit ( $SFORMID , ":" , 2 )
	If @error Then
		$FGETFORMBYID = True
	Else
		If $ASPLITFORM [ 0 ] = "name" Then
			$SFORMNAME = $ASPLITFORM [ 1 ]
			$FGETFORMBYNAME = True
		ElseIf $ASPLITFORM [ 0 ] = "index" Then
			$IFORMINDEX = Number ( $ASPLITFORM [ 1 ] )
			$FGETFORMBYINDEX = True
		ElseIf $ASPLITFORM [ 0 ] = "id" Then
			$SFORMID = $ASPLITFORM [ 1 ]
			$FGETFORMBYID = True
		Else
			$SFORMID = $ASPLITFORM [ 0 ]
			$FGETFORMBYID = True
		EndIf
	EndIf
	Local $SFORM , $SATTRIBUTES , $AINPUT
	Local $INUMPARAMS = Ceiling ( ( $INUMARGS + 4294967294 ) / 2 ) + 4294967295
	Local $SADDDATA , $SNEWURL
	For $IFORMORDINAL = 0 To UBound ( $AFORM ) + 4294967295
		If $FGETFORMBYINDEX And $IFORMORDINAL <> $IFORMINDEX Then ContinueLoop
		$SFORM = $AFORM [ $IFORMORDINAL ]
		$SATTRIBUTES = StringRegExp ( $SFORM , "(?s)(.*?)>" , 3 )
		If Not @error Then $SATTRIBUTES = StringRegExpReplace ( $SATTRIBUTES [ 0 ] , "\v" , " " )
		Local $SACTION = "" , $SACCEPT = "" , $SENCTYPE = "" , $SMETHOD = "" , $SNAME = "" , $SID = ""
		$SID = __WINHTTPATTRIBVAL ( $SATTRIBUTES , "id" )
		If $FGETFORMBYID And $SFORMID <> Default And $SID <> $SFORMID Then ContinueLoop
		$SNAME = __WINHTTPATTRIBVAL ( $SATTRIBUTES , "name" )
		If $FGETFORMBYNAME And $SFORMNAME <> $SNAME Then ContinueLoop
		$SACTION = __WINHTTPHTMLDECODE ( __WINHTTPATTRIBVAL ( $SATTRIBUTES , "action" ) )
		$SACCEPT = __WINHTTPATTRIBVAL ( $SATTRIBUTES , "accept" )
		$SENCTYPE = __WINHTTPATTRIBVAL ( $SATTRIBUTES , "enctype" )
		$SMETHOD = __WINHTTPATTRIBVAL ( $SATTRIBUTES , "method" )
		$FSEND = True
		Local $SSPR1 = Chr ( 27 ) , $SSPR2 = Chr ( 26 )
		__WINHTTPNORMALIZEFORM ( $SFORM , $SSPR1 , $SSPR2 )
		$AINPUT = StringRegExp ( $SFORM , "(?si)<\h*(?:input|textarea|label|fieldset|legend|select|optgroup|option|button)\h*(.*?)/*\h*>" , 3 )
		If @error Then Return SetError ( 2 , 0 , "" )
		__WINHTTPHTML5FORMATTRIBS ( $ADTAS , $AFLDS , $INUMPARAMS , $AINPUT , $SACTION , $SENCTYPE , $SMETHOD )
		__WINHTTPNORMALIZEACTIONURL ( $SACTIONPAGE , $SACTION , $ISCHEME , $SNEWURL , $SENCTYPE , $SMETHOD , $SURL )
		If $FVARFORM And Not $SNEWURL Then Return SetError ( 5 , 0 , "" )
		Local $ASPLIT , $SBOUNDARY , $SPASSEDID , $SPASSEDDATA , $INUMREPL , $FMULTIPART = False , $SSUBMIT , $SRADIO , $SCHECKBOX , $SBUTTON
		Local $SGRSEP = Chr ( 29 ) , $IERR
		Local $AINPUTIDS [ 4 ] [ UBound ( $AINPUT ) ]
		Switch $SENCTYPE
		Case "" , "application/x-www-form-urlencoded" , "text/plain"
			For $I = 0 To UBound ( $AINPUT ) + 4294967295
				__WINHTTPFORMATTRIB ( $AINPUTIDS , $I , $AINPUT [ $I ] )
				If $AINPUTIDS [ 1 ] [ $I ] Then
					$AINPUTIDS [ 1 ] [ $I ] = __WINHTTPURLENCODE ( StringReplace ( $AINPUTIDS [ 1 ] [ $I ] , $SSPR1 , " " ) , $SENCTYPE )
					$AINPUTIDS [ 2 ] [ $I ] = __WINHTTPURLENCODE ( StringReplace ( StringReplace ( $AINPUTIDS [ 2 ] [ $I ] , $SSPR2 , ">" ) , $SSPR1 , " " ) , $SENCTYPE )
					$SADDDATA &= $AINPUTIDS [ 1 ] [ $I ] & "=" & $AINPUTIDS [ 2 ] [ $I ] & "&"
					If $AINPUTIDS [ 3 ] [ $I ] = "submit" Then $SSUBMIT &= $AINPUTIDS [ 1 ] [ $I ] & "=" & $AINPUTIDS [ 2 ] [ $I ] & $SGRSEP
					If $AINPUTIDS [ 3 ] [ $I ] = "radio" Then $SRADIO &= $AINPUTIDS [ 1 ] [ $I ] & "=" & $AINPUTIDS [ 2 ] [ $I ] & $SGRSEP
					If $AINPUTIDS [ 3 ] [ $I ] = "checkbox" Then $SCHECKBOX &= $AINPUTIDS [ 1 ] [ $I ] & "=" & $AINPUTIDS [ 2 ] [ $I ] & $SGRSEP
					If $AINPUTIDS [ 3 ] [ $I ] = "button" Then $SBUTTON &= $AINPUTIDS [ 1 ] [ $I ] & "=" & $AINPUTIDS [ 2 ] [ $I ] & $SGRSEP
				EndIf
			Next
			$SSUBMIT = StringTrimRight ( $SSUBMIT , 1 )
			$SRADIO = StringTrimRight ( $SRADIO , 1 )
			$SCHECKBOX = StringTrimRight ( $SCHECKBOX , 1 )
			$SBUTTON = StringTrimRight ( $SBUTTON , 1 )
			$SADDDATA = StringTrimRight ( $SADDDATA , 1 )
			For $K = 1 To $INUMPARAMS
				$SPASSEDDATA = __WINHTTPURLENCODE ( $ADTAS [ $K ] , $SENCTYPE )
				$ADTAS [ $K ] = 0
				$SPASSEDID = $AFLDS [ $K ]
				$AFLDS [ $K ] = 0
				$ASPLIT = StringSplit ( $SPASSEDID , ":" , 2 )
				$IERR = @error
				$ASPLIT [ 0 ] = __WINHTTPURLENCODE ( $ASPLIT [ 0 ] , $SENCTYPE )
				If Not $IERR Then $ASPLIT [ 1 ] = __WINHTTPURLENCODE ( $ASPLIT [ 1 ] , $SENCTYPE )
				If $IERR Or $ASPLIT [ 0 ] <> "name" Then
					If Not $IERR And $ASPLIT [ 0 ] = "id" Then $SPASSEDID = $ASPLIT [ 1 ]
					For $J = 0 To UBound ( $AINPUTIDS , 2 ) + 4294967295
						If $AINPUTIDS [ 0 ] [ $J ] = $SPASSEDID Then
							If $AINPUTIDS [ 3 ] [ $J ] = "submit" Then
								If $SPASSEDDATA = True Then
									If $SSUBMIT Then
										Local $FDELID = False
										For $SCHUNKSUB In StringSplit ( $SSUBMIT , $SGRSEP , 3 )
											If $SCHUNKSUB == $AINPUTIDS [ 1 ] [ $J ] & "=" & $AINPUTIDS [ 2 ] [ $J ] Then
												If $FDELID Then $SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:&|\A)\Q" & $SCHUNKSUB & "\E(?:&|\Z)" , "&" , 1 )
												$FDELID = True
											Else
												$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:&|\A)\Q" & $SCHUNKSUB & "\E(?:&|\Z)" , "&" )
											EndIf
											__WINHTTPTRIMBOUNDS ( $SADDDATA , "&" )
										Next
										$SSUBMIT = ""
									EndIf
								EndIf
							ElseIf $AINPUTIDS [ 3 ] [ $J ] = "radio" Then
								If $SPASSEDDATA = $AINPUTIDS [ 2 ] [ $J ] Then
									For $SCHUNKSUB In StringSplit ( $SRADIO , $SGRSEP , 3 )
										If $SCHUNKSUB == $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA Then
											$SADDDATA = StringRegExpReplace ( StringReplace ( $SADDDATA , "&" , "&&" ) , "(?:&|\A)\Q" & $AINPUTIDS [ 1 ] [ $J ] & "\E(.*?)(?:&|\Z)" , "&" )
											$SADDDATA = StringReplace ( StringReplace ( $SADDDATA , "&&" , "&" ) , "&&" , "&" )
											If StringLeft ( $SADDDATA , 1 ) = "&" Then $SADDDATA = StringTrimLeft ( $SADDDATA , 1 )
											$SADDDATA &= "&" & $SCHUNKSUB
											$SRADIO = StringRegExpReplace ( StringReplace ( $SRADIO , $SGRSEP , $SGRSEP & $SGRSEP ) , "(?:" & $SGRSEP & "|\A)\Q" & $AINPUTIDS [ 1 ] [ $J ] & "\E(.*?)(?:" & $SGRSEP & "|\Z)" , $SGRSEP )
											$SRADIO = StringReplace ( StringReplace ( $SRADIO , $SGRSEP & $SGRSEP , $SGRSEP ) , $SGRSEP & $SGRSEP , $SGRSEP )
										EndIf
									Next
								EndIf
							ElseIf $AINPUTIDS [ 3 ] [ $J ] = "checkbox" Then
								$SCHECKBOX = StringRegExpReplace ( $SCHECKBOX , "\Q" & $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA & "\E" & $SGRSEP & "*" , "" )
								__WINHTTPTRIMBOUNDS ( $SCHECKBOX , $SGRSEP )
							ElseIf $AINPUTIDS [ 3 ] [ $J ] = "button" Then
								$SBUTTON = StringRegExpReplace ( $SBUTTON , "\Q" & $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA & "\E" & $SGRSEP & "*" , "" )
								__WINHTTPTRIMBOUNDS ( $SBUTTON , $SGRSEP )
							Else
								$SADDDATA = StringRegExpReplace ( StringReplace ( $SADDDATA , "&" , "&&" ) , "(?:&|\A)\Q" & $AINPUTIDS [ 1 ] [ $J ] & "=" & $AINPUTIDS [ 2 ] [ $J ] & "\E(?:&|\Z)" , "&" & $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA & "&" )
								$INUMREPL = @extended
								$SADDDATA = StringReplace ( $SADDDATA , "&&" , "&" )
								If $INUMREPL > 1 Then
									$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:&|\A)\Q" & $AINPUTIDS [ 1 ] [ $J ] & "\E=.*?(?:&|\Z)" , "&" , $INUMREPL + 4294967295 )
								EndIf
								__WINHTTPTRIMBOUNDS ( $SADDDATA , "&" )
							EndIf
						EndIf
					Next
				Else
					For $J = 0 To UBound ( $AINPUTIDS , 2 ) + 4294967295
						If $AINPUTIDS [ 3 ] [ $J ] = "submit" Then
							If $SPASSEDDATA = True Then
								If $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] Then
									If $SSUBMIT Then
										Local $FDEL = False
										For $SCHUNKSUB In StringSplit ( $SSUBMIT , $SGRSEP , 3 )
											If $SCHUNKSUB = $AINPUTIDS [ 1 ] [ $J ] & "=" & $AINPUTIDS [ 2 ] [ $J ] Then
												If $FDEL Then $SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:&|\A)\Q" & $SCHUNKSUB & "\E(?:&|\Z)" , "&" , 1 )
												$FDEL = True
											Else
												$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:&|\A)\Q" & $SCHUNKSUB & "\E(?:&|\Z)" , "&" )
											EndIf
											__WINHTTPTRIMBOUNDS ( $SADDDATA , "&" )
										Next
										$SSUBMIT = ""
									EndIf
									ContinueLoop 2
								EndIf
							Else
								ContinueLoop 2
							EndIf
						ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "radio" Then
							For $SCHUNKSUB In StringSplit ( $SRADIO , $SGRSEP , 3 )
								If $SCHUNKSUB == $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA Then
									$SADDDATA = StringReplace ( StringReplace ( StringRegExpReplace ( StringReplace ( $SADDDATA , "&" , "&&" ) , "(?:&|\A)\Q" & $AINPUTIDS [ 1 ] [ $J ] & "\E(.*?)(?:&|\Z)" , "&" ) , "&&" , "&" ) , "&&" , "&" )
									If StringLeft ( $SADDDATA , 1 ) = "&" Then $SADDDATA = StringTrimLeft ( $SADDDATA , 1 )
									$SADDDATA &= "&" & $SCHUNKSUB
									$SRADIO = StringRegExpReplace ( StringReplace ( $SRADIO , $SGRSEP , $SGRSEP & $SGRSEP ) , "(?:" & $SGRSEP & "|\A)\Q" & $AINPUTIDS [ 1 ] [ $J ] & "\E(.*?)(?:" & $SGRSEP & "|\Z)" , $SGRSEP )
									$SRADIO = StringReplace ( StringReplace ( $SRADIO , $SGRSEP & $SGRSEP , $SGRSEP ) , $SGRSEP & $SGRSEP , $SGRSEP )
								EndIf
							Next
							ContinueLoop 2
						ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "checkbox" Then
							$SCHECKBOX = StringRegExpReplace ( $SCHECKBOX , "\Q" & $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA & "\E" & $SGRSEP & "*" , "" )
							__WINHTTPTRIMBOUNDS ( $SCHECKBOX , $SGRSEP )
							ContinueLoop 2
						ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "button" Then
							$SBUTTON = StringRegExpReplace ( $SBUTTON , "\Q" & $AINPUTIDS [ 1 ] [ $J ] & "=" & $SPASSEDDATA & "\E" & $SGRSEP & "*" , "" )
							__WINHTTPTRIMBOUNDS ( $SBUTTON , $SGRSEP )
							ContinueLoop 2
						EndIf
					Next
					$SADDDATA = StringRegExpReplace ( StringReplace ( $SADDDATA , "&" , "&&" ) , "(?:&|\A)\Q" & $ASPLIT [ 1 ] & "\E=.*?(?:&|\Z)" , "&" & $ASPLIT [ 1 ] & "=" & $SPASSEDDATA & "&" )
					$INUMREPL = @extended
					$SADDDATA = StringReplace ( $SADDDATA , "&&" , "&" )
					If $INUMREPL > 1 Then
						$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:&|\A)\Q" & $ASPLIT [ 1 ] & "\E=.*?(?:&|\Z)" , "&" , $INUMREPL + 4294967295 )
					EndIf
					__WINHTTPTRIMBOUNDS ( $SADDDATA , "&" )
				EndIf
			Next
			__WINHTTPFINALIZECTRLS ( $SSUBMIT , $SRADIO , $SCHECKBOX , $SBUTTON , $SADDDATA , $SGRSEP , "&" )
			If $SMETHOD = "GET" Then
				$SACTION &= "?" & $SADDDATA
				$SADDDATA = ""
			EndIf
		Case "multipart/form-data"
			If $SMETHOD = "POST" Then
				$FMULTIPART = True
				$SBOUNDARY = StringFormat ( "%s%.5f" , "----WinHttpBoundaryLine_" , Random ( 10000 , 99999 ) )
				Local $SCDISP = "Content-Disposition: form-data; name="""
				For $I = 0 To UBound ( $AINPUT ) + 4294967295
					__WINHTTPFORMATTRIB ( $AINPUTIDS , $I , $AINPUT [ $I ] )
					If $AINPUTIDS [ 1 ] [ $I ] Then
						$AINPUTIDS [ 1 ] [ $I ] = StringReplace ( $AINPUTIDS [ 1 ] [ $I ] , $SSPR1 , " " )
						$AINPUTIDS [ 2 ] [ $I ] = StringReplace ( StringReplace ( $AINPUTIDS [ 2 ] [ $I ] , $SSPR2 , ">" ) , $SSPR1 , " " )
						If $AINPUTIDS [ 3 ] [ $I ] = "file" Then
							$SADDDATA &= "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $I ] & """; filename=""""" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $I ] & @CRLF
						Else
							$SADDDATA &= "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $I ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $I ] & @CRLF
						EndIf
						If $AINPUTIDS [ 3 ] [ $I ] = "submit" Then $SSUBMIT &= "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $I ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $I ] & @CRLF & $SGRSEP
						If $AINPUTIDS [ 3 ] [ $I ] = "radio" Then $SRADIO &= "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $I ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $I ] & @CRLF & $SGRSEP
						If $AINPUTIDS [ 3 ] [ $I ] = "checkbox" Then $SCHECKBOX &= "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $I ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $I ] & @CRLF & $SGRSEP
						If $AINPUTIDS [ 3 ] [ $I ] = "button" Then $SBUTTON &= "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $I ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $I ] & @CRLF & $SGRSEP
					EndIf
				Next
				$SSUBMIT = StringTrimRight ( $SSUBMIT , 1 )
				$SRADIO = StringTrimRight ( $SRADIO , 1 )
				$SCHECKBOX = StringTrimRight ( $SCHECKBOX , 1 )
				$SBUTTON = StringTrimRight ( $SBUTTON , 1 )
				$SADDDATA &= "--" & $SBOUNDARY & "--" & @CRLF
				For $K = 1 To $INUMPARAMS
					$SPASSEDDATA = $ADTAS [ $K ]
					$ADTAS [ $K ] = 0
					$SPASSEDID = $AFLDS [ $K ]
					$AFLDS [ $K ] = 0
					$ASPLIT = StringSplit ( $SPASSEDID , ":" , 2 )
					If @error Or $ASPLIT [ 0 ] <> "name" Then
						If Not @error And $ASPLIT [ 0 ] = "id" Then $SPASSEDID = $ASPLIT [ 1 ]
						For $J = 0 To UBound ( $AINPUTIDS , 2 ) + 4294967295
							If $AINPUTIDS [ 0 ] [ $J ] = $SPASSEDID Then
								If $AINPUTIDS [ 3 ] [ $J ] = "file" Then
									$SADDDATA = StringReplace ( $SADDDATA , $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """; filename=""""" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $J ] & @CRLF , __WINHTTPFILECONTENT ( $SACCEPT , $AINPUTIDS [ 1 ] [ $J ] , $SPASSEDDATA , $SBOUNDARY ) , 0 , 1 )
								ElseIf $AINPUTIDS [ 3 ] [ $J ] = "submit" Then
									If $SPASSEDDATA = True Then
										If $SSUBMIT Then
											Local $FMDELID = False
											For $SCHUNKSUB In StringSplit ( $SSUBMIT , $SGRSEP , 3 )
												If $SCHUNKSUB = "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $J ] & @CRLF Then
													If $FMDELID Then $SADDDATA = StringReplace ( $SADDDATA , $SCHUNKSUB , "" , 1 , 1 )
													$FMDELID = True
												Else
													$SADDDATA = StringReplace ( $SADDDATA , $SCHUNKSUB , "" , 0 , 1 )
												EndIf
											Next
											$SSUBMIT = ""
										EndIf
									EndIf
								ElseIf $AINPUTIDS [ 3 ] [ $J ] = "radio" Then
									If $SPASSEDDATA = $AINPUTIDS [ 2 ] [ $J ] Then
										For $SCHUNKSUB In StringSplit ( $SRADIO , $SGRSEP , 3 )
											If StringInStr ( $SCHUNKSUB , "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF , 1 ) Then
												$SADDDATA = StringRegExpReplace ( $SADDDATA , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & "\E" & "(.*?)" & @CRLF , "" )
												$SADDDATA = StringReplace ( $SADDDATA , "--" & $SBOUNDARY & "--" & @CRLF , "" , 0 , 1 )
												$SADDDATA &= $SCHUNKSUB & "--" & $SBOUNDARY & "--" & @CRLF
												$SRADIO = StringRegExpReplace ( $SRADIO , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & "\E(.*?)" & @CRLF & $SGRSEP & "?" , "" )
											EndIf
										Next
									EndIf
								ElseIf $AINPUTIDS [ 3 ] [ $J ] = "checkbox" Then
									$SCHECKBOX = StringRegExpReplace ( $SCHECKBOX , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF & "\E" & $SGRSEP & "*" , "" )
									If StringRight ( $SCHECKBOX , 1 ) = $SGRSEP Then $SCHECKBOX = StringTrimRight ( $SCHECKBOX , 1 )
								ElseIf $AINPUTIDS [ 3 ] [ $J ] = "button" Then
									$SBUTTON = StringRegExpReplace ( $SBUTTON , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF & "\E" & $SGRSEP & "*" , "" )
									If StringRight ( $SBUTTON , 1 ) = $SGRSEP Then $SBUTTON = StringTrimRight ( $SBUTTON , 1 )
								Else
									$SADDDATA = StringReplace ( $SADDDATA , $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $J ] & @CRLF , $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF , 0 , 1 )
									$INUMREPL = @extended
									If $INUMREPL > 1 Then
										$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?s)\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & "\E\r\n\r\n.*?\r\n" , "" , $INUMREPL + 4294967295 )
									EndIf
								EndIf
							EndIf
						Next
					Else
						For $J = 0 To UBound ( $AINPUTIDS , 2 ) + 4294967295
							If $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "file" Then
								$SADDDATA = StringReplace ( $SADDDATA , $SCDISP & $ASPLIT [ 1 ] & """; filename=""""" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $J ] & @CRLF , __WINHTTPFILECONTENT ( $SACCEPT , $AINPUTIDS [ 1 ] [ $J ] , $SPASSEDDATA , $SBOUNDARY ) , 0 , 1 )
							ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "submit" Then
								If $SPASSEDDATA = True Then
									If $SSUBMIT Then
										Local $FMDEL = False
										For $SCHUNKSUB In StringSplit ( $SSUBMIT , $SGRSEP , 3 )
											If $SCHUNKSUB = "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $AINPUTIDS [ 2 ] [ $J ] & @CRLF Then
												If $FMDEL Then $SADDDATA = StringReplace ( $SADDDATA , $SCHUNKSUB , "" , 1 , 1 )
												$FMDEL = True
											Else
												$SADDDATA = StringReplace ( $SADDDATA , $SCHUNKSUB , "" , 0 , 1 )
											EndIf
										Next
										$SSUBMIT = ""
									EndIf
									ContinueLoop 2
								Else
									ContinueLoop 2
								EndIf
							ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "radio" Then
								For $SCHUNKSUB In StringSplit ( $SRADIO , $SGRSEP , 3 )
									If StringInStr ( $SCHUNKSUB , "--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF , 1 ) Then
										$SADDDATA = StringRegExpReplace ( $SADDDATA , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & "\E" & "(.*?)" & @CRLF , "" )
										$SADDDATA = StringReplace ( $SADDDATA , "--" & $SBOUNDARY & "--" & @CRLF , "" , 0 , 1 )
										$SADDDATA &= $SCHUNKSUB & "--" & $SBOUNDARY & "--" & @CRLF
										$SRADIO = StringRegExpReplace ( $SRADIO , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & "\E(.*?)" & @CRLF & $SGRSEP & "?" , "" )
									EndIf
								Next
								ContinueLoop 2
							ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "checkbox" Then
								$SCHECKBOX = StringRegExpReplace ( $SCHECKBOX , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF & "\E" & $SGRSEP & "*" , "" )
								If StringRight ( $SCHECKBOX , 1 ) = $SGRSEP Then $SCHECKBOX = StringTrimRight ( $SCHECKBOX , 1 )
								ContinueLoop 2
							ElseIf $AINPUTIDS [ 1 ] [ $J ] == $ASPLIT [ 1 ] And $AINPUTIDS [ 3 ] [ $J ] = "button" Then
								$SBUTTON = StringRegExpReplace ( $SBUTTON , "\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $AINPUTIDS [ 1 ] [ $J ] & """" & @CRLF & @CRLF & $SPASSEDDATA & @CRLF & "\E" & $SGRSEP & "*" , "" )
								If StringRight ( $SBUTTON , 1 ) = $SGRSEP Then $SBUTTON = StringTrimRight ( $SBUTTON , 1 )
								ContinueLoop 2
							EndIf
						Next
						$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?s)\Q" & $SCDISP & $ASPLIT [ 1 ] & """" & "\E\r\n\r\n.*?\r\n" , $SCDISP & $ASPLIT [ 1 ] & """" & @CRLF & @CRLF & StringReplace ( $SPASSEDDATA , "\" , "\\" ) & @CRLF )
						$INUMREPL = @extended
						If $INUMREPL > 1 Then
							$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?s)\Q--" & $SBOUNDARY & @CRLF & $SCDISP & $ASPLIT [ 1 ] & """" & "\E\r\n\r\n.*?\r\n" , "" , $INUMREPL + 4294967295 )
						EndIf
					EndIf
				Next
			EndIf
			__WINHTTPFINALIZECTRLS ( $SSUBMIT , $SRADIO , $SCHECKBOX , $SBUTTON , $SADDDATA , $SGRSEP )
		EndSwitch
		ExitLoop
	Next
	If $FSEND Then
		If $FVARFORM Then
			$HINTERNET = _WINHTTPCONNECT ( $HOPEN , $SNEWURL )
		Else
			If $SNEWURL Then
				$HOPEN = _WINHTTPQUERYOPTION ( $HINTERNET , $WINHTTP_OPTION_PARENT_HANDLE )
				_WINHTTPCLOSEHANDLE ( $HINTERNET )
				$HINTERNET = _WINHTTPCONNECT ( $HOPEN , $SNEWURL )
			EndIf
		EndIf
		Local $HREQUEST
		If $ISCHEME = $INTERNET_SCHEME_HTTPS Then
			$HREQUEST = __WINHTTPFORMSEND ( $HINTERNET , $SMETHOD , $SACTION , $FMULTIPART , $SBOUNDARY , $SADDDATA , True , $SADDITIONALHEADERS , $SCREDNAME , $SCREDPASS , $IIGNORECERTERR )
		Else
			$HREQUEST = __WINHTTPFORMSEND ( $HINTERNET , $SMETHOD , $SACTION , $FMULTIPART , $SBOUNDARY , $SADDDATA , False , $SADDITIONALHEADERS , $SCREDNAME , $SCREDPASS )
			If _WINHTTPQUERYHEADERS ( $HREQUEST , $WINHTTP_QUERY_STATUS_CODE ) >= $HTTP_STATUS_BAD_REQUEST Then
				_WINHTTPCLOSEHANDLE ( $HREQUEST )
				$HREQUEST = __WINHTTPFORMSEND ( $HINTERNET , $SMETHOD , $SACTION , $FMULTIPART , $SBOUNDARY , $SADDDATA , True , $SADDITIONALHEADERS , $SCREDNAME , $SCREDPASS , $IIGNORECERTERR )
			EndIf
		EndIf
		Local $VRETURNED = _WINHTTPSIMPLEREADDATA ( $HREQUEST )
		If @error Then
			_WINHTTPCLOSEHANDLE ( $HREQUEST )
			Return SetError ( 4 , 0 , "" )
		EndIf
		Local $ISCODE = _WINHTTPQUERYHEADERS ( $HREQUEST , $WINHTTP_QUERY_STATUS_CODE )
		If $IRETARR Then
			Local $ARETURN [ 3 ] = [ _WINHTTPQUERYHEADERS ( $HREQUEST ) , $VRETURNED , _WINHTTPQUERYOPTION ( $HREQUEST , $WINHTTP_OPTION_URL ) ]
			$VRETURNED = $ARETURN
		EndIf
		_WINHTTPCLOSEHANDLE ( $HREQUEST )
		Return SetExtended ( $ISCODE , $VRETURNED )
	EndIf
	Return SetError ( 3 , 0 , "" )
EndFunc
Func _WINHTTPSIMPLEFORMFILL_SETUPLOADCALLBACK ( $VCALLBACK = Default , $INUMCHUNKS = 100 )
	If $INUMCHUNKS <= 0 Then $INUMCHUNKS = 100
	Local Static $VFUNC = Default , $IPARTS = $INUMCHUNKS
	If $VCALLBACK <> Default Then
		$VFUNC = $VCALLBACK
		$IPARTS = Ceiling ( $INUMCHUNKS )
	ElseIf $VCALLBACK = 0 Then
		$VFUNC = Default
		$IPARTS = 1
	EndIf
	Local $AOUT [ 2 ] = [ $VFUNC , $IPARTS ]
	Return $AOUT
EndFunc
Func _WINHTTPSIMPLEREADDATA ( $HREQUEST , $IMODE = Default )
	If $IMODE = Default Then
		$IMODE = 0
		If __WINHTTPCHARSET ( _WINHTTPQUERYHEADERS ( $HREQUEST , $WINHTTP_QUERY_CONTENT_TYPE ) ) = 65001 Then $IMODE = 1
	Else
		__WINHTTPDEFAULT ( $IMODE , 0 )
	EndIf
	If $IMODE > 2 Or $IMODE < 0 Then Return SetError ( 1 , 0 , "" )
	Local $VDATA = Binary ( "" )
	If _WINHTTPQUERYDATAAVAILABLE ( $HREQUEST ) Then
		Do
			$VDATA &= _WINHTTPREADDATA ( $HREQUEST , 2 )
		Until @error
		Switch $IMODE
		Case 0
			Return BinaryToString ( $VDATA )
		Case 1
			Return BinaryToString ( $VDATA , 4 )
	Case Else
			Return $VDATA
		EndSwitch
	EndIf
	Return SetError ( 2 , 0 , $VDATA )
EndFunc
Func _WINHTTPSIMPLEREADDATAASYNC ( $HINTERNET , ByRef $PBUFFER , $INUMBEROFBYTESTOREAD = Default )
	__WINHTTPDEFAULT ( $INUMBEROFBYTESTOREAD , 8192 )
	Local $VOUT = _WINHTTPREADDATA ( $HINTERNET , 2 , $INUMBEROFBYTESTOREAD , $PBUFFER )
	Return SetError ( @error , @extended , $VOUT )
EndFunc
Func _WINHTTPSIMPLEREQUEST ( $HCONNECT , $STYPE = Default , $SPATH = Default , $SREFERRER = Default , $SDTA = Default , $SHEADER = Default , $FGETHEADERS = Default , $IMODE = Default , $SCREDNAME = Default , $SCREDPASS = Default )
	__WINHTTPDEFAULT ( $STYPE , "GET" )
	__WINHTTPDEFAULT ( $SPATH , "" )
	__WINHTTPDEFAULT ( $SREFERRER , $WINHTTP_NO_REFERER )
	__WINHTTPDEFAULT ( $SDTA , $WINHTTP_NO_REQUEST_DATA )
	__WINHTTPDEFAULT ( $SHEADER , $WINHTTP_NO_ADDITIONAL_HEADERS )
	__WINHTTPDEFAULT ( $FGETHEADERS , False )
	__WINHTTPDEFAULT ( $IMODE , Default )
	__WINHTTPDEFAULT ( $SCREDNAME , "" )
	__WINHTTPDEFAULT ( $SCREDPASS , "" )
	If $IMODE > 2 Or $IMODE < 0 Then Return SetError ( 4 , 0 , 0 )
	Local $HREQUEST = _WINHTTPSIMPLESENDREQUEST ( $HCONNECT , $STYPE , $SPATH , $SREFERRER , $SDTA , $SHEADER )
	If @error Then Return SetError ( @error , 0 , 0 )
	__WINHTTPSETCREDENTIALS ( $HREQUEST , $SHEADER , $SDTA , $SCREDNAME , $SCREDPASS )
	Local $IEXTENDED = _WINHTTPQUERYHEADERS ( $HREQUEST , $WINHTTP_QUERY_STATUS_CODE )
	If $FGETHEADERS Then
		Local $ADATA [ 3 ] = [ _WINHTTPQUERYHEADERS ( $HREQUEST ) , _WINHTTPSIMPLEREADDATA ( $HREQUEST , $IMODE ) , _WINHTTPQUERYOPTION ( $HREQUEST , $WINHTTP_OPTION_URL ) ]
		_WINHTTPCLOSEHANDLE ( $HREQUEST )
		Return SetExtended ( $IEXTENDED , $ADATA )
	EndIf
	Local $SOUTDATA = _WINHTTPSIMPLEREADDATA ( $HREQUEST , $IMODE )
	_WINHTTPCLOSEHANDLE ( $HREQUEST )
	Return SetExtended ( $IEXTENDED , $SOUTDATA )
EndFunc
Func _WINHTTPSIMPLESENDREQUEST ( $HCONNECT , $STYPE = Default , $SPATH = Default , $SREFERRER = Default , $SDTA = Default , $SHEADER = Default )
	__WINHTTPDEFAULT ( $STYPE , "GET" )
	__WINHTTPDEFAULT ( $SPATH , "" )
	__WINHTTPDEFAULT ( $SREFERRER , $WINHTTP_NO_REFERER )
	__WINHTTPDEFAULT ( $SDTA , $WINHTTP_NO_REQUEST_DATA )
	__WINHTTPDEFAULT ( $SHEADER , $WINHTTP_NO_ADDITIONAL_HEADERS )
	Local $HREQUEST = _WINHTTPOPENREQUEST ( $HCONNECT , $STYPE , $SPATH , Default , $SREFERRER )
	If Not $HREQUEST Then Return SetError ( 1 , @error , 0 )
	If $STYPE = "POST" And $SHEADER = $WINHTTP_NO_ADDITIONAL_HEADERS Then $SHEADER = "Content-Type: application/x-www-form-urlencoded" & @CRLF
	_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_DECOMPRESSION , $WINHTTP_DECOMPRESSION_FLAG_ALL )
	_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_UNSAFE_HEADER_PARSING , 1 )
	_WINHTTPSENDREQUEST ( $HREQUEST , $SHEADER , $SDTA )
	If @error Then Return SetError ( 2 , 0 * _WINHTTPCLOSEHANDLE ( $HREQUEST ) , 0 )
	_WINHTTPRECEIVERESPONSE ( $HREQUEST )
	If @error Then Return SetError ( 3 , 0 * _WINHTTPCLOSEHANDLE ( $HREQUEST ) , 0 )
	Return $HREQUEST
EndFunc
Func _WINHTTPSIMPLESENDSSLREQUEST ( $HCONNECT , $STYPE = Default , $SPATH = Default , $SREFERRER = Default , $SDTA = Default , $SHEADER = Default , $IIGNOREALLCERTERRORS = 0 )
	__WINHTTPDEFAULT ( $STYPE , "GET" )
	__WINHTTPDEFAULT ( $SPATH , "" )
	__WINHTTPDEFAULT ( $SREFERRER , $WINHTTP_NO_REFERER )
	__WINHTTPDEFAULT ( $SDTA , $WINHTTP_NO_REQUEST_DATA )
	__WINHTTPDEFAULT ( $SHEADER , $WINHTTP_NO_ADDITIONAL_HEADERS )
	Local $HREQUEST = _WINHTTPOPENREQUEST ( $HCONNECT , $STYPE , $SPATH , Default , $SREFERRER , Default , BitOR ( $WINHTTP_FLAG_SECURE , $WINHTTP_FLAG_ESCAPE_DISABLE ) )
	If Not $HREQUEST Then Return SetError ( 1 , @error , 0 )
	If $IIGNOREALLCERTERRORS Then _WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_SECURITY_FLAGS , BitOR ( $SECURITY_FLAG_IGNORE_UNKNOWN_CA , $SECURITY_FLAG_IGNORE_CERT_DATE_INVALID , $SECURITY_FLAG_IGNORE_CERT_CN_INVALID , $SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE ) )
	If $STYPE = "POST" And $SHEADER = $WINHTTP_NO_ADDITIONAL_HEADERS Then $SHEADER = "Content-Type: application/x-www-form-urlencoded" & @CRLF
	_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_DECOMPRESSION , $WINHTTP_DECOMPRESSION_FLAG_ALL )
	_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_UNSAFE_HEADER_PARSING , 1 )
	_WINHTTPSENDREQUEST ( $HREQUEST , $SHEADER , $SDTA )
	If @error Then Return SetError ( 2 , 0 * _WINHTTPCLOSEHANDLE ( $HREQUEST ) , 0 )
	_WINHTTPRECEIVERESPONSE ( $HREQUEST )
	If @error Then Return SetError ( 3 , 0 * _WINHTTPCLOSEHANDLE ( $HREQUEST ) , 0 )
	Return $HREQUEST
EndFunc
Func _WINHTTPSIMPLESSLREQUEST ( $HCONNECT , $STYPE = Default , $SPATH = Default , $SREFERRER = Default , $SDTA = Default , $SHEADER = Default , $FGETHEADERS = Default , $IMODE = Default , $SCREDNAME = Default , $SCREDPASS = Default , $IIGNORECERTERRORS = 0 )
	__WINHTTPDEFAULT ( $STYPE , "GET" )
	__WINHTTPDEFAULT ( $SPATH , "" )
	__WINHTTPDEFAULT ( $SREFERRER , $WINHTTP_NO_REFERER )
	__WINHTTPDEFAULT ( $SDTA , $WINHTTP_NO_REQUEST_DATA )
	__WINHTTPDEFAULT ( $SHEADER , $WINHTTP_NO_ADDITIONAL_HEADERS )
	__WINHTTPDEFAULT ( $FGETHEADERS , False )
	__WINHTTPDEFAULT ( $IMODE , Default )
	__WINHTTPDEFAULT ( $SCREDNAME , "" )
	__WINHTTPDEFAULT ( $SCREDPASS , "" )
	If $IMODE > 2 Or $IMODE < 0 Then Return SetError ( 4 , 0 , 0 )
	Local $HREQUEST = _WINHTTPSIMPLESENDSSLREQUEST ( $HCONNECT , $STYPE , $SPATH , $SREFERRER , $SDTA , $SHEADER , $IIGNORECERTERRORS )
	If @error Then Return SetError ( @error , 0 , 0 )
	__WINHTTPSETCREDENTIALS ( $HREQUEST , $SHEADER , $SDTA , $SCREDNAME , $SCREDPASS )
	If $FGETHEADERS Then
		Local $ADATA [ 3 ] = [ _WINHTTPQUERYHEADERS ( $HREQUEST ) , _WINHTTPSIMPLEREADDATA ( $HREQUEST , $IMODE ) , _WINHTTPQUERYOPTION ( $HREQUEST , $WINHTTP_OPTION_URL ) ]
		_WINHTTPCLOSEHANDLE ( $HREQUEST )
		Return $ADATA
	EndIf
	Local $SOUTDATA = _WINHTTPSIMPLEREADDATA ( $HREQUEST , $IMODE )
	_WINHTTPCLOSEHANDLE ( $HREQUEST )
	Return $SOUTDATA
EndFunc
Func _WINHTTPTIMEFROMSYSTEMTIME ( )
	Local $SYSTEMTIME = DllStructCreate ( "word Year;" & "word Month;" & "word DayOfWeek;" & "word Day;" & "word Hour;" & "word Minute;" & "word Second;" & "word Milliseconds" )
	DllCall ( "kernel32.dll" , "none" , "GetSystemTime" , "struct*" , $SYSTEMTIME )
	If @error Then Return SetError ( 1 , 0 , "" )
	Local $TTIME = DllStructCreate ( "wchar[62]" )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpTimeFromSystemTime" , "struct*" , $SYSTEMTIME , "struct*" , $TTIME )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 2 , 0 , "" )
	Return DllStructGetData ( $TTIME , 1 )
EndFunc
Func _WINHTTPTIMETOSYSTEMTIME ( $SHTTPTIME )
	Local $SYSTEMTIME = DllStructCreate ( "word Year;" & "word Month;" & "word DayOfWeek;" & "word Day;" & "word Hour;" & "word Minute;" & "word Second;" & "word Milliseconds" )
	Local $TTIME = DllStructCreate ( "wchar[62]" )
	DllStructSetData ( $TTIME , 1 , $SHTTPTIME )
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpTimeToSystemTime" , "struct*" , $TTIME , "struct*" , $SYSTEMTIME )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 2 , 0 , 0 )
	Local $ARET [ 8 ] = [ DllStructGetData ( $SYSTEMTIME , "Year" ) , DllStructGetData ( $SYSTEMTIME , "Month" ) , DllStructGetData ( $SYSTEMTIME , "DayOfWeek" ) , DllStructGetData ( $SYSTEMTIME , "Day" ) , DllStructGetData ( $SYSTEMTIME , "Hour" ) , DllStructGetData ( $SYSTEMTIME , "Minute" ) , DllStructGetData ( $SYSTEMTIME , "Second" ) , DllStructGetData ( $SYSTEMTIME , "Milliseconds" ) ]
	Return $ARET
EndFunc
Func _WINHTTPWRITEDATA ( $HREQUEST , $VDATA , $IMODE = Default )
	__WINHTTPDEFAULT ( $IMODE , 0 )
	Local $INUMBEROFBYTESTOWRITE , $TDATA
	If $IMODE = 1 Then
		$INUMBEROFBYTESTOWRITE = BinaryLen ( $VDATA )
		$TDATA = DllStructCreate ( "byte[" & $INUMBEROFBYTESTOWRITE & "]" )
		DllStructSetData ( $TDATA , 1 , $VDATA )
	ElseIf IsDllStruct ( $VDATA ) Then
		$INUMBEROFBYTESTOWRITE = DllStructGetSize ( $VDATA )
		$TDATA = $VDATA
	Else
		$INUMBEROFBYTESTOWRITE = StringLen ( $VDATA )
		$TDATA = DllStructCreate ( "char[" & $INUMBEROFBYTESTOWRITE + 1 & "]" )
		DllStructSetData ( $TDATA , 1 , $VDATA )
	EndIf
	Local $ACALL = DllCall ( $HWINHTTPDLL__WINHTTP , "bool" , "WinHttpWriteData" , "handle" , $HREQUEST , "struct*" , $TDATA , "dword" , $INUMBEROFBYTESTOWRITE , "dword*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return SetExtended ( $ACALL [ 4 ] , 1 )
EndFunc
Func __WINHTTPFILECONTENT ( $SACCEPT , $SNAME , $SFILESTRING , $SBOUNDARYMAIN = "" )
	#forceref $sAccept
	Local $FNONSTANDARD = False
	If StringLeft ( $SFILESTRING , 10 ) = "PHP#50338:" Then
		$SFILESTRING = StringTrimLeft ( $SFILESTRING , 10 )
		$FNONSTANDARD = True
	EndIf
	Local $SOUT = "Content-Disposition: form-data; name=""" & $SNAME & """"
	If Not $SFILESTRING Then Return $SOUT & "; filename=""""" & @CRLF & @CRLF & @CRLF
	If StringRight ( $SFILESTRING , 1 ) = "|" Then $SFILESTRING = StringTrimRight ( $SFILESTRING , 1 )
	Local $AFILES = StringSplit ( $SFILESTRING , "|" , 2 ) , $HFILE
	If UBound ( $AFILES ) = 1 Then
		$HFILE = FileOpen ( $AFILES [ 0 ] , 16 )
		$SOUT &= "; filename=""" & StringRegExpReplace ( $AFILES [ 0 ] , ".*\\" , "" ) & """" & @CRLF & "Content-Type: " & __WINHTTPMIMETYPE ( $AFILES [ 0 ] ) & @CRLF & @CRLF & BinaryToString ( FileRead ( $HFILE ) , 1 ) & @CRLF
		FileClose ( $HFILE )
		Return $SOUT
	EndIf
	If $FNONSTANDARD Then
		$SOUT = ""
		Local $IFILES = UBound ( $AFILES )
		For $I = 0 To $IFILES + 4294967295
			$HFILE = FileOpen ( $AFILES [ $I ] , 16 )
			$SOUT &= "Content-Disposition: form-data; name=""" & $SNAME & """" & "; filename=""" & StringRegExpReplace ( $AFILES [ $I ] , ".*\\" , "" ) & """" & @CRLF & "Content-Type: " & __WINHTTPMIMETYPE ( $AFILES [ $I ] ) & @CRLF & @CRLF & BinaryToString ( FileRead ( $HFILE ) , 1 ) & @CRLF
			FileClose ( $HFILE )
			If $I < $IFILES + 4294967295 Then $SOUT &= "--" & $SBOUNDARYMAIN & @CRLF
		Next
	Else
		Local $SBOUNDARY = StringFormat ( "%s%.5f" , "----WinHttpSubBoundaryLine_" , Random ( 10000 , 99999 ) )
		$SOUT &= @CRLF & "Content-Type: multipart/mixed; boundary=" & $SBOUNDARY & @CRLF & @CRLF
		For $I = 0 To UBound ( $AFILES ) + 4294967295
			$HFILE = FileOpen ( $AFILES [ $I ] , 16 )
			$SOUT &= "--" & $SBOUNDARY & @CRLF & "Content-Disposition: file; filename=""" & StringRegExpReplace ( $AFILES [ $I ] , ".*\\" , "" ) & """" & @CRLF & "Content-Type: " & __WINHTTPMIMETYPE ( $AFILES [ $I ] ) & @CRLF & @CRLF & BinaryToString ( FileRead ( $HFILE ) , 1 ) & @CRLF
			FileClose ( $HFILE )
		Next
		$SOUT &= "--" & $SBOUNDARY & "--" & @CRLF
	EndIf
	Return $SOUT
EndFunc
Func __WINHTTPMIMETYPE ( $SFILENAME )
	Local $AARRAY = StringRegExp ( __WINHTTPMIMEASSOCSTRING ( ) , "(?i)\Q;" & StringRegExpReplace ( $SFILENAME , ".*\." , "" ) & "\E\|(.*?);" , 3 )
	If @error Then Return "application/octet-stream"
	Return $AARRAY [ 0 ]
EndFunc
Func __WINHTTPMIMEASSOCSTRING ( )
	Return ";ai|application/postscript;aif|audio/x-aiff;aifc|audio/x-aiff;aiff|audio/x-aiff;asc|text/plain;atom|application/atom+xml;au|audio/basic;avi|video/x-msvideo;bcpio|application/x-bcpio;bin|application/octet-stream;bmp|image/bmp;cdf|application/x-netcdf;cgm|image/cgm;class|application/octet-stream;cpio|application/x-cpio;cpt|application/mac-compactpro;csh|application/x-csh;css|text/css;dcr|application/x-director;dif|video/x-dv;dir|application/x-director;djv|image/vnd.djvu;djvu|image/vnd.djvu;dll|application/octet-stream;dmg|application/octet-stream;dms|application/octet-stream;doc|application/msword;dtd|application/xml-dtd;dv|video/x-dv;dvi|application/x-dvi;dxr|application/x-director;eps|application/postscript;etx|text/x-setext;exe|application/octet-stream;ez|application/andrew-inset;gif|image/gif;gram|application/srgs;grxml|application/srgs+xml;gtar|application/x-gtar;hdf|application/x-hdf;hqx|application/mac-binhex40;htm|text/html;html|text/html;ice|x-conference/x-cooltalk;ico|image/x-icon;ics|text/calendar;ief|image/ief;ifb|text/calendar;iges|model/iges;igs|model/iges;jnlp|application/x-java-jnlp-file;jp2|image/jp2;jpe|image/jpeg;jpeg|image/jpeg;jpg|image/jpeg;js|application/x-javascript;kar|audio/midi;latex|application/x-latex;lha|application/octet-stream;lzh|application/octet-stream;m3u|audio/x-mpegurl;m4a|audio/mp4a-latm;m4b|audio/mp4a-latm;m4p|audio/mp4a-latm;m4u|video/vnd.mpegurl;m4v|video/x-m4v;mac|image/x-macpaint;man|application/x-troff-man;mathml|application/mathml+xml;me|application/x-troff-me;mesh|model/mesh;mid|audio/midi;midi|audio/midi;mif|application/vnd.mif;mov|video/quicktime;movie|video/x-sgi-movie;mp2|audio/mpeg;mp3|audio/mpeg;mp4|video/mp4;mpe|video/mpeg;mpeg|video/mpeg;mpg|video/mpeg;mpga|audio/mpeg;ms|application/x-troff-ms;msh|model/mesh;mxu|video/vnd.mpegurl;nc|application/x-netcdf;oda|application/oda;ogg|application/ogg;pbm|image/x-portable-bitmap;pct|image/pict;pdb|chemical/x-pdb;pdf|application/pdf;pgm|image/x-portable-graymap;pgn|application/x-chess-pgn;pic|image/pict;pict|image/pict;png|image/png;pnm|image/x-portable-anymap;pnt|image/x-macpaint;pntg|image/x-macpaint;ppm|image/x-portable-pixmap;ppt|application/vnd.ms-powerpoint;ps|application/postscript;qt|video/quicktime;qti|image/x-quicktime;qtif|image/x-quicktime;ra|audio/x-pn-realaudio;ram|audio/x-pn-realaudio;ras|image/x-cmu-raster;rdf|application/rdf+xml;rgb|image/x-rgb;rm|application/vnd.rn-realmedia;roff|application/x-troff;rtf|text/rtf;rtx|text/richtext;sgm|text/sgml;sgml|text/sgml;sh|application/x-sh;shar|application/x-shar;silo|model/mesh;sit|application/x-stuffit;skd|application/x-koan;skm|application/x-koan;skp|application/x-koan;skt|application/x-koan;smi|application/smil;smil|application/smil;snd|audio/basic;so|application/octet-stream;spl|application/x-futuresplash;src|application/x-wais-source;sv4cpio|application/x-sv4cpio;sv4crc|application/x-sv4crc;svg|image/svg+xml;swf|application/x-shockwave-flash;t|application/x-troff;tar|application/x-tar;tcl|application/x-tcl;tex|application/x-tex;texi|application/x-texinfo;texinfo|application/x-texinfo;tif|image/tiff;tiff|image/tiff;tr|application/x-troff;tsv|text/tab-separated-values;txt|text/plain;ustar|application/x-ustar;vcd|application/x-cdlink;vrml|model/vrml;vxml|application/voicexml+xml;wav|audio/x-wav;wbmp|image/vnd.wap.wbmp;wbmxl|application/vnd.wap.wbxml;wml|text/vnd.wap.wml;wmlc|application/vnd.wap.wmlc;wmls|text/vnd.wap.wmlscript;wmlsc|application/vnd.wap.wmlscriptc;wrl|model/vrml;xbm|image/x-xbitmap;xht|application/xhtml+xml;xhtml|application/xhtml+xml;xls|application/vnd.ms-excel;xml|application/xml;xpm|image/x-xpixmap;xsl|application/xml;xslt|application/xslt+xml;xul|application/vnd.mozilla.xul+xml;xwd|image/x-xwindowdump;xyz|chemical/x-xyz;zip|application/zip;"
EndFunc
Func __WINHTTPCHARSET ( $SCONTENTTYPE )
	Local $ACONTENTTYPE = StringRegExp ( $SCONTENTTYPE , "(?i).*?\Qcharset=\E(?U)([^ ]+)(;| |\Z)" , 2 )
	If Not @error Then $SCONTENTTYPE = $ACONTENTTYPE [ 1 ]
	If StringLeft ( $SCONTENTTYPE , 2 ) = "cp" Then Return Int ( StringTrimLeft ( $SCONTENTTYPE , 2 ) )
	If $SCONTENTTYPE = "utf-8" Then Return 65001
EndFunc
Func __WINHTTPURLENCODE ( $VDATA , $SENCTYPE = "" )
	If IsBool ( $VDATA ) Then Return $VDATA
	$VDATA = __WINHTTPHTMLDECODE ( $VDATA )
	If $SENCTYPE = "text/plain" Then Return StringReplace ( $VDATA , " " , "+" )
	Local $ADATA = StringToASCIIArray ( $VDATA , Default , Default , 2 )
	Local $SOUT
	For $I = 0 To UBound ( $ADATA ) + 4294967295
		Switch $ADATA [ $I ]
		Case 45 , 46 , 48 To 57 , 65 To 90 , 95 , 97 To 122 , 126
			$SOUT &= Chr ( $ADATA [ $I ] )
		Case 32
			$SOUT &= "+"
	Case Else
			$SOUT &= "%" & Hex ( $ADATA [ $I ] , 2 )
		EndSwitch
	Next
	Return $SOUT
EndFunc
Func __WINHTTPHTMLDECODE ( $VDATA )
	Return StringReplace ( StringReplace ( StringReplace ( StringReplace ( $VDATA , "&amp;" , "&" ) , "&lt;" , "<" ) , "&gt;" , ">" ) , "&quot;" , """" )
EndFunc
Func __WINHTTPNORMALIZEACTIONURL ( $SACTIONPAGE , ByRef $SACTION , ByRef $ISCHEME , ByRef $SNEWURL , ByRef $SENCTYPE , ByRef $SMETHOD , $SURL = "" )
	Local $ACRACKURL = _WINHTTPCRACKURL ( $SACTION )
	If @error Then
		If $SACTION Then
			If StringLeft ( $SACTION , 2 ) = "//" Then
				$ACRACKURL = _WINHTTPCRACKURL ( $SURL )
				If Not @error Then
					$ACRACKURL = _WINHTTPCRACKURL ( $ACRACKURL [ 0 ] & ":" & $SACTION )
					If Not @error Then
						$SNEWURL = $ACRACKURL [ 0 ] & "://" & $ACRACKURL [ 2 ] & ":" & $ACRACKURL [ 3 ]
						$ISCHEME = $ACRACKURL [ 1 ]
						$SACTION = $ACRACKURL [ 6 ] & $ACRACKURL [ 7 ]
						$SACTIONPAGE = ""
					EndIf
				EndIf
			ElseIf StringLeft ( $SACTION , 1 ) = "?" Then
				$ACRACKURL = _WINHTTPCRACKURL ( $SURL )
				$SACTION = $ACRACKURL [ 6 ] & $SACTION
			ElseIf StringLeft ( $SACTION , 1 ) = "#" Then
				$SACTION = StringReplace ( $SACTIONPAGE , StringRegExpReplace ( $SACTIONPAGE , "(.*?)(#.*?)" , "$2" ) , $SACTION )
			ElseIf StringLeft ( $SACTION , 1 ) <> "/" Then
				Local $SCURRENT
				Local $AURL = StringRegExp ( $SACTIONPAGE , "(.*)/" , 3 )
				If Not @error Then $SCURRENT = $AURL [ 0 ]
				If $SCURRENT Then $SACTION = $SCURRENT & "/" & $SACTION
			EndIf
			If StringLeft ( $SACTION , 1 ) = "?" Then $SACTION = $SACTIONPAGE & $SACTION
		EndIf
		If Not $SACTION Then $SACTION = $SACTIONPAGE
		$SACTION = StringRegExpReplace ( $SACTION , "\A(/*\.\./)*" , "" )
	Else
		$ISCHEME = $ACRACKURL [ 1 ]
		$SNEWURL = $ACRACKURL [ 0 ] & "://" & $ACRACKURL [ 2 ] & ":" & $ACRACKURL [ 3 ]
		$SACTION = $ACRACKURL [ 6 ] & $ACRACKURL [ 7 ]
	EndIf
	If Not $SMETHOD Then $SMETHOD = "GET"
	If $SMETHOD = "GET" Then $SENCTYPE = ""
EndFunc
Func __WINHTTPHTML5FORMATTRIBS ( ByRef $ADTAS , ByRef $AFLDS , ByRef $INUMPARAMS , ByRef $AINPUT , ByRef $SACTION , ByRef $SENCTYPE , ByRef $SMETHOD )
	Local $ASPL , $ISUBMITHTML5 = 0 , $IINPSUBM , $SIMGAPPX = "."
	For $K = 1 To $INUMPARAMS
		$ASPL = StringSplit ( $AFLDS [ $K ] , ":" , 2 )
		If $ASPL [ 0 ] = "type" And ( $ASPL [ 1 ] = "submit" Or $ASPL [ 1 ] = "image" ) Then
			Local $ISUBMINDEX = $ADTAS [ $K ] , $ISUBMCUR = 0 , $IIMGCUR = 0 , $STYPE , $SINPNME
			If $ASPL [ 1 ] = "image" Then
				$ISUBMINDEX = Int ( $ADTAS [ $K ] )
			EndIf
			For $I = 0 To UBound ( $AINPUT ) + 4294967295
				Switch __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "type" )
				Case "submit"
					If $ISUBMCUR = $ISUBMINDEX Then
						$ISUBMITHTML5 = 1
						$IINPSUBM = $I
						ExitLoop 2
					EndIf
					$ISUBMCUR += 1
				Case "image"
					If $IIMGCUR = $ISUBMINDEX Then
						$ISUBMITHTML5 = 1
						$IINPSUBM = $I
						$SINPNME = __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "name" )
						If $SINPNME Then $SINPNME &= $SIMGAPPX
						$AINPUT [ $IINPSUBM ] = "type=""image"" formaction=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formaction" ) & """ formenctype=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formenctype" ) & """ formmethod=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formmethod" ) & """"
						Local $SX = 0 , $SY = 0
						$IX = Int ( StringRegExpReplace ( $ADTAS [ $K ] , "(\d+)\h*(\d+),(\d+)" , "$2" , 1 ) )
						$IY = Int ( StringRegExpReplace ( $ADTAS [ $K ] , "(\d+)\h*(\d+),(\d+)" , "$3" , 1 ) )
						ReDim $AINPUT [ UBound ( $AINPUT ) + 2 ]
						$AINPUT [ UBound ( $AINPUT ) + 4294967294 ] = "type=""image"" name=""" & $SINPNME & "x"" value=""" & $IX & """"
						$AINPUT [ UBound ( $AINPUT ) + 4294967295 ] = "type=""image"" name=""" & $SINPNME & "y"" value=""" & $IY & """"
						ExitLoop 2
					EndIf
					$IIMGCUR += 1
				EndSwitch
			Next
		ElseIf $ASPL [ 0 ] = "name" Then
			Local $SINPNME = $ASPL [ 1 ] , $STYPE
			For $I = 0 To UBound ( $AINPUT ) + 4294967295
				$STYPE = __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "type" )
				If $STYPE = "submit" Then
					If __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "name" ) = $SINPNME And $ADTAS [ $K ] = True Then
						$ISUBMITHTML5 = 1
						$IINPSUBM = $I
						ExitLoop 2
					EndIf
				ElseIf $STYPE = "image" Then
					If __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "name" ) = $SINPNME And $ADTAS [ $K ] Then
						$ISUBMITHTML5 = 1
						$IINPSUBM = $I
						Local $ASTRSPLIT = StringSplit ( $ADTAS [ $K ] , "," , 3 ) , $IX = 0 , $IY = 0
						If Not @error Then
							$IX = Int ( $ASTRSPLIT [ 0 ] )
							$IY = Int ( $ASTRSPLIT [ 1 ] )
						EndIf
						$AINPUT [ $IINPSUBM ] = "type=""image"" formaction=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formaction" ) & """ formenctype=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formenctype" ) & """ formmethod=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formmethod" ) & """"
						$SINPNME &= $SIMGAPPX
						ReDim $AINPUT [ UBound ( $AINPUT ) + 2 ]
						$AINPUT [ UBound ( $AINPUT ) + 4294967294 ] = "type=""image"" name=""" & $SINPNME & "x"" value=""" & $IX & """"
						$AINPUT [ UBound ( $AINPUT ) + 4294967295 ] = "type=""image"" name=""" & $SINPNME & "y"" value=""" & $IY & """"
						ExitLoop 2
					EndIf
				EndIf
			Next
		Else
			Local $SINPID , $STYPE
			If @error Then
				$SINPID = $ASPL [ 0 ]
			ElseIf $ASPL [ 0 ] = "id" Then
				$SINPID = $ASPL [ 1 ]
			EndIf
			For $I = 0 To UBound ( $AINPUT ) + 4294967295
				$STYPE = __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "type" )
				If $STYPE = "submit" Then
					If __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "id" ) = $SINPID And $ADTAS [ $K ] = True Then
						$ISUBMITHTML5 = 1
						$IINPSUBM = $I
						ExitLoop 2
					EndIf
				ElseIf $STYPE = "image" Then
					If __WINHTTPATTRIBVAL ( $AINPUT [ $I ] , "id" ) = $SINPID And $ADTAS [ $K ] Then
						$ISUBMITHTML5 = 1
						$IINPSUBM = $I
						Local $SINPNME = __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "name" )
						If $SINPNME Then $SINPNME &= $SIMGAPPX
						Local $ASTRSPLIT = StringSplit ( $ADTAS [ $K ] , "," , 3 ) , $IX = 0 , $IY = 0
						If Not @error Then
							$IX = Int ( $ASTRSPLIT [ 0 ] )
							$IY = Int ( $ASTRSPLIT [ 1 ] )
						EndIf
						$AINPUT [ $IINPSUBM ] = "type=""image"" formaction=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formaction" ) & """ formenctype=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formenctype" ) & """ formmethod=""" & __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formmethod" ) & """"
						ReDim $AINPUT [ UBound ( $AINPUT ) + 2 ]
						$AINPUT [ UBound ( $AINPUT ) + 4294967294 ] = "type=""image"" name=""" & $SINPNME & "x"" value=""" & $IX & """"
						$AINPUT [ UBound ( $AINPUT ) + 4294967295 ] = "type=""image"" name=""" & $SINPNME & "y"" value=""" & $IY & """"
						ExitLoop 2
					EndIf
				EndIf
			Next
		EndIf
	Next
	If $ISUBMITHTML5 Then
		Local $IUBOUND = UBound ( $AINPUT ) + 4294967295
		If __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "type" ) = "image" Then $IUBOUND -= 2
		For $J = 0 To $IUBOUND
			If $J = $IINPSUBM Then ContinueLoop
			Switch __WINHTTPATTRIBVAL ( $AINPUT [ $J ] , "type" )
			Case "submit" , "image"
				$AINPUT [ $J ] = ""
			EndSwitch
		Next
		Local $SATTR = __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formaction" )
		If $SATTR Then $SACTION = $SATTR
		$SATTR = __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formenctype" )
		If $SATTR Then $SENCTYPE = $SATTR
		$SATTR = __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "formmethod" )
		If $SATTR Then $SMETHOD = $SATTR
		If __WINHTTPATTRIBVAL ( $AINPUT [ $IINPSUBM ] , "type" ) = "image" Then $AINPUT [ $IINPSUBM ] = ""
	EndIf
EndFunc
Func __WINHTTPNORMALIZEFORM ( ByRef $SFORM , $SSPR1 , $SSPR2 )
	Local $ADATA = StringToASCIIArray ( $SFORM , Default , Default , 2 )
	Local $SOUT , $BQUOT = False , $BSQUOT = False
	For $I = 0 To UBound ( $ADATA ) + 4294967295
		Switch $ADATA [ $I ]
		Case 34
			$BQUOT = Not $BQUOT
		Case 39
			$BSQUOT = Not $BSQUOT
		Case 32
			If $BQUOT Or $BSQUOT Then
				$SOUT &= $SSPR1
			Else
				$SOUT &= Chr ( $ADATA [ $I ] )
			EndIf
		Case 62
			If $BQUOT Or $BSQUOT Then
				$SOUT &= $SSPR2
			Else
				$SOUT &= Chr ( $ADATA [ $I ] )
			EndIf
	Case Else
			$SOUT &= Chr ( $ADATA [ $I ] )
		EndSwitch
	Next
	$SFORM = $SOUT
EndFunc
Func __WINHTTPFINALIZECTRLS ( $SSUBMIT , $SRADIO , $SCHECKBOX , $SBUTTON , ByRef $SADDDATA , $SGRSEP , $SBOUND = "" )
	If $SSUBMIT Then
		Local $ASUBMIT = StringSplit ( $SSUBMIT , $SGRSEP , 3 )
		For $M = 1 To UBound ( $ASUBMIT ) + 4294967295
			$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:\Q" & $SBOUND & "\E|\A)\Q" & $ASUBMIT [ $M ] & "\E(?:\Q" & $SBOUND & "\E|\z)" , $SBOUND )
		Next
		__WINHTTPTRIMBOUNDS ( $SADDDATA , $SBOUND )
	EndIf
	If $SRADIO Then
		If $SRADIO <> $SGRSEP Then
			For $SELEM In StringSplit ( $SRADIO , $SGRSEP , 3 )
				$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:\Q" & $SBOUND & "\E|\A)\Q" & $SELEM & "\E(?:\Q" & $SBOUND & "\E|\z)" , $SBOUND )
			Next
			__WINHTTPTRIMBOUNDS ( $SADDDATA , $SBOUND )
		EndIf
	EndIf
	If $SCHECKBOX Then
		For $SELEM In StringSplit ( $SCHECKBOX , $SGRSEP , 3 )
			$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:\Q" & $SBOUND & "\E|\A)\Q" & $SELEM & "\E(?:\Q" & $SBOUND & "\E|\z)" , $SBOUND )
		Next
		__WINHTTPTRIMBOUNDS ( $SADDDATA , $SBOUND )
	EndIf
	If $SBUTTON Then
		For $SELEM In StringSplit ( $SBUTTON , $SGRSEP , 3 )
			$SADDDATA = StringRegExpReplace ( $SADDDATA , "(?:\Q" & $SBOUND & "\E|\A)\Q" & $SELEM & "\E(?:\Q" & $SBOUND & "\E|\z)" , $SBOUND )
		Next
		__WINHTTPTRIMBOUNDS ( $SADDDATA , $SBOUND )
	EndIf
EndFunc
Func __WINHTTPTRIMBOUNDS ( ByRef $SDTA , $SBOUND )
	Local $IBLEN = StringLen ( $SBOUND )
	If StringRight ( $SDTA , $IBLEN ) = $SBOUND Then $SDTA = StringTrimRight ( $SDTA , $IBLEN )
	If StringLeft ( $SDTA , $IBLEN ) = $SBOUND Then $SDTA = StringTrimLeft ( $SDTA , $IBLEN )
EndFunc
Func __WINHTTPFORMATTRIB ( ByRef $AATTRIB , $I , $SELEMENT )
	$AATTRIB [ 0 ] [ $I ] = __WINHTTPATTRIBVAL ( $SELEMENT , "id" )
	$AATTRIB [ 1 ] [ $I ] = __WINHTTPATTRIBVAL ( $SELEMENT , "name" )
	$AATTRIB [ 2 ] [ $I ] = __WINHTTPATTRIBVAL ( $SELEMENT , "value" )
	$AATTRIB [ 3 ] [ $I ] = __WINHTTPATTRIBVAL ( $SELEMENT , "type" )
EndFunc
Func __WINHTTPATTRIBVAL ( $SIN , $SATTRIB )
	Local $AARRAY = StringRegExp ( $SIN , "(?i).*?(\A| )\b" & $SATTRIB & "\h*=(\h*""(.*?)""|" & "\h*'(.*?)'|" & "\h*(.*?)(?: |\Z))" , 1 )
	If @error Then Return ""
	Return $AARRAY [ UBound ( $AARRAY ) + 4294967295 ]
EndFunc
Func __WINHTTPFORMSEND ( $HINTERNET , $SMETHOD , $SACTION , $FMULTIPART , $SBOUNDARY , $SADDDATA , $FSECURE = False , $SADDITIONALHEADERS = "" , $SCREDNAME = "" , $SCREDPASS = "" , $IIGNOREALLCERTERRORS = 0 )
	Local $HREQUEST
	If $FSECURE Then
		$HREQUEST = _WINHTTPOPENREQUEST ( $HINTERNET , $SMETHOD , $SACTION , Default , Default , Default , $WINHTTP_FLAG_SECURE )
		If $IIGNOREALLCERTERRORS Then _WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_SECURITY_FLAGS , BitOR ( $SECURITY_FLAG_IGNORE_UNKNOWN_CA , $SECURITY_FLAG_IGNORE_CERT_DATE_INVALID , $SECURITY_FLAG_IGNORE_CERT_CN_INVALID , $SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE ) )
	Else
		$HREQUEST = _WINHTTPOPENREQUEST ( $HINTERNET , $SMETHOD , $SACTION )
	EndIf
	If $FMULTIPART Then
		_WINHTTPADDREQUESTHEADERS ( $HREQUEST , "Content-Type: multipart/form-data; boundary=" & $SBOUNDARY )
	Else
		If $SMETHOD = "POST" Then _WINHTTPADDREQUESTHEADERS ( $HREQUEST , "Content-Type: application/x-www-form-urlencoded" )
	EndIf
	_WINHTTPADDREQUESTHEADERS ( $HREQUEST , "Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5" )
	_WINHTTPADDREQUESTHEADERS ( $HREQUEST , "Accept-Charset: utf-8;q=0.7" )
	If $SADDITIONALHEADERS Then _WINHTTPADDREQUESTHEADERS ( $HREQUEST , $SADDITIONALHEADERS , BitOR ( $WINHTTP_ADDREQ_FLAG_REPLACE , $WINHTTP_ADDREQ_FLAG_ADD ) )
	_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_DECOMPRESSION , $WINHTTP_DECOMPRESSION_FLAG_ALL )
	_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_UNSAFE_HEADER_PARSING , 1 )
	__WINHTTPFORMUPLOAD ( $HREQUEST , "" , $SADDDATA )
	_WINHTTPRECEIVERESPONSE ( $HREQUEST )
	__WINHTTPSETCREDENTIALS ( $HREQUEST , "" , $SADDDATA , $SCREDNAME , $SCREDPASS , 1 )
	Return $HREQUEST
EndFunc
Func __WINHTTPSETCREDENTIALS ( $HREQUEST , $SHEADERS = "" , $SOPTIONAL = "" , $SCREDNAME = "" , $SCREDPASS = "" , $IFORMFILL = 0 )
	If $SCREDNAME And $SCREDPASS Then
		Local $ISTATUSCODE = _WINHTTPQUERYHEADERS ( $HREQUEST , $WINHTTP_QUERY_STATUS_CODE )
		If $ISTATUSCODE = $HTTP_STATUS_DENIED Or $ISTATUSCODE = $HTTP_STATUS_PROXY_AUTH_REQ Then
			Local $ISUPPORTEDSCHEMES , $IFIRSTSCHEME , $IAUTHTARGET
			If _WINHTTPQUERYAUTHSCHEMES ( $HREQUEST , $ISUPPORTEDSCHEMES , $IFIRSTSCHEME , $IAUTHTARGET ) Then
				If $IFIRSTSCHEME = $WINHTTP_AUTH_SCHEME_PASSPORT And $ISTATUSCODE = $HTTP_STATUS_PROXY_AUTH_REQ Then
					_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH , $WINHTTP_ENABLE_PASSPORT_AUTH )
					_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_PROXY_USERNAME , $SCREDNAME )
					_WINHTTPSETOPTION ( $HREQUEST , $WINHTTP_OPTION_PROXY_PASSWORD , $SCREDPASS )
				Else
					_WINHTTPSETCREDENTIALS ( $HREQUEST , $IAUTHTARGET , $IFIRSTSCHEME , $SCREDNAME , $SCREDPASS )
				EndIf
				If $IFORMFILL Then
					__WINHTTPFORMUPLOAD ( $HREQUEST , $SHEADERS , $SOPTIONAL )
				Else
					_WINHTTPSENDREQUEST ( $HREQUEST , $SHEADERS , $SOPTIONAL )
				EndIf
				_WINHTTPRECEIVERESPONSE ( $HREQUEST )
			EndIf
		EndIf
	EndIf
EndFunc
Func __WINHTTPFORMUPLOAD ( $HREQUEST , $SHEADERS , $SDATA )
	Local $ACLBK = _WINHTTPSIMPLEFORMFILL_SETUPLOADCALLBACK ( )
	If $ACLBK [ 0 ] <> Default Then
		Local $ISIZE = StringLen ( $SDATA ) , $ICHUNK = Floor ( $ISIZE / $ACLBK [ 1 ] ) , $IREST = $ISIZE - ( $ACLBK [ 1 ] + 4294967295 ) * $ICHUNK , $ICURCH = $ICHUNK
		_WINHTTPSENDREQUEST ( $HREQUEST , Default , Default , $ISIZE )
		For $I = 1 To $ACLBK [ 1 ]
			If $I = $ACLBK [ 1 ] Then $ICURCH = $IREST
			_WINHTTPWRITEDATA ( $HREQUEST , StringMid ( $SDATA , 1 + $ICHUNK * ( $I + 4294967295 ) , $ICURCH ) )
			Call ( $ACLBK [ 0 ] , Floor ( $I * 100 / $ACLBK [ 1 ] ) )
		Next
	Else
		_WINHTTPSENDREQUEST ( $HREQUEST , Default , $SDATA )
	EndIf
EndFunc
Func __WINHTTPDEFAULT ( ByRef $VINPUT , $VOUTPUT )
	If $VINPUT = Default Or Number ( $VINPUT ) = + 4294967295 Then $VINPUT = $VOUTPUT
EndFunc
Func __WINHTTPMEMGLOBALFREE ( $PMEM )
	Local $ACALL = DllCall ( "kernel32.dll" , "ptr" , "GlobalFree" , "ptr" , $PMEM )
	If @error Or $ACALL [ 0 ] Then Return SetError ( 1 , 0 , 0 )
	Return 1
EndFunc
Func __WINHTTPPTRSTRINGLENW ( $PSTR )
	Local $ACALL = DllCall ( "kernel32.dll" , "dword" , "lstrlenW" , "ptr" , $PSTR )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func __WINHTTPUA ( )
	Local Static $SUA = "Mozilla/5.0 " & __WINHTTPSYSINFO ( ) & " WinHttp/" & __WINHTTPVER ( ) & " (WinHTTP/5.1) like Gecko"
	Return $SUA
EndFunc
Func __WINHTTPSYSINFO ( )
	Local $SDTA = FileGetVersion ( "kernel32.dll" )
	$SDTA = "(Windows NT " & StringLeft ( $SDTA , StringInStr ( $SDTA , "." , 1 , 2 ) + 4294967295 )
	If StringInStr ( @OSArch , "64" ) And Not @AutoItX64 Then $SDTA &= "; WOW64"
	$SDTA &= ")"
	Return $SDTA
EndFunc
Func __WINHTTPVER ( )
	Return "1.6.4.0"
EndFunc
Func _WINHTTPBINARYCONCAT ( ByRef $BBINARY1 , ByRef $BBINARY2 )
	Local $BOUT = _WINHTTPSIMPLEBINARYCONCAT ( $BBINARY1 , $BBINARY2 )
	Return SetError ( @error , 0 , $BOUT )
EndFunc
Global $__BINARYCALL_KERNEL32DLL = DllOpen ( "kernel32.dll" )
Global $__BINARYCALL_MSVCRTDLL = DllOpen ( "msvcrt.dll" )
Global $__BINARYCALL_LASTERROR = ""
Func _BINARYCALL_GETPROCADDRESS ( $MODULE , $PROC )
	Local $RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "ptr" , "GetProcAddress" , "ptr" , $MODULE , "str" , $PROC )
	If @error Or Not $RET [ 0 ] Then Return SetError ( 1 , @error , 0 )
	Return $RET [ 0 ]
EndFunc
Func _BINARYCALL_LOADLIBRARY ( $FILENAME )
	Local $RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "handle" , "LoadLibraryW" , "wstr" , $FILENAME )
	If @error Then Return SetError ( 1 , @error , 0 )
	Return $RET [ 0 ]
EndFunc
Func _BINARYCALL_LSTRLENA ( $PTR )
	Local $RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "int" , "lstrlenA" , "ptr" , $PTR )
	If @error Then Return SetError ( 1 , @error , 0 )
	Return $RET [ 0 ]
EndFunc
Func _BINARYCALL_ALLOC ( $CODE , $PADDING = 0 )
	Local $LENGTH = BinaryLen ( $CODE ) + $PADDING
	Local $RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "ptr" , "VirtualAlloc" , "ptr" , 0 , "ulong_ptr" , $LENGTH , "dword" , 4096 , "dword" , 64 )
	If @error Or Not $RET [ 0 ] Then Return SetError ( 1 , @error , 0 )
	If BinaryLen ( $CODE ) Then
		Local $BUFFER = DllStructCreate ( "byte[" & $LENGTH & "]" , $RET [ 0 ] )
		DllStructSetData ( $BUFFER , 1 , $CODE )
	EndIf
	Return $RET [ 0 ]
EndFunc
Func _BINARYCALL_REGIONSIZE ( $PTR )
	Local $BUFFER = DllStructCreate ( "ptr;ptr;dword;uint_ptr;dword;dword;dword" )
	Local $RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "int" , "VirtualQuery" , "ptr" , $PTR , "ptr" , DllStructGetPtr ( $BUFFER ) , "uint_ptr" , DllStructGetSize ( $BUFFER ) )
	If @error Or $RET [ 0 ] = 0 Then Return SetError ( 1 , @error , 0 )
	Return DllStructGetData ( $BUFFER , 4 )
EndFunc
Func _BINARYCALL_FREE ( $PTR )
	Local $RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "bool" , "VirtualFree" , "ptr" , $PTR , "ulong_ptr" , 0 , "dword" , 32768 )
	If @error Or $RET [ 0 ] = 0 Then
		$RET = DllCall ( $__BINARYCALL_KERNEL32DLL , "bool" , "GlobalFree" , "ptr" , $PTR )
		If @error Or $RET [ 0 ] <> 0 Then Return SetError ( 1 , @error , False )
	EndIf
	Return True
EndFunc
Func _BINARYCALL_RELEASE ( $CODEBASE )
	Local $RET = _BINARYCALL_FREE ( $CODEBASE )
	Return SetError ( @error , @extended , $RET )
EndFunc
Func _BINARYCALL_MEMORYSEARCH ( $PTR , $LENGTH , $BINARY )
	Static $CODEBASE
	If Not $CODEBASE Then
		If @AutoItX64 Then
			$CODEBASE = _BINARYCALL_CREATE ( "0x4883EC084D85C94889C8742C4C39CA72254C29CA488D141131C9EB0848FFC14C39C97414448A1408453A140874EE48FFC04839D076E231C05AC3" , "" , 0 , True , False )
		Else
			$CODEBASE = _BINARYCALL_CREATE ( "0x5589E58B4D14578B4508568B550C538B7D1085C9742139CA721B29CA8D341031D2EB054239CA740F8A1C17381C1074F34039F076EA31C05B5E5F5DC3" , "" , 0 , True , False )
		EndIf
		If Not $CODEBASE Then Return SetError ( 1 , 0 , 0 )
	EndIf
	$BINARY = Binary ( $BINARY )
	Local $BUFFER = DllStructCreate ( "byte[" & BinaryLen ( $BINARY ) & "]" )
	DllStructSetData ( $BUFFER , 1 , $BINARY )
	Local $RET = DllCallAddress ( "ptr:cdecl" , $CODEBASE , "ptr" , $PTR , "uint" , $LENGTH , "ptr" , DllStructGetPtr ( $BUFFER ) , "uint" , DllStructGetSize ( $BUFFER ) )
	Return $RET [ 0 ]
EndFunc
Func _BINARYCALL_BASE64DECODE ( $SRC )
	Static $CODEBASE
	If Not $CODEBASE Then
		If @AutoItX64 Then
			$CODEBASE = _BINARYCALL_CREATE ( "0x41544989CAB9FF000000555756E8BE000000534881EC000100004889E7F3A44C89D6E98A0000004439C87E0731C0E98D0000000FB66E01440FB626FFC00FB65E020FB62C2C460FB62424408A3C1C0FB65E034189EB41C1E4024183E3308A1C1C41C1FB044509E34080FF634189CC45881C08744C440FB6DFC1E5044489DF4088E883E73CC1FF0209C7418D44240241887C08014883C10380FB63742488D841C1E3064883C60483E03F4409D841884408FF89F389C84429D339D30F8C67FFFFFF4881C4000100005B5E5F5D415CC35EC3E8F9FFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000003E0000003F3435363738393A3B3C3D00000063000000000102030405060708090A0B0C0D0E0F101112131415161718190000000000001A1B1C1D1E1F202122232425262728292A2B2C2D2E2F30313233" , "" , 132 , True , False )
		Else
			$CODEBASE = _BINARYCALL_CREATE ( "0x55B9FF00000089E531C05756E8F10000005381EC0C0100008B55088DBDF5FEFFFFF3A4E9C00000003B45140F8FC20000000FB65C0A028A9C1DF5FEFFFF889DF3FEFFFF0FB65C0A038A9C1DF5FEFFFF889DF2FEFFFF0FB65C0A018985E8FEFFFF0FB69C1DF5FEFFFF899DECFEFFFF0FB63C0A89DE83E630C1FE040FB6BC3DF5FEFFFFC1E70209FE8B7D1089F3881C074080BDF3FEFFFF63745C0FB6B5F3FEFFFF8BBDECFEFFFF8B9DE8FEFFFF89F083E03CC1E704C1F80209F88B7D1088441F0189D883C00280BDF2FEFFFF6374278A85F2FEFFFFC1E60683C10483E03F09F088441F0289D883C0033B4D0C0F8C37FFFFFFEB0231C081C40C0100005B5E5F5DC35EC3E8F9FFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000003E0000003F3435363738393A3B3C3D00000063000000000102030405060708090A0B0C0D0E0F101112131415161718190000000000001A1B1C1D1E1F202122232425262728292A2B2C2D2E2F30313233" , "" , 132 , True , False )
		EndIf
		If Not $CODEBASE Then Return SetError ( 1 , 0 , Binary ( "" ) )
	EndIf
	$SRC = String ( $SRC )
	Local $SRCLEN = StringLen ( $SRC )
	Local $SRCBUF = DllStructCreate ( "char[" & $SRCLEN & "]" )
	DllStructSetData ( $SRCBUF , 1 , $SRC )
	Local $DSTLEN = Int ( ( $SRCLEN + 2 ) / 4 ) * 3 + 1
	Local $DSTBUF = DllStructCreate ( "byte[" & $DSTLEN & "]" )
	Local $RET = DllCallAddress ( "uint:cdecl" , $CODEBASE , "ptr" , DllStructGetPtr ( $SRCBUF ) , "uint" , $SRCLEN , "ptr" , DllStructGetPtr ( $DSTBUF ) , "uint" , $DSTLEN )
	If $RET [ 0 ] = 0 Then Return SetError ( 2 , 0 , Binary ( "" ) )
	Return BinaryMid ( DllStructGetData ( $DSTBUF , 1 ) , 1 , $RET [ 0 ] )
EndFunc
Func _BINARYCALL_BASE64ENCODE ( $SRC )
	Static $CODEBASE
	If Not $CODEBASE Then
		If @AutoItX64 Then
			$CODEBASE = _BINARYCALL_CREATE ( "AwAAAARiAQAAAAAAAAArkuFQDAlvIp0qAgbDnjr76UDZs1EPNIP2K18t9s6SNTbd43IB7HfdyPM8VfD/o36z4AmSW2m2AIsC6Af3fKNsHU4BdQKGd0PQXHxPSX0iNqp1YAKovksqQna06NeKMoOYqryTUX4WgpHjokhp6zY2sEFSIjcL7dW3FDoNVz4bGPyZHRvjFwmqvr7YGlNYKwNoh+SYCXmIgVPVZ63Vz1fbT33/QFpWmWOeBRqs4J+c8Qp6zJFsK345Pjw0I8kMSsnho4F4oNzQ2OsAbmIioaQ6Ma2ziw5NH+M+t4SpEeHDnBdUTTL20sxWZ0yKruFAsBIRoHvM7LYcid2eBV2d5roSjnkwMG0g69LNjs1fHjbI/9iU/hJwpSsgl4fltXdZG659/li13UFY89M7UfckiZ9XOeBM0zadgNsy8r8M3rEAAA==" )
		Else
			$CODEBASE = _BINARYCALL_CREATE ( "AwAAAARVAQAAAAAAAAAqr7blBndrIGnmhhfXD7R1fkOTKhicg1W6MCtStbz+CsneBEg0bbHH1sqTLmLfY7A6LqZl6LYWT5ULVj6MXgugPbBn9wKsSU2ZCcBBPNkx09HVPdUaKnbqghDGj/C5SHoF+A/5g+UgE1C5zJZORjJ8ljs5lt2Y9lA4BsY7jVKX2vmDvHK1NnSR6nVwh7Pb+Po/UpNcy5sObVWDKkYSCCtCIjKIYqOe3c6k8Xsp4eritCUprXEVvCFi7K5Z6HFXdm3nZsFcE+eSJ1WkRnVQbWcmpjGMGka61C68+CI7tsQ13UnCFWNSpDrCbzUejMZh8HdPgEc5vCg3pKMKin/NavNpB6+87Y9y7HIxmKsPdjDT30u9hUKWnYiRe3nrwKyVDsiYpKU/Nse368jHag5B5or3UKA+nb2+eY8JwzgA" )
		EndIf
		If Not $CODEBASE Then Return SetError ( 1 , 0 , Binary ( "" ) )
	EndIf
	$SRC = Binary ( $SRC )
	Local $SRCLEN = BinaryLen ( $SRC )
	Local $SRCBUF = DllStructCreate ( "byte[" & $SRCLEN & "]" )
	DllStructSetData ( $SRCBUF , 1 , $SRC )
	Local $DSTLEN = Int ( ( $SRCLEN + 2 ) / 3 ) * 4 + 1
	Local $DSTBUF = DllStructCreate ( "char[" & $DSTLEN & "]" )
	Local $RET = DllCallAddress ( "uint:cdecl" , $CODEBASE , "ptr" , DllStructGetPtr ( $SRCBUF ) , "uint" , $SRCLEN , "ptr" , DllStructGetPtr ( $DSTBUF ) , "uint" , $DSTLEN )
	If $RET [ 0 ] = 0 Then Return Binary ( "" )
	Return StringMid ( DllStructGetData ( $DSTBUF , 1 ) , 1 , $RET [ 0 ] )
EndFunc
Func _BINARYCALL_LZMADECOMPRESS ( $SRC )
	Static $CODEBASE
	If Not $CODEBASE Then
		If @AutoItX64 Then
			$CODEBASE = _BINARYCALL_CREATE ( _BINARYCALL_BASE64DECODE ( "QVcxwEFWQVVBVFVXSInXVkiJzlMx20iB7OgAAABEiiFBgPzgdgnpyQAAAEGD7C1BiMf/wEGA/Cx38THA6wRBg+wJQYjG/8BBgPwId/GLRglEi24FQQ+2zkyJRCQoRQ+2/0HB5xBBiQFBD7bEAcG4AAMAANPgjYQAcA4AAEhjyOjIBAAATInpSInF6L0EAABIicMxwEyJ8kSI4EyLRCQoiNQl//8A/0QJ+EiF24lFAHQoTYXtdCNIjVfzSI1MJDhIg8YNTIkEJE2J6UmJ2EiJ7+g2AAAAicbrBb4BAAAASInp6IQEAACF9nQKSInZMdvodgQAAEiJ2EiBxOgAAABbXl9dQVxBXUFeQV/DVVNBV0FWQVVBVEFQTQHBQVFNicVRVkgB8lJIieX8SYn0iwdMjX8Eik8Cg8r/0+L30olV6Ijhg8r/0+L30olV5ADBiUXsuAEAAACJReCJRdyJRdhIiUXQRSnJKfaDy/8A0bgAAwAA0+BIjYg2BwAAuAAEAARMif/R6fOrvwUAAADoUAMAAP/PdfdEie9EicgrfSDB4ARBifpEI1XoRAHQTY0cR+hAAwAAD4WTAAAAik3sI33k0+eA6Qj22dPuAfe4AQAAAEiNPH++AAEAAMHnCEGD+QdNjbR/bA4AAHI0TInvSCt90A+2P9HnQYnzIf5BAfNPjRxe6O8CAACJwcHuCIPhATnOvgABAAB1DjnGd9jrDE2J8+jQAgAAOfBy9EyJ76pEiclBg/kEcg65AwAAAEGD+QpyA4PBA0EpyelDAgAAT42cT4ABAADomgIAAHUsi0XcQYP5B4lF4BnAi1XY99CLTdCD4AOJVdxBicGJTdhNjbdkBgAA6akAAABPjZxPmAEAAOhfAgAAdUZEicjB4AREAdBNjZxH4AEAAOhHAgAAdWpBg/kHuQkAAAByA4PBAkGJyUyJ70grfdBIO30gD4L9AQAAigdIA33QqumzAQAAT42cT7ABAADoCgIAAIt12HQhT42cT8gBAADo+AEAAIt13HQJi03ci3XgiU3gi03YiU3ci03QiU3YiXXQQYP5B7kIAAAAcgODwQNBiclNjbdoCgAATYnz6LsBAAB1FESJ0CnJweADvggAAABJjXxGBOs2TY1eAuicAQAAdRpEidC5CAAAAMHgA74IAAAASY28RgQBAADrEUmNvgQCAAC5EAAAAL4AAQAAiU3MuAEAAABJifvoYQEAAInCKfJy8gNVzEGD+QSJVcwPg7kAAABBg8EHuQMAAAA50XICidHB4Qa4AQAAAEmNvE9gAwAAvkAAAABJifvoHwEAAEGJwkEp8nLwQYP6BHJ4RInWRIlV0NHug2XQAf/Og03QAkGD+g5zFYnx0mXQi0XQRCnQTY20R14FAADrLIPuBOi6AAAA0evRZdBBOdhyBv9F0EEp2P/OdedNjbdEBgAAwWXQBL4EAAAAvwEAAACJ+E2J8+ioAAAAqAF0Awl90NHn/8516+sERIlV0P9F0EyJ74tNzEiJ+IPBAkgrRSBIOUXQd1RIif5IK3XQSItVGKyqSDnXcwT/yXX1SYn9D7bwTDttGA+C9fz//+gwAAAAKcBIi1UQTCtlCESJIkiLVWBMK20gRIkqSIPEKEFcQV1BXUFfW13DXli4AQAAAOvSgfsAAAABcgHDweMITDtlAHPmQcHgCEWKBCRJg8QBwynATY0cQ4H7AAAAAXMVweMITDtlAHPBQcHgCEWKBCRJg8QBidlBD7cTwekLD6/KQTnIcxOJy7kACAAAKdHB6QVmQQELAcDDKcvB6gVBKchmQSkTAcCDwAHDSLj////////////gbXN2Y3J0LmRsbHxtYWxsb2MASLj////////////gZnJlZQA=" ) )
		Else
			$CODEBASE = _BINARYCALL_CREATE ( _BINARYCALL_BASE64DECODE ( "VYnlVzH/VlOD7EyLXQiKC4D54A+HxQAAADHA6wWD6S2I0ID5LI1QAXfziEXmMcDrBYPpCYjQgPkIjVABd/OIReWLRRSITeSLUwkPtsmLcwWJEA+2ReUBwbgAAwAA0+CNhABwDgAAiQQk6EcEAACJNCSJRdToPAQAAItV1InHi0Xkhf+JArgBAAAAdDaF9nQyi0UQg8MNiRQkiXQkFIl8JBCJRCQYjUXgiUQkDItFDIlcJASD6A2JRCQI6CkAAACLVdSJRdSJFCToAQQAAItF1IXAdAqJPCQx/+jwAwAAg8RMifhbXl9dw1dWU1WJ5YtFJAFFKFD8i3UYAXUcVot1FK2SUopO/oPI/9Pg99BQiPGDyP/T4PfQUADRifeD7AwpwEBQUFBQUFcp9laDy/+4AAMAANPgjYg2BwAAuAAEAATR6fOragVZ6MoCAADi+Yt9/ItF8Ct9JCH4iUXosADoywIAAA+FhQAAAIpN9CN97NPngOkI9tnT7lgB916NPH/B5wg8B1qNjH5sDgAAUVa+AAEAAFCwAXI0i338K33cD7Y/i23M0eeJ8SH+AfGNbE0A6JgCAACJwcHuCIPhATnOvgABAAB1DjnwctfrDIttzOh5AgAAOfBy9FqD+gSJ0XIJg/oKsQNyArEGKcpS60mwwOhJAgAAdRRYX1pZWln/NCRRUrpkBgAAsQDrb7DM6CwCAAB1LLDw6BMCAAB1U1g8B7AJcgKwC1CLdfwrddw7dSQPgs8BAACsi338qumOAQAAsNjo9wEAAIt12HQbsOTo6wEAAIt11HQJi3XQi03UiU3Qi03YiU3Ui03ciU3YiXXcWF9ZumgKAACxCAH6Ulc8B4jIcgIEA1CLbczovAEAAHUUi0Xoi33MweADKclqCF6NfEcE6zWLbcyDxQLomwEAAHUYi0Xoi33MweADaghZaghejbxHBAEAAOsQvwQCAAADfcxqEFm+AAEAAIlN5CnAQIn96GYBAACJwSnxcvMBTeSDfcQED4OwAAAAg0XEB4tN5IP5BHIDagNZi33IweEGKcBAakBejbxPYAMAAIn96CoBAACJwSnxcvOJTeiJTdyD+QRyc4nOg2XcAdHug03cAk6D+Q5zGbivAgAAKciJ8dJl3ANF3NHgA0XIiUXM6y2D7gToowAAANHr0WXcOV3gcgb/RdwpXeBOdei4RAYAAANFyIlFzMFl3ARqBF4p/0eJ+IttzOi0AAAAqAF0Awl93NHnTnXs6wD/RdyLTeSDwQKLffyJ+CtFJDlF3HdIif4rddyLVSisqjnXcwNJdfeJffwPtvA7fSgPgnH9///oKAAAACnAjWwkPItVIIt1+Ct1GIkyi1Usi338K30kiTrJW15fw15YKcBA69qB+wAAAAFyAcPB4whWi3X4O3Ucc+SLReDB4AisiUXgiXX4XsOLTcQPtsDB4QQDRegByOsGD7bAA0XEi23IjWxFACnAjWxFAIH7AAAAAXMci0wkOMFkJCAIO0wkXHOcihH/RCQ4weMIiFQkIInZD7dVAMHpCw+vyjlMJCBzF4nLuQAIAAAp0cHpBWYBTQABwI1sJEDDweoFKUwkICnLZilVAAHAg8ABjWwkQMO4///////gbXN2Y3J0LmRsbHxtYWxsb2MAuP//////4GZyZWUA" ) )
		EndIf
		If Not $CODEBASE Then Return SetError ( 1 , 0 , Binary ( "" ) )
	EndIf
	$SRC = Binary ( $SRC )
	Local $SRCLEN = BinaryLen ( $SRC )
	Local $SRCBUF = DllStructCreate ( "byte[" & $SRCLEN & "]" )
	DllStructSetData ( $SRCBUF , 1 , $SRC )
	Local $RET = DllCallAddress ( "ptr:cdecl" , $CODEBASE , "ptr" , DllStructGetPtr ( $SRCBUF ) , "uint_ptr" , $SRCLEN , "uint_ptr*" , 0 , "uint*" , 0 )
	If $RET [ 0 ] Then
		Local $DSTBUF = DllStructCreate ( "byte[" & $RET [ 3 ] & "]" , $RET [ 0 ] )
		Local $OUTPUT = DllStructGetData ( $DSTBUF , 1 )
		DllCall ( $__BINARYCALL_MSVCRTDLL , "none:cdecl" , "free" , "ptr" , $RET [ 0 ] )
		Return $OUTPUT
	EndIf
	Return SetError ( 2 , 0 , Binary ( "" ) )
EndFunc
Func _BINARYCALL_RELOCATION ( $BASE , $RELOC )
	Local $SIZE = Int ( BinaryMid ( $RELOC , 1 , 2 ) )
	For $I = 3 To BinaryLen ( $RELOC ) Step $SIZE
		Local $OFFSET = Int ( BinaryMid ( $RELOC , $I , $SIZE ) )
		Local $PTR = $BASE + $OFFSET
		DllStructSetData ( DllStructCreate ( "ptr" , $PTR ) , 1 , DllStructGetData ( DllStructCreate ( "ptr" , $PTR ) , 1 ) + $BASE )
	Next
EndFunc
Func _BINARYCALL_IMPORTLIBRARY ( $BASE , $LENGTH )
	Local $JMPBIN , $JMPOFF , $JMPLEN , $DLLNAME , $PROCNAME
	If @AutoItX64 Then
		$JMPBIN = Binary ( "0x48B8FFFFFFFFFFFFFFFFFFE0" )
		$JMPOFF = 2
	Else
		$JMPBIN = Binary ( "0xB8FFFFFFFFFFE0" )
		$JMPOFF = 1
	EndIf
	$JMPLEN = BinaryLen ( $JMPBIN )
	Do
		Local $PTR = _BINARYCALL_MEMORYSEARCH ( $BASE , $LENGTH , $JMPBIN )
		If $PTR = 0 Then ExitLoop
		Local $STRINGPTR = $PTR + $JMPLEN
		Local $STRINGLEN = _BINARYCALL_LSTRLENA ( $STRINGPTR )
		Local $STRING = DllStructGetData ( DllStructCreate ( "char[" & $STRINGLEN & "]" , $STRINGPTR ) , 1 )
		Local $SPLIT = StringSplit ( $STRING , "|" )
		If $SPLIT [ 0 ] = 1 Then
			$PROCNAME = $SPLIT [ 1 ]
		ElseIf $SPLIT [ 0 ] = 2 Then
			If $SPLIT [ 1 ] Then $DLLNAME = $SPLIT [ 1 ]
			$PROCNAME = $SPLIT [ 2 ]
		EndIf
		If $DLLNAME And $PROCNAME Then
			Local $HANDLE = _BINARYCALL_LOADLIBRARY ( $DLLNAME )
			If Not $HANDLE Then
				$__BINARYCALL_LASTERROR = "LoadLibrary fail on " & $DLLNAME
				Return SetError ( 1 , 0 , False )
			EndIf
			Local $PROC = _BINARYCALL_GETPROCADDRESS ( $HANDLE , $PROCNAME )
			If Not $PROC Then
				$__BINARYCALL_LASTERROR = "GetProcAddress failed on " & $PROCNAME
				Return SetError ( 2 , 0 , False )
			EndIf
			DllStructSetData ( DllStructCreate ( "ptr" , $PTR + $JMPOFF ) , 1 , $PROC )
		EndIf
		Local $DIFF = Int ( $PTR - $BASE + $JMPLEN + $STRINGLEN + 1 )
		$BASE += $DIFF
		$LENGTH -= $DIFF
	Until $LENGTH <= $JMPLEN
	Return True
EndFunc
Func _BINARYCALL_CODEPREPARE ( $CODE )
	If Not $CODE Then Return ""
	If IsBinary ( $CODE ) Then Return $CODE
	$CODE = String ( $CODE )
	If StringLeft ( $CODE , 2 ) = "0x" Then Return Binary ( $CODE )
	If StringIsXDigit ( $CODE ) Then Return Binary ( "0x" & $CODE )
	Return _BINARYCALL_LZMADECOMPRESS ( _BINARYCALL_BASE64DECODE ( $CODE ) )
EndFunc
Func _BINARYCALL_SYMBOLFIND ( $CODEBASE , $IDENTIFY , $LENGTH = Default )
	$IDENTIFY = Binary ( $IDENTIFY )
	If IsKeyword ( $LENGTH ) Then
		$LENGTH = _BINARYCALL_REGIONSIZE ( $CODEBASE )
	EndIf
	Local $PTR = _BINARYCALL_MEMORYSEARCH ( $CODEBASE , $LENGTH , $IDENTIFY )
	If $PTR = 0 Then Return SetError ( 1 , 0 , 0 )
	Return $PTR + BinaryLen ( $IDENTIFY )
EndFunc
Func _BINARYCALL_SYMBOLLIST ( $CODEBASE , $SYMBOL )
	If Not IsArray ( $SYMBOL ) Or $CODEBASE = 0 Then Return SetError ( 1 , 0 , 0 )
	Local $TAG = ""
	For $I = 0 To UBound ( $SYMBOL ) + 4294967295
		$TAG &= "ptr " & $SYMBOL [ $I ] & ";"
	Next
	Local $SYMBOLLIST = DllStructCreate ( $TAG )
	If @error Then Return SetError ( 1 , 0 , 0 )
	For $I = 0 To UBound ( $SYMBOL ) + 4294967295
		$CODEBASE = _BINARYCALL_SYMBOLFIND ( $CODEBASE , $SYMBOL [ $I ] )
		DllStructSetData ( $SYMBOLLIST , $SYMBOL [ $I ] , $CODEBASE )
	Next
	Return $SYMBOLLIST
EndFunc
Func _BINARYCALL_CREATE ( $CODE , $RELOC = "" , $PADDING = 0 , $RELEASEONEXIT = True , $LIBRARYIMPORT = True )
	Local $BINARYCODE = _BINARYCALL_CODEPREPARE ( $CODE )
	If Not $BINARYCODE Then Return SetError ( 1 , 0 , 0 )
	Local $BINARYCODELEN = BinaryLen ( $BINARYCODE )
	Local $TOTALCODELEN = $BINARYCODELEN + $PADDING
	Local $CODEBASE = _BINARYCALL_ALLOC ( $BINARYCODE , $PADDING )
	If Not $CODEBASE Then Return SetError ( 2 , 0 , 0 )
	If $RELOC Then
		$RELOC = _BINARYCALL_CODEPREPARE ( $RELOC )
		If Not $RELOC Then Return SetError ( 3 , 0 , 0 )
		_BINARYCALL_RELOCATION ( $CODEBASE , $RELOC )
	EndIf
	If $LIBRARYIMPORT Then
		If Not _BINARYCALL_IMPORTLIBRARY ( $CODEBASE , $BINARYCODELEN ) Then
			_BINARYCALL_FREE ( $CODEBASE )
			Return SetError ( 4 , 0 , 0 )
		EndIf
	EndIf
	If $RELEASEONEXIT Then
		_BINARYCALL_RELEASEONEXIT ( $CODEBASE )
	EndIf
	Return SetError ( 0 , $TOTALCODELEN , $CODEBASE )
EndFunc
Func _BINARYCALL_COMMANDLINETOARGV ( $COMMANDLINE , ByRef $ARGC , $ISUNICODE = False )
	Static $SYMBOLLIST
	If Not IsDllStruct ( $SYMBOLLIST ) Then
		Local $CODE
		If @AutoItX64 Then
			$CODE = "AwAAAASuAgAAAAAAAAAkL48ClEB9jTEOeYv4yYTosNjFNgf81Ag4vS2VP4y4wxFa+4yMI7GDB7CG+xn4JE3cdEVvk8cMp4oIuS3DgTxlcKHGVIg94tvzG/256bizZfGtAETQUCPQjW5+JSx2C/Y4C0VNJMKTlSCHiV5AzXRZ5gw3WFghbtkCCFxWOX+RDSI2oH/vROEOnqc0jfKTo17EBjqX+dW3QxrUe45xsbyYTZ9ccIGySgcOAxetbRiSxQnz8BOMbJyfrbZbuVJyGpKrXFLh/5MlBZ09Cim9qgflbGzmkrGStT9QL1f+O2krzyOzgaWWqhWL6S+y0G32RWVi0uMLR/JOGLEW/+Yg/4bzkeC0lKELT+RmWAatNa38BRfaitROMN12moRDHM6LYD1lzPLnaiefSQRVti561sxni/AFkYoCb5Lkuyw4RIn/r/flRiUg5w48YkqBBd9rXkaXrEoKwPg6rmOvOCZadu//B6HN4+Ipq5aYNuZMxSJXmxwXVRSQZVpSfLS2ATZMd9/Y7kLqrKy1H4V76SgI/d9OKApfKSbQ8ZaKIHBCsoluEip3UDOB82Z21zd933UH5l0laGWLIrTz7xVGkecjo0NQzR7LyhhoV3xszlIuw2v8q0Q/S9LxB5G6tYbOXo7lLjNIZc0derZz7DNeeeJ9dQE9hp8unubaTBpulPxTNtRjog=="
		Else
			$CODE = "AwAAAAR6AgAAAAAAAABcQfD553vjya/3DmalU0BKqABevUb/60GZ55rMwmzpQfPSRUlIl04lEiS8RDrXpS0EoBUe+uzDgZd37nVu9wsJ4fykqYvLoMz3ApxQbTBKleOIRSla6I0V8dNP3P7rHeUfjH0jCho0RvhhVpf0o4ht/iZptauxaoy1zQ19TkPZ/vf5Im8ecY6qEdHNzjo2H60jVwiOJ+1J47TmQRwxJ+yKLakq8QNxtKkRIB9B9ugfo3NAL0QslDxbyU0dSgw2aOPxV+uttLzYNnWbLBZVQbchcKgLRjC/32U3Op576sOYFolB1Nj4/33c7MRgtGLjlZfTB/4yNvd4/E+u3U6/Q4MYApCfWF4R/d9CAdiwgIjCYUkGDExKjFtHbAWXfWh9kQ7Q/GWUjsfF9BtHO6924Cy1Ou+BUKksqsxmIKP4dBjvvmz9OHc1FdtR9I63XKyYtlUnqVRtKwlNrYAZVCSFsyAefMbteq1ihU33sCsLkAnp1LRZ2wofgT1/JtT8+GO2s/n52D18wM70RH2n5uJJv8tlxQc1lwbmo4XQvcbcE91U2j9glvt2wC1pkP0hF23Nr/iiIEZHIPAOAHvhervlHE830LSHyUx8yh5Tjojr0gdLvQ=="
		EndIf
		Local $CODEBASE = _BINARYCALL_CREATE ( $CODE )
		If @error Then Return SetError ( 1 , 0 , 0 )
		Local $SYMBOL [ ] = [ "ToArgvW" , "ToArgvA" ]
		$SYMBOLLIST = _BINARYCALL_SYMBOLLIST ( $CODEBASE , $SYMBOL )
		If @error Then Return SetError ( 1 , 0 , 0 )
	EndIf
	Local $RET
	If $ISUNICODE Then
		$RET = DllCallAddress ( "ptr:cdecl" , DllStructGetData ( $SYMBOLLIST , "ToArgvW" ) , "wstr" , $COMMANDLINE , "int*" , 0 )
	Else
		$RET = DllCallAddress ( "ptr:cdecl" , DllStructGetData ( $SYMBOLLIST , "ToArgvA" ) , "str" , $COMMANDLINE , "int*" , 0 )
	EndIf
	If Not @error And $RET [ 0 ] <> 0 Then
		_BINARYCALL_RELEASEONEXIT ( $RET [ 0 ] )
		$ARGC = $RET [ 2 ]
		Return $RET [ 0 ]
	Else
		Return SetError ( 2 , 0 , 0 )
	EndIf
EndFunc
Func _BINARYCALL_STDIOREDIRECT ( $FILENAME = "CON" , $FLAG = 1 + 2 + 4 )
	Static $SYMBOLLIST
	If Not IsDllStruct ( $SYMBOLLIST ) Then
		Local $CODE , $RELOC
		If @AutoItX64 Then
			$CODE = "AwAAAASjAQAAAAAAAAAkL48ClEB9jTEOeYv4yYTosNjFM1rLNdMULriZUDxTj+ZdkQ01F5zKL+WDCScfQKKLn66EDmcA+gXIkPcZV4lyz8VPw8BPZlNB5KymydM15kCA+uqvmBc1V0NJfzgsF0Amhn0JhM/ZIguYCHxywMQ1SgKxUb05dxDg8WlX/2aPfSolcX47+4/72lPDNTeT7d7XRdm0ND+eCauuQcRH2YOahare9ASxuU4IMHCh2rbZYHwmTNRiQUB/8dLGtph93yhmwdHtyMPLX2x5n6sdA1mxua9htLsLTulE05LLmXbRYXylDz0A"
			$RELOC = "AwAAAAQIAAAAAAAAAAABAB7T+CzGn9ScQAC="
		Else
			$CODE = "AwAAAASVAQAAAAAAAABcQfD553vjya/3DmalU0BKqABaUcndypZ3mTYUkHxlLV/lKZPrXYWXgNATjyiowkUQGDVYUy5THQwK4zYdU7xuGf7qfVDELc1SNbiW3NgD4D6N6ZM7auI1jPaThsPfA/ouBcx2aVQX36fjmViTZ8ZLzafjJeR7d5OG5s9sAoIzFLTZsqrFlkIJedqDAOfhA/0mMrkavTWnsio6yTbic1dER0DcEsXpLn0vBNErKHoagLzAgofHNLeFRw5yHWz5owR5CYL7rgiv2k51neHBWGx97A=="
			$RELOC = "AwAAAAQgAAAAAAAAAAABABfyHS/VRkdjBBzbtGPD6vtmVH/IsGHYvPsTv2lGuqJxGlAA"
		EndIf
		Local $CODEBASE = _BINARYCALL_CREATE ( $CODE , $RELOC )
		If @error Then Return SetError ( 1 , 0 , 0 )
		Local $SYMBOL [ ] = [ "StdinRedirect" , "StdoutRedirect" , "StderrRedirect" ]
		$SYMBOLLIST = _BINARYCALL_SYMBOLLIST ( $CODEBASE , $SYMBOL )
		If @error Then Return SetError ( 1 , 0 , 0 )
	EndIf
	If BitAND ( $FLAG , 1 ) Then DllCallAddress ( "none:cdecl" , DllStructGetData ( $SYMBOLLIST , "StdinRedirect" ) , "str" , $FILENAME )
	If BitAND ( $FLAG , 2 ) Then DllCallAddress ( "none:cdecl" , DllStructGetData ( $SYMBOLLIST , "StdoutRedirect" ) , "str" , $FILENAME )
	If BitAND ( $FLAG , 4 ) Then DllCallAddress ( "none:cdecl" , DllStructGetData ( $SYMBOLLIST , "StderrRedirect" ) , "str" , $FILENAME )
EndFunc
Func _BINARYCALL_STDINREDIRECT ( $FILENAME = "CON" )
	Local $RET = _BINARYCALL_STDIOREDIRECT ( $FILENAME , 1 )
	Return SetError ( @error , @extended , $RET )
EndFunc
Func _BINARYCALL_STDOUTREDIRECT ( $FILENAME = "CON" )
	Local $RET = _BINARYCALL_STDIOREDIRECT ( $FILENAME , 2 )
	Return SetError ( @error , @extended , $RET )
EndFunc
Func _BINARYCALL_STDERRREDIRECT ( $FILENAME = "CON" )
	Local $RET = _BINARYCALL_STDIOREDIRECT ( $FILENAME , 4 )
	Return SetError ( @error , @extended , $RET )
EndFunc
Func _BINARYCALL_RELEASEONEXIT ( $PTR )
	OnAutoItExitRegister ( "__BinaryCall_DoRelease" )
	__BINARYCALL_RELEASEONEXIT_HANDLE ( $PTR )
EndFunc
Func __BINARYCALL_DORELEASE ( )
	__BINARYCALL_RELEASEONEXIT_HANDLE ( )
EndFunc
Func __BINARYCALL_RELEASEONEXIT_HANDLE ( $PTR = Default )
	Static $PTRLIST
	If @NumParams = 0 Then
		If IsArray ( $PTRLIST ) Then
			For $I = 1 To $PTRLIST [ 0 ]
				_BINARYCALL_FREE ( $PTRLIST [ $I ] )
			Next
		EndIf
	Else
		If Not IsArray ( $PTRLIST ) Then
			Local $INITARRAY [ 1 ] = [ 0 ]
			$PTRLIST = $INITARRAY
		EndIf
		If IsPtr ( $PTR ) Then
			Local $ARRAY = $PTRLIST
			Local $SIZE = UBound ( $ARRAY )
			ReDim $ARRAY [ $SIZE + 1 ]
			$ARRAY [ $SIZE ] = $PTR
			$ARRAY [ 0 ] += 1
			$PTRLIST = $ARRAY
		EndIf
	EndIf
EndFunc
Global Const $JSON_UNESCAPED_UNICODE = 1
Global Const $JSON_UNESCAPED_SLASHES = 2
Global Const $JSON_HEX_TAG = 4
Global Const $JSON_HEX_AMP = 8
Global Const $JSON_HEX_APOS = 16
Global Const $JSON_HEX_QUOT = 32
Global Const $JSON_UNESCAPED_ASCII = 64
Global Const $JSON_PRETTY_PRINT = 128
Global Const $JSON_STRICT_PRINT = 256
Global Const $JSON_UNQUOTED_STRING = 512
Global Const $JSMN_ERROR_NOMEM = + 4294967295
Global Const $JSMN_ERROR_INVAL = + 4294967294
Global Const $JSMN_ERROR_PART = + 4294967293
Global $TOTAL_JSON_DUMP_OUTPUT = ""
Func __JSMN_RUNTIMELOADER ( $PROCNAME = "" )
	Static $SYMBOLLIST
	If Not IsDllStruct ( $SYMBOLLIST ) Then
		Local $CODE
		If @AutoItX64 Then
			$CODE = "AwAAAAQfCAAAAAAAAAA1HbEvgTNrvX54gCiWSTVmt5v7RCdoFJ/zhkKmwcm8yVqZPjJBoVhNHHAIzrHWKbZh1J0QAUaHB5zyQTilTmWa9O0OKeLrk/Jg+o7CmMzjEk74uPongdHv37nwYXvg97fiHvjP2bBzI9gxSkKq9Cqh/GxSHIlZPYyW76pXUt//25Aqs2Icfpyay/NFd50rW7eMliH5ynkrp16HM1afithVrO+LpSaz/IojowApmXnBHUncHliDqbkx6/AODUkyDm1hj+AiEZ9Me1Jy+hBQ1/wC/YnuuYSJvNAKp6XDnyc8Nwr54Uqx5SbUW2CezwQQ7aXX/HFiHSKpQcFW/gi8oSx5nsoxUXVjxeNI/L7z6GF2mfu3Tnpt7hliWEdA2r2VB+TIM7Pgwl9X3Ge0T3KJQUaRtLJZcPvVtOuKXr2Q9wy7hl80hVRrt9zYrbjBHXLrRx/HeIMkZwxhmKo/dD/vvaNgE+BdU8eeJqFBJK2alrK2rh2WkRynftyepm1WrdKrz/5KhQPp/4PqH+9IADDjoGBbfvJQXdT+yiO8DtfrVnd+JOEKsKEsdgeM3UXx5r6tEHO9rYWbzbnyEiX7WozZemry+vBZMMtHn1aA63+RcDQED73xOsnj00/9E5Z6hszM5Hi8vi6Hw3iOgf3cHwcXG44aau0JpuA2DlrUvnJOYkNnY+bECeSdAR1UQkFNyqRoH2xm4Y7gYMCPsFtPBlwwleEKI27SsUq1ZHVQvFCoef7DXgf/GwPCAvwDMIQfb3hJtIVubOkASRQZVNIJ/y4KPrn/gcASV7fvMjE34loltTVlyqprUWxpI51tN6vhTOLAp+CHseKxWaf9g1wdbVs0e/5xAiqgJbmKNi9OYbhV/blpp3SL63XKxGiHdxhK1aR+4rUY4eckNbaHfW7ob+q7aBoHSs6LVX9lWakb/xWxwQdwcX/7/C+TcQSOOg6rLoWZ8wur9qp+QwzoCbXkf04OYpvD5kqgEiwQnB90kLtcA+2XSbDRu+aq02eNNCzgkZujeL/HjVISjf2EuQKSsZkBhS15eiXoRgPaUoQ5586VS7t7rhM8ng5LiVzoUQIZ0pNKxWWqD+gXRBvOMIXY2yd0Ei4sE5KFIEhbs3u8vwP7nFLIpZ/RembPTuc0ZlguGJgJ2F5iApfia+C2tRYRNjVCqECCveWw6P2Btfaq9gw7cWWmJflIQbjxtccDqsn52cftLqXSna9zk05mYdJSV8z2W7vM1YJ5Rd82v0j3kau710A/kQrN41bdaxmKjL+gvSRlOLB1bpvkCtf9+h+eVA4XIkIXKFydr1OjMZ8wq2FIxPJXskAe4YMgwQmeWZXMK1KBbLB3yQR1YOYaaHk1fNea9KsXgs5YLbiP/noAusz76oEDo/DJh1aw7cUwdhboVPg1bNq88mRb5RGa13KDK9uEET7OA02KbSL+Q4HOtyasLUoVrZzVyd8iZPoGrV36vHnj+yvG4fq6F/fkug/sBRp186yVZQVmdAgFd+WiRLnUjxHUKJ6xBbpt4FTP42E/PzPw3JlDb0UQtXTDnIL0CWqbns2E7rZ5PBwrwQYwvBn/gaEeLVGDSh84DfW4zknIneGnYDXdVEHC+ITzejAnNxb1duB+w2aVTk64iXsKHETq53GMH6DuFi0oUeEFb/xp0HsRyNC8vBjOq3Kk7NZHxCQLh7UATFttG7sH+VIqGjjNwmraGJ0C92XhpQwSgfAb3KHucCHGTTti0sn6cgS3vb36BkjGKsRhXVuoQCFH96bvTYtl8paQQW9ufRfvxPqmU0sALdR0fIvZwd7Z8z0UoEec6b1Sul4e60REj/H4scb6N2ryHBR9ua5N1YxJu1uwgoLXUL2wT9ZPBjPjySUzeqXikUIKKYgNlWy+VlNIiWWTPtKpCTr508logA=="
		Else
			$CODE = "AwAAAASFBwAAAAAAAAA1HbEvgTNrvX54gCiqsa1mt5v7RCdoAFjCfVE40DZbE5UfabA9UKuHrjqOMbvjSoB2zBJTEYEQejBREnPrXL3VwpVOW+L9SSfo0rTfA8U2W+Veqo1uy0dOsPhl7vAHbBHrvJNfEUe8TT0q2eaTX2LeWpyrFEm4I3mhDJY/E9cpWf0A78e+y4c7NxewvcVvAakIHE8Xb8fgtqCTVQj3Q1eso7n1fKQj5YsQ20A86Gy9fz8dky78raeZnhYayn0b1riSUKxGVnWja2i02OvAVM3tCCvXwcbSkHTRjuIAbMu2mXF1UpKci3i/GzPmbxo9n/3aX/jpR6UvxMZuaEDEij4yzfZv7EyK9WCNBXxMmtTp3Uv6MZsK+nopXO3C0xFzZA/zQObwP3zhJ4sdatzMhFi9GAM70R4kgMzsxQDNArueXj+UFzbCCFZ89zXs22F7Ixi0FyFTk3jhH56dBaN65S+gtPztNGzEUmtk4M8IanhQSw8xCXr0x0MPDpDFDZs3aN5TtTPYmyk3psk7OrmofCQGG5cRcqEt9902qtxQDOHumfuCPMvU+oMjzLzBVEDnBbj+tY3y1jvgGbmEJguAgfB04tSeAt/2618ksnJJK+dbBkDLxjB4xrFr3uIFFadJQWUckl5vfh4MVXbsFA1hG49lqWDa7uSuPCnOhv8Yql376I4U4gfcF8LcgorkxS+64urv2nMUq6AkBEMQ8bdkI64oKLFfO7fGxh5iMNZuLoutDn2ll3nq4rPi4kOyAtfhW0UPyjvqNtXJ/h0Wik5Mi8z7BVxaURTDk81TP8y9+tzjySB/uGfHFAzjF8DUY1vqJCgn0GQ8ANtiiElX/+Wnc9HWi2bEEXItbm4yv97QrEPvJG9nPRBKWGiAQsIA5J+WryX5NrfEfRPk0QQwyl16lpHlw6l0UMuk7S21xjQgyWo0MywfzoBWW7+t4HH9sqavvP4dYAw81BxXqVHQhefUOS23en4bFUPWE98pAN6bul+kS767vDK34yTC3lA2a8wLrBEilmFhdB74fxbAl+db91PivhwF/CR4Igxr35uLdof7+jAYyACopQzmsbHpvAAwT2lapLix8H03nztAC3fBqFSPBVdIv12lsrrDw4dfhJEzq7AbL/Y7L/nIcBsQ/3UyVnZk4kZP1KzyPCBLLIQNpCVgOLJzQuyaQ6k2QCBy0eJ0ppUyfp54LjwVg0X7bwncYbAomG4ZcFwTQnC2AX3oYG5n6Bz4SLLjxrFsY+v/SVa+GqH8uePBh1TPkHVNmzjXXymEf5jROlnd+EjfQdRyitkjPrg2HiQxxDcVhCh5J2L5+6CY9eIaYgrbd8zJnzAD8KnowHwh2bi4JLgmt7ktJ1XGizox7cWf3/Dod56KAcaIrSVw9XzYybdJCf0YRA6yrwPWXbwnzc/4+UDkmegi+AoCEMoue+cC7vnYVdmlbq/YLE/DWJX383oz2Ryq8anFrZ8jYvdoh8WI+dIugYL2SwRjmBoSwn56XIaot/QpMo3pYJIa4o8aZIZrjvB7BXO5aCDeMuZdUMT6AXGAGF1AeAWxFd2XIo1coR+OplMNDuYia8YAtnSTJ9JwGYWi2dJz3xrxsTQpBONf3yn8LVf8eH+o5eXc7lzCtHlDB+YyI8V9PyMsUPOeyvpB3rr9fDfNy263Zx33zTi5jldgP2OetUqGfbwl+0+zNYnrg64bluyIN/Awt1doDCQkCKpKXxuPaem/SyCHrKjg"
		EndIf
		Local $SYMBOL [ ] = [ "jsmn_parse" , "jsmn_init" , "json_string_decode" , "json_string_encode" ]
		Local $CODEBASE = _BINARYCALL_CREATE ( $CODE )
		If @error Then Exit MsgBox ( 16 , "Json" , "Startup Failure!" )
		$SYMBOLLIST = _BINARYCALL_SYMBOLLIST ( $CODEBASE , $SYMBOL )
		If @error Then Exit MsgBox ( 16 , "Json" , "Startup Failure!" )
	EndIf
	If $PROCNAME Then Return DllStructGetData ( $SYMBOLLIST , $PROCNAME )
EndFunc
Func JSON_STRINGENCODE ( $STRING , $OPTION = 0 )
	Static $JSON_STRINGENCODE = __JSMN_RUNTIMELOADER ( "json_string_encode" )
	Local $LENGTH = StringLen ( $STRING ) * 6 + 1
	Local $BUFFER = DllStructCreate ( "wchar[" & $LENGTH & "]" )
	Local $RET = DllCallAddress ( "int:cdecl" , $JSON_STRINGENCODE , "wstr" , $STRING , "ptr" , DllStructGetPtr ( $BUFFER ) , "uint" , $LENGTH , "int" , $OPTION )
	Return SetError ( $RET [ 0 ] , 0 , DllStructGetData ( $BUFFER , 1 ) )
EndFunc
Func JSON_STRINGDECODE ( $STRING )
	Static $JSON_STRINGDECODE = __JSMN_RUNTIMELOADER ( "json_string_decode" )
	Local $LENGTH = StringLen ( $STRING ) + 1
	Local $BUFFER = DllStructCreate ( "wchar[" & $LENGTH & "]" )
	Local $RET = DllCallAddress ( "int:cdecl" , $JSON_STRINGDECODE , "wstr" , $STRING , "ptr" , DllStructGetPtr ( $BUFFER ) , "uint" , $LENGTH )
	Return SetError ( $RET [ 0 ] , 0 , DllStructGetData ( $BUFFER , 1 ) )
EndFunc
Func JSON_DECODE ( $JSON , $INITTOKENCOUNT = 1000 )
	Static $JSMN_INIT = __JSMN_RUNTIMELOADER ( "jsmn_init" ) , $JSMN_PARSE = __JSMN_RUNTIMELOADER ( "jsmn_parse" )
	If $JSON = "" Then $JSON = """"""
	Local $TOKENLIST , $RET
	Local $PARSER = DllStructCreate ( "uint pos;int toknext;int toksuper" )
	Do
		DllCallAddress ( "none:cdecl" , $JSMN_INIT , "ptr" , DllStructGetPtr ( $PARSER ) )
		$TOKENLIST = DllStructCreate ( "byte[" & ( $INITTOKENCOUNT * 20 ) & "]" )
		$RET = DllCallAddress ( "int:cdecl" , $JSMN_PARSE , "ptr" , DllStructGetPtr ( $PARSER ) , "wstr" , $JSON , "ptr" , DllStructGetPtr ( $TOKENLIST ) , "uint" , $INITTOKENCOUNT )
		$INITTOKENCOUNT *= 2
	Until $RET [ 0 ] <> $JSMN_ERROR_NOMEM
	Local $NEXT = 0
	Return SetError ( $RET [ 0 ] , 0 , _JSON_TOKEN ( $JSON , DllStructGetPtr ( $TOKENLIST ) , $NEXT ) )
EndFunc
Func _JSON_TOKEN ( ByRef $JSON , $PTR , ByRef $NEXT )
	If $NEXT = + 4294967295 Then Return Null
	Local $TOKEN = DllStructCreate ( "int;int;int;int" , $PTR + ( $NEXT * 20 ) )
	Local $TYPE = DllStructGetData ( $TOKEN , 1 )
	Local $START = DllStructGetData ( $TOKEN , 2 )
	Local $END = DllStructGetData ( $TOKEN , 3 )
	Local $SIZE = DllStructGetData ( $TOKEN , 4 )
	$NEXT += 1
	If $TYPE = 0 And $START = 0 And $END = 0 And $SIZE = 0 Then
		$NEXT = + 4294967295
		Return Null
	EndIf
	Switch $TYPE
	Case 0
		Local $PRIMITIVE = StringMid ( $JSON , $START + 1 , $END - $START )
		Switch $PRIMITIVE
		Case "true"
			Return True
		Case "false"
			Return False
		Case "null"
			Return Null
	Case Else
			If StringRegExp ( $PRIMITIVE , "^[+\-0-9]" ) Then
				Return Number ( $PRIMITIVE )
			Else
				Return JSON_STRINGDECODE ( $PRIMITIVE )
			EndIf
		EndSwitch
	Case 1
		Local $OBJECT = JSON_OBJCREATE ( )
		For $I = 0 To $SIZE + 4294967295 Step 2
			Local $KEY = _JSON_TOKEN ( $JSON , $PTR , $NEXT )
			Local $VALUE = _JSON_TOKEN ( $JSON , $PTR , $NEXT )
			If Not IsString ( $KEY ) Then $KEY = JSON_ENCODE ( $KEY )
			If $OBJECT .Exists ( $KEY ) Then $OBJECT .Remove ( $KEY )
			$OBJECT .Add ( $KEY , $VALUE )
		Next
		Return $OBJECT
	Case 2
		Local $ARRAY [ $SIZE ]
		For $I = 0 To $SIZE + 4294967295
			$ARRAY [ $I ] = _JSON_TOKEN ( $JSON , $PTR , $NEXT )
		Next
		Return $ARRAY
	Case 3
		Return JSON_STRINGDECODE ( StringMid ( $JSON , $START + 1 , $END - $START ) )
	EndSwitch
EndFunc
Func JSON_ISOBJECT ( ByRef $OBJECT )
	Return ( IsObj ( $OBJECT ) And ObjName ( $OBJECT ) = "Dictionary" )
EndFunc
Func JSON_ISNULL ( ByRef $NULL )
	Return IsKeyword ( $NULL ) Or ( Not IsObj ( $NULL ) And VarGetType ( $NULL ) = "Object" )
EndFunc
Func JSON_ENCODE_COMPACT ( $DATA , $OPTION = 0 )
	Local $JSON = ""
	Select
	Case IsString ( $DATA )
		Return """" & JSON_STRINGENCODE ( $DATA , $OPTION ) & """"
	Case IsNumber ( $DATA )
		Return $DATA
	Case IsArray ( $DATA ) And UBound ( $DATA , 0 ) = 1
		$JSON = "["
		For $I = 0 To UBound ( $DATA ) + 4294967295
			$JSON &= JSON_ENCODE_COMPACT ( $DATA [ $I ] , $OPTION ) & ","
		Next
		If StringRight ( $JSON , 1 ) = "," Then $JSON = StringTrimRight ( $JSON , 1 )
		Return $JSON & "]"
	Case JSON_ISOBJECT ( $DATA )
		$JSON = "{"
		Local $KEYS = $DATA .Keys ( )
		For $I = 0 To UBound ( $KEYS ) + 4294967295
			$JSON &= """" & JSON_STRINGENCODE ( $KEYS [ $I ] , $OPTION ) & """:" & JSON_ENCODE_COMPACT ( $DATA .Item ( $KEYS [ $I ] ) , $OPTION ) & ","
		Next
		If StringRight ( $JSON , 1 ) = "," Then $JSON = StringTrimRight ( $JSON , 1 )
		Return $JSON & "}"
	Case IsBool ( $DATA )
		Return StringLower ( $DATA )
	Case IsPtr ( $DATA )
		Return Number ( $DATA )
	Case IsBinary ( $DATA )
		Return """" & JSON_STRINGENCODE ( BinaryToString ( $DATA , 4 ) , $OPTION ) & """"
Case Else
		Return "null"
	EndSelect
EndFunc
Func JSON_ENCODE_PRETTY ( $DATA , $OPTION , $INDENT , $ARRAYSEP , $OBJECTSEP , $COLONSEP , $ARRAYCRLF = Default , $OBJECTCRLF = Default , $NEXTIDENT = "" )
	Local $THISIDENT = $NEXTIDENT , $JSON = "" , $STRING = "" , $MATCH = "" , $KEYS = ""
	Local $LENGTH = 0
	Select
	Case IsString ( $DATA )
		$STRING = JSON_STRINGENCODE ( $DATA , $OPTION )
		If BitAND ( $OPTION , $JSON_UNQUOTED_STRING ) And Not BitAND ( $OPTION , $JSON_STRICT_PRINT ) And Not StringRegExp ( $STRING , "[\s,:]" ) And Not StringRegExp ( $STRING , "^[+\-0-9]" ) Then
			Return $STRING
		Else
			Return """" & $STRING & """"
		EndIf
	Case IsArray ( $DATA ) And UBound ( $DATA , 0 ) = 1
		If UBound ( $DATA ) = 0 Then Return "[]"
		If IsKeyword ( $ARRAYCRLF ) Then
			$ARRAYCRLF = ""
			$MATCH = StringRegExp ( $ARRAYSEP , "[\r\n]+$" , 3 )
			If IsArray ( $MATCH ) Then $ARRAYCRLF = $MATCH [ 0 ]
		EndIf
		If $ARRAYCRLF Then $NEXTIDENT &= $INDENT
		$LENGTH = UBound ( $DATA ) + 4294967295
		For $I = 0 To $LENGTH
			If $ARRAYCRLF Then $JSON &= $NEXTIDENT
			$JSON &= JSON_ENCODE_PRETTY ( $DATA [ $I ] , $OPTION , $INDENT , $ARRAYSEP , $OBJECTSEP , $COLONSEP , $ARRAYCRLF , $OBJECTCRLF , $NEXTIDENT )
			If $I < $LENGTH Then $JSON &= $ARRAYSEP
		Next
		If $ARRAYCRLF Then Return "[" & $ARRAYCRLF & $JSON & $ARRAYCRLF & $THISIDENT & "]"
		Return "[" & $JSON & "]"
	Case JSON_ISOBJECT ( $DATA )
		If $DATA .Count = 0 Then Return "{}"
		If IsKeyword ( $OBJECTCRLF ) Then
			$OBJECTCRLF = ""
			$MATCH = StringRegExp ( $OBJECTSEP , "[\r\n]+$" , 3 )
			If IsArray ( $MATCH ) Then $OBJECTCRLF = $MATCH [ 0 ]
		EndIf
		If $OBJECTCRLF Then $NEXTIDENT &= $INDENT
		$KEYS = $DATA .Keys ( )
		$LENGTH = UBound ( $KEYS ) + 4294967295
		For $I = 0 To $LENGTH
			If $OBJECTCRLF Then $JSON &= $NEXTIDENT
			$JSON &= JSON_ENCODE_PRETTY ( String ( $KEYS [ $I ] ) , $OPTION , $INDENT , $ARRAYSEP , $OBJECTSEP , $COLONSEP ) & $COLONSEP & JSON_ENCODE_PRETTY ( $DATA .Item ( $KEYS [ $I ] ) , $OPTION , $INDENT , $ARRAYSEP , $OBJECTSEP , $COLONSEP , $ARRAYCRLF , $OBJECTCRLF , $NEXTIDENT )
			If $I < $LENGTH Then $JSON &= $OBJECTSEP
		Next
		If $OBJECTCRLF Then Return "{" & $OBJECTCRLF & $JSON & $OBJECTCRLF & $THISIDENT & "}"
		Return "{" & $JSON & "}"
Case Else
		Return JSON_ENCODE_COMPACT ( $DATA , $OPTION )
	EndSelect
EndFunc
Func JSON_ENCODE ( $DATA , $OPTION = 0 , $INDENT = Default , $ARRAYSEP = Default , $OBJECTSEP = Default , $COLONSEP = Default )
	If BitAND ( $OPTION , $JSON_PRETTY_PRINT ) Then
		Local $STRICT = BitAND ( $OPTION , $JSON_STRICT_PRINT )
		If IsKeyword ( $INDENT ) Then
			$INDENT = @TAB
		Else
			$INDENT = JSON_STRINGDECODE ( $INDENT )
			If StringRegExp ( $INDENT , "[^\t ]" ) Then $INDENT = @TAB
		EndIf
		If IsKeyword ( $ARRAYSEP ) Then
			$ARRAYSEP = "," & @CRLF
		Else
			$ARRAYSEP = JSON_STRINGDECODE ( $ARRAYSEP )
			If $ARRAYSEP = "" Or StringRegExp ( $ARRAYSEP , "[^\s,]|,.*," ) Or ( $STRICT And Not StringRegExp ( $ARRAYSEP , "," ) ) Then $ARRAYSEP = "," & @CRLF
		EndIf
		If IsKeyword ( $OBJECTSEP ) Then
			$OBJECTSEP = "," & @CRLF
		Else
			$OBJECTSEP = JSON_STRINGDECODE ( $OBJECTSEP )
			If $OBJECTSEP = "" Or StringRegExp ( $OBJECTSEP , "[^\s,]|,.*," ) Or ( $STRICT And Not StringRegExp ( $OBJECTSEP , "," ) ) Then $OBJECTSEP = "," & @CRLF
		EndIf
		If IsKeyword ( $COLONSEP ) Then
			$COLONSEP = ": "
		Else
			$COLONSEP = JSON_STRINGDECODE ( $COLONSEP )
			If $COLONSEP = "" Or StringRegExp ( $COLONSEP , "[^\s,:]|[,:].*[,:]" ) Or ( $STRICT And ( StringRegExp ( $COLONSEP , "," ) Or Not StringRegExp ( $COLONSEP , ":" ) ) ) Then $COLONSEP = ": "
		EndIf
		Return JSON_ENCODE_PRETTY ( $DATA , $OPTION , $INDENT , $ARRAYSEP , $OBJECTSEP , $COLONSEP )
	ElseIf BitAND ( $OPTION , $JSON_UNQUOTED_STRING ) Then
		Return JSON_ENCODE_PRETTY ( $DATA , $OPTION , "" , "," , "," , ":" )
	Else
		Return JSON_ENCODE_COMPACT ( $DATA , $OPTION )
	EndIf
EndFunc
Func JSON_OBJCREATE ( )
	Local $OBJECT = ObjCreate ( "Scripting.Dictionary" )
	$OBJECT .CompareMode = 0
	Return $OBJECT
EndFunc
Func JSON_OBJPUT ( ByRef $OBJECT , $KEY , $VALUE )
	$KEY = String ( $KEY )
	If $OBJECT .Exists ( $KEY ) Then $OBJECT .Remove ( $KEY )
	$OBJECT .Add ( $KEY , $VALUE )
EndFunc
Func JSON_OBJGET ( ByRef $OBJECT , $KEY )
	Local $DYNOBJECT = $OBJECT
	Local $KEYS = StringSplit ( $KEY , "." )
	For $X = 1 To $KEYS [ 0 ]
		If $DYNOBJECT .Exists ( $KEYS [ $X ] ) Then
			If $X = $KEYS [ 0 ] Then
				Return $DYNOBJECT .Item ( $KEYS [ $X ] )
			Else
				$DYNOBJECT = JSON_OBJGET ( $DYNOBJECT , $KEYS [ $X ] )
			EndIf
		EndIf
	Next
	Return SetError ( 1 , 0 , "" )
EndFunc
Func JSON_OBJDELETE ( ByRef $OBJECT , $KEY )
	$KEY = String ( $KEY )
	If $OBJECT .Exists ( $KEY ) Then $OBJECT .Remove ( $KEY )
EndFunc
Func JSON_OBJEXISTS ( ByRef $OBJECT , $KEY )
	Local $DYNOBJECT = $OBJECT
	Local $KEYS = StringSplit ( $KEY , "." )
	For $X = 1 To $KEYS [ 0 ]
		If $DYNOBJECT .Exists ( $KEYS [ $X ] ) Then
			If $X = $KEYS [ 0 ] Then
				Return True
			Else
				$DYNOBJECT = JSON_OBJGET ( $DYNOBJECT , $KEYS [ $X ] )
			EndIf
		Else
			Return False
		EndIf
	Next
	Return False
EndFunc
Func JSON_OBJGETCOUNT ( ByRef $OBJECT )
	Return $OBJECT .Count
EndFunc
Func JSON_OBJGETKEYS ( ByRef $OBJECT )
	Return $OBJECT .Keys ( )
EndFunc
Func JSON_OBJGETITEMS ( ByRef $OBJECT )
	Return $OBJECT .Items ( )
EndFunc
Func JSON_OBJCLEAR ( ByRef $OBJECT )
	Return $OBJECT .RemoveAll ( )
EndFunc
Func JSON_PUT ( ByRef $VAR , $NOTATION , $DATA , $CHECKEXISTS = False )
	Const $REGEX_DOT_WITH_STRING = "^\.(""[^""]+"")" , $REGEX_DOT_WITH_LITERAL = "^\.([^.[]+)" , $REGEX_BRACKET_WITH_STRING = "^\[(""[^""]+"")]" , $REGEX_BRACKET_WITH_LITERAL = "^\[([^]]+)]"
	Local $RET = 0 , $ITEM = "" , $ERROR = 0
	Local $MATCH = ""
	Local $REGEX = ""
	Select
	Case StringRegExp ( $NOTATION , $REGEX_DOT_WITH_STRING )
		$REGEX = $REGEX_DOT_WITH_STRING
	Case StringRegExp ( $NOTATION , $REGEX_DOT_WITH_LITERAL )
		$REGEX = $REGEX_DOT_WITH_LITERAL
	Case StringRegExp ( $NOTATION , $REGEX_BRACKET_WITH_STRING )
		$REGEX = $REGEX_BRACKET_WITH_STRING
	Case StringRegExp ( $NOTATION , $REGEX_BRACKET_WITH_LITERAL )
		$REGEX = $REGEX_BRACKET_WITH_LITERAL
Case Else
		Return SetError ( 2 , 0 , "" )
	EndSelect
	$MATCH = StringRegExp ( $NOTATION , $REGEX , 2 )
	If IsArray ( $MATCH ) Then
		Local $INDEX
		If StringLeft ( $MATCH [ 0 ] , 1 ) = "." Then
			$INDEX = String ( JSON_DECODE ( $MATCH [ 1 ] ) )
		Else
			$INDEX = JSON_DECODE ( $MATCH [ 1 ] )
		EndIf
		$NOTATION = StringTrimLeft ( $NOTATION , StringLen ( $MATCH [ 0 ] ) )
		If IsString ( $INDEX ) Then
			If $CHECKEXISTS And ( Not JSON_ISOBJECT ( $VAR ) Or Not JSON_OBJEXISTS ( $VAR , $INDEX ) ) Then
				Return SetError ( 1 , 0 , False )
			EndIf
			If Not JSON_ISOBJECT ( $VAR ) Then $VAR = JSON_OBJCREATE ( )
			If $NOTATION Then
				$ITEM = JSON_OBJGET ( $VAR , $INDEX )
				$RET = JSON_PUT ( $ITEM , $NOTATION , $DATA , $CHECKEXISTS )
				$ERROR = @error
				If Not $ERROR Then JSON_OBJPUT ( $VAR , $INDEX , $ITEM )
				Return SetError ( $ERROR , 0 , $RET )
			Else
				JSON_OBJPUT ( $VAR , $INDEX , $DATA )
				Return True
			EndIf
		ElseIf IsInt ( $INDEX ) Then
			If $INDEX < 0 Or ( $CHECKEXISTS And ( Not IsArray ( $VAR ) Or UBound ( $VAR , 0 ) <> 1 Or $INDEX >= UBound ( $VAR ) ) ) Then
				Return SetError ( 1 , 0 , False )
			EndIf
			If Not IsArray ( $VAR ) Or UBound ( $VAR , 0 ) <> 1 Then
				Dim $VAR [ $INDEX + 1 ]
			ElseIf $INDEX >= UBound ( $VAR ) Then
				ReDim $VAR [ $INDEX + 1 ]
			EndIf
			If $NOTATION Then
				$RET = JSON_PUT ( $VAR [ $INDEX ] , $NOTATION , $DATA , $CHECKEXISTS )
				Return SetError ( @error , 0 , $RET )
			Else
				$VAR [ $INDEX ] = $DATA
				Return True
			EndIf
		EndIf
	EndIf
	Return SetError ( 2 , 0 , False )
EndFunc
Func JSON_GET ( ByRef $VAR , $NOTATION )
	Const $REGEX_DOT_WITH_STRING = "^\.(""[^""]+"")" , $REGEX_DOT_WITH_LITERAL = "^\.([^.[]+)" , $REGEX_BRACKET_WITH_STRING = "^\[(""[^""]+"")]" , $REGEX_BRACKET_WITH_LITERAL = "^\[([^]]+)]"
	Local $REGEX = ""
	Select
	Case StringRegExp ( $NOTATION , $REGEX_DOT_WITH_STRING )
		$REGEX = $REGEX_DOT_WITH_STRING
	Case StringRegExp ( $NOTATION , $REGEX_DOT_WITH_LITERAL )
		$REGEX = $REGEX_DOT_WITH_LITERAL
	Case StringRegExp ( $NOTATION , $REGEX_BRACKET_WITH_STRING )
		$REGEX = $REGEX_BRACKET_WITH_STRING
	Case StringRegExp ( $NOTATION , $REGEX_BRACKET_WITH_LITERAL )
		$REGEX = $REGEX_BRACKET_WITH_LITERAL
Case Else
		Return SetError ( 2 , 0 , "" )
	EndSelect
	Local $MATCH = StringRegExp ( $NOTATION , $REGEX , 2 )
	If IsArray ( $MATCH ) Then
		Local $INDEX
		If StringLeft ( $MATCH [ 0 ] , 1 ) = "." Then
			$INDEX = String ( JSON_DECODE ( $MATCH [ 1 ] ) )
		Else
			$INDEX = JSON_DECODE ( $MATCH [ 1 ] )
		EndIf
		$NOTATION = StringTrimLeft ( $NOTATION , StringLen ( $MATCH [ 0 ] ) )
		Local $ITEM
		If IsString ( $INDEX ) And JSON_ISOBJECT ( $VAR ) And JSON_OBJEXISTS ( $VAR , $INDEX ) Then
			$ITEM = JSON_OBJGET ( $VAR , $INDEX )
		ElseIf IsInt ( $INDEX ) And IsArray ( $VAR ) And UBound ( $VAR , 0 ) = 1 And $INDEX >= 0 And $INDEX < UBound ( $VAR ) Then
			$ITEM = $VAR [ $INDEX ]
		Else
			Return SetError ( 1 , 0 , "" )
		EndIf
		If Not $NOTATION Then Return $ITEM
		Local $RET = JSON_GET ( $ITEM , $NOTATION )
		Return SetError ( @error , 0 , $RET )
	EndIf
EndFunc
Func JSON_DUMP ( $JSON , $INITTOKENCOUNT = 1000 )
	Static $JSMN_INIT = __JSMN_RUNTIMELOADER ( "jsmn_init" ) , $JSMN_PARSE = __JSMN_RUNTIMELOADER ( "jsmn_parse" )
	If $JSON = "" Then $JSON = """"""
	Local $TOKENLIST , $RET
	$TOTAL_JSON_DUMP_OUTPUT = ""
	Local $PARSER = DllStructCreate ( "uint pos;int toknext;int toksuper" )
	Do
		DllCallAddress ( "none:cdecl" , $JSMN_INIT , "ptr" , DllStructGetPtr ( $PARSER ) )
		$TOKENLIST = DllStructCreate ( "byte[" & ( $INITTOKENCOUNT * 20 ) & "]" )
		$RET = DllCallAddress ( "int:cdecl" , $JSMN_PARSE , "ptr" , DllStructGetPtr ( $PARSER ) , "wstr" , $JSON , "ptr" , DllStructGetPtr ( $TOKENLIST ) , "uint" , $INITTOKENCOUNT )
		$INITTOKENCOUNT *= 2
	Until $RET [ 0 ] <> $JSMN_ERROR_NOMEM
	Local $NEXT = 0
	_JSON_TOKENDUMP ( $JSON , DllStructGetPtr ( $TOKENLIST ) , $NEXT )
EndFunc
Func _JSON_TOKENDUMP ( ByRef $JSON , $PTR , ByRef $NEXT , $OBJPATH = "" )
	If $NEXT = + 4294967295 Then Return Null
	Local $TOKEN = DllStructCreate ( "int;int;int;int" , $PTR + ( $NEXT * 20 ) )
	Local $TYPE = DllStructGetData ( $TOKEN , 1 )
	Local $START = DllStructGetData ( $TOKEN , 2 )
	Local $END = DllStructGetData ( $TOKEN , 3 )
	Local $SIZE = DllStructGetData ( $TOKEN , 4 )
	Local $VALUE
	$NEXT += 1
	If $TYPE = 0 And $START = 0 And $END = 0 And $SIZE = 0 Then
		$NEXT = + 4294967295
		Return Null
	EndIf
	Switch $TYPE
	Case 0
		Local $PRIMITIVE = StringMid ( $JSON , $START + 1 , $END - $START )
		Switch $PRIMITIVE
		Case "true"
			Return "True"
		Case "false"
			Return "False"
		Case "null"
			Return "Null"
	Case Else
			If StringRegExp ( $PRIMITIVE , "^[+\-0-9]" ) Then
				Return Number ( $PRIMITIVE )
			Else
				Return JSON_STRINGDECODE ( $PRIMITIVE )
			EndIf
		EndSwitch
	Case 1
		For $I = 0 To $SIZE + 4294967295 Step 2
			Local $KEY = _JSON_TOKENDUMP ( $JSON , $PTR , $NEXT )
			Local $COBJPATH = $OBJPATH & "." & $KEY
			$VALUE = _JSON_TOKENDUMP ( $JSON , $PTR , $NEXT , $OBJPATH & "." & $KEY )
			If Not ( IsBool ( $VALUE ) And $VALUE = False ) Then
				If Not IsString ( $KEY ) Then
					$KEY = JSON_ENCODE ( $KEY )
				EndIf
				ConsoleWrite ( "+-> " & $COBJPATH & "  =" & $VALUE & @CRLF )
				$TOTAL_JSON_DUMP_OUTPUT &= "+-> " & $COBJPATH & "  =" & $VALUE & @CRLF
			EndIf
		Next
		Return False
	Case 2
		Local $SOBJPATH = $OBJPATH
		For $I = 0 To $SIZE + 4294967295
			$SOBJPATH = $OBJPATH & "[" & $I & "]"
			$VALUE = _JSON_TOKENDUMP ( $JSON , $PTR , $NEXT , $SOBJPATH )
			If Not ( IsBool ( $VALUE ) And $VALUE = False ) Then
				ConsoleWrite ( "+=> " & $SOBJPATH & "=>" & $VALUE & @CRLF )
				$TOTAL_JSON_DUMP_OUTPUT &= "+=> " & $SOBJPATH & "=>" & $VALUE & @CRLF
			EndIf
		Next
		$OBJPATH = $SOBJPATH
		Return False
	Case 3
		Local $LASTKEY = JSON_STRINGDECODE ( StringMid ( $JSON , $START + 1 , $END - $START ) )
		Return $LASTKEY
	EndSwitch
EndFunc
Func _HEXTOSTRING ( $SHEX )
	If Not ( StringLeft ( $SHEX , 2 ) == "0x" ) Then $SHEX = "0x" & $SHEX
	Return BinaryToString ( $SHEX , $SB_UTF8 )
EndFunc
Func _STRINGBETWEEN ( $SSTRING , $SSTART , $SEND , $IMODE = $STR_ENDISSTART , $BCASE = False )
	$SSTART = $SSTART ? "\Q" & $SSTART & "\E" : "\A"
	If $IMODE <> $STR_ENDNOTSTART Then $IMODE = $STR_ENDISSTART
	If $IMODE = $STR_ENDISSTART Then
		$SEND = $SEND ? "(?=\Q" & $SEND & "\E)" : "\z"
	Else
		$SEND = $SEND ? "\Q" & $SEND & "\E" : "\z"
	EndIf
	If $BCASE = Default Then
		$BCASE = False
	EndIf
	Local $ARET = StringRegExp ( $SSTRING , "(?s" & ( Not $BCASE ? "i" : "" ) & ")" & $SSTART & "(.*?)" & $SEND , $STR_REGEXPARRAYGLOBALMATCH )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Return $ARET
EndFunc
Func _STRINGEXPLODE ( $SSTRING , $SDELIMITER , $ILIMIT = 0 )
	If $ILIMIT = Default Then $ILIMIT = 0
	If $ILIMIT > 0 Then
		Local Const $NULL = Chr ( 0 )
		$SSTRING = StringReplace ( $SSTRING , $SDELIMITER , $NULL , $ILIMIT )
		$SDELIMITER = $NULL
	ElseIf $ILIMIT < 0 Then
		Local $IINDEX = StringInStr ( $SSTRING , $SDELIMITER , $STR_NOCASESENSEBASIC , $ILIMIT )
		If $IINDEX Then
			$SSTRING = StringLeft ( $SSTRING , $IINDEX + 4294967295 )
		EndIf
	EndIf
	Return StringSplit ( $SSTRING , $SDELIMITER , BitOR ( $STR_ENTIRESPLIT , $STR_NOCOUNT ) )
EndFunc
Func _STRINGINSERT ( $SSTRING , $SINSERTION , $IPOSITION )
	Local $ILENGTH = StringLen ( $SSTRING )
	$IPOSITION = Int ( $IPOSITION )
	If $IPOSITION < 0 Then $IPOSITION = $ILENGTH + $IPOSITION
	If $ILENGTH < $IPOSITION Or $IPOSITION < 0 Then Return SetError ( 1 , 0 , $SSTRING )
	Return StringLeft ( $SSTRING , $IPOSITION ) & $SINSERTION & StringRight ( $SSTRING , $ILENGTH - $IPOSITION )
EndFunc
Func _STRINGPROPER ( $SSTRING )
	Local $BCAPNEXT = True , $SCHR = "" , $SRETURN = ""
	Local $SPATTERN = "[a-zA-Z-]"
	For $I = 1 To StringLen ( $SSTRING )
		$SCHR = StringMid ( $SSTRING , $I , 1 )
		Select
		Case $BCAPNEXT = True
			If StringRegExp ( $SCHR , $SPATTERN ) Then
				$SCHR = StringUpper ( $SCHR )
				$BCAPNEXT = False
			EndIf
		Case Not StringRegExp ( $SCHR , $SPATTERN )
			$BCAPNEXT = True
	Case Else
			$SCHR = StringLower ( $SCHR )
		EndSelect
		$SRETURN &= $SCHR
	Next
	Return $SRETURN
EndFunc
Func _STRINGREPEAT ( $SSTRING , $IREPEATCOUNT )
	$IREPEATCOUNT = Int ( $IREPEATCOUNT )
	If $IREPEATCOUNT = 0 Then Return ""
	If StringLen ( $SSTRING ) < 1 Or $IREPEATCOUNT < 0 Then Return SetError ( 1 , 0 , "" )
	Local $SRESULT = ""
	While $IREPEATCOUNT > 1
		If BitAND ( $IREPEATCOUNT , 1 ) Then $SRESULT &= $SSTRING
		$SSTRING &= $SSTRING
		$IREPEATCOUNT = BitShift ( $IREPEATCOUNT , 1 )
	WEnd
	Return $SSTRING & $SRESULT
EndFunc
Func _STRINGTITLECASE ( $SSTRING )
	Local $BCAPNEXT = True , $SCHR = "" , $SRETURN = ""
	For $I = 1 To StringLen ( $SSTRING )
		$SCHR = StringMid ( $SSTRING , $I , 1 )
		Select
		Case $BCAPNEXT = True
			If StringRegExp ( $SCHR , "[a-zA-Z\xC0-\xFF0-9]" ) Then
				$SCHR = StringUpper ( $SCHR )
				$BCAPNEXT = False
			EndIf
		Case Not StringRegExp ( $SCHR , "[a-zA-Z\xC0-\xFF'0-9]" )
			$BCAPNEXT = True
	Case Else
			$SCHR = StringLower ( $SCHR )
		EndSelect
		$SRETURN &= $SCHR
	Next
	Return $SRETURN
EndFunc
Func _STRINGTOHEX ( $SSTRING )
	Return Hex ( StringToBinary ( $SSTRING , $SB_UTF8 ) )
EndFunc
Global $TOKEN = ""
Global $URL = "https://api.telegram.org/bot"
Global $OFFSET = 0
Const $BOT_CRLF = __URLENCODE ( @CRLF )
Const $INVALID_TOKEN_ERROR = 1
Const $FILE_NOT_DOWNLOADED = 2
Const $OFFSET_GRATER_THAN_TOTAL = 3
Const $INVALID_JSON_RESPONSE = 4
#Region "@ENDPOINT FUNCTIONS"
Func _GETUPDATES ( )
	Return __HTTPGET ( $URL & "/getUpdates?offset=" & $OFFSET )
EndFunc
Func _GETME ( )
	Local $JSON = JSON_DECODE ( __HTTPGET ( $URL & "/getMe" ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Local $DATA [ 3 ] = [ JSON_GET ( $JSON , "[result][id]" ) , JSON_GET ( $JSON , "[result][username]" ) , JSON_GET ( $JSON , "[result][first_name]" ) ]
	Return $DATA
EndFunc
Func _SENDMSG ( $CHATID , $TEXT , $PARSEMODE = Default , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLEWEBPREVIEW = False , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendMessage?chat_id=" & $CHATID & "&text=" & $TEXT
	If StringLower ( $PARSEMODE ) = "markdown" Then $QUERY &= "&parse_mode=markdown"
	If StringLower ( $PARSEMODE ) = "html" Then $QUERY &= "&parse_mode=html"
	If $DISABLEWEBPREVIEW = True Then $QUERY &= "&disable_web_page_preview=True"
	If $DISABLENOTIFICATION = True Then $QUERY &= "&disable_notification=True"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "&reply_to_message_id=" & $REPLYTOMESSAGE
	If $REPLYMARKUP <> Default Then $QUERY &= "&reply_markup=" & $REPLYMARKUP
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return JSON_GET ( $JSON , "[result][message_id]" )
EndFunc
Func _FORWARDMESSAGE ( $CHATID , $ORIGINALCHATID , $MSGID , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/forwardMessage?chat_id=" & $CHATID & "&from_chat_id=" & $ORIGINALCHATID & "&message_id=" & $MSGID
	If $DISABLENOTIFICATION Then $QUERY &= "&disable_notification=True"
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return JSON_GET ( $JSON , "[result][message_id]" )
EndFunc
Func _SENDPHOTO ( $CHATID , $PHOTO , $CAPTION = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendPhoto"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""photo""/>" & "<input type=""text"" name=""caption""/>"
	If $REPLYMARKUP <> Default Then $FORM &= "<input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= "<input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:photo" , $PHOTO , "name:caption" , $CAPTION , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "photo" )
EndFunc
Func _SENDAUDIO ( $CHATID , $AUDIO , $CAPTION = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendAudio"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""audio""/>" & "<input type=""text"" name=""caption""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:audio" , $AUDIO , "name:caption" , $CAPTION , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "audio" )
EndFunc
Func _SENDDOCUMENT ( $CHATID , $DOCUMENT , $CAPTION = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendDocument"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""document""/>" & "<input type=""text"" name=""caption""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:document" , $DOCUMENT , "name:caption" , $CAPTION , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "document" )
EndFunc
Func _SENDVIDEO ( $CHATID , $VIDEO , $CAPTION = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendVideo"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""video""/>" & "<input type=""text"" name=""caption""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:video" , $VIDEO , "name:caption" , $CAPTION , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "video" )
EndFunc
Func _SENDANIMATION ( $CHATID , $ANIMATION , $CAPTION = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendAnimation"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""animation""/>" & "<input type=""text"" name=""caption""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:animation" , $ANIMATION , "name:caption" , $CAPTION , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "animation" )
EndFunc
Func _SENDVOICE ( $CHATID , $PATH , $CAPTION = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendVoice"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""voice""/>" & "<input type=""text"" name=""caption""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:voice" , $PATH , "name:caption" , $CAPTION , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "voice" )
EndFunc
Func _SENDVIDEONOTE ( $CHATID , $VIDEONOTE , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendVideoNote"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""video_note""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:video_note" , $VIDEONOTE , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "videonote" )
EndFunc
Func _SENDMEDIAGROUP ( $CHATID , $MEDIA , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendMediaGroup"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""mediagroup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:media" , $MEDIA , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "mediagroup" )
EndFunc
Func _SENDSTICKER ( $CHATID , $PATH , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendSticker"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""sticker""/>"
	If $REPLYMARKUP <> Default Then $FORM &= " <input type=""text"" name=""reply_markup""/>"
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "<input type=""text"" name=""reply_to_message_id""/>"
	If $DISABLENOTIFICATION Then $FORM &= " <input type=""text"" name=""disable_notification""/>"
	$FORM &= "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:sticker" , $PATH , "name:reply_markup" , $REPLYMARKUP , "name:reply_to_message_id" , $REPLYTOMESSAGE , "name:disable_notification" , $DISABLENOTIFICATION )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	Return __GETFILEID ( $JSON , "sticker" )
EndFunc
Func _SENDLOCATION ( $CHATID , $LATITUDE , $LONGITUDE , $LIVEPERIOD = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendLocation?chat_id=" & $CHATID & "&latitude=" & $LATITUDE & "&longitude=" & $LONGITUDE
	If $LIVEPERIOD <> "" Then $QUERY &= "&live_period=" & $LIVEPERIOD
	If $REPLYMARKUP <> Default Then $QUERY &= "&reply_markup=" & $REPLYMARKUP
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "&reply_to_message_id=" & $REPLYTOMESSAGE
	If $DISABLENOTIFICATION Then $QUERY &= "&disable_notification=true"
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _EDITMESSAGELIVELOCATION ( $CHATID , $LATITUDE , $LONGITUDE , $REPLYMARKUP = Default )
	$QUERY = $URL & "/editMessageLiveLocation?chat_id=" & $CHATID & "&latitude=" & $LATITUDE & "&longitude=" & $LONGITUDE
	If $REPLYMARKUP <> Default Then $QUERY &= "&reply_markup=" & $REPLYMARKUP
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _STOPMESSAGELIVELOCATION ( $CHATID , $REPLYMARKUP = Default )
	$QUERY = $URL & "/stopMessageLiveLocation?chat_id=" & $CHATID
	If $REPLYMARKUP <> Default Then $QUERY &= "&reply_markup=" & $REPLYMARKUP
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _SENDVENUE ( $CHATID , $LATITUDE , $LONGITUDE , $TITLE , $ADDRESS , $FOURSQUARE = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendVenue?chat_id=" & $CHATID & "&latitude=" & $LATITUDE & "&longitude=" & $LONGITUDE & "&title=" & $TITLE & "&address=" & $ADDRESS
	If $FOURSQUARE <> "" Then $QUERY &= "&foursquare=" & $FOURSQUARE
	If $REPLYMARKUP <> Default Then $QUERY &= "&reply_markup=" & $REPLYMARKUP
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "&reply_to_message_id=" & $REPLYTOMESSAGE
	If $DISABLENOTIFICATION Then $QUERY &= "&disable_notification=true"
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _SENDCONTACT ( $CHATID , $PHONE , $FIRSTNAME , $LASTNAME = "" , $REPLYMARKUP = Default , $REPLYTOMESSAGE = "" , $DISABLENOTIFICATION = False )
	Local $QUERY = $URL & "/sendContact?chat_id=" & $CHATID & "&phone_number=" & $PHONE & "&first_name=" & $FIRSTNAME
	If $LASTNAME <> "" Then $QUERY &= "&last_name=" & $LASTNAME
	If $REPLYMARKUP <> Default Then $QUERY &= "&reply_markup=" & $REPLYMARKUP
	If $REPLYTOMESSAGE <> "" Then $QUERY &= "&reply_to_message_id=" & $REPLYTOMESSAGE
	If $DISABLENOTIFICATION = True Then $QUERY &= "&disable_notification=True"
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _SENDCHATACTION ( $CHATID , $ACTION )
	Local $QUERY = $URL & "/sendChatAction?chat_id=" & $CHATID & "&action=" & $ACTION
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _GETUSERPROFILEPHOTOS ( $CHATID , $OFFSET = "" , $LIMIT = "" )
	$QUERY = $URL & "/getUserProfilePhotos?user_id=" & $CHATID
	If $OFFSET <> "" Then $QUERY &= "&offset=" & $OFFSET
	If $LIMIT <> "" Then $QUERY &= "&limit=" & $LIMIT
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( 2 , 0 , False )
	Local $COUNT = JSON_GET ( $JSON , "[result][total_count]" )
	If $OFFSET >= $COUNT Then Return SetError ( $OFFSET_GRATER_THAN_TOTAL , 0 , False )
	If $LIMIT <> "" And $LIMIT < $COUNT Then
		Local $PHOTOARRAY [ $LIMIT + 1 ]
		$PHOTOARRAY [ 0 ] = $LIMIT
	Else
		Local $PHOTOARRAY [ $COUNT + 1 ]
		$PHOTOARRAY [ 0 ] = $COUNT
	EndIf
	For $I = 1 To $PHOTOARRAY [ 0 ]
		$PHOTOARRAY [ $I ] = JSON_GET ( $JSON , "[result][photos][" & $I + 4294967295 & "][2][file_id]" )
		If $PHOTOARRAY [ $I ] == "" Then
			$PHOTOARRAY [ $I ] = JSON_GET ( $JSON , "[result][photos][" & $I + 4294967295 & "][1][file_id]" )
			If $PHOTOARRAY [ $I ] == "" Then
				$PHOTOARRAY [ $I ] = JSON_GET ( $JSON , "[result][photos][" & $I + 4294967295 & "][0][file_id]" )
			EndIf
		EndIf
	Next
	Return $PHOTOARRAY
EndFunc
Func _KICKCHATMEMBER ( $CHATID , $USERID , $UNTILDATE = "" )
	$QUERY = $URL & "/kickChatMember?chat_id=" & $CHATID & "&user_id=" & $USERID
	If $UNTILDATE <> "" Then $QUERY &= "&until_date=" & $UNTILDATE
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _UNBANCHATMEMBER ( $CHATID , $USERID )
	$QUERY = $URL & "/unbanChatMember?chat_id=" & $CHATID & "&user_id=" & $USERID
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _EXPORTCHATINVITELINK ( $CHATID )
	$QUERY = $URL & "/exportChatInviteLink?chat_id=" & $CHATID
	Local $JSON = JSON_DECODE ( __HTTPGET ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return JSON_GET ( $JSON , "[result]" )
EndFunc
Func _SETCHATPHOTO ( $CHATID , $PATH )
	Local $QUERY = $URL & "/setChatPhoto"
	Local $HOPEN = _WINHTTPOPEN ( )
	Local $FORM = "<form action=""" & $QUERY & """ method=""post"" enctype=""multipart/form-data"">" & "<input type=""text"" name=""chat_id""/>" & "<input type=""file"" name=""photo""/>" & "</form>"
	Local $RESPONSE = _WINHTTPSIMPLEFORMFILL ( $FORM , $HOPEN , Default , "name:chat_id" , $CHATID , "name:photo" , $PATH )
	_WINHTTPCLOSEHANDLE ( $HOPEN )
	Local $JSON = JSON_DECODE ( $RESPONSE )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _DELETECHATPHOTO ( $CHATID )
	$QUERY = $URL & "/deleteChatPhoto?chat_id=" & $CHATID
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _SETCHATTITLE ( $CHATID , $TITLE )
	$QUERY = $URL & "/setChatTitle?chat_id=" & $CHATID & "&title=" & $TITLE
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _SETCHATDESCRIPTION ( $CHATID , $DESCRIPTION )
	$QUERY = $URL & "/setChatDescription?chat_id=" & $CHATID & "&description=" & $DESCRIPTION
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _PINCHATMESSAGE ( $CHATID , $MSGID , $DISABLENOTIFICATION = False )
	$QUERY = $URL & "/pinChatMessage?chat_id=" & $CHATID & "&message_id=" & $MSGID
	If $DISABLENOTIFICATION Then $QUERY &= "&disable_notification=true"
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _UNPINCHATMESSAGE ( $CHATID )
	$QUERY = $URL & "/unpinChatMessage?chat_id=" & $CHATID
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _LEAVECHAT ( $CHATID )
	$QUERY = $URL & "/leaveChat?chat_id=" & $CHATID
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _GETCHAT ( $CHATID )
	Local $QUERY = $URL & "/getChat?chat_id=" & $CHATID
	Local $JSON = JSON_DECODE ( __HTTPGET ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Local $CHATDATA [ 4 ] = [ JSON_GET ( $JSON , "[result][id]" ) , JSON_GET ( $JSON , "[result][username]" ) , JSON_GET ( $JSON , "[result][first_name]" ) , JSON_GET ( $JSON , "[result][photo][big_file_id]" ) ]
	Return $CHATDATA
EndFunc
Func _GETCHATADMINISTRATORS ( $CHATID )
	Local $QUERY = $URL & "/getChatAdministrators?chat_id=" & $CHATID
	ConsoleWrite ( __HTTPGET ( $QUERY ) )
EndFunc
Func _GETCHATMEMBERSCOUNT ( $CHATID )
	Local $QUERY = $URL & "/getChatMembersCount?chat_id=" & $CHATID
	ConsoleWrite ( __HTTPGET ( $QUERY ) )
EndFunc
Func _GETCHATMEMBER ( $CHATID )
	Local $QUERY = $URL & "/getChatMember?chat_id=" & $CHATID
	ConsoleWrite ( __HTTPGET ( $QUERY ) )
EndFunc
Func _SETCHATSTICKERSET ( $CHATID )
	Local $QUERY = $URL & "/setChatStickerSet?chat_id=" & $CHATID
	ConsoleWrite ( __HTTPGET ( $QUERY ) )
EndFunc
Func _DELETECHATSTICKERSET ( $CHATID )
	Local $QUERY = $URL & "/deleteChatStickerSet?chat_id=" & $CHATID
	ConsoleWrite ( __HTTPGET ( $QUERY ) )
EndFunc
Func _ANSWERCALLBACKQUERY ( $CALLBACKID , $TEXT = "" , $CBURL = "" , $SHOWALERT = False , $CACHETIME = "" )
	Local $QUERY = $URL & "/answerCallbackQuery?callback_query_id=" & $CALLBACKID
	If $TEXT <> "" Then $QUERY &= "&text=" & $TEXT
	If $CBURL <> "" Then $QUERY &= "&url=" & $CBURL
	If $SHOWALERT Then $QUERY &= "&show_alert=true"
	If $CACHETIME <> "" Then $QUERY &= "&cache_time=" & $CACHETIME
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	If Not ( JSON_ISOBJECT ( $JSON ) ) Then Return SetError ( $INVALID_JSON_RESPONSE , 0 , False )
	If Not ( JSON_GET ( $JSON , "[ok]" ) = "true" ) Then Return SetError ( 2 , 0 , False )
	Return True
EndFunc
Func _DELETEMESSAGE ( $CHATID , $MSGID )
	Local $QUERY = $URL & "/deleteMessage?chat_id=" & $CHATID & "&message_id=" & $MSGID
	ConsoleWrite ( __HTTPGET ( $QUERY ) )
EndFunc
#EndRegion "@ENDPOINT FUNCTIONS"
#Region "@EXTRA FUNCTIONS"
Func _INITBOT ( $TOKEN )
	Return
EndFunc
Func _POLLING ( )
	While 1
		Sleep ( 10 )
		$NEWUPDATES = _GETUPDATES ( )
		If Not StringInStr ( $NEWUPDATES , "update_id" ) Then ContinueLoop
		$MSGDATA = __MSGDECODE ( $NEWUPDATES )
		$OFFSET = $MSGDATA [ 0 ] + 1
		Return $MSGDATA
	WEnd
EndFunc
Func _POLLING_ONESHOT ( )
	$NEWUPDATES = _GETUPDATES ( )
	If Not StringInStr ( $NEWUPDATES , "update_id" ) Then Return 0
	$MSGDATA = __MSGDECODE ( $NEWUPDATES )
	If IsArray ( $MSGDATA ) Then
		$OFFSET = $MSGDATA [ 0 ] + 1
		Return $MSGDATA
	Else
		FILECONSOLEWRITE ( "Telegram STOP by error" & @CRLF )
		$TELEGRAMTOKEN = ""
		$TELEGRAMCHATID = 0
		Return 0
	EndIf
EndFunc
Func _CREATEKEYBOARD ( ByRef $KEYBOARD , $RESIZE = False , $ONETIME = False )
	Local $JSONKEYBOARD = "{""keyboard"":["
	For $I = 0 To UBound ( $KEYBOARD ) + 4294967295
		If ( $KEYBOARD [ $I ] <> "" ) Then
			If ( StringRight ( $JSONKEYBOARD , 1 ) = """" ) Then
				$JSONKEYBOARD &= ",""" & $KEYBOARD [ $I ] & """"
			Else
				$JSONKEYBOARD &= "[""" & $KEYBOARD [ $I ] & """"
			EndIf
		Else
			$JSONKEYBOARD &= "],"
		EndIf
	Next
	$JSONKEYBOARD &= "]]"
	If $RESIZE = True Then $JSONKEYBOARD &= ",""resize_keyboard"":true"
	If $ONETIME = True Then $JSONKEYBOARD &= ",""one_time_keyboard"":true"
	$JSONKEYBOARD &= "}"
	Return $JSONKEYBOARD
EndFunc
Func _CREATEINLINEKEYBOARD ( ByRef $KEYBOARD )
	Local $JSONKEYBOARD = "{""inline_keyboard"":[["
	For $I = 0 To UBound ( $KEYBOARD ) + 4294967295
		If ( $KEYBOARD [ $I ] <> "" ) Then
			If ( StringRight ( $JSONKEYBOARD , 2 ) = "[[" ) Then
				$JSONKEYBOARD &= "{""text"":""" & $KEYBOARD [ $I ] & ""","
			ElseIf ( StringRight ( $JSONKEYBOARD , 2 ) = """," ) Then
				$JSONKEYBOARD &= """callback_data"":""" & $KEYBOARD [ $I ] & """}"
			ElseIf ( StringRight ( $JSONKEYBOARD , 2 ) = """}" ) Then
				$JSONKEYBOARD &= ",{""text"":""" & $KEYBOARD [ $I ] & ""","
			ElseIf ( StringRight ( $JSONKEYBOARD , 2 ) = "]," ) Then
				$JSONKEYBOARD &= "[{""text"":""" & $KEYBOARD [ $I ] & ""","
			EndIf
		Else
			$JSONKEYBOARD &= "],"
		EndIf
	Next
	$JSONKEYBOARD &= "]]}"
	Return $JSONKEYBOARD
EndFunc
#EndRegion "@EXTRA FUNCTIONS"
#Region "@INTERNAL FUNCTIONS"
Func __GETFILEID ( ByRef $JSON , $TYPE )
	If ( $TYPE = "photo" ) Then
		If ( JSON_GET ( $JSON , "[result][photo][3][file_id]" ) ) Then Return JSON_GET ( $JSON , "[result][photo][3][file_id]" )
		If ( JSON_GET ( $JSON , "[result][photo][2][file_id]" ) ) Then Return JSON_GET ( $JSON , "[result][photo][2][file_id]" )
		If ( JSON_GET ( $JSON , "[result][photo][1][file_id]" ) ) Then Return JSON_GET ( $JSON , "[result][photo][1][file_id]" )
		If ( JSON_GET ( $JSON , "[result][photo][0][file_id]" ) ) Then Return JSON_GET ( $JSON , "[result][photo][0][file_id]" )
	EndIf
	If ( $TYPE = "video" ) Then Return JSON_GET ( $JSON , "[result][animation][file_id]" )
	If ( $TYPE = "audio" ) Then Return JSON_GET ( $JSON , "[result][audio][file_id]" )
	If ( $TYPE = "document" ) Then Return JSON_GET ( $JSON , "[result][document][file_id]" )
	If ( $TYPE = "voice" ) Then Return JSON_GET ( $JSON , "[result][voice][file_id]" )
	If ( $TYPE = "sticker" ) Then Return JSON_GET ( $JSON , "[result][sticker][file_id]" )
	If ( $TYPE = "videonote" ) Then Return JSON_GET ( $JSON , "[result][document][file_id]" )
EndFunc
Func __GETFILEPATH ( $FILEID )
	Local $QUERY = $URL & "/getFile?file_id=" & $FILEID
	Local $JSON = JSON_DECODE ( __HTTPPOST ( $QUERY ) )
	Return JSON_GET ( $JSON , "[result][file_path]" )
EndFunc
Func __DOWNLOADFILE ( $FILEPATH )
	Local $FILENAME = StringSplit ( $FILEPATH , "/" ) [ 2 ]
	Local $QUERY = "https://api.telegram.org/file/bot" & $TOKEN & "/" & $FILEPATH
	Local $RESULT = InetGet ( $QUERY , $FILENAME )
	If $RESULT And Not @error And FileExists ( $FILENAME ) Then
		Return $FILENAME
	Else
		Return SetError ( $FILE_NOT_DOWNLOADED , 0 , False )
	EndIf
EndFunc
Func __URLENCODE ( $STRING )
	$STRING = StringSplit ( $STRING , "" )
	For $I = 1 To $STRING [ 0 ]
		If AscW ( $STRING [ $I ] ) < 48 Or AscW ( $STRING [ $I ] ) > 122 Then
			$STRING [ $I ] = "%" & _STRINGTOHEX ( $STRING [ $I ] )
		EndIf
	Next
	$STRING = _ARRAYTOSTRING ( $STRING , "" , 1 )
	Return $STRING
EndFunc
Func __MSGDECODE ( $UPDATE )
	Local $JSON = JSON_DECODE ( $UPDATE )
	If @error Then
		MsgBox ( 0 , "failed" , @error )
	EndIf
	If ( JSON_GET ( $JSON , "[result][0][message][chat][type]" ) = "private" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][message][message_id]" ) , JSON_GET ( $JSON , "[result][0][message][from][id]" ) , JSON_GET ( $JSON , "[result][0][message][from][username]" ) , JSON_GET ( $JSON , "[result][0][message][from][first_name]" ) ]
		If ( JSON_GET ( $JSON , "[result][0][message][text]" ) ) Then $MSGDATA [ 5 ] = JSON_GET ( $JSON , "[result][0][message][text]" )
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][message][chat][type]" ) = "group" ) Or ( JSON_GET ( $JSON , "[result][0][message][chat][type]" ) = "supergroup" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][message][message_id]" ) , JSON_GET ( $JSON , "[result][0][message][from][id]" ) , JSON_GET ( $JSON , "[result][0][message][from][username]" ) , JSON_GET ( $JSON , "[result][0][message][from][first_name]" ) , JSON_GET ( $JSON , "[result][0][message][chat][id]" ) , JSON_GET ( $JSON , "[result][0][message][chat][title]" ) ]
		If ( JSON_GET ( $JSON , "[result][0][message][left_chat_member]" ) ) Then
			$MSGDATA [ 7 ] = "left"
			$MSGDATA [ 8 ] = JSON_GET ( $JSON , "[result][0][message][from][id]" )
			$MSGDATA [ 9 ] = JSON_GET ( $JSON , "[result][0][message][from][username]" )
			$MSGDATA [ 10 ] = JSON_GET ( $JSON , "[result][0][message][from][first_name]" )
		ElseIf ( JSON_GET ( $JSON , "[result][0][message][new_chat_member]" ) ) Then
			$MSGDATA [ 7 ] = "new"
			$MSGDATA [ 8 ] = JSON_GET ( $JSON , "[result][0][message][from][id]" )
			$MSGDATA [ 9 ] = JSON_GET ( $JSON , "[result][0][message][from][username]" )
			$MSGDATA [ 10 ] = JSON_GET ( $JSON , "[result][0][message][from][first_name]" )
		Else
			$MSGDATA [ 7 ] = JSON_GET ( $JSON , "[result][0][message][text]" )
		EndIf
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][edited_message][chat][type]" ) = "private" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][message_id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][username]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][first_name]" ) ]
		If ( JSON_GET ( $JSON , "[result][0][edited_message][text]" ) ) Then $MSGDATA [ 5 ] = JSON_GET ( $JSON , "[result][0][edited_message][text]" )
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][edited_message][chat][type]" ) = "group" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][message_id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][username]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][first_name]" ) ]
		If ( JSON_GET ( $JSON , "[result][0][edited_message][text]" ) ) Then $MSGDATA [ 5 ] = JSON_GET ( $JSON , "[result][0][edited_message][text]" )
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][callback_query][id]" ) <> "" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][callback_query][id]" ) , JSON_GET ( $JSON , "[result][0][callback_query][from][id]" ) , JSON_GET ( $JSON , "[result][0][callback_query][from][username]" ) , JSON_GET ( $JSON , "[result][0][callback_query][from][first_name]" ) , JSON_GET ( $JSON , "[result][0][callback_query][data]" ) ]
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][inline_query][id]" ) <> "" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][inline_query][id]" ) , JSON_GET ( $JSON , "[result][0][inline_query][from][id]" ) , JSON_GET ( $JSON , "[result][0][inline_query][from][username]" ) , JSON_GET ( $JSON , "[result][0][inline_query][from][first_name]" ) , JSON_GET ( $JSON , "[result][0][inline_query][query]" ) ]
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][channel_post][message_id]" ) <> "" ) Then
		Local $MSGDATA [ 5 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][channel_post][message_id]" ) , JSON_GET ( $JSON , "[result][0][channel_post][chat][id]" ) , JSON_GET ( $JSON , "[result][0][channel_post][chat][title]" ) ]
		If ( JSON_GET ( $JSON , "[result][0][channel_post][text]" ) ) Then
			$MSGDATA [ 4 ] = JSON_GET ( $JSON , "[result][0][channel_post][text]" )
		EndIf
		Return $MSGDATA
	ElseIf ( JSON_GET ( $JSON , "[result][0][edited_channel_post][chat][type]" ) = "channel" ) Then
		Local $MSGDATA [ 10 ] = [ JSON_GET ( $JSON , "[result][0][update_id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][message_id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][id]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][username]" ) , JSON_GET ( $JSON , "[result][0][edited_message][from][first_name]" ) ]
		If ( JSON_GET ( $JSON , "[result][0][edited_message][text]" ) ) Then $MSGDATA [ 5 ] = JSON_GET ( $JSON , "[result][0][edited_message][text]" )
		Return $MSGDATA
	EndIf
EndFunc
#EndRegion "@INTERNAL FUNCTIONS"
#Region "@HTTP Request"
Func __HTTPGET ( $SURL , $SDATA = "" )
	Local $OHTTP = ObjCreate ( "WinHttp.WinHttpRequest.5.1" )
	$OHTTP .Open ( "GET" , $SURL & "?" & $SDATA , False )
	If ( @error ) Then Return SetError ( 1 , 0 , 0 )
	$OHTTP .Send ( )
	If ( @error ) Then Return SetError ( 2 , 0 , 0 )
	If ( $OHTTP .Status <> $HTTP_STATUS_OK ) Then Return SetError ( 3 , 0 , 0 )
	Return SetError ( 0 , 0 , $OHTTP .ResponseText )
EndFunc
Func __HTTPPOST ( $SURL , $SDATA = "" )
	Local $OHTTP = ObjCreate ( "WinHttp.WinHttpRequest.5.1" )
	$OHTTP .Open ( "POST" , $SURL , False )
	If ( @error ) Then Return SetError ( 1 , 0 , 0 )
	$OHTTP .SetRequestHeader ( "Content-Type" , "application/x-www-form-urlencoded" )
	$OHTTP .Send ( $SDATA )
	If ( @error ) Then Return SetError ( 2 , 0 , 0 )
	If ( $OHTTP .Status <> $HTTP_STATUS_OK ) Then Return SetError ( 3 , 0 , 0 )
	Return SetError ( 0 , 0 , $OHTTP .ResponseText )
EndFunc
#EndRegion "@HTTP Request"
Func _FILECOUNTLINES ( $SFILEPATH )
	FileReadToArray ( $SFILEPATH )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return @extended
EndFunc
Func _FILECREATE ( $SFILEPATH )
	Local $HFILEOPEN = FileOpen ( $SFILEPATH , BitOR ( $FO_OVERWRITE , $FO_CREATEPATH ) )
	If $HFILEOPEN = + 4294967295 Then Return SetError ( 1 , 0 , 0 )
	Local $IFILEWRITE = FileWrite ( $HFILEOPEN , "" )
	FileClose ( $HFILEOPEN )
	If Not $IFILEWRITE Then Return SetError ( 2 , 0 , 0 )
	Return 1
EndFunc
Func _FILELISTTOARRAY ( $SFILEPATH , $SFILTER = "*" , $IFLAG = $FLTA_FILESFOLDERS , $BRETURNPATH = False )
	Local $SDELIMITER = "|" , $SFILELIST = "" , $SFILENAME = "" , $SFULLPATH = ""
	$SFILEPATH = StringRegExpReplace ( $SFILEPATH , "[\\/]+$" , "" ) & "\"
	If $IFLAG = Default Then $IFLAG = $FLTA_FILESFOLDERS
	If $BRETURNPATH Then $SFULLPATH = $SFILEPATH
	If $SFILTER = Default Then $SFILTER = "*"
	If Not FileExists ( $SFILEPATH ) Then Return SetError ( 1 , 0 , 0 )
	If StringRegExp ( $SFILTER , "[\\/:><\|]|(?s)^\s*$" ) Then Return SetError ( 2 , 0 , 0 )
	If Not ( $IFLAG = 0 Or $IFLAG = 1 Or $IFLAG = 2 ) Then Return SetError ( 3 , 0 , 0 )
	Local $HSEARCH = FileFindFirstFile ( $SFILEPATH & $SFILTER )
	If @error Then Return SetError ( 4 , 0 , 0 )
	While 1
		$SFILENAME = FileFindNextFile ( $HSEARCH )
		If @error Then ExitLoop
		If ( $IFLAG + @extended = 2 ) Then ContinueLoop
		$SFILELIST &= $SDELIMITER & $SFULLPATH & $SFILENAME
	WEnd
	FileClose ( $HSEARCH )
	If $SFILELIST = "" Then Return SetError ( 4 , 0 , 0 )
	Return StringSplit ( StringTrimLeft ( $SFILELIST , 1 ) , $SDELIMITER )
EndFunc
Func _FILELISTTOARRAYREC ( $SFILEPATH , $SMASK = "*" , $IRETURN = $FLTAR_FILESFOLDERS , $IRECUR = $FLTAR_NORECUR , $ISORT = $FLTAR_NOSORT , $IRETURNPATH = $FLTAR_RELPATH )
	If Not FileExists ( $SFILEPATH ) Then Return SetError ( 1 , 1 , "" )
	If $SMASK = Default Then $SMASK = "*"
	If $IRETURN = Default Then $IRETURN = $FLTAR_FILESFOLDERS
	If $IRECUR = Default Then $IRECUR = $FLTAR_NORECUR
	If $ISORT = Default Then $ISORT = $FLTAR_NOSORT
	If $IRETURNPATH = Default Then $IRETURNPATH = $FLTAR_RELPATH
	If $IRECUR > 1 Or Not IsInt ( $IRECUR ) Then Return SetError ( 1 , 6 , "" )
	Local $BLONGPATH = False
	If StringLeft ( $SFILEPATH , 4 ) == "\\?\" Then
		$BLONGPATH = True
	EndIf
	Local $SFOLDERSLASH = ""
	If StringRight ( $SFILEPATH , 1 ) = "\" Then
		$SFOLDERSLASH = "\"
	Else
		$SFILEPATH = $SFILEPATH & "\"
	EndIf
	Local $ASFOLDERSEARCHLIST [ 100 ] = [ 1 ]
	$ASFOLDERSEARCHLIST [ 1 ] = $SFILEPATH
	Local $IHIDE_HS = 0 , $SHIDE_HS = ""
	If BitAND ( $IRETURN , $FLTAR_NOHIDDEN ) Then
		$IHIDE_HS += 2
		$SHIDE_HS &= "H"
		$IRETURN -= $FLTAR_NOHIDDEN
	EndIf
	If BitAND ( $IRETURN , $FLTAR_NOSYSTEM ) Then
		$IHIDE_HS += 4
		$SHIDE_HS &= "S"
		$IRETURN -= $FLTAR_NOSYSTEM
	EndIf
	Local $IHIDE_LINK = 0
	If BitAND ( $IRETURN , $FLTAR_NOLINK ) Then
		$IHIDE_LINK = 1024
		$IRETURN -= $FLTAR_NOLINK
	EndIf
	Local $IMAXLEVEL = 0
	If $IRECUR < 0 Then
		StringReplace ( $SFILEPATH , "\" , "" , 0 , $STR_NOCASESENSEBASIC )
		$IMAXLEVEL = @extended - $IRECUR
	EndIf
	Local $SEXCLUDE_LIST = "" , $SEXCLUDE_LIST_FOLDER = "" , $SINCLUDE_LIST = "*"
	Local $AMASKSPLIT = StringSplit ( $SMASK , "|" )
	Switch $AMASKSPLIT [ 0 ]
	Case 3
		$SEXCLUDE_LIST_FOLDER = $AMASKSPLIT [ 3 ]
		ContinueCase
	Case 2
		$SEXCLUDE_LIST = $AMASKSPLIT [ 2 ]
		ContinueCase
	Case 1
		$SINCLUDE_LIST = $AMASKSPLIT [ 1 ]
	EndSwitch
	Local $SINCLUDE_FILE_MASK = ".+"
	If $SINCLUDE_LIST <> "*" Then
		If Not __FLTAR_LISTTOMASK ( $SINCLUDE_FILE_MASK , $SINCLUDE_LIST ) Then Return SetError ( 1 , 2 , "" )
	EndIf
	Local $SINCLUDE_FOLDER_MASK = ".+"
	Switch $IRETURN
	Case 0
		Switch $IRECUR
		Case 0
			$SINCLUDE_FOLDER_MASK = $SINCLUDE_FILE_MASK
		EndSwitch
	Case 2
		$SINCLUDE_FOLDER_MASK = $SINCLUDE_FILE_MASK
	EndSwitch
	Local $SEXCLUDE_FILE_MASK = ":"
	If $SEXCLUDE_LIST <> "" Then
		If Not __FLTAR_LISTTOMASK ( $SEXCLUDE_FILE_MASK , $SEXCLUDE_LIST ) Then Return SetError ( 1 , 3 , "" )
	EndIf
	Local $SEXCLUDE_FOLDER_MASK = ":"
	If $IRECUR Then
		If $SEXCLUDE_LIST_FOLDER Then
			If Not __FLTAR_LISTTOMASK ( $SEXCLUDE_FOLDER_MASK , $SEXCLUDE_LIST_FOLDER ) Then Return SetError ( 1 , 4 , "" )
		EndIf
		If $IRETURN = 2 Then
			$SEXCLUDE_FOLDER_MASK = $SEXCLUDE_FILE_MASK
		EndIf
	Else
		$SEXCLUDE_FOLDER_MASK = $SEXCLUDE_FILE_MASK
	EndIf
	If Not ( $IRETURN = 0 Or $IRETURN = 1 Or $IRETURN = 2 ) Then Return SetError ( 1 , 5 , "" )
	If Not ( $ISORT = 0 Or $ISORT = 1 Or $ISORT = 2 ) Then Return SetError ( 1 , 7 , "" )
	If Not ( $IRETURNPATH = 0 Or $IRETURNPATH = 1 Or $IRETURNPATH = 2 ) Then Return SetError ( 1 , 8 , "" )
	If $IHIDE_LINK Then
		Local $TFILE_DATA = DllStructCreate ( "struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct" )
		Local $HDLL = DllOpen ( "kernel32.dll" ) , $ADLL_RET
	EndIf
	Local $ASRETURNLIST [ 100 ] = [ 0 ]
	Local $ASFILEMATCHLIST = $ASRETURNLIST , $ASROOTFILEMATCHLIST = $ASRETURNLIST , $ASFOLDERMATCHLIST = $ASRETURNLIST
	Local $BFOLDER = False , $HSEARCH = 0 , $SCURRENTPATH = "" , $SNAME = "" , $SRETPATH = ""
	Local $IATTRIBS = 0 , $SATTRIBS = ""
	Local $ASFOLDERFILESECTIONLIST [ 100 ] [ 2 ] = [ [ 0 , 0 ] ]
	While $ASFOLDERSEARCHLIST [ 0 ] > 0
		$SCURRENTPATH = $ASFOLDERSEARCHLIST [ $ASFOLDERSEARCHLIST [ 0 ] ]
		$ASFOLDERSEARCHLIST [ 0 ] -= 1
		Switch $IRETURNPATH
		Case 1
			$SRETPATH = StringReplace ( $SCURRENTPATH , $SFILEPATH , "" )
		Case 2
			If $BLONGPATH Then
				$SRETPATH = StringTrimLeft ( $SCURRENTPATH , 4 )
			Else
				$SRETPATH = $SCURRENTPATH
			EndIf
		EndSwitch
		If $IHIDE_LINK Then
			$ADLL_RET = DllCall ( $HDLL , "handle" , "FindFirstFileW" , "wstr" , $SCURRENTPATH & "*" , "struct*" , $TFILE_DATA )
			If @error Or Not $ADLL_RET [ 0 ] Then
				ContinueLoop
			EndIf
			$HSEARCH = $ADLL_RET [ 0 ]
		Else
			$HSEARCH = FileFindFirstFile ( $SCURRENTPATH & "*" )
			If $HSEARCH = + 4294967295 Then
				ContinueLoop
			EndIf
		EndIf
		If $IRETURN = 0 And $ISORT And $IRETURNPATH Then
			__FLTAR_ADDTOLIST ( $ASFOLDERFILESECTIONLIST , $SRETPATH , $ASFILEMATCHLIST [ 0 ] + 1 )
		EndIf
		$SATTRIBS = ""
		While 1
			If $IHIDE_LINK Then
				$ADLL_RET = DllCall ( $HDLL , "int" , "FindNextFileW" , "handle" , $HSEARCH , "struct*" , $TFILE_DATA )
				If @error Or Not $ADLL_RET [ 0 ] Then
					ExitLoop
				EndIf
				$SNAME = DllStructGetData ( $TFILE_DATA , "FileName" )
				If $SNAME = ".." Or $SNAME = "." Then
					ContinueLoop
				EndIf
				$IATTRIBS = DllStructGetData ( $TFILE_DATA , "FileAttributes" )
				If $IHIDE_HS And BitAND ( $IATTRIBS , $IHIDE_HS ) Then
					ContinueLoop
				EndIf
				If BitAND ( $IATTRIBS , $IHIDE_LINK ) Then
					ContinueLoop
				EndIf
				$BFOLDER = False
				If BitAND ( $IATTRIBS , 16 ) Then
					$BFOLDER = True
				EndIf
			Else
				$BFOLDER = False
				$SNAME = FileFindNextFile ( $HSEARCH , 1 )
				If @error Then
					ExitLoop
				EndIf
				If $SNAME = ".." Or $SNAME = "." Then
					ContinueLoop
				EndIf
				$SATTRIBS = @extended
				If StringInStr ( $SATTRIBS , "D" ) Then
					$BFOLDER = True
				EndIf
				If StringRegExp ( $SATTRIBS , "[" & $SHIDE_HS & "]" ) Then
					ContinueLoop
				EndIf
			EndIf
			If $BFOLDER Then
				Select
				Case $IRECUR < 0
					StringReplace ( $SCURRENTPATH , "\" , "" , 0 , $STR_NOCASESENSEBASIC )
					If @extended < $IMAXLEVEL Then
						ContinueCase
					EndIf
				Case $IRECUR = 1
					If Not StringRegExp ( $SNAME , $SEXCLUDE_FOLDER_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASFOLDERSEARCHLIST , $SCURRENTPATH & $SNAME & "\" )
					EndIf
				EndSelect
			EndIf
			If $ISORT Then
				If $BFOLDER Then
					If StringRegExp ( $SNAME , $SINCLUDE_FOLDER_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FOLDER_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASFOLDERMATCHLIST , $SRETPATH & $SNAME & $SFOLDERSLASH )
					EndIf
				Else
					If StringRegExp ( $SNAME , $SINCLUDE_FILE_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FILE_MASK ) Then
						If $SCURRENTPATH = $SFILEPATH Then
							__FLTAR_ADDTOLIST ( $ASROOTFILEMATCHLIST , $SRETPATH & $SNAME )
						Else
							__FLTAR_ADDTOLIST ( $ASFILEMATCHLIST , $SRETPATH & $SNAME )
						EndIf
					EndIf
				EndIf
			Else
				If $BFOLDER Then
					If $IRETURN <> 1 And StringRegExp ( $SNAME , $SINCLUDE_FOLDER_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FOLDER_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASRETURNLIST , $SRETPATH & $SNAME & $SFOLDERSLASH )
					EndIf
				Else
					If $IRETURN <> 2 And StringRegExp ( $SNAME , $SINCLUDE_FILE_MASK ) And Not StringRegExp ( $SNAME , $SEXCLUDE_FILE_MASK ) Then
						__FLTAR_ADDTOLIST ( $ASRETURNLIST , $SRETPATH & $SNAME )
					EndIf
				EndIf
			EndIf
		WEnd
		If $IHIDE_LINK Then
			DllCall ( $HDLL , "int" , "FindClose" , "ptr" , $HSEARCH )
		Else
			FileClose ( $HSEARCH )
		EndIf
	WEnd
	If $IHIDE_LINK Then
		DllClose ( $HDLL )
	EndIf
	If $ISORT Then
		Switch $IRETURN
		Case 2
			If $ASFOLDERMATCHLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
			ReDim $ASFOLDERMATCHLIST [ $ASFOLDERMATCHLIST [ 0 ] + 1 ]
			$ASRETURNLIST = $ASFOLDERMATCHLIST
			__ARRAYDUALPIVOTSORT ( $ASRETURNLIST , 1 , $ASRETURNLIST [ 0 ] )
		Case 1
			If $ASROOTFILEMATCHLIST [ 0 ] = 0 And $ASFILEMATCHLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
			If $IRETURNPATH = 0 Then
				__FLTAR_ADDFILELISTS ( $ASRETURNLIST , $ASROOTFILEMATCHLIST , $ASFILEMATCHLIST )
				__ARRAYDUALPIVOTSORT ( $ASRETURNLIST , 1 , $ASRETURNLIST [ 0 ] )
			Else
				__FLTAR_ADDFILELISTS ( $ASRETURNLIST , $ASROOTFILEMATCHLIST , $ASFILEMATCHLIST , 1 )
			EndIf
		Case 0
			If $ASROOTFILEMATCHLIST [ 0 ] = 0 And $ASFOLDERMATCHLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
			If $IRETURNPATH = 0 Then
				__FLTAR_ADDFILELISTS ( $ASRETURNLIST , $ASROOTFILEMATCHLIST , $ASFILEMATCHLIST )
				$ASRETURNLIST [ 0 ] += $ASFOLDERMATCHLIST [ 0 ]
				ReDim $ASFOLDERMATCHLIST [ $ASFOLDERMATCHLIST [ 0 ] + 1 ]
				_ARRAYCONCATENATE ( $ASRETURNLIST , $ASFOLDERMATCHLIST , 1 )
				__ARRAYDUALPIVOTSORT ( $ASRETURNLIST , 1 , $ASRETURNLIST [ 0 ] )
			Else
				Local $ASRETURNLIST [ $ASFILEMATCHLIST [ 0 ] + $ASROOTFILEMATCHLIST [ 0 ] + $ASFOLDERMATCHLIST [ 0 ] + 1 ]
				$ASRETURNLIST [ 0 ] = $ASFILEMATCHLIST [ 0 ] + $ASROOTFILEMATCHLIST [ 0 ] + $ASFOLDERMATCHLIST [ 0 ]
				__ARRAYDUALPIVOTSORT ( $ASROOTFILEMATCHLIST , 1 , $ASROOTFILEMATCHLIST [ 0 ] )
				For $I = 1 To $ASROOTFILEMATCHLIST [ 0 ]
					$ASRETURNLIST [ $I ] = $ASROOTFILEMATCHLIST [ $I ]
				Next
				Local $INEXTINSERTIONINDEX = $ASROOTFILEMATCHLIST [ 0 ] + 1
				__ARRAYDUALPIVOTSORT ( $ASFOLDERMATCHLIST , 1 , $ASFOLDERMATCHLIST [ 0 ] )
				Local $SFOLDERTOFIND = ""
				For $I = 1 To $ASFOLDERMATCHLIST [ 0 ]
					$ASRETURNLIST [ $INEXTINSERTIONINDEX ] = $ASFOLDERMATCHLIST [ $I ]
					$INEXTINSERTIONINDEX += 1
					If $SFOLDERSLASH Then
						$SFOLDERTOFIND = $ASFOLDERMATCHLIST [ $I ]
					Else
						$SFOLDERTOFIND = $ASFOLDERMATCHLIST [ $I ] & "\"
					EndIf
					Local $IFILESECTIONENDINDEX = 0 , $IFILESECTIONSTARTINDEX = 0
					For $J = 1 To $ASFOLDERFILESECTIONLIST [ 0 ] [ 0 ]
						If $SFOLDERTOFIND = $ASFOLDERFILESECTIONLIST [ $J ] [ 0 ] Then
							$IFILESECTIONSTARTINDEX = $ASFOLDERFILESECTIONLIST [ $J ] [ 1 ]
							If $J = $ASFOLDERFILESECTIONLIST [ 0 ] [ 0 ] Then
								$IFILESECTIONENDINDEX = $ASFILEMATCHLIST [ 0 ]
							Else
								$IFILESECTIONENDINDEX = $ASFOLDERFILESECTIONLIST [ $J + 1 ] [ 1 ] + 4294967295
							EndIf
							If $ISORT = 1 Then
								__ARRAYDUALPIVOTSORT ( $ASFILEMATCHLIST , $IFILESECTIONSTARTINDEX , $IFILESECTIONENDINDEX )
							EndIf
							For $K = $IFILESECTIONSTARTINDEX To $IFILESECTIONENDINDEX
								$ASRETURNLIST [ $INEXTINSERTIONINDEX ] = $ASFILEMATCHLIST [ $K ]
								$INEXTINSERTIONINDEX += 1
							Next
							ExitLoop
						EndIf
					Next
				Next
			EndIf
		EndSwitch
	Else
		If $ASRETURNLIST [ 0 ] = 0 Then Return SetError ( 1 , 9 , "" )
		ReDim $ASRETURNLIST [ $ASRETURNLIST [ 0 ] + 1 ]
	EndIf
	Return $ASRETURNLIST
EndFunc
Func __FLTAR_ADDFILELISTS ( ByRef $ASTARGET , $ASSOURCE_1 , $ASSOURCE_2 , $ISORT = 0 )
	ReDim $ASSOURCE_1 [ $ASSOURCE_1 [ 0 ] + 1 ]
	If $ISORT = 1 Then __ARRAYDUALPIVOTSORT ( $ASSOURCE_1 , 1 , $ASSOURCE_1 [ 0 ] )
	$ASTARGET = $ASSOURCE_1
	$ASTARGET [ 0 ] += $ASSOURCE_2 [ 0 ]
	ReDim $ASSOURCE_2 [ $ASSOURCE_2 [ 0 ] + 1 ]
	If $ISORT = 1 Then __ARRAYDUALPIVOTSORT ( $ASSOURCE_2 , 1 , $ASSOURCE_2 [ 0 ] )
	_ARRAYCONCATENATE ( $ASTARGET , $ASSOURCE_2 , 1 )
EndFunc
Func __FLTAR_ADDTOLIST ( ByRef $ALIST , $VVALUE_0 , $VVALUE_1 = + 4294967295 )
	If $VVALUE_1 = + 4294967295 Then
		$ALIST [ 0 ] += 1
		If UBound ( $ALIST ) <= $ALIST [ 0 ] Then ReDim $ALIST [ UBound ( $ALIST ) * 2 ]
		$ALIST [ $ALIST [ 0 ] ] = $VVALUE_0
	Else
		$ALIST [ 0 ] [ 0 ] += 1
		If UBound ( $ALIST ) <= $ALIST [ 0 ] [ 0 ] Then ReDim $ALIST [ UBound ( $ALIST ) * 2 ] [ 2 ]
		$ALIST [ $ALIST [ 0 ] [ 0 ] ] [ 0 ] = $VVALUE_0
		$ALIST [ $ALIST [ 0 ] [ 0 ] ] [ 1 ] = $VVALUE_1
	EndIf
EndFunc
Func __FLTAR_LISTTOMASK ( ByRef $SMASK , $SLIST )
	If StringRegExp ( $SLIST , "\\|/|:|\<|\>|\|" ) Then Return 0
	$SLIST = StringReplace ( StringStripWS ( StringRegExpReplace ( $SLIST , "\s*;\s*" , ";" ) , BitOR ( $STR_STRIPLEADING , $STR_STRIPTRAILING ) ) , ";" , "|" )
	$SLIST = StringReplace ( StringReplace ( StringRegExpReplace ( $SLIST , "[][$^.{}()+\-]" , "\\$0" ) , "?" , "." ) , "*" , ".*?" )
	$SMASK = "(?i)^(" & $SLIST & ")\z"
	Return 1
EndFunc
Func _FILEPRINT ( $SFILEPATH , $ISHOW = @SW_HIDE )
	Return ShellExecute ( $SFILEPATH , "" , @WorkingDir , "print" , $ISHOW = Default ? @SW_HIDE : $ISHOW )
EndFunc
Func _FILEREADTOARRAY ( $SFILEPATH , ByRef $VRETURN , $IFLAGS = $FRTA_COUNT , $SDELIMITER = "" )
	$VRETURN = 0
	If $IFLAGS = Default Then $IFLAGS = $FRTA_COUNT
	If $SDELIMITER = Default Then $SDELIMITER = ""
	Local $BEXPAND = True
	If BitAND ( $IFLAGS , $FRTA_INTARRAYS ) Then
		$BEXPAND = False
		$IFLAGS -= $FRTA_INTARRAYS
	EndIf
	Local $IENTIRE = $STR_CHRSPLIT
	If BitAND ( $IFLAGS , $FRTA_ENTIRESPLIT ) Then
		$IENTIRE = $STR_ENTIRESPLIT
		$IFLAGS -= $FRTA_ENTIRESPLIT
	EndIf
	Local $INOCOUNT = 0
	If $IFLAGS <> $FRTA_COUNT Then
		$IFLAGS = $FRTA_NOCOUNT
		$INOCOUNT = $STR_NOCOUNT
	EndIf
	If $SDELIMITER Then
		Local $ALINES = FileReadToArray ( $SFILEPATH )
		If @error Then Return SetError ( @error , 0 , 0 )
		Local $IDIM_1 = UBound ( $ALINES ) + $IFLAGS
		If $BEXPAND Then
			Local $IDIM_2 = UBound ( StringSplit ( $ALINES [ 0 ] , $SDELIMITER , $IENTIRE + $STR_NOCOUNT ) )
			Local $ATEMP_ARRAY [ $IDIM_1 ] [ $IDIM_2 ]
			Local $IFIELDS , $ASPLIT
			For $I = 0 To $IDIM_1 - $IFLAGS + 4294967295
				$ASPLIT = StringSplit ( $ALINES [ $I ] , $SDELIMITER , $IENTIRE + $STR_NOCOUNT )
				$IFIELDS = UBound ( $ASPLIT )
				If $IFIELDS <> $IDIM_2 Then
					Return SetError ( 3 , 0 , 0 )
				EndIf
				For $J = 0 To $IFIELDS + 4294967295
					$ATEMP_ARRAY [ $I + $IFLAGS ] [ $J ] = $ASPLIT [ $J ]
				Next
			Next
			If $IDIM_2 < 2 Then Return SetError ( 4 , 0 , 0 )
			If $IFLAGS Then
				$ATEMP_ARRAY [ 0 ] [ 0 ] = $IDIM_1 - $IFLAGS
				$ATEMP_ARRAY [ 0 ] [ 1 ] = $IDIM_2
			EndIf
		Else
			Local $ATEMP_ARRAY [ $IDIM_1 ]
			For $I = 0 To $IDIM_1 - $IFLAGS + 4294967295
				$ATEMP_ARRAY [ $I + $IFLAGS ] = StringSplit ( $ALINES [ $I ] , $SDELIMITER , $IENTIRE + $INOCOUNT )
			Next
			If $IFLAGS Then
				$ATEMP_ARRAY [ 0 ] = $IDIM_1 - $IFLAGS
			EndIf
		EndIf
		$VRETURN = $ATEMP_ARRAY
	Else
		If $IFLAGS Then
			Local $HFILEOPEN = FileOpen ( $SFILEPATH , $FO_READ )
			If $HFILEOPEN = + 4294967295 Then Return SetError ( 1 , 0 , 0 )
			Local $SFILEREAD = FileRead ( $HFILEOPEN )
			FileClose ( $HFILEOPEN )
			If StringLen ( $SFILEREAD ) Then
				$VRETURN = StringRegExp ( @LF & $SFILEREAD , "(?|(\N+)\z|(\N*)(?:\R))" , $STR_REGEXPARRAYGLOBALMATCH )
				$VRETURN [ 0 ] = UBound ( $VRETURN ) + 4294967295
			Else
				Return SetError ( 2 , 0 , 0 )
			EndIf
		Else
			$VRETURN = FileReadToArray ( $SFILEPATH )
			If @error Then
				$VRETURN = 0
				Return SetError ( @error , 0 , 0 )
			EndIf
		EndIf
	EndIf
	Return 1
EndFunc
Func _FILEWRITEFROMARRAY ( $SFILEPATH , Const ByRef $AARRAY , $IBASE = Default , $IUBOUND = Default , $SDELIMITER = "|" )
	Local $IRETURN = 0
	If Not IsArray ( $AARRAY ) Then Return SetError ( 2 , 0 , $IRETURN )
	Local $IDIMS = UBound ( $AARRAY , $UBOUND_DIMENSIONS )
	If $IDIMS > 2 Then Return SetError ( 4 , 0 , 0 )
	Local $ILAST = UBound ( $AARRAY ) + 4294967295
	If $IUBOUND = Default Or $IUBOUND > $ILAST Then $IUBOUND = $ILAST
	If $IBASE < 0 Or $IBASE = Default Then $IBASE = 0
	If $IBASE > $IUBOUND Then Return SetError ( 5 , 0 , $IRETURN )
	If $SDELIMITER = Default Then $SDELIMITER = "|"
	Local $HFILEOPEN = $SFILEPATH
	If IsString ( $SFILEPATH ) Then
		$HFILEOPEN = FileOpen ( $SFILEPATH , $FO_OVERWRITE )
		If $HFILEOPEN = + 4294967295 Then Return SetError ( 1 , 0 , $IRETURN )
	EndIf
	Local $IERROR = 0
	$IRETURN = 1
	Switch $IDIMS
	Case 1
		For $I = $IBASE To $IUBOUND
			If Not FileWrite ( $HFILEOPEN , $AARRAY [ $I ] & @CRLF ) Then
				$IERROR = 3
				$IRETURN = 0
				ExitLoop
			EndIf
		Next
	Case 2
		Local $STEMP = ""
		For $I = $IBASE To $IUBOUND
			$STEMP = $AARRAY [ $I ] [ 0 ]
			For $J = 1 To UBound ( $AARRAY , $UBOUND_COLUMNS ) + 4294967295
				$STEMP &= $SDELIMITER & $AARRAY [ $I ] [ $J ]
			Next
			If Not FileWrite ( $HFILEOPEN , $STEMP & @CRLF ) Then
				$IERROR = 3
				$IRETURN = 0
				ExitLoop
			EndIf
		Next
	EndSwitch
	If IsString ( $SFILEPATH ) Then FileClose ( $HFILEOPEN )
	Return SetError ( $IERROR , 0 , $IRETURN )
EndFunc
Func _FILEWRITELOG ( $SLOGPATH , $SLOGMSG , $IFLAG = + 4294967295 )
	Local $IOPENMODE = $FO_APPEND
	Local $SMSG = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $SLOGMSG
	If $IFLAG = Default Then $IFLAG = + 4294967295
	If $IFLAG <> + 4294967295 Then
		$IOPENMODE = $FO_OVERWRITE
		$SMSG &= @CRLF & FileRead ( $SLOGPATH )
	EndIf
	Local $HFILEOPEN = $SLOGPATH
	If IsString ( $SLOGPATH ) Then $HFILEOPEN = FileOpen ( $SLOGPATH , $IOPENMODE )
	If $HFILEOPEN = + 4294967295 Then Return SetError ( 1 , 0 , 0 )
	Local $IRETURN = FileWriteLine ( $HFILEOPEN , $SMSG )
	If IsString ( $SLOGPATH ) Then $IRETURN = FileClose ( $HFILEOPEN )
	If $IFLAG <> + 4294967295 And Not IsString ( $SLOGPATH ) Then SetExtended ( 1 )
	If $IRETURN = 0 Then Return SetError ( 2 , 0 , 0 )
	Return $IRETURN
EndFunc
Func _FILEWRITETOLINE ( $SFILEPATH , $ILINE , $STEXT , $BOVERWRITE = False , $BFILL = False )
	If $BOVERWRITE = Default Then $BOVERWRITE = False
	If $BFILL = Default Then $BFILL = False
	If Not FileExists ( $SFILEPATH ) Then Return SetError ( 2 , 0 , 0 )
	If $ILINE <= 0 Then Return SetError ( 4 , 0 , 0 )
	If Not ( IsBool ( $BOVERWRITE ) Or $BOVERWRITE = 0 Or $BOVERWRITE = 1 ) Then Return SetError ( 5 , 0 , 0 )
	If Not IsString ( $STEXT ) Then
		$STEXT = String ( $STEXT )
		If $STEXT = "" Then Return SetError ( 6 , 0 , 0 )
	EndIf
	If Not IsBool ( $BFILL ) Then Return SetError ( 7 , 0 , 0 )
	Local $AARRAY = FileReadToArray ( $SFILEPATH )
	If @error Then Local $AARRAY [ 0 ]
	Local $IUBOUND = UBound ( $AARRAY ) + 4294967295
	If $BFILL Then
		If $IUBOUND < $ILINE Then
			ReDim $AARRAY [ $ILINE ]
			$IUBOUND = $ILINE + 4294967295
		EndIf
	Else
		If ( $IUBOUND + 1 ) < $ILINE Then Return SetError ( 1 , 0 , 0 )
	EndIf
	$AARRAY [ $ILINE + 4294967295 ] = ( $BOVERWRITE ? $STEXT : $STEXT & @CRLF & $AARRAY [ $ILINE + 4294967295 ] )
	Local $SDATA = ""
	For $I = 0 To $IUBOUND
		$SDATA &= $AARRAY [ $I ] & @CRLF
	Next
	$SDATA = StringTrimRight ( $SDATA , StringLen ( @CRLF ) )
	Local $HFILEOPEN = FileOpen ( $SFILEPATH , FileGetEncoding ( $SFILEPATH ) + $FO_OVERWRITE )
	If $HFILEOPEN = + 4294967295 Then Return SetError ( 3 , 0 , 0 )
	FileWrite ( $HFILEOPEN , $SDATA )
	FileClose ( $HFILEOPEN )
	Return 1
EndFunc
Func _PATHFULL ( $SRELATIVEPATH , $SBASEPATH = @WorkingDir )
	If Not $SRELATIVEPATH Or $SRELATIVEPATH = "." Then Return $SBASEPATH
	Local $SFULLPATH = StringReplace ( $SRELATIVEPATH , "/" , "\" )
	Local Const $SFULLPATHCONST = $SFULLPATH
	Local $SPATH
	Local $BROOTONLY = StringLeft ( $SFULLPATH , 1 ) = "\" And StringMid ( $SFULLPATH , 2 , 1 ) <> "\"
	If $SBASEPATH = Default Then $SBASEPATH = @WorkingDir
	For $I = 1 To 2
		$SPATH = StringLeft ( $SFULLPATH , 2 )
		If $SPATH = "\\" Then
			$SFULLPATH = StringTrimLeft ( $SFULLPATH , 2 )
			Local $NSERVERLEN = StringInStr ( $SFULLPATH , "\" ) + 4294967295
			$SPATH = "\\" & StringLeft ( $SFULLPATH , $NSERVERLEN )
			$SFULLPATH = StringTrimLeft ( $SFULLPATH , $NSERVERLEN )
			ExitLoop
		ElseIf StringRight ( $SPATH , 1 ) = ":" Then
			$SFULLPATH = StringTrimLeft ( $SFULLPATH , 2 )
			ExitLoop
		Else
			$SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
		EndIf
	Next
	If StringLeft ( $SFULLPATH , 1 ) <> "\" Then
		If StringLeft ( $SFULLPATHCONST , 2 ) = StringLeft ( $SBASEPATH , 2 ) Then
			$SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
		Else
			$SFULLPATH = "\" & $SFULLPATH
		EndIf
	EndIf
	Local $ATEMP = StringSplit ( $SFULLPATH , "\" )
	Local $APATHPARTS [ $ATEMP [ 0 ] ] , $J = 0
	For $I = 2 To $ATEMP [ 0 ]
		If $ATEMP [ $I ] = ".." Then
			If $J Then $J -= 1
		ElseIf Not ( $ATEMP [ $I ] = "" And $I <> $ATEMP [ 0 ] ) And $ATEMP [ $I ] <> "." Then
			$APATHPARTS [ $J ] = $ATEMP [ $I ]
			$J += 1
		EndIf
	Next
	$SFULLPATH = $SPATH
	If Not $BROOTONLY Then
		For $I = 0 To $J + 4294967295
			$SFULLPATH &= "\" & $APATHPARTS [ $I ]
		Next
	Else
		$SFULLPATH &= $SFULLPATHCONST
		If StringInStr ( $SFULLPATH , ".." ) Then $SFULLPATH = _PATHFULL ( $SFULLPATH )
	EndIf
	Do
		$SFULLPATH = StringReplace ( $SFULLPATH , ".\" , "\" )
	Until @extended = 0
	Return $SFULLPATH
EndFunc
Func _PATHGETRELATIVE ( $SFROM , $STO )
	If StringRight ( $SFROM , 1 ) <> "\" Then $SFROM &= "\"
	If StringRight ( $STO , 1 ) <> "\" Then $STO &= "\"
	If $SFROM = $STO Then Return SetError ( 1 , 0 , StringTrimRight ( $STO , 1 ) )
	Local $ASFROM = StringSplit ( $SFROM , "\" )
	Local $ASTO = StringSplit ( $STO , "\" )
	If $ASFROM [ 1 ] <> $ASTO [ 1 ] Then Return SetError ( 2 , 0 , StringTrimRight ( $STO , 1 ) )
	Local $I = 2
	Local $IDIFF = 1
	While 1
		If $ASFROM [ $I ] <> $ASTO [ $I ] Then
			$IDIFF = $I
			ExitLoop
		EndIf
		$I += 1
	WEnd
	$I = 1
	Local $SRELPATH = ""
	For $J = 1 To $ASTO [ 0 ]
		If $I >= $IDIFF Then
			$SRELPATH &= "\" & $ASTO [ $I ]
		EndIf
		$I += 1
	Next
	$SRELPATH = StringTrimLeft ( $SRELPATH , 1 )
	$I = 1
	For $J = 1 To $ASFROM [ 0 ]
		If $I > $IDIFF Then
			$SRELPATH = "..\" & $SRELPATH
		EndIf
		$I += 1
	Next
	If StringRight ( $SRELPATH , 1 ) == "\" Then $SRELPATH = StringTrimRight ( $SRELPATH , 1 )
	Return $SRELPATH
EndFunc
Func _PATHMAKE ( $SDRIVE , $SDIR , $SFILENAME , $SEXTENSION )
	If StringLen ( $SDRIVE ) Then
		If Not ( StringLeft ( $SDRIVE , 2 ) = "\\" ) Then $SDRIVE = StringLeft ( $SDRIVE , 1 ) & ":"
	EndIf
	If StringLen ( $SDIR ) Then
		If Not ( StringRight ( $SDIR , 1 ) = "\" ) And Not ( StringRight ( $SDIR , 1 ) = "/" ) Then $SDIR = $SDIR & "\"
	Else
		$SDIR = "\"
	EndIf
	If StringLen ( $SDIR ) Then
		If Not ( StringLeft ( $SDIR , 1 ) = "\" ) And Not ( StringLeft ( $SDIR , 1 ) = "/" ) Then $SDIR = "\" & $SDIR
	EndIf
	If StringLen ( $SEXTENSION ) Then
		If Not ( StringLeft ( $SEXTENSION , 1 ) = "." ) Then $SEXTENSION = "." & $SEXTENSION
	EndIf
	Return $SDRIVE & $SDIR & $SFILENAME & $SEXTENSION
EndFunc
Func _PATHSPLIT ( $SFILEPATH , ByRef $SDRIVE , ByRef $SDIR , ByRef $SFILENAME , ByRef $SEXTENSION )
	Local $AARRAY = StringRegExp ( $SFILEPATH , "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$" , $STR_REGEXPARRAYMATCH )
	If @error Then
		ReDim $AARRAY [ 5 ]
		$AARRAY [ $PATH_ORIGINAL ] = $SFILEPATH
	EndIf
	$SDRIVE = $AARRAY [ $PATH_DRIVE ]
	If StringLeft ( $AARRAY [ $PATH_DIRECTORY ] , 1 ) == "/" Then
		$SDIR = StringRegExpReplace ( $AARRAY [ $PATH_DIRECTORY ] , "\h*[\/\\]+\h*" , "\/" )
	Else
		$SDIR = StringRegExpReplace ( $AARRAY [ $PATH_DIRECTORY ] , "\h*[\/\\]+\h*" , "\\" )
	EndIf
	$AARRAY [ $PATH_DIRECTORY ] = $SDIR
	$SFILENAME = $AARRAY [ $PATH_FILENAME ]
	$SEXTENSION = $AARRAY [ $PATH_EXTENSION ]
	Return $AARRAY
EndFunc
Func _REPLACESTRINGINFILE ( $SFILEPATH , $SSEARCHSTRING , $SREPLACESTRING , $ICASESENSITIVE = 0 , $IOCCURANCE = 1 )
	If StringInStr ( FileGetAttrib ( $SFILEPATH ) , "R" ) Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $HFILEOPEN = FileOpen ( $SFILEPATH , $FO_READ )
	If $HFILEOPEN = + 4294967295 Then Return SetError ( 2 , 0 , + 4294967295 )
	Local $SFILEREAD = FileRead ( $HFILEOPEN )
	FileClose ( $HFILEOPEN )
	If $ICASESENSITIVE = Default Then $ICASESENSITIVE = 0
	If $IOCCURANCE = Default Then $IOCCURANCE = 1
	$SFILEREAD = StringReplace ( $SFILEREAD , $SSEARCHSTRING , $SREPLACESTRING , 1 - $IOCCURANCE , $ICASESENSITIVE )
	Local $IRETURN = @extended
	If $IRETURN Then
		Local $IFILEENCODING = FileGetEncoding ( $SFILEPATH )
		$HFILEOPEN = FileOpen ( $SFILEPATH , $IFILEENCODING + $FO_OVERWRITE )
		If $HFILEOPEN = + 4294967295 Then Return SetError ( 3 , 0 , + 4294967295 )
		FileWrite ( $HFILEOPEN , $SFILEREAD )
		FileClose ( $HFILEOPEN )
	EndIf
	Return $IRETURN
EndFunc
Func _TEMPFILE ( $SDIRECTORYNAME = @TempDir , $SFILEPREFIX = "~" , $SFILEEXTENSION = ".tmp" , $IRANDOMLENGTH = 7 )
	If $IRANDOMLENGTH = Default Or $IRANDOMLENGTH <= 0 Then $IRANDOMLENGTH = 7
	If $SDIRECTORYNAME = Default Or ( Not FileExists ( $SDIRECTORYNAME ) ) Then $SDIRECTORYNAME = @TempDir
	If $SFILEEXTENSION = Default Then $SFILEEXTENSION = ".tmp"
	If $SFILEPREFIX = Default Then $SFILEPREFIX = "~"
	If Not FileExists ( $SDIRECTORYNAME ) Then $SDIRECTORYNAME = @ScriptDir
	$SDIRECTORYNAME = StringRegExpReplace ( $SDIRECTORYNAME , "[\\/]+$" , "" )
	$SFILEEXTENSION = StringRegExpReplace ( $SFILEEXTENSION , "^\.+" , "" )
	$SFILEPREFIX = StringRegExpReplace ( $SFILEPREFIX , "[\\/:*?""<>|]" , "" )
	Local $STEMPNAME = ""
	Do
		$STEMPNAME = ""
		While StringLen ( $STEMPNAME ) < $IRANDOMLENGTH
			$STEMPNAME &= Chr ( Random ( 97 , 122 , 1 ) )
		WEnd
		$STEMPNAME = $SDIRECTORYNAME & "\" & $SFILEPREFIX & $STEMPNAME & "." & $SFILEEXTENSION
	Until Not FileExists ( $STEMPNAME )
	Return $STEMPNAME
EndFunc
TCPStartup ( )
OnAutoItExitRegister ( "__Android_OnExit" )
Func _ANDROID_CONNECT ( )
	Local $ISOCKET = TCPConnect ( "127.0.0.1" , 5037 )
	Return SetError ( @error , 0 , $ISOCKET )
EndFunc
Func _ANDROID_SHUTDOWN ( $ISOCKET )
	TCPCloseSocket ( $ISOCKET )
EndFunc
Func _ANDROID_SEND ( $ISOCKET , $SCOMMAND )
	Local $VDATA = __SEND ( $ISOCKET , Hex ( StringLen ( $SCOMMAND ) , 4 ) & $SCOMMAND )
	Return SetError ( @error , 0 , $VDATA )
EndFunc
Func _ANDROID_SEND_COMMAND ( $ISOCKET , $SCOMMAND )
	Local $VDATA = __SEND_COMMAND ( $ISOCKET , Hex ( StringLen ( $SCOMMAND ) , 4 ) & $SCOMMAND )
	Return SetError ( @error , 0 , $VDATA )
EndFunc
Func _ANDROID_SYNC ( $ISOCKET , $SCOMMAND , $SDATA )
	Local $VDATA = _ANDROID_SEND ( $ISOCKET , "sync:" )
	If @error Then Return SetError ( @error , 0 , $VDATA )
	If StringLeft ( $VDATA , 4 ) = "FAIL" Then Return $VDATA
	__SEND ( $ISOCKET , $SCOMMAND )
	__SEND ( $ISOCKET , "0x" & Hex ( _WINAPI_SWAPDWORD ( StringLen ( $SDATA ) ) , 8 ) )
	$VDATA = __SEND ( $ISOCKET , $SDATA )
	Return SetError ( @error , 0 , $VDATA )
EndFunc
Func _ANDROID_FILELISTTOARRAY ( $ISOCKET , $SFILEPATH )
	Local $SDELIMITER = ":" , $SFILELIST = "" , $IFILEMODE , $IFILESIZE , $ILASTMODIFIEDTIME , $IFILENAMELENGTH , $SFILENAME
	Local $VDATA = _ANDROID_SYNC ( $ISOCKET , "LIST" , $SFILEPATH )
	If @error Then Return SetError ( @error , 0 , $VDATA )
	Local $I = 1
	While BinaryToString ( BinaryMid ( $VDATA , $I , 4 ) ) <> "DONE"
		$IFILEMODE = Int ( BinaryMid ( $VDATA , $I + 4 , 4 ) )
		$IFILESIZE = Int ( BinaryMid ( $VDATA , $I + 8 , 4 ) )
		$ILASTMODIFIEDTIME = Int ( BinaryMid ( $VDATA , $I + 12 , 4 ) )
		$IFILENAMELENGTH = Int ( BinaryMid ( $VDATA , $I + 16 , 4 ) )
		$SFILENAME = BinaryToString ( BinaryMid ( $VDATA , $I + 20 , $IFILENAMELENGTH ) )
		$SFILELIST &= $SDELIMITER & $SFILENAME & "|" & $ILASTMODIFIEDTIME & "|" & $IFILEMODE & "|" & $IFILESIZE
		$I += $IFILENAMELENGTH + 20
	WEnd
	Return StringSplit ( StringTrimLeft ( $SFILELIST , 1 ) , $SDELIMITER )
EndFunc
Func __ANDROID_ONEXIT ( )
	TCPShutdown ( )
EndFunc
Func __SEND ( $ISOCKET , $SCOMMAND )
	TCPSend ( $ISOCKET , $SCOMMAND )
	If @error Then SetError ( 1 , 0 , "" )
	Local $VDATA = TCPRecv ( $ISOCKET , 1024 * 64 )
	If @error Then SetError ( 2 , 0 , "" )
	Return $VDATA
EndFunc
Func __SEND_COMMAND ( $ISOCKET , $SCOMMAND )
	TCPSend ( $ISOCKET , $SCOMMAND )
	If @error Then SetError ( 1 , 0 , "" )
	Local $VDATA = TCPRecv ( $ISOCKET , 4 )
	If @error Then SetError ( 2 , 0 , "" )
	Return $VDATA
EndFunc
Global Const $__COLORCONSTANTS_HMAX = 360
Global Const $__COLORCONSTANTS_SLMAX = 100
Global Const $__COLORCONSTANTS_RGBMAX = 255
Func _COLORCONVERTHSLTORGB ( $AARRAY )
	If UBound ( $AARRAY ) <> 3 Or UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 1 , 0 , 0 )
	Local $NR , $NG , $NB
	Local $NH = Number ( $AARRAY [ 0 ] ) / $__COLORCONSTANTS_HMAX
	Local $NS = Number ( $AARRAY [ 1 ] ) / $__COLORCONSTANTS_SLMAX
	Local $NL = Number ( $AARRAY [ 2 ] ) / $__COLORCONSTANTS_SLMAX
	If $NS = 0 Then
		$NR = $NL
		$NG = $NL
		$NB = $NL
	Else
		Local $NVALA , $NVALB
		If $NL <= 0.5 Then
			$NVALB = $NL * ( $NS + 1 )
		Else
			$NVALB = ( $NL + $NS ) - ( $NL * $NS )
		EndIf
		$NVALA = 2 * $NL - $NVALB
		$NR = __COLORCONVERTHUETORGB ( $NVALA , $NVALB , $NH + 1 / 3 )
		$NG = __COLORCONVERTHUETORGB ( $NVALA , $NVALB , $NH )
		$NB = __COLORCONVERTHUETORGB ( $NVALA , $NVALB , $NH + 4294967295 / 3 )
	EndIf
	$AARRAY [ 0 ] = $NR * $__COLORCONSTANTS_RGBMAX
	$AARRAY [ 1 ] = $NG * $__COLORCONSTANTS_RGBMAX
	$AARRAY [ 2 ] = $NB * $__COLORCONSTANTS_RGBMAX
	Return $AARRAY
EndFunc
Func __COLORCONVERTHUETORGB ( $NA , $NB , $NH )
	If $NH < 0 Then $NH += 1
	If $NH > 1 Then $NH -= 1
	If ( 6 * $NH ) < 1 Then Return $NA + ( $NB - $NA ) * 6 * $NH
	If ( 2 * $NH ) < 1 Then Return $NB
	If ( 3 * $NH ) < 2 Then Return $NA + ( $NB - $NA ) * 6 * ( 2 / 3 - $NH )
	Return $NA
EndFunc
Func _COLORCONVERTRGBTOHSL ( $AARRAY )
	If UBound ( $AARRAY ) <> 3 Or UBound ( $AARRAY , $UBOUND_DIMENSIONS ) <> 1 Then Return SetError ( 1 , 0 , 0 )
	Local $NH , $NS , $NL
	Local $NR = Number ( $AARRAY [ 0 ] ) / $__COLORCONSTANTS_RGBMAX
	Local $NG = Number ( $AARRAY [ 1 ] ) / $__COLORCONSTANTS_RGBMAX
	Local $NB = Number ( $AARRAY [ 2 ] ) / $__COLORCONSTANTS_RGBMAX
	Local $NMAX = $NR
	If $NMAX < $NG Then $NMAX = $NG
	If $NMAX < $NB Then $NMAX = $NB
	Local $NMIN = $NR
	If $NMIN > $NG Then $NMIN = $NG
	If $NMIN > $NB Then $NMIN = $NB
	Local $NMINMAXSUM = ( $NMAX + $NMIN )
	Local $NMINMAXDIFF = ( $NMAX - $NMIN )
	$NL = $NMINMAXSUM / 2
	If $NMINMAXDIFF = 0 Then
		$NH = 0
		$NS = 0
	Else
		If $NL < 0.5 Then
			$NS = $NMINMAXDIFF / $NMINMAXSUM
		Else
			$NS = $NMINMAXDIFF / ( 2 - $NMINMAXSUM )
		EndIf
		Switch $NMAX
		Case $NR
			$NH = ( $NG - $NB ) / ( 6 * $NMINMAXDIFF )
		Case $NG
			$NH = ( $NB - $NR ) / ( 6 * $NMINMAXDIFF ) + 1 / 3
		Case $NB
			$NH = ( $NR - $NG ) / ( 6 * $NMINMAXDIFF ) + 2 / 3
		EndSwitch
		If $NH < 0 Then $NH += 1
		If $NH > 1 Then $NH -= 1
	EndIf
	$AARRAY [ 0 ] = $NH * $__COLORCONSTANTS_HMAX
	$AARRAY [ 1 ] = $NS * $__COLORCONSTANTS_SLMAX
	$AARRAY [ 2 ] = $NL * $__COLORCONSTANTS_SLMAX
	Return $AARRAY
EndFunc
Func _COLORGETBLUE ( $ICOLOR )
	Return BitAND ( $ICOLOR , 255 )
EndFunc
Func _COLORGETGREEN ( $ICOLOR )
	Return BitAND ( BitShift ( $ICOLOR , 8 ) , 255 )
EndFunc
Func _COLORGETRED ( $ICOLOR )
	Return BitAND ( BitShift ( $ICOLOR , 16 ) , 255 )
EndFunc
Func _COLORGETCOLORREF ( $ICOLOR , Const $_ICALLEREXTENDED = @extended )
	If BitAND ( $ICOLOR , 4278190080 ) Then Return SetError ( 1 , 0 , 0 )
	Local $ACOLOR [ 3 ]
	$ACOLOR [ 2 ] = BitAND ( BitShift ( $ICOLOR , 16 ) , 255 )
	$ACOLOR [ 1 ] = BitAND ( BitShift ( $ICOLOR , 8 ) , 255 )
	$ACOLOR [ 0 ] = BitAND ( $ICOLOR , 255 )
	Return SetExtended ( $_ICALLEREXTENDED , $ACOLOR )
EndFunc
Func _COLORGETRGB ( $ICOLOR , Const $_ICALLEREXTENDED = @extended )
	If BitAND ( $ICOLOR , 4278190080 ) Then Return SetError ( 1 , 0 , 0 )
	Local $ACOLOR [ 3 ]
	$ACOLOR [ 0 ] = BitAND ( BitShift ( $ICOLOR , 16 ) , 255 )
	$ACOLOR [ 1 ] = BitAND ( BitShift ( $ICOLOR , 8 ) , 255 )
	$ACOLOR [ 2 ] = BitAND ( $ICOLOR , 255 )
	Return SetExtended ( $_ICALLEREXTENDED , $ACOLOR )
EndFunc
Func _COLORSETCOLORREF ( $ACOLOR , Const $_ICALLEREXTENDED = @extended )
	If UBound ( $ACOLOR ) <> 3 Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $ICOLOR = 0 , $ICOLORI
	For $I = 2 To 0 Step + 4294967295
		$ICOLOR = BitShift ( $ICOLOR , + 4294967288 )
		$ICOLORI = $ACOLOR [ $I ]
		If $ICOLORI < 0 Or $ICOLORI > 255 Then Return SetError ( 2 , $I , + 4294967295 )
		$ICOLOR += $ICOLORI
	Next
	Return SetExtended ( $_ICALLEREXTENDED , $ICOLOR )
EndFunc
Func _COLORSETRGB ( $ACOLOR , Const $_ICALLEREXTENDED = @extended )
	If UBound ( $ACOLOR ) <> 3 Then Return SetError ( 1 , 0 , + 4294967295 )
	Local $ICOLOR = 0 , $ICOLORI
	For $I = 0 To 2
		$ICOLOR = BitShift ( $ICOLOR , + 4294967288 )
		$ICOLORI = $ACOLOR [ $I ]
		If $ICOLORI < 0 Or $ICOLORI > 255 Then Return SetError ( 2 , 0 , + 4294967295 )
		$ICOLOR += $ICOLORI
	Next
	Return SetExtended ( $_ICALLEREXTENDED , $ICOLOR )
EndFunc
$CURRFUNCNAME = "_IsChecked"
Func KILLEMULATOR ( )
	$CURRFUNCNAME = "KillEmulator"
	LOGINFO ( "Trying to kill emulator" )
	If $EMULATORPID > 0 Then RunWait ( @ComSpec & " /c TaskKill /PID " & $EMULATORPID & " /F" )
EndFunc
Func LONGMOUSECLICK ( $BUTTON , $X , $Y , $CLICKS , $SPEED )
	$CURRFUNCNAME = "LongMouseClick"
	If ( $X < $XBASE ) Or ( $X > $XBASE + $XWIDTH ) Or ( $Y < $YBASE ) Or ( $Y > $YBASE + $YHEIGHT ) Then
		LOGINFO ( "!!MISSCLICK: x=" & $X & " y=" & $Y )
	Else
		MouseMove ( $X , $Y , 0 )
		MouseDown ( $BUTTON )
		Sleep ( Random ( 200 , 300 , 1 ) )
		MouseUp ( $BUTTON )
	EndIf
EndFunc
Func MOUSEMOVES ( $X , $Y )
	$CURRFUNCNAME = "MouseMoveS"
	MouseMove ( $X , $Y , Random ( 0 , 2 , 1 ) )
EndFunc
Func KILLEVE ( )
	$CURRFUNCNAME = "KillEve"
	Local $ANSW
	LOGINFO ( "Start ADB KillEve" )
	$ANSW = SENDADB ( " shell am force-stop com.netease.eve.en" )
	LOGINFO ( "ADB devices Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
	LOGINFO ( "Stop ADB KillEve" )
EndFunc
Func CHECKFORNEWVERSION ( )
	Return 0
EndFunc
Func _STRINGCOMPAREVERSIONS ( $S_VERSION1 , $S_VERSION2 = "0.0.0.0" )
	$CURRFUNCNAME = "_StringCompareVersions"
	SetError ( ( StringIsDigit ( StringReplace ( $S_VERSION1 , "." , "" ) ) = 0 ) + 2 * ( StringIsDigit ( StringReplace ( $S_VERSION2 , "." , "" ) ) = 0 ) )
	If @error > 0 Then Return 0
	Local $I_INDEX , $I_RESULT , $AI_VERSION1 , $AI_VERSION2
	$AI_VERSION1 = StringSplit ( $S_VERSION1 , "." )
	$AI_VERSION2 = StringSplit ( $S_VERSION2 , "." )
	$I_RESULT = 0
	If $AI_VERSION1 [ 0 ] <> 4 Then ReDim $AI_VERSION1 [ 5 ]
	For $I_INDEX = 1 To 4
		$AI_VERSION1 [ $I_INDEX ] = Int ( $AI_VERSION1 [ $I_INDEX ] )
	Next
	If $AI_VERSION2 [ 0 ] <> 4 Then ReDim $AI_VERSION2 [ 5 ]
	For $I_INDEX = 1 To 4
		$AI_VERSION2 [ $I_INDEX ] = Int ( $AI_VERSION2 [ $I_INDEX ] )
	Next
	For $I_INDEX = 1 To 4
		If $AI_VERSION1 [ $I_INDEX ] < $AI_VERSION2 [ $I_INDEX ] Then
			$I_RESULT = + 4294967295
		ElseIf $AI_VERSION1 [ $I_INDEX ] > $AI_VERSION2 [ $I_INDEX ] Then
			$I_RESULT = 1
		EndIf
		If $I_RESULT <> 0 Then ExitLoop
	Next
	Return $I_RESULT
EndFunc
Func _WINAPI_DRAWRECT ( $START_X , $START_Y , $IWIDTH , $IHEIGHT , $ICOLOR )
	$CURRFUNCNAME = "_WinAPI_DrawRect"
	Local $HDC = _WINAPI_GETWINDOWDC ( 0 )
	$TRECT = DllStructCreate ( $TAGRECT )
	DllStructSetData ( $TRECT , 1 , $START_X )
	DllStructSetData ( $TRECT , 2 , $START_Y )
	DllStructSetData ( $TRECT , 3 , $IWIDTH )
	DllStructSetData ( $TRECT , 4 , $IHEIGHT )
	Local $HBRUSH = _WINAPI_CREATESOLIDBRUSH ( $ICOLOR )
	_WINAPI_FRAMERECT ( $HDC , DllStructGetPtr ( $TRECT ) , $HBRUSH )
	_WINAPI_DELETEOBJECT ( $HBRUSH )
	_WINAPI_RELEASEDC ( 0 , $HDC )
EndFunc
Global $TRECT
Func FILECONSOLEWRITE ( $STRING , $RAW = 0 )
	$CURRFUNCNAME = "FileConsoleWrite"
	Local $COLOR
	If Not $RAW Then
		$COLOR = StringLeft ( $STRING , 1 )
		If $COLOR = ">" Or $COLOR = "+" Or $COLOR = "-" Then
			$STRING = $COLOR & @HOUR & ":" & @MIN & ":" & @SEC & ":" & @MSEC & " >> " & $STRING
		ElseIf $COLOR = "*" Then
			$STRING = StringTrimLeft ( $STRING , 1 )
		Else
			$STRING = @HOUR & ":" & @MIN & ":" & @SEC & ":" & @MSEC & " >> " & $STRING
		EndIf
	EndIf
	ConsoleWrite ( $STRING )
EndFunc
Func _COLORINBOUNDS ( $PMCOLOR , $PTCOLOR , $PVARIATION )
	$CURRFUNCNAME = "_ColorInBounds"
	$LMCBLUE = _COLORGETBLUE ( $PMCOLOR )
	$LMCGREEN = _COLORGETGREEN ( $PMCOLOR )
	$LMCRED = _COLORGETRED ( $PMCOLOR )
	$LTCBLUE = _COLORGETBLUE ( $PTCOLOR )
	$LTCGREEN = _COLORGETGREEN ( $PTCOLOR )
	$LTCRED = _COLORGETRED ( $PTCOLOR )
	$A = Abs ( $LMCBLUE - $LTCBLUE )
	$B = Abs ( $LMCGREEN - $LTCGREEN )
	$C = Abs ( $LMCRED - $LTCRED )
	If ( ( $A < $PVARIATION ) And ( $B < $PVARIATION ) And ( $C < $PVARIATION ) ) Then
		Return 1
	Else
		Return 0
	EndIf
EndFunc
Func INJECTADB ( $VER = "" )
	$CURRFUNCNAME = "InjectADB"
	Local $ANSW
	If $VER <> 28 Then $VER = ""
	$ANSW = SENDADB ( " push " & @ScriptDir & "\adb\ascreencap" & $VER & " /data/local/tmp/ascreencap" )
	$ANSW = SENDADB ( " shell chmod 0777 /data/local/tmp/ascreencap" )
EndFunc
Func GETSAVEDID ( )
	$CURRFUNCNAME = "GetSavedId"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func TESTADB ( )
	$CURRFUNCNAME = "testAdb"
	Local $ANSW
	Local $IDS = 0
	LOGINFO ( "Start ADB test" )
	If $ADB_TESTPASSED = 1 Then
		LOGINFO ( "Already completed" )
		Return
	EndIf
	GUICtrlSetData ( $LABEL_ADBSTATUS , "ADB status: checking" )
	Local $PREVDOING = SETDOINGSTATUS ( "Preparing ADB" )
	$ANSW = SENDADB ( " devices" )
	If $ADBTRANSPORTSERIAL = 0 Then
		If Not StringInStr ( $ANSW , "emulator" ) Then
			$ANSW = SENDADB ( " kill-server" )
			$ANSW = SENDADB ( " start-server" )
			$ANSW = SENDADB ( " wait-for-device" )
			LOGINFO ( "ADB wait-for-device Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
		EndIf
	EndIf
	LOGINFO ( "ADB wait-for-device Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
	If StringLen ( $ANSW ) = 0 Or StringInStr ( $ANSW , "daemon started successfully" ) Then
		$ANSW = SENDADB ( " devices" )
		LOGINFO ( "ADB devices Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
		$ANSW = StringReplace ( $ANSW , @CR , "" )
		$ANSW = StringReplace ( $ANSW , @LF , "" )
		$ANSW = StringReplace ( $ANSW , "List of devices attached" , "" )
		LOGINFO ( "ADB Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
		GUICtrlSetData ( $LABEL_ADBSTATUS , "ADB status: " & $ANSW )
	EndIf
	$ANSW = SENDADB ( " shell rm -rf /data/local/tmp/!(pid)" )
	LOGINFO ( "Get Versions:" )
	$SDKVER = Number ( SENDADB ( " shell getprop ro.build.version.sdk" ) )
	LOGINFO ( "$SDKVer:" & $SDKVER )
	If $SDKVER = 28 Then LOGINFO ( "LOLOLOLOL 28" )
	If $SDKVER < 28 Then $SDKVER = ""
	$CPUABL = SENDADB ( " shell getprop  ro.vendor.product.cpu.abilist" )
	LOGINFO ( "$CPUAbl:" & $CPUABL )
	$ANSW = SENDADB ( " shell find /data/local/tmp/pid -type f -mtime +1 -delete" )
	LOGINFO ( "ADB shell ls Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
	LOGINFO ( "Prepare screencap" )
	INJECTADB ( $SDKVER )
	LOGINFO ( "Push files" )
	SENDADB ( " push " & @ScriptDir & "\adb\push\ /data/local/tmp/" )
	SENDADB ( " shell mv /data/local/tmp/push/* /data/local/tmp/" )
	SENDADB ( " shell chmod -R 0777 /data/local/tmp/" )
	LOGINFO ( "Push files" )
	$ANSW = SENDADB ( " shell ""ps | grep netease | tr -s " & "' '" & " | cut -d" & " ' '" & " -f2""" )
	LOGINFO ( "ADB shell ls Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
	If StringLen ( $ANSW ) = 0 Then
		LOGINFO ( "EVE Echoes not started" )
		TELEGRAMBOTSEND ( "EVE Echoes not started." )
		MsgBox ( 262144 , "ERROR" , "EVE Echoes not started." & @CRLF )
		$BOT_ENABLED = 0
		TERMINATE ( )
	Else
		$NETEASEPID = $ANSW
		LOGINFO ( "EVE Echoes PID=[" & $NETEASEPID & "]" )
	EndIf
	If $USERID = 0 Then
		LOGINFO ( "Trying to get ID by ADB" )
		$ANSW = SENDADB ( " shell logcat com.netease.eve.en:I -e char_id="" -v brief -d" )
		$IDS = StringRegExp ( $ANSW , "char_id=([^\],]+)" , 3 )
		If UBound ( $IDS ) > 0 Then
			LOGINFO ( "ADB id=" & $IDS [ UBound ( $IDS ) + 4294967295 ] )
			$USERID = $IDS [ UBound ( $IDS ) + 4294967295 ]
			$ANSW = SENDADB ( " shell ""echo " & $USERID & " > /data/local/tmp/pid""" )
		Else
			Local $OLDID = SENDADB ( " shell ""cat /data/local/tmp/pid""" )
			$OLDID = Number ( $OLDID )
			LOGINFO ( "Old ADB id=" & $OLDID )
			If $OLDID > 0 Then
				$USERID = $OLDID
				GUICtrlSetData ( $LABEL_PLAYERID , "Saved Player ID:" & $USERID )
			Else
				$USERID = 0
			EndIf
		EndIf
	EndIf
	$ADB_TESTPASSED = 1
	SETDOINGSTATUS ( $PREVDOING )
	LOGINFO ( "End ADB test" )
EndFunc
Func TESTADBRESOLUTION ( )
	$CURRFUNCNAME = "testAdbResolution"
	Local $ANSW
	LOGINFO ( "Start ADB resolution test" )
	$ANSW = SENDADB ( " shell wm size" )
	LOGINFO ( "ADB Answ len:" & StringLen ( $ANSW ) & " Answ:" & $ANSW )
	If StringInStr ( $ANSW , "Physical size" ) Then
		If StringInStr ( $ANSW , "1280x720" ) Then
			LOGINFO ( "Video resolution is ok" )
			Return 1
		Else
			LOGINFO ( "Video resolution is WRONG" )
			MsgBox ( 262144 , "ERROR" , "Change video resolution to 1280x720 and restart." & @CRLF )
			Return 0
		EndIf
	Else
		LOGINFO ( "Something is WRONG" )
		MsgBox ( 262144 , "ERROR" , "Something gone wrong!" & @CRLF & "ADB Answer:" & @CRLF & $ANSW & @CRLF )
		Return 0
	EndIf
EndFunc
Func _ARRAYCLEAR ( ByRef $AARRAY )
	$CURRFUNCNAME = "_ArrayClear"
	Local $ICOLS = UBound ( $AARRAY , 2 )
	Local $IDIM = UBound ( $AARRAY , 0 )
	Local $IROWS = UBound ( $AARRAY , 1 )
	If $IDIM = 1 Then
		Local $AARRAY1D [ $IROWS ]
		$AARRAY = $AARRAY1D
	Else
		Local $AARRAY2D [ $IROWS ] [ $ICOLS ]
		$AARRAY = $AARRAY2D
	EndIf
EndFunc
Func CHECKCOLOR ( $X , $Y , $SILENCE = 0 , $SAVE_POINT = 0 , $MAKESCREENSHOT = 1 )
	$CURRFUNCNAME = "CheckColor"
	Local $ICOLOR = 0
	Local $ACOLOR = 0
	Local $SDEBUG = ""
	If $MAKESCREENSHOT Then ADBSCREEN ( 1 )
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	If @error Then MsgBox ( 0 , "failed" , @error )
	$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $X , $Y )
	$ACOLOR = __COLORGETRGB ( $ICOLOR )
	If $SILENCE Or $SAVE_POINT Then
		$SDEBUG = "$sDebug= Pixel at x=" & $X & " y=" & $Y & " icolor=" & $ICOLOR & " has color=" & "0x" & Hex ( $ICOLOR , 6 ) & " acolor[0]=" & $ACOLOR [ 0 ] & " acolor[1]=" & $ACOLOR [ 1 ] & " acolor[2]=" & $ACOLOR [ 2 ]
		LOGINFO ( $SDEBUG )
	EndIf
	If $SAVE_POINT Then
		Local $ANSW
		Local $HBRUSH = _GDIPLUS_BRUSHCREATESOLID ( 4294967295 )
		LOGINFO ( "Saving check color screenshot" )
		_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X , $Y , "0xFFFF00FF" )
		Local $BITMAP1 = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $BITMAP )
		Local $HPEN = _GDIPLUS_PENCREATE ( 4294902015 , 2 )
		_GDIPLUS_PENSETWIDTH ( $HPEN , 1 )
		If @error Then MsgBox ( 0 , "failed" , @error )
		_GDIPLUS_GRAPHICSDRAWELLIPSE ( $BITMAP1 , $X + 4294967286 , $Y + 4294967286 , 20 , 20 , $HPEN )
		If @error Then MsgBox ( 0 , "failed" , @error )
		$ANSW = _GDIPLUS_GRAPHICSFILLRECT ( $BITMAP1 , 177 , 53 + 69 , 856 , 61 , $HBRUSH )
		If $ANSW = False Then LOGERROR ( "filled:" & $ANSW )
		If @error Then MsgBox ( 0 , "failed" , @error )
		$ANSW = _GDIPLUS_GRAPHICSDRAWSTRING ( $BITMAP1 , $SDEBUG , 177 , 53 + 89 , Default , Default , Default , 16711807 )
		If $ANSW = False Then LOGERROR ( "drawned:" & $ANSW )
		If @error Then MsgBox ( 0 , "failed" , @error )
		Local $HSL_COLOR = _COLORCONVERTRGBTOHSL ( $ACOLOR )
		_GDIPLUS_GRAPHICSDRAWSTRING ( $BITMAP1 , "HSL[0]=" & $HSL_COLOR [ 0 ] & "HSL[1]=" & $HSL_COLOR [ 1 ] & "HSL[2]=" & $HSL_COLOR [ 2 ] , 177 , 53 + 104 , "Arial" , 10 , 0 )
		$ANSW = _GDIPLUS_IMAGESAVETOFILE ( $BITMAP , @ScriptDir & "\screenshot\screenshot_colorchecked-" & @MDAY & "." & @HOUR & "." & @MIN & "." & @MSEC & ".bmp" )
		If $ANSW = False Then LOGERROR ( "saved:" & $ANSW )
		If @error Then MsgBox ( 0 , "failed" , @error )
		_GDIPLUS_GRAPHICSDISPOSE ( $BITMAP1 )
		_WINAPI_DELETEOBJECT ( $BITMAP1 )
	EndIf
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_WINAPI_DELETEOBJECT ( $BITMAP )
	Return $ACOLOR
EndFunc
Func SECTOMSEC ( $SEC , $ADD = 0 )
	$CURRFUNCNAME = "SecToMsec"
	Return ( $SEC + $ADD ) * 1000
EndFunc
Func HOURSTOMSEC ( $HOURS )
	$CURRFUNCNAME = "HoursToMsec"
	Return $HOURS * 60 * 60 * 1000
EndFunc
Func __COLORGETRGB ( $ICOLOR )
	$CURRFUNCNAME = "__ColorGetRGB"
	Local $COLOR [ 3 ]
	$COLOR [ 0 ] = BitShift ( BitAND ( $ICOLOR , 16711680 ) , 16 )
	$COLOR [ 1 ] = BitShift ( BitAND ( $ICOLOR , 65280 ) , 8 )
	$COLOR [ 2 ] = BitAND ( $ICOLOR , 255 )
	Return $COLOR
EndFunc
Func MAKESREENSHOT ( )
	$CURRFUNCNAME = "MakeSreenshot"
	Local $TIME
	$TIME = @YEAR & "." & @MON & "." & @MDAY & " " & @HOUR & "-" & @MIN & "-" & @SEC
	LOGINFO ( "MakeSreenshot : screenshot " & $TIME & ".bmp" )
	ADBSCREEN ( 0 )
	FileCopy ( @ScriptDir & "\screenshot\screenshot.bmp" , @ScriptDir & "\screenshot " & $TIME & ".bmp" )
	LOGINFO ( "MakeSreenshot : " & @ScriptDir & "\screenshot " & $TIME & ".bmp" )
EndFunc
Func PRINTLIST ( $LIST )
	$CURRFUNCNAME = "PrintList"
	If IsArray ( $LIST ) Then
		Local $TXT = ""
		For $I = 0 To UBound ( $LIST ) + 4294967295
			$TXT = $TXT & "," & $LIST [ $I ]
		Next
		Local $OUT = StringMid ( $TXT , 2 )
		Global $RESULT = "[" & $OUT & "]"
		ConsoleWrite ( $RESULT )
		Return $RESULT
	Else
		MsgBox ( 0 , "List Error" , "Variable is not an array or a list" )
	EndIf
EndFunc
Func SEC2TIME ( $NR_SEC )
	$CURRFUNCNAME = "Sec2Time"
	$SEC2TIME_HOUR = Int ( $NR_SEC / 3600 )
	$SEC2TIME_MIN = Int ( ( $NR_SEC - $SEC2TIME_HOUR * 3600 ) / 60 )
	$SEC2TIME_SEC = $NR_SEC - $SEC2TIME_HOUR * 3600 - $SEC2TIME_MIN * 60
	Return StringFormat ( "%02d:%02d:%02d" , $SEC2TIME_HOUR , $SEC2TIME_MIN , $SEC2TIME_SEC )
EndFunc
Func SENDFILETOADB ( $FILE )
	$CURRFUNCNAME = "SendFileToAdb"
	LOGINFO ( "Injecting file: " & $FILE )
	$ANSW = SENDADB ( " push " & @ScriptDir & "\adb\" & $FILE & " /data/local/tmp/" & $FILE )
	$ANSW = $ANSW & SENDADB ( " shell chmod 0777 /data/local/tmp/" & $FILE )
	LOGINFO ( "Result: " & $ANSW )
EndFunc
Func MINUTESTOMS ( $MINUTES )
	$CURRFUNCNAME = "MinutesToMs"
	Return $MINUTES * 60 * 1000
EndFunc
Func DISCORDSENDMESSAGE ( $MESSAGE , $NAME = "" )
	Return
EndFunc
Func DISCORDSENDFILE ( $MESSAGE = "" , $FILE = "" , $NAME = "" )
	Return
EndFunc
Func NUMFORMAT ( $VAR )
	$CURRFUNCNAME = "NumFormat"
	Local $RESULT = StringSplit ( $VAR , "" )
	Local $X , $T , $FINAL
	For $X = $RESULT [ 0 ] To 1 Step + 4294967295
		$T = $T + 1
		If $T = 4 Then
			$FINAL = "." & $FINAL
			$T = 1
		EndIf
		$FINAL = $RESULT [ $X ] & $FINAL
	Next
	Return $FINAL
EndFunc
Func GETUNIXTIME ( $SDATE = 0 )
	$CURRFUNCNAME = "GetUnixTime"
	Local $ASYSTIMEINFO = _DATE_TIME_GETTIMEZONEINFORMATION ( )
	Local $UTCTIME = ""
	If Not $SDATE Then $SDATE = _NOWCALC ( )
	If Int ( StringLeft ( $SDATE , 4 ) ) < 1970 Then Return ""
	If $ASYSTIMEINFO [ 0 ] = 2 Then
		$UTCTIME = _DATEADD ( "n" , $ASYSTIMEINFO [ 1 ] + $ASYSTIMEINFO [ 7 ] , $SDATE )
	Else
		$UTCTIME = _DATEADD ( "n" , $ASYSTIMEINFO [ 1 ] , $SDATE )
	EndIf
	Return _DATEDIFF ( "s" , "1970/01/01 00:00:00" , $UTCTIME )
EndFunc
Func INRANGE ( $VALUE , $MIN , $MAX )
	$CURRFUNCNAME = "InRange"
	If $VALUE >= $MIN And $VALUE <= $MAX Then
		Return 1
	Else
		Return 0
	EndIf
EndFunc
Global Const $IDELAYSLEEP = 5
Func LAUNCHCONSOLE ( $CMD , $PARAM , ByRef $PROCESS_KILLED , $TIMEOUT = 10000 , $BUSESEMAPHORE = False )
	Local $DEBUGFILECONSOLEWRITE = 0
	Local $DEBUGCONSOLEWRITE = 0
	Local $DATA , $PID , $HTIMER , $ERRORDATA
	If StringLen ( $PARAM ) > 0 Then $CMD &= " " & $PARAM
	$HTIMER = TimerInit ( )
	$PROCESS_KILLED = False
	If $DEBUGFILECONSOLEWRITE = 1 Then FILECONSOLEWRITE ( "Func LaunchConsole: " & $CMD & @CRLF )
	$PID = Run ( $CMD , "" , @SW_HIDE , $STDERR_CHILD + $STDOUT_CHILD )
	If $PID = 0 Or @error Then
		LOGERROR ( "Launch failed: " & $CMD & " error=" & @error & @CRLF )
		Return
	EndIf
	If $DEBUGFILECONSOLEWRITE = 1 Then FILECONSOLEWRITE ( "Func LaunchConsole: command launched" & @CRLF )
	$DATA = ""
	$ERRORDATA = ""
	Local $TIMEOUT_SEC = Round ( $TIMEOUT / 1000 )
	Local $MM = 0 , $TEMPDATA
	While True
		Sleep ( $IDELAYSLEEP )
		$DATA &= StdoutRead ( $PID )
		$ERRORDATA &= StderrRead ( $PID )
		If @error Then
			If Not $ERRORDATA = "" Then
				LOGERROR ( "error:" & @error )
				$DATA &= "StderrRead:" & $ERRORDATA
			EndIf
			ExitLoop
		EndIf
		If StringInStr ( $DATA , "screendone" ) Then
			LOGDEBUG ( "Console: screendone finded" )
			ExitLoop
		EndIf
		If StringInStr ( $DATA , "tapdone" ) Then
			LOGDEBUG ( "Console: tapdone finded" )
			ExitLoop
		EndIf
		If ( $TIMEOUT > 0 And TimerDiff ( $HTIMER ) > $TIMEOUT ) Then
			LOGERROR ( "Console $pid:" & $PID & @CRLF )
			LOGERROR ( "Console TIMEOUT:" & @error & @CRLF )
			LOGERROR ( "Console $data:" & $DATA & @CRLF )
			LOGERROR ( "Console $errordata:" & $ERRORDATA & @CRLF )
			LOGERROR ( "Console $cmd:" & $CMD & @CRLF )
			LOGERROR ( "Console $param:" & $PARAM & @CRLF )
			$ADBERROR = 1
			ExitLoop
		EndIf
	WEnd
	If ( 0 ) And Not StringInStr ( $CMD , "7z.exe" ) Then
		LOGDEBUG ( "Console $data:" & $DATA & @CRLF )
		LOGDEBUG ( "Console $errordata:" & $ERRORDATA & @CRLF )
		LOGDEBUG ( "Console $cmd:" & $CMD & @CRLF )
		LOGDEBUG ( "Console $param:" & $PARAM & @CRLF )
	EndIf
	CLEANLAUNCHOUTPUT ( $DATA )
	If $DEBUGCONSOLEWRITE Then ConsoleWrite ( "5" )
	If ProcessExists ( $PID ) Then
		If ProcessClose ( $PID ) = 1 Then
			LOGERROR ( "Process killed: " & $CMD & @CRLF )
			LOGERROR ( "Func LaunchConsole Output: " & $DATA & @CRLF )
			$PROCESS_KILLED = True
		EndIf
	EndIf
	StdioClose ( $PID )
	If $DEBUGFILECONSOLEWRITE = 1 Then FILECONSOLEWRITE ( "Func LaunchConsole Output: " & $DATA & @CRLF )
	Return $DATA
EndFunc
Func PROCESSEXISTS2 ( $PROGRAMPATH , $PROGRAMPARAMETER = Default , $COMPAREMODE = Default , $SEARCHMODE = 0 , $COMPARECOMMANDLINEFUNC = "" , $STRCOMPUTER = "." )
	If IsNumber ( $PROGRAMPATH ) Then
		Local $HPROCESS , $PID = $PROGRAMPATH
		If _WINAPI_GETVERSION ( ) >= 6.0 Then
			$HPROCESS = _WINAPI_OPENPROCESS ( $PROCESS_QUERY_LIMITED_INFORMATION , 0 , $PID )
		Else
			$HPROCESS = _WINAPI_OPENPROCESS ( $PROCESS_QUERY_INFORMATION , 0 , $PID )
		EndIf
		If $HPROCESS Then
			_WINAPI_CLOSEHANDLE ( $HPROCESS )
		EndIf
		Return ( ( $HPROCESS ) ? $PID : 0 )
	EndIf
	If $PROGRAMPARAMETER = Default Then
		$PROGRAMPARAMETER = ""
		If $COMPAREMODE = Default Then $COMPAREMODE = 1
	EndIf
	If $COMPAREMODE = Default Then
		$COMPAREMODE = 0
	EndIf
	Local $OWMI = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\" & $STRCOMPUTER & "\root\cimv2" )
	FILECONSOLEWRITE ( "ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2"")" )
	If @error <> 0 Then
		FILECONSOLEWRITE ( "Cannot create ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2" )
		Return 0
	EndIf
	Local $EXE = $PROGRAMPATH
	Local $ILASTBS = StringInStr ( $EXE , "\" , 0 , + 4294967295 )
	If $ILASTBS > 0 Then $EXE = StringMid ( $EXE , $ILASTBS + 1 )
	Local $COMMANDLINE = ( $PROGRAMPATH <> "" ? ( """" & $PROGRAMPATH & """" & ( $PROGRAMPARAMETER = "" ? "" : " " & $PROGRAMPARAMETER ) ) : $PROGRAMPARAMETER )
	Local $COMMANDLINECOMPARE = StringReplace ( StringReplace ( StringReplace ( StringReplace ( $COMMANDLINE , ".exe" , "" , 1 ) , " " , "" ) , """" , "" ) , "'" , "" )
	Local $QUERY = "Select * from Win32_Process"
	If StringLen ( $COMMANDLINE ) > 0 Then
		$QUERY &= " where "
		If StringLen ( $PROGRAMPATH ) > 0 Then
			$QUERY &= "ExecutablePath like ""%" & StringReplace ( $PROGRAMPATH , "\" , "\\" ) & "%"""
			If $SEARCHMODE = 1 And StringLen ( $PROGRAMPARAMETER ) > 0 Then $QUERY &= " And "
		EndIf
		If $SEARCHMODE = 1 And StringLen ( $PROGRAMPARAMETER ) > 0 Then $QUERY &= "CommandLine like ""%" & StringReplace ( $PROGRAMPARAMETER , "\" , "\\" ) & "%"""
	EndIf
	FILECONSOLEWRITE ( "WMI Query: " & $QUERY )
	Local $OPROCESSCOLL = $OWMI .ExecQuery ( $QUERY )
	Local $PROCESS , $PID = 0 , $I = 0
	For $PROCESS In $OPROCESSCOLL
		FILECONSOLEWRITE ( $PROCESS .Handle & " = " & $PROCESS .ExecutablePath & " (" & $PROCESS .CommandLine & ")" )
		If $PID = 0 Then
			Local $PROCESSCOMMANDLINECOMPARE = StringReplace ( StringReplace ( StringReplace ( StringReplace ( $PROCESS .CommandLine , ".exe" , "" , 1 ) , " " , "" ) , """" , "" ) , "'" , "" )
			If ( $COMPAREMODE = 0 And $COMMANDLINECOMPARE = $PROCESSCOMMANDLINECOMPARE ) Or ( $COMPAREMODE = 0 And StringRight ( $COMMANDLINECOMPARE , StringLen ( $PROCESSCOMMANDLINECOMPARE ) ) = $PROCESSCOMMANDLINECOMPARE ) Or ( $COMPAREMODE = 0 And $COMPARECOMMANDLINEFUNC <> "" And Execute ( $COMPARECOMMANDLINEFUNC & "(""" & StringReplace ( $PROCESS .CommandLine , """" , "" ) & """)" ) = True ) Or $COMPAREMODE = 1 Then
				$PID = Number ( $PROCESS .Handle )
			EndIf
		EndIf
		$I += 1
	Next
	If $PID = 0 Then
		FILECONSOLEWRITE ( "Process by CommandLine not found: " & $PROGRAMPATH & ( $PROGRAMPARAMETER = "" ? "" : ( $PROGRAMPATH <> "" ? " " : "" ) & $PROGRAMPARAMETER ) )
	Else
		FILECONSOLEWRITE ( "Found Process " & $PID & " by CommandLine: " & $PROGRAMPATH & ( $PROGRAMPARAMETER = "" ? "" : ( $PROGRAMPATH <> "" ? " " : "" ) & $PROGRAMPARAMETER ) )
	EndIf
	Return $PID
EndFunc
Func LAUNCHCONSOLE2 ( $CMD , $TIMEOUT = 10000 , $RETRY = 0 , $RUNANDFORGET = 0 )
	$CURRFUNCNAME = "LaunchConsole2"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	LOGDEBUG ( "#########$AdbError=" & $ADBERROR & @CRLF )
	Local $SERROR = ""
	Local $SOUTPUT = ""
	Local $TIMEOUTED = 0
	$CMD = $CMD & " && echo cmddone"
	LOGDEBUG ( "Launch cmd: " & $CMD )
	If $RUNANDFORGET = 1 Then LOGDEBUG ( "Run and forget" )
	$CMD = $CMD & @CRLF
	If $RETRY = 1 Then LOGDEBUG ( "Second try" )
	If ProcessExists ( $HCONSOLEPID ) > 0 Then
	Else
		$HCONSOLEPID = Run ( "cmd" , @ScriptDir , @SW_HIDE , $STDIN_CHILD + $STDOUT_CHILD + $STDERR_CHILD )
		If $HCONSOLEPID = 0 Or @error Then
			LOGERROR ( "Launch failed: " & $CMD & " error=" & @error )
		Else
			LOGINFO ( "Console started. Pid:" & $HCONSOLEPID )
		EndIf
	EndIf
	Local $HTIMEOUTTIMER = TimerInit ( )
	StdinWrite ( $HCONSOLEPID , $CMD )
	Local $CMDREAD = 0
	While True
		If $RUNANDFORGET = 1 Then ExitLoop
		$SOUTPUT &= StdoutRead ( $HCONSOLEPID )
		$SERROR = StderrRead ( $HCONSOLEPID )
		If StringLen ( $SERROR ) > 0 Then
			$SOUTPUT &= "errr: " & $SERROR
			ExitLoop
		EndIf
		If @error Then
			ExitLoop
		EndIf
		If StringInStr ( $SOUTPUT , $CMD ) Then
			$SOUTPUT = ""
			$CMDREAD = 1
		EndIf
		If StringInStr ( $SOUTPUT , "cmddone" ) And $CMDREAD = 1 Then
			ExitLoop
		EndIf
		If TimerDiff ( $HTIMEOUTTIMER ) > $TIMEOUT Then
			LOGERROR ( "TimeOuted" )
			$TIMEOUTED = 1
			ExitLoop
		EndIf
		If $CMDREAD = 1 Then
			Sleep ( 10 )
		Else
			Sleep ( 1 )
		EndIf
	WEnd
	If $TIMEOUTED = 1 Then
		If ProcessExists ( $HCONSOLEPID ) > 0 Then StdinWrite ( $HCONSOLEPID )
		If $RETRY = 0 Then
			LAUNCHCONSOLE2 ( $CMD , $TIMEOUT = 10000 , 1 )
		Else
			$ADBERROR = 1
		EndIf
	EndIf
	If $ADBERROR = 1 Or $RETRY = 1 Or StringLen ( $SERROR ) > 0 Then LOGDEBUG ( "$AdbError=" & $ADBERROR & ".$Retry=" & $RETRY & ".StringLen($sError)=" & StringLen ( $SERROR ) & @CRLF & "sOutput:" & @CRLF & $SOUTPUT )
	LOGINFO ( "Stop " & $CURRFUNCNAME & " .Time for Console2:" & TimerDiff ( $HTIMEOUTTIMER ) )
	Return $SOUTPUT
EndFunc
Func PROCESSESEXIST ( $PROGRAMPATH , $PROGRAMPARAMETER = "" , $COMPAREMODE = 0 , $STRCOMPUTER = "." )
	If IsNumber ( $PROGRAMPATH ) Then
		Local $A [ 1 ] = [ ProcessExists ( $PROGRAMPATH ) ]
		Return $A
	EndIf
	Local $OWMI = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\" & $STRCOMPUTER & "\root\cimv2" )
	FILECONSOLEWRITE ( "ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2"")" )
	If @error <> 0 Then
		FILECONSOLEWRITE ( "Cannot create ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2" )
		Local $A [ 0 ]
		Return $A
	EndIf
	Local $EXE = $PROGRAMPATH
	Local $ILASTBS = StringInStr ( $EXE , "\" , 0 , + 4294967295 )
	If $ILASTBS > 0 Then $EXE = StringMid ( $EXE , $ILASTBS + 1 )
	Local $COMMANDLINE = ( $PROGRAMPATH <> "" ? ( """" & $PROGRAMPATH & """" & ( $PROGRAMPARAMETER = "" ? "" : " " & $PROGRAMPARAMETER ) ) : $PROGRAMPARAMETER )
	Local $COMMANDLINECOMPARE = StringReplace ( StringReplace ( StringReplace ( StringReplace ( $COMMANDLINE , ".exe" , "" , 1 ) , " " , "" ) , """" , "" ) , "'" , "" )
	Local $QUERY = "Select * from Win32_Process where ExecutablePath like ""%" & StringReplace ( $PROGRAMPATH , "\" , "\\" ) & "%"""
	FILECONSOLEWRITE ( "WMI Query: " & $QUERY )
	Local $OPROCESSCOLL = $OWMI .ExecQuery ( $QUERY )
	Local $PROCESS , $PID = 0 , $I = 0
	Local $PIDS [ 0 ]
	For $PROCESS In $OPROCESSCOLL
		FILECONSOLEWRITE ( $PROCESS .Handle & " = " & $PROCESS .ExecutablePath )
		Local $PROCESSCOMMANDLINECOMPARE = StringReplace ( StringReplace ( StringReplace ( StringReplace ( $PROCESS .CommandLine , ".exe" , "" , 1 ) , " " , "" ) , """" , "" ) , "'" , "" )
		If ( $COMPAREMODE = 0 And $COMMANDLINECOMPARE = $PROCESSCOMMANDLINECOMPARE ) Or ( $COMPAREMODE = 0 And StringRight ( $COMMANDLINECOMPARE , StringLen ( $PROCESSCOMMANDLINECOMPARE ) ) = $PROCESSCOMMANDLINECOMPARE ) Or $COMPAREMODE = 1 Then
			ReDim $PIDS [ $I + 1 ]
			$PIDS [ $I ] = Number ( $PROCESS .Handle )
			$I += 1
		EndIf
	Next
	If $I = 0 Then
		FILECONSOLEWRITE ( "No process found by CommandLine: " & $PROGRAMPATH & ( $PROGRAMPARAMETER = "" ? "" : " " & $PROGRAMPARAMETER ) )
	Else
		FILECONSOLEWRITE ( "Found " & $I & " process(es) with " & $PROGRAMPATH & ( $PROGRAMPARAMETER = "" ? "" : " " & $PROGRAMPARAMETER ) )
	EndIf
	Return $PIDS
EndFunc
Func PROCESSGETCOMMANDLINE ( $PID , $STRCOMPUTER = "." )
	If Not IsNumber ( $PID ) Then Return SetError ( 2 , 0 , + 4294967295 )
	Local $OWMI = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\" & $STRCOMPUTER & "\root\cimv2" )
	FILECONSOLEWRITE ( "ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2"")" )
	If @error <> 0 Then
		FILECONSOLEWRITE ( "Cannot create ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2" )
		Return SetError ( 3 , 0 , + 4294967295 )
	EndIf
	Local $COMMANDLINE
	Local $QUERY = "Select * from Win32_Process where Handle = " & $PID
	FILECONSOLEWRITE ( "WMI Query: " & $QUERY )
	Local $OPROCESSCOLL = $OWMI .ExecQuery ( $QUERY )
	Local $PROCESS , $I = 0
	For $PROCESS In $OPROCESSCOLL
		FILECONSOLEWRITE ( $PROCESS .Handle & " = " & $PROCESS .CommandLine )
		SetError ( 0 , 0 , 0 )
		Return $PROCESS .CommandLine
	Next
	FILECONSOLEWRITE ( "Process not found with PID " & $PID )
	Return SetError ( 1 , 0 , + 4294967295 )
EndFunc
Func PROCESSGETWMIPROCESS ( $PID , $STRCOMPUTER = "." )
	If Not IsNumber ( $PID ) Then Return SetError ( 2 , 0 , + 4294967295 )
	Local $OWMI = ObjGet ( "winmgmts:{impersonationLevel=impersonate}!\\" & $STRCOMPUTER & "\root\cimv2" )
	FILECONSOLEWRITE ( "ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2"")" )
	If @error <> 0 Then
		FILECONSOLEWRITE ( "Cannot create ObjGet(""winmgmts:\\" & $STRCOMPUTER & "\root\cimv2" )
		Return SetError ( 3 , 0 , + 4294967295 )
	EndIf
	Local $COMMANDLINE
	Local $QUERY = "Select * from Win32_Process where Handle = " & $PID
	FILECONSOLEWRITE ( "WMI Query: " & $QUERY )
	Local $OPROCESSCOLL = $OWMI .ExecQuery ( $QUERY )
	Local $PROCESS , $I = 0
	For $PROCESS In $OPROCESSCOLL
		FILECONSOLEWRITE ( $PROCESS .Handle & " = " & $PROCESS .CommandLine )
		SetError ( 0 , 0 , 0 )
		Return $PROCESS
	Next
	FILECONSOLEWRITE ( "Process not found with PID " & $PID )
	Return SetError ( 1 , 0 , + 4294967295 )
EndFunc
Func CLEANLAUNCHOUTPUT ( ByRef $OUTPUT )
	$OUTPUT = StringReplace ( $OUTPUT , @CR & @CR , "" )
	$OUTPUT = StringReplace ( $OUTPUT , @CRLF & @CRLF , "" )
	If StringRight ( $OUTPUT , 1 ) = @LF Then $OUTPUT = StringLeft ( $OUTPUT , StringLen ( $OUTPUT ) + 4294967295 )
	If StringRight ( $OUTPUT , 1 ) = @CR Then $OUTPUT = StringLeft ( $OUTPUT , StringLen ( $OUTPUT ) + 4294967295 )
EndFunc
Global Const $SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = 2048
Global Const $SYMOPT_ALLOW_ZERO_ADDRESS = 16777216
Global Const $SYMOPT_AUTO_PUBLICS = 65536
Global Const $SYMOPT_CASE_INSENSITIVE = 1
Global Const $SYMOPT_DEBUG = 2147483648
Global Const $SYMOPT_DEFERRED_LOADS = 4
Global Const $SYMOPT_DISABLE_SYMSRV_AUTODETECT = 33554432
Global Const $SYMOPT_EXACT_SYMBOLS = 1024
Global Const $SYMOPT_FAIL_CRITICAL_ERRORS = 512
Global Const $SYMOPT_FAVOR_COMPRESSED = 8388608
Global Const $SYMOPT_FLAT_DIRECTORY = 4194304
Global Const $SYMOPT_IGNORE_CVREC = 128
Global Const $SYMOPT_IGNORE_IMAGEDIR = 2097152
Global Const $SYMOPT_IGNORE_NT_SYMPATH = 4096
Global Const $SYMOPT_INCLUDE_32BIT_MODULES = 8192
Global Const $SYMOPT_LOAD_ANYTHING = 64
Global Const $SYMOPT_LOAD_LINES = 16
Global Const $SYMOPT_NO_CPP = 8
Global Const $SYMOPT_NO_IMAGE_SEARCH = 131072
Global Const $SYMOPT_NO_PROMPTS = 524288
Global Const $SYMOPT_NO_PUBLICS = 32768
Global Const $SYMOPT_NO_UNQUALIFIED_LOADS = 256
Global Const $SYMOPT_OVERWRITE = 1048576
Global Const $SYMOPT_PUBLICS_ONLY = 16384
Global Const $SYMOPT_SECURE = 262144
Global Const $SYMOPT_UNDNAME = 2
Global Const $SEM_FAILCRITICALERRORS = 1
Global Const $SEM_NOALIGNMENTFAULTEXCEPT = 4
Global Const $SEM_NOGPFAULTERRORBOX = 2
Global Const $SEM_NOOPENFILEERRORBOX = 32768
Global Const $NETWORK_ALIVE_LAN = 1
Global Const $NETWORK_ALIVE_WAN = 2
Global Const $NETWORK_ALIVE_AOL = 4
Global Const $RESTART_NO_CRASH = 1
Global Const $RESTART_NO_HANG = 2
Global Const $RESTART_NO_PATCH = 4
Global Const $RESTART_NO_REBOOT = 8
Global Const $UHID_MB = 0
Global Const $UHID_BIOS = 1
Global Const $UHID_CPU = 2
Global Const $UHID_HDD = 4
Global Const $UHID_ALL = BitOR ( $UHID_MB , $UHID_BIOS , $UHID_CPU , $UHID_HDD )
Global Const $BPBF_COMPATIBLEBITMAP = 0
Global Const $BPBF_DIB = 1
Global Const $BPBF_TOPDOWNDIB = 2
Global Const $BPBF_TOPDOWNMONODIB = 3
Global Const $BPPF_ERASE = 1
Global Const $BPPF_NOCLIP = 2
Global Const $BPPF_NONCLIENT = 4
Global Const $DTT_TEXTCOLOR = 1
Global Const $DTT_BORDERCOLOR = 2
Global Const $DTT_SHADOWCOLOR = 4
Global Const $DTT_SHADOWTYPE = 8
Global Const $DTT_SHADOWOFFSET = 16
Global Const $DTT_BORDERSIZE = 32
Global Const $DTT_FONTPROP = 64
Global Const $DTT_COLORPROP = 128
Global Const $DTT_STATEID = 256
Global Const $DTT_CALCRECT = 512
Global Const $DTT_APPLYOVERLAY = 1024
Global Const $DTT_GLOWSIZE = 2048
Global Const $DTT_CALLBACK = 4096
Global Const $DTT_COMPOSITED = 8192
Global Const $DTT_VALIDBITS = BitOR ( $DTT_TEXTCOLOR , $DTT_BORDERCOLOR , $DTT_SHADOWCOLOR , $DTT_SHADOWTYPE , $DTT_SHADOWOFFSET , $DTT_BORDERSIZE , $DTT_FONTPROP , $DTT_COLORPROP , $DTT_STATEID , $DTT_CALCRECT , $DTT_APPLYOVERLAY , $DTT_GLOWSIZE , $DTT_COMPOSITED )
Global Const $TST_NONE = 0
Global Const $TST_SINGLE = 1
Global Const $TST_CONTINUOUS = 2
Global Const $STAP_ALLOW_NONCLIENT = 1
Global Const $STAP_ALLOW_CONTROLS = 2
Global Const $STAP_ALLOW_WEBCONTENT = 4
Global Const $GBF_DIRECT = 1
Global Const $GBF_COPY = 2
Global Const $GBF_VALIDBITS = BitOR ( $GBF_DIRECT , $GBF_COPY )
Global Const $SZ_THDOCPROP_AUTHOR = "Author"
Global Const $SZ_THDOCPROP_CANONICALNAME = "ThemeName"
Global Const $SZ_THDOCPROP_DISPLAYNAME = "DisplayName"
Global Const $SZ_THDOCPROP_TOOLTIP = "ToolTip"
Global Const $TS_MIN = 0
Global Const $TS_TRUE = 1
Global Const $TS_DRAW = 2
Global Const $PO_CLASS = 2
Global Const $PO_GLOBAL = 3
Global Const $PO_NOTFOUND = 4
Global Const $PO_PART = 1
Global Const $PO_STATE = 0
Global Const $TMT_BOOL = 203
Global Const $TMT_COLOR = 204
Global Const $TMT_DIBDATA = 2
Global Const $TMT_DISKSTREAM = 213
Global Const $TMT_ENUM = 200
Global Const $TMT_FILENAME = 206
Global Const $TMT_FONT = 210
Global Const $TMT_GLYPHDIBDATA = 8
Global Const $TMT_HBITMAP = 212
Global Const $TMT_INT = 202
Global Const $TMT_INTLIST = 211
Global Const $TMT_MARGINS = 205
Global Const $TMT_POSITION = 208
Global Const $TMT_RECT = 209
Global Const $TMT_SIZE = 207
Global Const $TMT_STRING = 201
Global Const $TMT_ALWAYSSHOWSIZINGBAR = 2208
Global Const $TMT_AUTOSIZE = 2202
Global Const $TMT_BGFILL = 2205
Global Const $TMT_BORDERONLY = 2203
Global Const $TMT_COMPOSITED = 2204
Global Const $TMT_COMPOSITEDOPAQUE = 2219
Global Const $TMT_DRAWBORDERS = 2214
Global Const $TMT_FLATMENUS = 1001
Global Const $TMT_GLYPHONLY = 2207
Global Const $TMT_GLYPHTRANSPARENT = 2206
Global Const $TMT_INTEGRALSIZING = 2211
Global Const $TMT_LOCALIZEDMIRRORIMAGE = 2220
Global Const $TMT_MIRRORIMAGE = 2209
Global Const $TMT_NOETCHEDEFFECT = 2215
Global Const $TMT_SOURCEGROW = 2212
Global Const $TMT_SOURCESHRINK = 2213
Global Const $TMT_TEXTAPPLYOVERLAY = 2216
Global Const $TMT_TEXTGLOW = 2217
Global Const $TMT_TEXTITALIC = 2218
Global Const $TMT_TRANSPARENT = 2201
Global Const $TMT_UNIFORMSIZING = 2210
Global Const $TMT_USERPICTURE = 5001
Global Const $TMT_ACCENTCOLORHINT = 3823
Global Const $TMT_ACTIVEBORDER = 1611
Global Const $TMT_ACTIVECAPTION = 1603
Global Const $TMT_APPWORKSPACE = 1613
Global Const $TMT_BACKGROUND = 1602
Global Const $TMT_BLENDCOLOR = 5003
Global Const $TMT_BODYTEXTCOLOR = 3827
Global Const $TMT_BORDERCOLOR = 3801
Global Const $TMT_BORDERCOLORHINT = 3822
Global Const $TMT_BTNFACE = 1616
Global Const $TMT_BTNHIGHLIGHT = 1621
Global Const $TMT_BTNSHADOW = 1617
Global Const $TMT_BTNTEXT = 1619
Global Const $TMT_BUTTONALTERNATEFACE = 1626
Global Const $TMT_CAPTIONTEXT = 1610
Global Const $TMT_DKSHADOW3D = 1622
Global Const $TMT_EDGEDKSHADOWCOLOR = 3807
Global Const $TMT_EDGEFILLCOLOR = 3808
Global Const $TMT_EDGEHIGHLIGHTCOLOR = 3805
Global Const $TMT_EDGELIGHTCOLOR = 3804
Global Const $TMT_EDGESHADOWCOLOR = 3806
Global Const $TMT_FILLCOLOR = 3802
Global Const $TMT_FILLCOLORHINT = 3821
Global Const $TMT_FROMCOLOR1 = 2001
Global Const $TMT_FROMCOLOR2 = 2002
Global Const $TMT_FROMCOLOR3 = 2003
Global Const $TMT_FROMCOLOR4 = 2004
Global Const $TMT_FROMCOLOR5 = 2005
Global Const $TMT_GLOWCOLOR = 3816
Global Const $TMT_GLYPHTEXTCOLOR = 3819
Global Const $TMT_GLYPHTRANSPARENTCOLOR = 3820
Global Const $TMT_GRADIENTACTIVECAPTION = 1628
Global Const $TMT_GRADIENTCOLOR1 = 3810
Global Const $TMT_GRADIENTCOLOR2 = 3811
Global Const $TMT_GRADIENTCOLOR3 = 3812
Global Const $TMT_GRADIENTCOLOR4 = 3813
Global Const $TMT_GRADIENTCOLOR5 = 3814
Global Const $TMT_GRADIENTINACTIVECAPTION = 1629
Global Const $TMT_GRAYTEXT = 1618
Global Const $TMT_HEADING1TEXTCOLOR = 3825
Global Const $TMT_HEADING2TEXTCOLOR = 3826
Global Const $TMT_HIGHLIGHT = 1614
Global Const $TMT_HIGHLIGHTTEXT = 1615
Global Const $TMT_HOTTRACKING = 1627
Global Const $TMT_INACTIVEBORDER = 1612
Global Const $TMT_INACTIVECAPTION = 1604
Global Const $TMT_INACTIVECAPTIONTEXT = 1620
Global Const $TMT_INFOBK = 1625
Global Const $TMT_INFOTEXT = 1624
Global Const $TMT_LIGHT3D = 1623
Global Const $TMT_MENU = 1605
Global Const $TMT_MENUBAR = 1631
Global Const $TMT_MENUHILIGHT = 1630
Global Const $TMT_MENUTEXT = 1608
Global Const $TMT_SCROLLBAR = 1601
Global Const $TMT_SHADOWCOLOR = 3815
Global Const $TMT_TEXTBORDERCOLOR = 3817
Global Const $TMT_TEXTCOLOR = 3803
Global Const $TMT_TEXTCOLORHINT = 3824
Global Const $TMT_TEXTSHADOWCOLOR = 3818
Global Const $TMT_TRANSPARENTCOLOR = 3809
Global Const $TMT_WINDOW = 1606
Global Const $TMT_WINDOWFRAME = 1607
Global Const $TMT_WINDOWTEXT = 1609
Global Const $TMT_ATLASIMAGE = 8000
Global Const $TMT_BGTYPE = 4001
Global Const $TMT_BORDERTYPE = 4002
Global Const $TMT_CONTENTALIGNMENT = 4006
Global Const $TMT_FILLTYPE = 4003
Global Const $TMT_GLYPHTYPE = 4012
Global Const $TMT_GLYPHFONTSIZINGTYPE = 4014
Global Const $TMT_HALIGN = 4005
Global Const $TMT_ICONEFFECT = 4009
Global Const $TMT_IMAGELAYOUT = 4011
Global Const $TMT_IMAGESELECTTYPE = 4013
Global Const $TMT_OFFSETTYPE = 4008
Global Const $TMT_SIZINGTYPE = 4004
Global Const $TMT_TEXTSHADOWTYPE = 4010
Global Const $TMT_TRUESIZESCALINGTYPE = 4015
Global Const $TMT_VALIGN = 4007
Global Const $TMT_GLYPHIMAGEFILE = 3008
Global Const $TMT_IMAGEFILE = 3001
Global Const $TMT_IMAGEFILE1 = 3002
Global Const $TMT_IMAGEFILE2 = 3003
Global Const $TMT_IMAGEFILE3 = 3004
Global Const $TMT_IMAGEFILE4 = 3005
Global Const $TMT_IMAGEFILE5 = 3006
Global Const $TMT_SCALEDBACKGROUND = 7001
Global Const $TMT_BODYFONT = 809
Global Const $TMT_CAPTIONFONT = 801
Global Const $TMT_GLYPHFONT = 2601
Global Const $TMT_HEADING1FONT = 807
Global Const $TMT_HEADING2FONT = 808
Global Const $TMT_ICONTITLEFONT = 806
Global Const $TMT_MENUFONT = 803
Global Const $TMT_MSGBOXFONT = 805
Global Const $TMT_SMALLCAPTIONFONT = 802
Global Const $TMT_STATUSFONT = 804
Global Const $TMT_ALPHALEVEL = 2402
Global Const $TMT_ALPHATHRESHOLD = 2415
Global Const $TMT_ANIMATIONDELAY = 2428
Global Const $TMT_ANIMATIONDURATION = 5006
Global Const $TMT_BORDERSIZE = 2403
Global Const $TMT_CHARSET = 403
Global Const $TMT_COLORIZATIONCOLOR = 2431
Global Const $TMT_COLORIZATIONOPACITY = 2432
Global Const $TMT_FRAMESPERSECOND = 2426
Global Const $TMT_FROMHUE1 = 1801
Global Const $TMT_FROMHUE2 = 1802
Global Const $TMT_FROMHUE3 = 1803
Global Const $TMT_FROMHUE4 = 1804
Global Const $TMT_FROMHUE5 = 1805
Global Const $TMT_GLOWINTENSITY = 2429
Global Const $TMT_GLYPHINDEX = 2418
Global Const $TMT_GRADIENTRATIO1 = 2406
Global Const $TMT_GRADIENTRATIO2 = 2407
Global Const $TMT_GRADIENTRATIO3 = 2408
Global Const $TMT_GRADIENTRATIO4 = 2409
Global Const $TMT_GRADIENTRATIO5 = 2410
Global Const $TMT_HEIGHT = 2417
Global Const $TMT_IMAGECOUNT = 2401
Global Const $TMT_MINCOLORDEPTH = 1301
Global Const $TMT_MINDPI1 = 2420
Global Const $TMT_MINDPI2 = 2421
Global Const $TMT_MINDPI3 = 2422
Global Const $TMT_MINDPI4 = 2423
Global Const $TMT_MINDPI5 = 2424
Global Const $TMT_OPACITY = 2430
Global Const $TMT_PIXELSPERFRAME = 2427
Global Const $TMT_PROGRESSCHUNKSIZE = 2411
Global Const $TMT_PROGRESSSPACESIZE = 2412
Global Const $TMT_ROUNDCORNERHEIGHT = 2405
Global Const $TMT_ROUNDCORNERWIDTH = 2404
Global Const $TMT_SATURATION = 2413
Global Const $TMT_TEXTBORDERSIZE = 2414
Global Const $TMT_TEXTGLOWSIZE = 2425
Global Const $TMT_TOCOLOR1 = 2006
Global Const $TMT_TOCOLOR2 = 2007
Global Const $TMT_TOCOLOR3 = 2008
Global Const $TMT_TOCOLOR4 = 2009
Global Const $TMT_TOCOLOR5 = 2010
Global Const $TMT_TOHUE1 = 1806
Global Const $TMT_TOHUE2 = 1807
Global Const $TMT_TOHUE3 = 1808
Global Const $TMT_TOHUE4 = 1809
Global Const $TMT_TOHUE5 = 1810
Global Const $TMT_TRUESIZESTRETCHMARK = 2419
Global Const $TMT_WIDTH = 2416
Global Const $TMT_TRANSITIONDURATIONS = 6000
Global Const $TMT_CAPTIONMARGINS = 3603
Global Const $TMT_CONTENTMARGINS = 3602
Global Const $TMT_SIZINGMARGINS = 3601
Global Const $TMT_MINSIZE = 3403
Global Const $TMT_MINSIZE1 = 3404
Global Const $TMT_MINSIZE2 = 3405
Global Const $TMT_MINSIZE3 = 3406
Global Const $TMT_MINSIZE4 = 3407
Global Const $TMT_MINSIZE5 = 3408
Global Const $TMT_NORMALSIZE = 3409
Global Const $TMT_OFFSET = 3401
Global Const $TMT_TEXTSHADOWOFFSET = 3402
Global Const $TMT_ANIMATIONBUTTONRECT = 5005
Global Const $TMT_ATLASRECT = 8002
Global Const $TMT_CUSTOMSPLITRECT = 5004
Global Const $TMT_DEFAULTPANESIZE = 5002
Global Const $TMT_CAPTIONBARHEIGHT = 1205
Global Const $TMT_CAPTIONBARWIDTH = 1204
Global Const $TMT_MENUBARHEIGHT = 1209
Global Const $TMT_MENUBARWIDTH = 1208
Global Const $TMT_PADDEDBORDERWIDTH = 1210
Global Const $TMT_SCROLLBARHEIGHT = 1203
Global Const $TMT_SCROLLBARWIDTH = 1202
Global Const $TMT_SIZINGBORDERWIDTH = 1201
Global Const $TMT_SMCAPTIONBARHEIGHT = 1207
Global Const $TMT_SMCAPTIONBARWIDTH = 1206
Global Const $TMT_ALIAS = 1404
Global Const $TMT_ATLASINPUTIMAGE = 8001
Global Const $TMT_AUTHOR = 604
Global Const $TMT_CLASSICVALUE = 3202
Global Const $TMT_COLORSCHEMES = 401
Global Const $TMT_COMPANY = 603
Global Const $TMT_COPYRIGHT = 605
Global Const $TMT_CSSNAME = 1401
Global Const $TMT_DESCRIPTION = 608
Global Const $TMT_DISPLAYNAME = 601
Global Const $TMT_LASTUPDATED = 1403
Global Const $TMT_SIZES = 402
Global Const $TMT_TEXT = 3201
Global Const $TMT_TOOLTIP = 602
Global Const $TMT_URL = 606
Global Const $TMT_VERSION = 607
Global Const $TMT_XMLNAME = 1402
Global Const $TMT_NAME = 600
#Region Global Variables and Constants
Global Const $TAGDTTOPTS = "dword Size;dword Flags;dword clrText;dword clrBorder;dword clrShadow;int TextShadowType;" & $TAGPOINT & ";int BorderSize;int FontPropId;int ColorPropId;int StateId;int ApplyOverlay;int GlowSize;ptr DrawTextCallback;lparam lParam"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_BEGINBUFFEREDPAINT ( $HDC , $TTARGET , ByRef $HNEWDC , $IFORMAT = 0 , $IFLAGS = 0 , $TEXCLUDE = 0 , $IALPHA = + 4294967295 )
	Local Const $TAGBP_PAINTPARAMS = "dword cbSize;dword dwFlags;ptr prcExclude;ptr pBlendFunction"
	Local $TPP = DllStructCreate ( $TAGBP_PAINTPARAMS )
	$HNEWDC = 0
	Local $TBF = 0
	If $IALPHA <> + 4294967295 Then
		$TBF = DllStructCreate ( $TAGBLENDFUNCTION )
		DllStructSetData ( $TBF , 1 , 0 )
		DllStructSetData ( $TBF , 2 , 0 )
		DllStructSetData ( $TBF , 3 , $IALPHA )
		DllStructSetData ( $TBF , 4 , 1 )
	EndIf
	DllStructSetData ( $TPP , 1 , DllStructGetSize ( $TPP ) )
	DllStructSetData ( $TPP , 2 , $IFLAGS )
	DllStructSetData ( $TPP , 3 , DllStructGetPtr ( $TEXCLUDE ) )
	DllStructSetData ( $TPP , 4 , DllStructGetPtr ( $TBF ) )
	Local $ACALL = DllCall ( "uxtheme.dll" , "handle" , "BeginBufferedPaint" , "handle" , $HDC , "struct*" , $TTARGET , "dword" , $IFORMAT , "struct*" , $TPP , "handle*" , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error , @extended , 0 )
	$HNEWDC = $ACALL [ 5 ]
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_BUFFEREDPAINTCLEAR ( $HBP , $TRECT = 0 )
	Local $ACALL = DllCall ( "uxtheme.dll" , "long" , "BufferedPaintClear" , "handle" , $HBP , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_BUFFEREDPAINTINIT ( )
	Local $ACALL = DllCall ( "uxtheme.dll" , "long" , "BufferedPaintInit" )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_BUFFEREDPAINTSETALPHA ( $HBP , $IALPHA = 255 , $TRECT = 0 )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "BufferedPaintSetAlpha" , "handle" , $HBP , "struct*" , $TRECT , "byte" , $IALPHA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_BUFFEREDPAINTUNINIT ( )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "BufferedPaintUnInit" )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_CLOSETHEMEDATA ( $HTHEME )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "CloseThemeData" , "handle" , $HTHEME )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWTHEMEBACKGROUND ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT , $TCLIP = 0 )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "DrawThemeBackground" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "struct*" , $TCLIP )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWTHEMEEDGE ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT , $IEDGE , $IFLAGS , $TAREA = 0 )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "DrawThemeEdge" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "uint" , $IEDGE , "uint" , $IFLAGS , "struct*" , $TAREA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWTHEMEICON ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT , $HIL , $IINDEX )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "DrawThemeIcon" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "handle" , $HIL , "int" , $IINDEX )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWTHEMEPARENTBACKGROUND ( $HWND , $HDC , $TRECT = 0 )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "DrawThemeParentBackground" , "hwnd" , $HWND , "handle" , $HDC , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWTHEMETEXT ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $STEXT , $TRECT , $IFLAGS )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "DrawThemeText" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "wstr" , $STEXT , "int" , + 4294967295 , "dword" , $IFLAGS , "dword" , 0 , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_DRAWTHEMETEXTEX ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $STEXT , $TRECT , $IFLAGS , $TDTTOPTS )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "DrawThemeTextEx" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "wstr" , $STEXT , "int" , + 4294967295 , "dword" , $IFLAGS , "struct*" , $TRECT , "struct*" , $TDTTOPTS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_ENDBUFFEREDPAINT ( $HBP , $BUPDATE = True )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "EndBufferedPaint" , "handle" , $HBP , "bool" , $BUPDATE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_GETBUFFEREDPAINTBITS ( $HBP )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetBufferedPaintBits" , "handle" , $HBP , "ptr*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return SetExtended ( $SRESULT [ 3 ] , $SRESULT [ 2 ] )
EndFunc
Func _WINAPI_GETBUFFEREDPAINTDC ( $HBP )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "handle" , "GetBufferedPaintDC" , "handle" , $HBP )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETBUFFEREDPAINTTARGETDC ( $HBP )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "handle" , "GetBufferedPaintTargetDC" , "handle" , $HBP )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETBUFFEREDPAINTTARGETRECT ( $HBP )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetBufferedPaintTargetRect" , "handle" , $HBP , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETCURRENTTHEMENAME ( )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetCurrentThemeName" , "wstr" , "" , "int" , 4096 , "wstr" , "" , "int" , 2048 , "wstr" , "" , "int" , 2048 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Local $ARET [ 3 ]
	For $I = 0 To 2
		$ARET [ $I ] = $SRESULT [ $I * 2 + 1 ]
	Next
	Return $ARET
EndFunc
Func _WINAPI_GETTHEMEAPPPROPERTIES ( )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "dword" , "GetThemeAppProperties" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETTHEMEBACKGROUNDCONTENTRECT ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT )
	Local $TAREA = DllStructCreate ( $TAGRECT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeBackgroundContentRect" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "struct*" , $TAREA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TAREA
EndFunc
Func _WINAPI_GETTHEMEBACKGROUNDEXTENT ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT )
	Local $TAREA = DllStructCreate ( $TAGRECT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeBackgroundExtent" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "struct*" , $TAREA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TAREA
EndFunc
Func _WINAPI_GETTHEMEBACKGROUNDREGION ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeBackgroundRegion" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 6 ]
EndFunc
Func _WINAPI_GETTHEMEBITMAP ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID , $IFLAG = 1 )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeBitmap" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "ulong" , $IFLAG , "handle*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , + 4294967295 )
	Return $SRESULT [ 6 ]
EndFunc
Func _WINAPI_GETTHEMEBOOL ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeBool" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "bool*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 5 ]
EndFunc
Func _WINAPI_GETTHEMECOLOR ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeColor" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , + 4294967295 )
	Return __RGB ( $SRESULT [ 5 ] )
EndFunc
Func _WINAPI_GETTHEMEDOCUMENTATIONPROPERTY ( $SFILEPATH , $SPROPERTY )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeDocumentationProperty" , "wstr" , $SFILEPATH , "wstr" , $SPROPERTY , "wstr" , "" , "int" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , "" )
	Return $SRESULT [ 3 ]
EndFunc
Func _WINAPI_GETTHEMEENUMVALUE ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeEnumValue" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 5 ]
EndFunc
Func _WINAPI_GETTHEMEFILENAME ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "uint" , "GetThemeFilename" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "wstr" , "" , "int" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , "" )
	Return $SRESULT [ 5 ]
EndFunc
Func _WINAPI_GETTHEMEFONT ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID , $HDC = 0 )
	Local $TLOGFONT = DllStructCreate ( $TAGLOGFONT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeFont" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "struct*" , $TLOGFONT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TLOGFONT
EndFunc
Func _WINAPI_GETTHEMEINT ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeInt" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 5 ]
EndFunc
Func _WINAPI_GETTHEMEMARGINS ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID , $HDC , $TRECT )
	Local $TMARGINS = DllStructCreate ( $TAGMARGINS )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeMargins" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "struct*" , $TRECT , "struct*" , $TMARGINS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TMARGINS
EndFunc
Func _WINAPI_GETTHEMEMETRIC ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID , $HDC = 0 )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeMetric" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 6 ]
EndFunc
Func _WINAPI_GETTHEMEPARTSIZE ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $TRECT , $ITYPE )
	Local $TSIZE = DllStructCreate ( $TAGSIZE )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemePartSize" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TRECT , "int" , $ITYPE , "struct*" , $TSIZE )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TSIZE
EndFunc
Func _WINAPI_GETTHEMEPOSITION ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $TPOINT = DllStructCreate ( $TAGPOINT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemePosition" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "struct*" , $TPOINT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TPOINT
EndFunc
Func _WINAPI_GETTHEMEPROPERTYORIGIN ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemePropertyOrigin" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "uint*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 5 ]
EndFunc
Func _WINAPI_GETTHEMERECT ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $TRECT = DllStructCreate ( $TAGRECT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeRect" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "struct*" , $TRECT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TRECT
EndFunc
Func _WINAPI_GETTHEMESTRING ( $HTHEME , $IPARTID , $ISTATEID , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeString" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID , "int" , $IPROPID , "wstr" , "" , "int" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , "" )
	Return $SRESULT [ 5 ]
EndFunc
Func _WINAPI_GETTHEMESYSBOOL ( $HTHEME , $IBOOLID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "bool" , "GetThemeSysBool" , "handle" , $HTHEME , "int" , $IBOOLID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETTHEMESYSCOLOR ( $HTHEME , $ICOLORID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "dword" , "GetThemeSysColor" , "handle" , $HTHEME , "int" , $ICOLORID )
	If @error Then Return SetError ( @error , @extended , + 4294967295 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETTHEMESYSCOLORBRUSH ( $HTHEME , $ICOLORID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "handle" , "GetThemeSysColorBrush" , "handle" , $HTHEME , "int" , $ICOLORID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETTHEMESYSFONT ( $HTHEME , $IFONTID )
	Local $TLOGFONT = DllStructCreate ( $TAGLOGFONT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeSysFont" , "handle" , $HTHEME , "int" , $IFONTID , "struct*" , $TLOGFONT )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TLOGFONT
EndFunc
Func _WINAPI_GETTHEMESYSINT ( $HTHEME , $IINTID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeSysInt" , "handle" , $HTHEME , "int" , $IINTID , "int*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 3 ]
EndFunc
Func _WINAPI_GETTHEMESYSSIZE ( $HTHEME , $ISIZEID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "int" , "GetThemeSysSize" , "handle" , $HTHEME , "int" , $ISIZEID )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_GETTHEMESYSSTRING ( $HTHEME , $ISTRINGID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeSysString" , "handle" , $HTHEME , "int" , $ISTRINGID , "wstr" , "" , "int" , 4096 )
	If @error Then Return SetError ( @error , @extended , "" )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , "" )
	Return $SRESULT [ 3 ]
EndFunc
Func _WINAPI_GETTHEMETEXTEXTENT ( $HTHEME , $IPARTID , $ISTATEID , $HDC , $STEXT , $TRECT , $IFLAGS )
	Local $TAREA = DllStructCreate ( $TAGRECT )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeTextExtent" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "wstr" , $STEXT , "int" , + 4294967295 , "dword" , $IFLAGS , "struct*" , $TRECT , "struct*" , $TAREA )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TAREA
EndFunc
Func _WINAPI_GETTHEMETEXTMETRICS ( $HTHEME , $IPARTID , $ISTATEID , $HDC = 0 )
	Local $TTEXTMETRIC = DllStructCreate ( $TAGTEXTMETRIC )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeTextMetrics" , "handle" , $HTHEME , "handle" , $HDC , "int" , $IPARTID , "int" , $ISTATEID , "struct*" , $TTEXTMETRIC )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $TTEXTMETRIC
EndFunc
Func _WINAPI_GETTHEMETRANSITIONDURATION ( $HTHEME , $IPARTID , $ISTATEIDFROM , $ISTATEIDTO , $IPROPID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "GetThemeTransitionDuration" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEIDFROM , "int" , $ISTATEIDTO , "int" , $IPROPID , "dword*" , 0 )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return $SRESULT [ 6 ]
EndFunc
Func _WINAPI_GETWINDOWTHEME ( $HWND )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "handle" , "GetWindowTheme" , "hwnd" , $HWND )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_ISTHEMEACTIVE ( )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "bool" , "IsThemeActive" )
	If @error Then Return SetError ( @error , @extended , False )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_ISTHEMEBACKGROUNDPARTIALLYTRANSPARENT ( $HTHEME , $IPARTID , $ISTATEID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "bool" , "IsThemeBackgroundPartiallyTransparent" , "handle" , $HTHEME , "int" , $IPARTID , "int" , $ISTATEID )
	If @error Then Return SetError ( @error , @extended , False )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_ISTHEMEPARTDEFINED ( $HTHEME , $IPARTID )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "int" , "IsThemePartDefined" , "handle" , $HTHEME , "int" , $IPARTID , "int" , 0 )
	If @error Then Return SetError ( @error , @extended , False )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_OPENTHEMEDATA ( $HWND , $SCLASS )
	Local $SRESULT = DllCall ( "uxtheme.dll" , "handle" , "OpenThemeData" , "hwnd" , $HWND , "wstr" , $SCLASS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $SRESULT [ 0 ]
EndFunc
Func _WINAPI_SETTHEMEAPPPROPERTIES ( $IFLAGS )
	DllCall ( "uxtheme.dll" , "none" , "SetThemeAppProperties" , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return 1
EndFunc
Func _WINAPI_SETWINDOWTHEME ( $HWND , $SNAME = Default , $SLIST = Default )
	If Not IsString ( $SNAME ) Then $SNAME = Null
	If Not IsString ( $SLIST ) Then $SLIST = Null
	Local $SRESULT = DllCall ( "uxtheme.dll" , "long" , "SetWindowTheme" , "hwnd" , $HWND , "wstr" , $SNAME , "wstr" , $SLIST )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $SRESULT [ 0 ] Then Return SetError ( 10 , $SRESULT [ 0 ] , 0 )
	Return 1
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global $__G_HFRDLG = 0 , $__G_HFRDLL = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WINAPI_DISPLAYSTRUCT ( $TSTRUCT , $SSTRUCT = "" , $STITLE = "" , $IITEM = 0 , $ISUBITEM = 0 , $IFLAGS = 0 , $BTOP = True , $HPARENT = 0 )
	If Not StringStripWS ( $STITLE , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then
		$STITLE = "Structure: ListView Display"
	EndIf
	$SSTRUCT = StringRegExpReplace ( StringStripWS ( $SSTRUCT , $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES ) , ";+\Z" , "" )
	Local $PDATA
	If IsDllStruct ( $TSTRUCT ) Then
		$PDATA = DllStructGetPtr ( $TSTRUCT )
		If Not $SSTRUCT Then
			$SSTRUCT = "byte[" & DllStructGetSize ( $TSTRUCT ) & "]"
			$IFLAGS = BitOR ( $IFLAGS , 64 )
		EndIf
	Else
		$PDATA = $TSTRUCT
		If Not $SSTRUCT Then Return SetError ( 10 , 0 , 0 )
	EndIf
	Local $TDATA = DllStructCreate ( $SSTRUCT , $PDATA )
	Local $IDATA = DllStructGetSize ( $TDATA )
	If ( Not BitAND ( $IFLAGS , 512 ) ) And ( _WINAPI_ISBADREADPTR ( $PDATA , $IDATA ) ) Then
		If Not BitAND ( $IFLAGS , 256 ) Then
			MsgBox ( $MB_SYSTEMMODAL , $STITLE , "The memory range allocated to a given structure could not be read." & @CRLF & @CRLF & Ptr ( $PDATA ) & " - " & Ptr ( $PDATA + $IDATA + 4294967295 ) & @CRLF & @CRLF & "Press OK to exit." )
			Exit + 3221225477
		EndIf
		Return SetError ( 15 , 0 , 0 )
	EndIf
	Local $SOPT1 = Opt ( "GUIDataSeparatorChar" , "|" )
	Local $IOPT2 = Opt ( "GUIOnEventMode" , 0 )
	Local $IOPT3 = Opt ( "GUICloseOnESC" , 1 )
	If $HPARENT Then
		GUISetState ( @SW_DISABLE , $HPARENT )
	EndIf
	Local $ISTYLE = 1
	If $BTOP Then
		$ISTYLE = BitOR ( $ISTYLE , 8 )
	EndIf
	$__G_HFRDLG = GUICreate ( $STITLE , 570 , 620 , + 4294967295 , + 4294967295 , 2160525312 , $ISTYLE , $HPARENT )
	Local $IDLV = GUICtrlCreateListView ( "#|Member|Offset|Type|Size|Value" , 0 , 0 , 570 , 620 , 32781 , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 65585 : 65584 ) )
	Local $HLV = GUICtrlGetHandle ( $IDLV )
	If _WINAPI_GETVERSION ( ) >= 6.0 Then
		_WINAPI_SETWINDOWTHEME ( $HLV , "Explorer" )
	EndIf
	GUICtrlSetResizing ( + 4294967295 , 102 )
	GUICtrlSetFont ( + 4294967295 , 8.5 , 400 , 0 , "Tahoma" )
	GUICtrlSetState ( + 4294967295 , 256 )
	Local $AVAL [ 101 ] = [ 0 ]
	If Not BitAND ( $IFLAGS , 1 ) Then
		__INC ( $AVAL )
		$AVAL [ $AVAL [ 0 ] ] = ""
		GUICtrlCreateListViewItem ( "-|-|" & $PDATA & "|<struct>|0|-" , $IDLV )
		GUICtrlSetColor ( + 4294967295 , 10263708 )
	EndIf
	Local $ADATA = StringSplit ( $SSTRUCT , ";" )
	Local $AITEM , $VITEM , $SITEM , $IMODE , $IINDEX , $ICOUNT = 0 , $IPREV = 0
	Local $ASEL [ 2 ] = [ 0 , 0 ]
	Local $ATYPE [ 28 ] [ 2 ] = [ [ "BYTE" , 1 ] , [ "BOOLEAN" , 1 ] , [ "CHAR" , 1 ] , [ "WCHAR" , 2 ] , [ "short" , 2 ] , [ "USHORT" , 2 ] , [ "WORD" , 2 ] , [ "int" , 4 ] , [ "long" , 4 ] , [ "BOOL" , 4 ] , [ "UINT" , 4 ] , [ "ULONG" , 4 ] , [ "DWORD" , 4 ] , [ "INT64" , 8 ] , [ "UINT64" , 8 ] , [ "ptr" , ( @AutoItX64 ? 8 : 4 ) ] , [ "HWND" , ( @AutoItX64 ? 8 : 4 ) ] , [ "HANDLE" , ( @AutoItX64 ? 8 : 4 ) ] , [ "float" , 4 ] , [ "double" , 8 ] , [ "INT_PTR" , ( @AutoItX64 ? 8 : 4 ) ] , [ "LONG_PTR" , ( @AutoItX64 ? 8 : 4 ) ] , [ "LRESULT" , ( @AutoItX64 ? 8 : 4 ) ] , [ "LPARAM" , ( @AutoItX64 ? 8 : 4 ) ] , [ "UINT_PTR" , ( @AutoItX64 ? 8 : 4 ) ] , [ "ULONG_PTR" , ( @AutoItX64 ? 8 : 4 ) ] , [ "DWORD_PTR" , ( @AutoItX64 ? 8 : 4 ) ] , [ "WPARAM" , ( @AutoItX64 ? 8 : 4 ) ] ]
	For $I = 1 To $ADATA [ 0 ]
		$AITEM = StringSplit ( StringStripWS ( $ADATA [ $I ] , $STR_STRIPLEADING + $STR_STRIPTRAILING ) , " " )
		Switch $AITEM [ 1 ]
		Case "ALIGN" , "STRUCT" , "ENDSTRUCT"
			ContinueLoop
	Case Else
		EndSwitch
		$ICOUNT += 1
		$IMODE = 1
		$SITEM = $ICOUNT & "|"
		If $AITEM [ 0 ] > 1 Then
			$VITEM = StringRegExpReplace ( $AITEM [ 2 ] , "\[.*\Z" , "" )
			$SITEM &= $VITEM & "|"
			If ( Not BitAND ( $IFLAGS , 16 ) ) And ( Not StringCompare ( StringRegExpReplace ( $VITEM , "[0-9]+\Z" , "" ) , "RESERVED" ) ) Then
				$IMODE = 0
			EndIf
			If Not IsString ( $IITEM ) Then
				$VITEM = $ICOUNT
			EndIf
			$IINDEX = 2
		Else
			If Not BitAND ( $IFLAGS , 4 ) Then
				$SITEM &= "<unnamed>|"
			Else
				$SITEM &= "|"
			EndIf
			If Not IsString ( $IITEM ) Then
				$VITEM = $ICOUNT
			Else
				$VITEM = 0
			EndIf
			$IINDEX = 1
		EndIf
		If ( Not $ASEL [ 0 ] ) And ( $VITEM ) And ( $IITEM ) And ( $VITEM = $IITEM ) Then
			$ASEL [ 0 ] = $ICOUNT
		EndIf
		Local $IOFFSET = Number ( DllStructGetPtr ( $TDATA , $ICOUNT ) - $PDATA )
		$IINDEX = StringRegExp ( $AITEM [ $IINDEX ] , "\[(\d+)\]" , $STR_REGEXPARRAYGLOBALMATCH )
		Local $ISIZE
		Do
			ReDim $AITEM [ 3 ]
			$VITEM = StringRegExpReplace ( $AITEM [ 1 ] , "\[.*\Z" , "" )
			For $J = 0 To UBound ( $ATYPE ) + 4294967295
				If Not StringCompare ( $ATYPE [ $J ] [ 0 ] , $VITEM ) Then
					$AITEM [ 1 ] = $ATYPE [ $J ] [ 0 ]
					$AITEM [ 2 ] = $ATYPE [ $J ] [ 1 ]
					$ISIZE = $AITEM [ 2 ]
					ExitLoop 2
				EndIf
			Next
			$AITEM [ 1 ] = "?"
			$AITEM [ 2 ] = "?"
			$ISIZE = 0
		Until 1
		$SITEM &= $IOFFSET & "|"
		If ( IsArray ( $IINDEX ) ) And ( $IINDEX [ 0 ] > "1" ) Then
			If $ISIZE Then
				$AITEM [ 2 ] = $AITEM [ 2 ] * $IINDEX [ 0 ]
			EndIf
			Do
				Switch $AITEM [ 1 ]
				Case "BYTE" , "BOOLEAN"
					If Not BitAND ( $IFLAGS , 64 ) Then
						ContinueCase
					EndIf
				Case "CHAR" , "WCHAR"
					$SITEM &= $AITEM [ 1 ] & "[" & $IINDEX [ 0 ] & "]|" & $AITEM [ 2 ] & "|"
					$IINDEX = 0
					ExitLoop
			Case Else
				EndSwitch
				If ( $ISIZE ) And ( $IMODE ) Then
					$SITEM &= $AITEM [ 1 ] & "[" & $IINDEX [ 0 ] & "]|" & $AITEM [ 2 ] & " (" & $ISIZE & ")" & "|"
				Else
					$SITEM &= $AITEM [ 1 ] & "[" & $IINDEX [ 0 ] & "]|" & $AITEM [ 2 ] & "|"
				EndIf
				If $IMODE Then
					$IINDEX = $IINDEX [ 0 ]
				Else
					$IINDEX = 0
				EndIf
			Until 1
		Else
			$SITEM &= $AITEM [ 1 ] & "|" & $AITEM [ 2 ] & "|"
			$IINDEX = 0
		EndIf
		If ( Not BitAND ( $IFLAGS , 2 ) ) And ( $IPREV ) And ( $IOFFSET > $IPREV ) Then
			__INC ( $AVAL )
			$AVAL [ $AVAL [ 0 ] ] = ""
			GUICtrlCreateListViewItem ( "-|-|-|<alignment>|" & ( $IOFFSET - $IPREV ) & "|-" , $IDLV )
			GUICtrlSetColor ( + 4294967295 , 16711680 )
		EndIf
		If $ISIZE Then
			$IPREV = $IOFFSET + $AITEM [ 2 ]
		Else
			$IPREV = 0
		EndIf
		Local $IDLVITEM , $IDINIT
		If $IINDEX Then
			Local $SPATTERN = "[%0" & StringLen ( $IINDEX ) & "d] "
			For $J = 1 To $IINDEX
				__INC ( $AVAL )
				$AVAL [ $AVAL [ 0 ] ] = DllStructGetData ( $TDATA , $ICOUNT , $J )
				If BitAND ( $IFLAGS , 128 ) Then
					$AVAL [ $AVAL [ 0 ] ] = __WINAPIDIAG_HEX ( $AVAL [ $AVAL [ 0 ] ] , $AITEM [ 1 ] )
				EndIf
				$IDLVITEM = GUICtrlCreateListViewItem ( $SITEM & StringFormat ( $SPATTERN , $J ) & $AVAL [ $AVAL [ 0 ] ] , $IDLV )
				If ( $ASEL [ 0 ] = $ICOUNT ) And ( Not $ASEL [ 1 ] ) Then
					If ( $ISUBITEM < 1 ) Or ( $ISUBITEM > $IINDEX ) Or ( $ISUBITEM = $J ) Then
						$ASEL [ 1 ] = $IDLVITEM
					EndIf
				EndIf
				If ( Not $IDINIT ) And ( $ICOUNT = 1 ) Then
					$IDINIT = $IDLVITEM
				EndIf
				If Not BitAND ( $IFLAGS , 8 ) Then
					GUICtrlSetBkColor ( + 4294967295 , 16119285 )
				EndIf
				If $ISIZE Then
					$SITEM = "-|-|" & ( $IOFFSET + $J * $ISIZE ) & "|-|-|"
				Else
					GUICtrlSetColor ( + 4294967295 , 16746496 )
					$SITEM = "-|-|-|-|-|"
				EndIf
			Next
		Else
			__INC ( $AVAL )
			If $IMODE Then
				$AVAL [ $AVAL [ 0 ] ] = DllStructGetData ( $TDATA , $ICOUNT )
				If BitAND ( $IFLAGS , 128 ) Then
					$AVAL [ $AVAL [ 0 ] ] = __WINAPIDIAG_HEX ( $AVAL [ $AVAL [ 0 ] ] , $AITEM [ 1 ] )
				EndIf
				$IDLVITEM = GUICtrlCreateListViewItem ( $SITEM & $AVAL [ $AVAL [ 0 ] ] , $IDLV )
			Else
				$AVAL [ $AVAL [ 0 ] ] = ""
				$IDLVITEM = GUICtrlCreateListViewItem ( $SITEM & "-" , $IDLV )
			EndIf
			If ( $ASEL [ 0 ] = $ICOUNT ) And ( Not $ASEL [ 1 ] ) Then
				$ASEL [ 1 ] = $IDLVITEM
			EndIf
			If ( Not $IDINIT ) And ( $ICOUNT = 1 ) Then
				$IDINIT = $IDLVITEM
			EndIf
			If Not $ISIZE Then
				GUICtrlSetColor ( + 4294967295 , 16746496 )
			EndIf
		EndIf
		If ( Not BitAND ( $IFLAGS , 2 ) ) And ( Not $ISIZE ) Then
			__INC ( $AVAL )
			$AVAL [ $AVAL [ 0 ] ] = ""
			GUICtrlCreateListViewItem ( "-|-|-|<alignment>|?|-" , $IDLV )
			GUICtrlSetColor ( + 4294967295 , 16746496 )
		EndIf
	Next
	If ( Not BitAND ( $IFLAGS , 2 ) ) And ( $IPREV ) And ( $IDATA > $IPREV ) Then
		__INC ( $AVAL )
		$AVAL [ $AVAL [ 0 ] ] = ""
		GUICtrlCreateListViewItem ( "-|-|-|<alignment>|" & ( $IDATA - $IPREV ) & "|-" , $IDLV )
		GUICtrlSetColor ( + 4294967295 , 16711680 )
	EndIf
	If Not BitAND ( $IFLAGS , 1 ) Then
		__INC ( $AVAL )
		$AVAL [ $AVAL [ 0 ] ] = ""
		GUICtrlCreateListViewItem ( "-|-|" & ( $PDATA + $IDATA + 0 ) & "|<endstruct>|" & $IDATA & "|-" , $IDLV )
		GUICtrlSetColor ( + 4294967295 , 10263708 )
	EndIf
	If $ASEL [ 1 ] Then
		GUICtrlSetState ( $ASEL [ 1 ] , 256 )
	Else
		GUICtrlSetState ( $IDINIT , 256 )
	EndIf
	Local $IDDUMMY = GUICtrlCreateDummy ( )
	Local $AWIDTH [ 6 ] = [ 30 , 130 , 76 , 100 , 50 , 167 ]
	For $I = 0 To UBound ( $AWIDTH ) + 4294967295
		GUICtrlSendMsg ( $IDLV , 4126 , $I , $AWIDTH [ $I ] )
	Next
	Local $TPARAM = DllStructCreate ( "ptr;uint" )
	DllStructSetData ( $TPARAM , 1 , $HLV )
	If Not BitAND ( $IFLAGS , 32 ) Then
		DllStructSetData ( $TPARAM , 2 , $IDDUMMY )
	Else
		DllStructSetData ( $TPARAM , 2 , 0 )
	EndIf
	$__G_HFRDLL = DllCallbackRegister ( "__DlgSubclassProc" , "lresult" , "hwnd;uint;wparam;lparam;uint;ptr" )
	Local $PDLL = DllCallbackGetPtr ( $__G_HFRDLL )
	If _WINAPI_SETWINDOWSUBCLASS ( $__G_HFRDLG , $PDLL , 1000 , DllStructGetPtr ( $TPARAM ) ) Then
		OnAutoItExitRegister ( "__WinAPIDiag_Quit" )
	Else
		DllCallbackFree ( $__G_HFRDLL )
		$__G_HFRDLL = 0
	EndIf
	GUISetState ( )
	While 1
		Switch GUIGetMsg ( )
		Case 0
			ContinueLoop
		Case + 4294967293
			ExitLoop
		Case $IDDUMMY
			$IINDEX = GUICtrlRead ( $IDDUMMY )
			If ( $IINDEX >= 0 ) And ( $IINDEX < $AVAL [ 0 ] ) Then
				ClipPut ( $AVAL [ $IINDEX + 1 ] )
			EndIf
		EndSwitch
	WEnd
	If $__G_HFRDLL Then
		OnAutoItExitUnRegister ( "__WinAPIDiag_Quit" )
	EndIf
	__WINAPIDIAG_QUIT ( )
	If $HPARENT Then
		GUISetState ( @SW_ENABLE , $HPARENT )
	EndIf
	GUIDelete ( $__G_HFRDLG )
	Opt ( "GUIDataSeparatorChar" , $SOPT1 )
	Opt ( "GUIOnEventMode" , $IOPT2 )
	Opt ( "GUICloseOnESC" , $IOPT3 )
	Return 1
EndFunc
Func _WINAPI_ENUMDLLPROC ( $SFILEPATH , $SMASK = "" , $IFLAGS = 0 )
	If Not __DLL ( "dbghelp.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $VVER = __WINAPIDIAG_VER ( "dbghelp.dll" )
	If $VVER < 1281 Then Return SetError ( 2 , 0 , 0 )
	$__G_VENUM = 0
	Local $IPE , $ACALL , $IERROR = 0 , $HLIBRARY = 0 , $VWOW64 = Default
	If _WINAPI_ISWOW64PROCESS ( ) Then
		$ACALL = DllCall ( "kernel32.dll" , "bool" , "Wow64DisableWow64FsRedirection" , "ptr*" , 0 )
		If Not @error And $ACALL [ 0 ] Then $VWOW64 = $ACALL [ 1 ]
	EndIf
	Do
		$ACALL = DllCall ( "kernel32.dll" , "dword" , "SearchPathW" , "ptr" , 0 , "wstr" , $SFILEPATH , "ptr" , 0 , "dword" , 4096 , "wstr" , "" , "ptr" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$__G_VEXT = $ACALL [ 5 ]
		$IPE = _WINAPI_GETPETYPE ( $__G_VEXT )
		Switch $IPE
		Case 332
		Case 512 , 34404
	Case Else
			$IERROR = @error + 20
			ExitLoop
		EndSwitch
		$HLIBRARY = _WINAPI_LOADLIBRARYEX ( $__G_VEXT , BitOR ( $DONT_RESOLVE_DLL_REFERENCES , $LOAD_LIBRARY_AS_DATAFILE ) )
		If Not $HLIBRARY Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		If $VVER >= 1536 Then
			__ENUMDLLPROCW ( $HLIBRARY , $SMASK , $IFLAGS )
		Else
			__ENUMDLLPROCA ( $HLIBRARY , $SMASK , $IFLAGS )
		EndIf
		If @error Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
	Until 1
	If $HLIBRARY Then
		_WINAPI_FREELIBRARY ( $HLIBRARY )
	EndIf
	If Not ( $VWOW64 = Default ) Then
		DllCall ( "kernel32.dll" , "bool" , "Wow64RevertWow64FsRedirection" , "ptr*" , $VWOW64 )
	EndIf
	Return SetError ( $IERROR , $IPE , $__G_VENUM )
EndFunc
Func _WINAPI_GETAPPLICATIONRESTARTSETTINGS ( $IPID = 0 )
	If Not $IPID Then $IPID = @AutoItPID
	Local $HPROCESS = DllCall ( "kernel32.dll" , "handle" , "OpenProcess" , "dword" , ( ( _WINAPI_GETVERSION ( ) < 6.0 ) ? 1040 : 4112 ) , "bool" , 0 , "dword" , $IPID )
	If @error Or Not $HPROCESS [ 0 ] Then Return SetError ( @error + 20 , @extended , 0 )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "GetApplicationRestartSettings" , "handle" , $HPROCESS [ 0 ] , "wstr" , "" , "dword*" , 4096 , "dword*" , 0 )
	Local $IERROR , $IEXTENDED = @extended
	If @error Then
		$IERROR = @error
	ElseIf $ACALL [ 0 ] Then
		$IERROR = 10
		$IEXTENDED = $ACALL [ 0 ]
	EndIf
	DllCall ( "kernel32.dll" , "bool" , "CloseHandle" , "handle" , $HPROCESS [ 0 ] )
	If $IERROR Then Return SetError ( $IERROR , $IEXTENDED , 0 )
	Local $ARET [ 2 ]
	$ARET [ 0 ] = $ACALL [ 2 ]
	$ARET [ 1 ] = $ACALL [ 4 ]
	Return $ARET
EndFunc
Func _WINAPI_GETERRORMODE ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "GetErrorMode" )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_FATALEXIT ( $ICODE )
	DllCall ( "kernel32.dll" , "none" , "FatalExit" , "int" , $ICODE )
	If @error Then Return SetError ( @error , @extended )
EndFunc
Func _WINAPI_ISINTERNETCONNECTED ( )
	If Not __DLL ( "connect.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $ACALL = DllCall ( "connect.dll" , "long" , "IsInternetConnected" )
	If @error Then Return SetError ( @error , @extended , 0 )
	If Not ( $ACALL [ 0 ] = 0 Or $ACALL [ 0 ] = 1 ) Then
		Return SetError ( 10 , $ACALL [ 0 ] , False )
	EndIf
	Return Not $ACALL [ 0 ]
EndFunc
Func _WINAPI_ISNETWORKALIVE ( )
	If Not __DLL ( "sensapi.dll" ) Then Return SetError ( 103 , 0 , 0 )
	Local $ACALL = DllCall ( "sensapi.dll" , "bool" , "IsNetworkAlive" , "int*" , 0 )
	Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
	If $ILASTERROR Then Return SetError ( 1 , $ILASTERROR , 0 )
	If @error Or Not $ACALL [ 0 ] Then Return SetError ( @error + 10 , $ILASTERROR , 0 )
	Return $ACALL [ 1 ]
EndFunc
Func _WINAPI_NTSTATUSTODOSERROR ( $ISTATUS )
	Local $ACALL = DllCall ( "ntdll.dll" , "ulong" , "RtlNtStatusToDosError" , "long" , $ISTATUS )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_REGISTERAPPLICATIONRESTART ( $IFLAGS = 0 , $SCMD = "" )
	Local $ACALL = DllCall ( "kernel32.dll" , "long" , "RegisterApplicationRestart" , "wstr" , $SCMD , "dword" , $IFLAGS )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
Func _WINAPI_SETERRORMODE ( $IMODE )
	Local $ACALL = DllCall ( "kernel32.dll" , "uint" , "SetErrorMode" , "uint" , $IMODE )
	If @error Then Return SetError ( @error , @extended , 0 )
	Return $ACALL [ 0 ]
EndFunc
Func _WINAPI_UNIQUEHARDWAREID ( $IFLAGS = 0 )
	Local $OSERVICE = ObjGet ( "winmgmts:\\.\root\cimv2" )
	If Not IsObj ( $OSERVICE ) Then Return SetError ( 1 , 0 , "" )
	Local $OITEMS = $OSERVICE .ExecQuery ( "SELECT * FROM Win32_ComputerSystemProduct" )
	If Not IsObj ( $OITEMS ) Then Return SetError ( 2 , 0 , "" )
	Local $SHW = "" , $IEXTENDED = 0
	For $OPROPERTY In $OITEMS
		$SHW &= $OPROPERTY .IdentifyingNumber
		$SHW &= $OPROPERTY .Name
		$SHW &= $OPROPERTY .SKUNumber
		$SHW &= $OPROPERTY .UUID
		$SHW &= $OPROPERTY .Vendor
		$SHW &= $OPROPERTY .Version
	Next
	$SHW = StringStripWS ( $SHW , $STR_STRIPALL )
	If Not $SHW Then Return SetError ( 3 , 0 , "" )
	Local $STEXT
	If BitAND ( $IFLAGS , 1 ) Then
		$OITEMS = $OSERVICE .ExecQuery ( "SELECT * FROM Win32_BIOS" )
		If Not IsObj ( $OITEMS ) Then Return SetError ( 3 , 0 , "" )
		$STEXT = ""
		For $OPROPERTY In $OITEMS
			$STEXT &= $OPROPERTY .IdentificationCode
			$STEXT &= $OPROPERTY .Manufacturer
			$STEXT &= $OPROPERTY .Name
			$STEXT &= $OPROPERTY .SerialNumber
			$STEXT &= $OPROPERTY .SMBIOSMajorVersion
			$STEXT &= $OPROPERTY .SMBIOSMinorVersion
		Next
		$STEXT = StringStripWS ( $STEXT , $STR_STRIPALL )
		If $STEXT Then
			$IEXTENDED += 1
			$SHW &= $STEXT
		EndIf
	EndIf
	If BitAND ( $IFLAGS , 2 ) Then
		$OITEMS = $OSERVICE .ExecQuery ( "SELECT * FROM Win32_Processor" )
		If Not IsObj ( $OITEMS ) Then Return SetError ( 4 , 0 , "" )
		$STEXT = ""
		For $OPROPERTY In $OITEMS
			$STEXT &= $OPROPERTY .Architecture
			$STEXT &= $OPROPERTY .Family
			$STEXT &= $OPROPERTY .Level
			$STEXT &= $OPROPERTY .Manufacturer
			$STEXT &= $OPROPERTY .Name
			$STEXT &= $OPROPERTY .ProcessorId
			$STEXT &= $OPROPERTY .Revision
			$STEXT &= $OPROPERTY .Version
		Next
		$STEXT = StringStripWS ( $STEXT , $STR_STRIPALL )
		If $STEXT Then
			$IEXTENDED += 2
			$SHW &= $STEXT
		EndIf
	EndIf
	If BitAND ( $IFLAGS , 4 ) Then
		$OITEMS = $OSERVICE .ExecQuery ( "SELECT * FROM Win32_PhysicalMedia" )
		If Not IsObj ( $OITEMS ) Then Return SetError ( 5 , 0 , "" )
		$STEXT = ""
		For $OPROPERTY In $OITEMS
			Switch _WINAPI_GETDRIVEBUSTYPE ( $OPROPERTY .Tag )
			Case 3 , 11
				$STEXT &= $OPROPERTY .SerialNumber
		Case Else
			EndSwitch
		Next
		$STEXT = StringStripWS ( $STEXT , $STR_STRIPALL )
		If $STEXT Then
			$IEXTENDED += 4
			$SHW &= $STEXT
		EndIf
	EndIf
	Local $SHASH = __WINAPIDIAG_MD5 ( $SHW )
	If Not $SHASH Then Return SetError ( 6 , 0 , "" )
	Return SetExtended ( $IEXTENDED , "{" & StringMid ( $SHASH , 1 , 8 ) & "-" & StringMid ( $SHASH , 9 , 4 ) & "-" & StringMid ( $SHASH , 13 , 4 ) & "-" & StringMid ( $SHASH , 17 , 4 ) & "-" & StringMid ( $SHASH , 21 , 12 ) & "}" )
EndFunc
Func _WINAPI_UNREGISTERAPPLICATIONRESTART ( )
	Local $ACALL = DllCall ( "kernel32.dll" , "long" , "UnregisterApplicationRestart" )
	If @error Then Return SetError ( @error , @extended , 0 )
	If $ACALL [ 0 ] Then Return SetError ( 10 , $ACALL [ 0 ] , 0 )
	Return 1
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __DLGSUBCLASSPROC ( $SHWND , $IMSG , $WPARAM , $LPARAM , $IDLV , $PDATA )
	#forceref $idLV
	Switch $IMSG
	Case 78
		Local $TNMIA = DllStructCreate ( "hwnd;uint_ptr;" & ( @AutoItX64 ? "int;int" : "int" ) & ";int Item;int;uint;uint;uint;long;long;lparam;uint" , $LPARAM )
		Local $HLISTVIEW = DllStructGetData ( $TNMIA , 1 )
		Local $NMSG = DllStructGetData ( $TNMIA , 3 )
		Local $TPARAM = DllStructCreate ( "ptr;uint" , $PDATA )
		Local $IDUMMY = DllStructGetData ( $TPARAM , 2 )
		Local $HLV = DllStructGetData ( $TPARAM , 1 )
		Switch $HLISTVIEW
		Case $HLV
			Switch $NMSG
			Case + 4294967187
				Return 0
			Case + 4294967182
				If $IDUMMY Then
					GUICtrlSendToDummy ( $IDUMMY , DllStructGetData ( $TNMIA , "Item" ) )
				EndIf
				Return 0
			EndSwitch
		EndSwitch
	EndSwitch
	Return _WINAPI_DEFSUBCLASSPROC ( $SHWND , $IMSG , $WPARAM , $LPARAM )
EndFunc
Func __ENUMDLLPROCA ( $HLIBRARY , $SMASK , $IFLAGS )
	Local $HPROCESS , $PADDRESS = 0 , $IINIT = 0 , $VOPTS = Default , $IERROR = 0
	$__G_VENUM = 0
	Do
		Local $ACALL = DllCall ( "dbghelp.dll" , "dword" , "SymGetOptions" )
		If @error Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$VOPTS = $ACALL [ 0 ]
		$ACALL = DllCall ( "dbghelp.dll" , "dword" , "SymSetOptions" , "dword" , BitOR ( BitAND ( $IFLAGS , 3 ) , 516 ) )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
		$HPROCESS = _WINAPI_GETCURRENTPROCESS ( )
		$ACALL = DllCall ( "dbghelp.dll" , "int" , "SymInitialize" , "handle" , $HPROCESS , "ptr" , 0 , "int" , 1 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$IINIT = 1
		$ACALL = DllCall ( "dbghelp.dll" , "uint64" , "SymLoadModule64" , "handle" , $HPROCESS , "ptr" , 0 , "str" , $__G_VEXT , "ptr" , 0 , "uint64" , $HLIBRARY , "dword" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
		$PADDRESS = $ACALL [ 0 ]
		Dim $__G_VENUM [ 501 ] [ 2 ] = [ [ 0 ] ]
		Local $HENUMPROC = DllCallbackRegister ( "__EnumSymbolsProcA" , "int" , "ptr;ulong;lparam" )
		Local $PENUMPROC = DllCallbackGetPtr ( $HENUMPROC )
		If Not StringStripWS ( $SMASK , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SMASK = Null
		$ACALL = DllCall ( "dbghelp.dll" , "int" , "SymEnumSymbols" , "handle" , $HPROCESS , "uint64" , $PADDRESS , "str" , $SMASK , "ptr" , $PENUMPROC , "lparam" , 0 )
		If @error Or Not $ACALL [ 0 ] Or ( Not $__G_VENUM [ 0 ] [ 0 ] ) Then
			$IERROR = @error + 50
			$__G_VENUM = 0
		EndIf
		DllCallbackFree ( $HENUMPROC )
		If IsArray ( $__G_VENUM ) Then
			__INC ( $__G_VENUM , + 4294967295 )
		EndIf
	Until 1
	If $PADDRESS Then
		DllCall ( "dbghelp.dll" , "int" , "SymUnloadModule64" , "handle" , $HPROCESS , "uint64" , $PADDRESS )
	EndIf
	If $IINIT Then
		DllCall ( "dbghelp.dll" , "int" , "SymCleanup" , "handle" , $HPROCESS )
	EndIf
	If Not ( $VOPTS = Default ) Then
		DllCall ( "dbghelp.dll" , "dword" , "SymSetOptions" , "dword" , $VOPTS )
	EndIf
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return 1
EndFunc
Func __ENUMDLLPROCW ( $HLIBRARY , $SMASK , $IFLAGS )
	Local $HPROCESS , $PADDRESS = 0 , $IINIT = 0 , $VOPTS = Default , $IERROR = 0
	$__G_VENUM = 0
	Do
		Local $ACALL = DllCall ( "dbghelp.dll" , "dword" , "SymGetOptions" )
		If @error Then
			$IERROR = @error + 10
			ExitLoop
		EndIf
		$VOPTS = $ACALL [ 0 ]
		$ACALL = DllCall ( "dbghelp.dll" , "dword" , "SymSetOptions" , "dword" , BitOR ( BitAND ( $IFLAGS , 3 ) , 516 ) )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 20
			ExitLoop
		EndIf
		$HPROCESS = _WINAPI_GETCURRENTPROCESS ( )
		$ACALL = DllCall ( "dbghelp.dll" , "int" , "SymInitializeW" , "handle" , $HPROCESS , "ptr" , 0 , "int" , 1 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$IINIT = 1
		$ACALL = DllCall ( "dbghelp.dll" , "uint64" , "SymLoadModuleExW" , "handle" , $HPROCESS , "ptr" , 0 , "wstr" , $__G_VEXT , "ptr" , 0 , "uint64" , $HLIBRARY , "dword" , 0 , "ptr" , 0 , "dword" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
		$PADDRESS = $ACALL [ 0 ]
		Dim $__G_VENUM [ 501 ] [ 2 ] = [ [ 0 ] ]
		Local $HENUMPROC = DllCallbackRegister ( "__EnumSymbolsProcW" , "int" , "ptr;ulong;lparam" )
		Local $PENUMPROC = DllCallbackGetPtr ( $HENUMPROC )
		If Not StringStripWS ( $SMASK , $STR_STRIPLEADING + $STR_STRIPTRAILING ) Then $SMASK = Null
		$ACALL = DllCall ( "dbghelp.dll" , "int" , "SymEnumSymbolsW" , "handle" , $HPROCESS , "uint64" , $PADDRESS , "wstr" , $SMASK , "ptr" , $PENUMPROC , "lparam" , 0 )
		If @error Or Not $ACALL [ 0 ] Or Not $__G_VENUM [ 0 ] [ 0 ] Then
			$IERROR = @error + 50
			$__G_VENUM = 0
		EndIf
		DllCallbackFree ( $HENUMPROC )
		If IsArray ( $__G_VENUM ) Then
			__INC ( $__G_VENUM , + 4294967295 )
		EndIf
	Until 1
	If $PADDRESS Then
		DllCall ( "dbghelp.dll" , "int" , "SymUnloadModule64" , "handle" , $HPROCESS , "uint64" , $PADDRESS )
	EndIf
	If $IINIT Then
		DllCall ( "dbghelp.dll" , "int" , "SymCleanup" , "handle" , $HPROCESS )
	EndIf
	If Not ( $VOPTS = Default ) Then
		DllCall ( "dbghelp.dll" , "dword" , "SymSetOptions" , "dword" , $VOPTS )
	EndIf
	If $IERROR Then Return SetError ( $IERROR , 0 , 0 )
	Return 1
EndFunc
Func __ENUMSYMBOLSPROCA ( $PSYMINFO , $ISYMSIZE , $LPARAM )
	#forceref $iSymSize, $lParam
	Local $TAGSYMBOL_INFO = "uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag;uint NameLen;uint MaxNameLen;wchar Name[1]"
	Local $TSYMINFO = DllStructCreate ( $TAGSYMBOL_INFO , $PSYMINFO )
	Local $ILENGTH = DllStructGetData ( $TSYMINFO , "NameLen" )
	If $ILENGTH And BitAND ( DllStructGetData ( $TSYMINFO , "Flags" ) , 1536 ) Then
		__INC ( $__G_VENUM , 500 )
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TSYMINFO , "Address" ) - DllStructGetData ( $TSYMINFO , "ModBase" )
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( DllStructCreate ( "char[" & ( $ILENGTH + 1 ) & "]" , DllStructGetPtr ( $TSYMINFO , "Name" ) ) , 1 )
	EndIf
	Return 1
EndFunc
Func __ENUMSYMBOLSPROCW ( $PSYMINFO , $ISYMSIZE , $LPARAM )
	#forceref $iSymSize, $lParam
	Local $TAGSYMBOL_INFO = "uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag;uint NameLen;uint MaxNameLen;wchar Name[1]"
	Local $TSYMINFO = DllStructCreate ( $TAGSYMBOL_INFO , $PSYMINFO )
	Local $ILENGTH = DllStructGetData ( $TSYMINFO , "NameLen" )
	If $ILENGTH And BitAND ( DllStructGetData ( $TSYMINFO , "Flags" ) , 1536 ) Then
		__INC ( $__G_VENUM , 500 )
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 0 ] = DllStructGetData ( $TSYMINFO , "Address" ) - DllStructGetData ( $TSYMINFO , "ModBase" )
		$__G_VENUM [ $__G_VENUM [ 0 ] [ 0 ] ] [ 1 ] = DllStructGetData ( DllStructCreate ( "wchar[" & ( $ILENGTH + 1 ) & "]" , DllStructGetPtr ( $TSYMINFO , "Name" ) ) , 1 )
	EndIf
	Return 1
EndFunc
Func __WINAPIDIAG_HEX ( $IVALUE , $STYPE )
	Local $ILENGTH
	Switch $STYPE
	Case "BYTE" , "BOOLEAN"
		$ILENGTH = 2
	Case "WORD" , "USHORT" , "short"
		$ILENGTH = 4
	Case "BOOL" , "UINT" , "ULONG" , "DWORD" , "int" , "long"
		$ILENGTH = 8
	Case "INT64" , "UINT64"
		$ILENGTH = 16
	Case "INT_PTR" , "UINT_PTR" , "LONG_PTR" , "ULONG_PTR" , "DWORD_PTR" , "WPARAM" , "LPARAM" , "LRESULT"
		$ILENGTH = ( @AutoItX64 ? 16 : 8 )
Case Else
		$ILENGTH = 0
	EndSwitch
	If $ILENGTH Then
		Return "0x" & Hex ( $IVALUE , $ILENGTH )
	Else
		Return $IVALUE
	EndIf
EndFunc
Func __WINAPIDIAG_MD5 ( $SDATA )
	Local $HHASH , $IERROR = 0
	Local $HPROV = DllCall ( "advapi32.dll" , "int" , "CryptAcquireContextW" , "ptr*" , 0 , "ptr" , 0 , "ptr" , 0 , "dword" , 3 , "dword" , 4026531840 )
	If @error Or Not $HPROV [ 0 ] Then Return SetError ( @error + 10 , @extended , "" )
	Do
		$HHASH = DllCall ( "advapi32.dll" , "int" , "CryptCreateHash" , "handle" , $HPROV [ 1 ] , "uint" , 32771 , "ptr" , 0 , "dword" , 0 , "ptr*" , 0 )
		If @error Or Not $HHASH [ 0 ] Then
			$IERROR = @error + 20
			$HHASH = 0
			ExitLoop
		EndIf
		$HHASH = $HHASH [ 5 ]
		Local $TDATA = DllStructCreate ( "byte[" & BinaryLen ( $SDATA ) & "]" )
		DllStructSetData ( $TDATA , 1 , $SDATA )
		Local $ACALL = DllCall ( "advapi32.dll" , "int" , "CryptHashData" , "handle" , $HHASH , "struct*" , $TDATA , "dword" , DllStructGetSize ( $TDATA ) , "dword" , 1 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 30
			ExitLoop
		EndIf
		$TDATA = DllStructCreate ( "byte[16]" )
		$ACALL = DllCall ( "advapi32.dll" , "int" , "CryptGetHashParam" , "handle" , $HHASH , "dword" , 2 , "struct*" , $TDATA , "dword*" , 16 , "dword" , 0 )
		If @error Or Not $ACALL [ 0 ] Then
			$IERROR = @error + 40
			ExitLoop
		EndIf
	Until 1
	If $HHASH Then
		DllCall ( "advapi32.dll" , "int" , "CryptDestroyHash" , "handle" , $HHASH )
	EndIf
	If $IERROR Then Return SetError ( $IERROR , 0 , "" )
	Return StringTrimLeft ( DllStructGetData ( $TDATA , 1 ) , 2 )
EndFunc
Func __WINAPIDIAG_QUIT ( )
	Local $PDLL = DllCallbackGetPtr ( $__G_HFRDLL )
	If $PDLL Then
		_WINAPI_REMOVEWINDOWSUBCLASS ( $__G_HFRDLG , $PDLL , 1000 )
		DllCallbackFree ( $__G_HFRDLL )
	EndIf
	$__G_HFRDLL = 0
EndFunc
Func __WINAPIDIAG_VER ( $SPATH )
	Local $HLIBRARY = _WINAPI_GETMODULEHANDLE ( $SPATH )
	If Not $HLIBRARY Then Return SetError ( @error + 10 , @extended , 0 )
	$SPATH = _WINAPI_GETMODULEFILENAMEEX ( _WINAPI_GETCURRENTPROCESS ( ) , $HLIBRARY )
	If Not $SPATH Then Return SetError ( @error + 20 , @extended , 0 )
	Local $VVER = FileGetVersion ( $SPATH )
	If @error Then Return SetError ( 1 , 0 , 0 )
	$VVER = StringSplit ( $VVER , "." , $STR_NOCOUNT )
	If UBound ( $VVER ) < 2 Then Return SetError ( 2 , 0 , 0 )
	Return BitOR ( BitShift ( Number ( $VVER [ 0 ] ) , + 4294967288 ) , Number ( $VVER [ 1 ] ) )
EndFunc
#EndRegion Internal Functions
Global $__GH_DLL_AIRL = + 4294967295 , $__GH_DLL_IRL = 0
Global $__G_PIR_OPENCLGETPLATFORM , $__G_PIR_OPENCLGETDEVICE , $__G_PIR_OPENCLFREE , $__G_PIR_FREERESULT
Global $__G_O_CALLBACKFUNCTION
Global Const $__G_T_STRUCTTYPE = "struct" & ( @AutoItX64 ? "*" : "" )
Global Const $__G_SZ_STRUCTSIZE = ( @AutoItX64 ? 120 : 112 )
#IR_WinCapture flags
Enum $IR_SNAP_NORMAL , $IR_SNAP_CLIENTONLY , $IR_SNAP_RENDERFULLCONTENT
#ErrorCode
Enum $IR_OK , $IR_ERROR_UNKNOWN , $IR_ERROR_NOT_ENOUGH_MEMORY , $IR_ERROR_LOADING , $IR_ERROR_OBJECT , $IR_ERROR_DIMENSIONS , $IR_ERROR_NOT_AVAILABLE , $IR_ERROR_OCL_NOT_AVAILABLE , $IR_ERROR_OCL_NOT_INITIALIZED , $IR_ERROR_OCL_NO_SEARCH_IN_SET , $IR_ERROR_OCL_NO_SEARCH_FOR_SET , $IR_ERROR_NO_SEARCH_QUEUE_SET , $IR_ERROR_OCL_SET_SEARCH_IN , $IR_ERROR_OCL_SET_SEARCH_FOR , $IR_ERROR_NO_LOAD_QUEUE_SET , $IR_ERROR_NO_MATCH
#Status types
Enum $IR_STATUS_PROGRESS
#Status types
Enum $IR_OCL_LOAD_IN , $IR_OCL_LOAD_FOR
#Input For Loading
Enum $IR_LOAD_UNKNOWN = 0 , $IR_LOAD_RESAMPLE = 1 , $IR_LOAD_IMAGEPATH = 2 , $IR_LOAD_IMAGEBINARY = 4 , $IR_LOAD_IMAGEHANDE = 8
#Compare type modes
Enum $IR_COMPARE_TYPE_EXACT , $IR_COMPARE_TYPE_RELATIVE_ARGB , $IR_COMPARE_TYPE_RELATIVE_AHSL , $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA , $IR_COMPARE_TYPE_RELATIVE_AHSL_ALPHA
#Pre-process types
Enum $IR_PROCESS_TYPE_NONE , $IR_PROCESS_TYPE_RESAMPLE
#Pre-process resample modes
Enum $IR_RESAMPLER_NONE = + 4294967295 , $IR_RESAMPLER_BOX , $IR_RESAMPLER_BICUBIC , $IR_RESAMPLER_BILINEAR , $IR_RESAMPLER_BSPLINE , $IR_RESAMPLER_CATMULLROM , $IR_RESAMPLER_LANCZOS3
#Auto unload after comparing
Enum $IR_UNLOAD_NONE , $IR_UNLOAD_IMAGESOURCE , $IR_UNLOAD_IMAGEFIND , $IR_UNLOAD_ALL
#Image set transparency for pixels range
Enum $IR_PIXTRANS_RANGE , $IR_PIXTRANS_TOLERANCE , $IR_PIXTRANS_SAMPLE
#Compute Core Count
Global Const $IR_RTX_2060 = 1920 , $IR_RTX_2070 = 2560 , $IR_RTX_2080 = 4352 , $IR_RTX_3080 = 8704 , $IR_RTX_3090 = 10496
Global Const $SIRCREATEOBJECTPARAMETERS = "long ProcessType;" & "long W;" & "long H;" & "long Resampler"
Global Const $SIROBJECT = "long Status;" & "ptr File;" & "ptr pImageObject;" & "byte GUID[16];" & "long W;" & "long H;" & "long Resample_W;" & "long Resample_H;" & "ptr IsResampler"
Global Const $SIRPROCESSPARAMETERS = StringReplace ( "---------------------------------------------------------------------" & "long CompareType;" & "byte ColorTolerance_A;" & "byte ColorTolerance_R;" & "byte ColorTolerance_G;" & "byte ColorTolerance_B;" & "double ColorTolerance_A;" & "double ColorTolerance_H;" & "double ColorTolerance_S;" & "double ColorTolerance_L;" & "long PixelTolerance;" & "---------------------------------------------------------------------" & "long StretchCompare;" & "long MinimalStretchSize_W;" & "long MinimalStretchSize_H;" & "long MaximalStretchSize_W;" & "long MaximalStretchSize_H;" & "long StretchResample;" & "---------------------------------------------------------------------" & "long MaxMatches;" & "long FilterTresholdX;" & "long FilterTresholdY;" & "long MultiThreadedProcessing;" & "long MultiThreadCount;" & "ptr StatusCallback;" & "---------------------------------------------------------------------" & "long RotateSearch;" & "float RotateSearchStartDegrees;" & "float RotateSearchEndDegrees;" & "float RotateSearchStepDegrees;" & "long SearchSorroundingPixels;" & "---------------------------------------------------------------------" & "long EnableOpenCL;" & "long PlaformIndex;" & "long DeviceIndex;" & "long ComputeCoreCount;" & "---------------------------------------------------------------------" & "long AutoUnload" , "---------------------------------------------------------------------" , "" )
Global $SIRRESULT = "long Success;" & "long MatchCount;" & "ptr MatchPointer"
Global Const $SIRRESULTMATCHES = "long X;" & "long Y;" & "long W;" & "long H;" & "float Angle;" & "long Difference;" & "float MatchPercentage"
Global Const $SIROCLDEVICE = "ptr Instance;" & "long PlatformIndex;" & "long DeviceIndex"
Func IR_STARTUP ( $SDLL_PATH = Default , $AIRL_NAME = "AIRL.dll" , $IRL_NAME = "ImageRecognition.dll" )
	If Not IsString ( $SDLL_PATH ) Or $SDLL_PATH = "" Then $SDLL_PATH = @ScriptDir & "\IRL" & ( @AutoItX64 ? "64" : "32" )
	Local $RET = DllCall ( "kernel32.dll" , "dword" , "GetFullPathNameW" , "wstr" , $SDLL_PATH , "dword" , 4096 , "wstr" , "" , "ptr" , 0 )
	If @error Or Not $RET [ 0 ] Then Exit MsgBox ( 16 , "Fatal Error" , "Could not try convert """ & $SDLL_PATH & """ to full path" )
	$SDLL_PATH = $RET [ 3 ]
	If Not FileExists ( $SDLL_PATH & "\" & $AIRL_NAME ) Then Exit MsgBox ( 16 , "Fatal Error" , "Not found " & $AIRL_NAME )
	If Not FileExists ( $SDLL_PATH & "\" & $IRL_NAME ) Then Exit MsgBox ( 16 , "Fatal Error" , "Not found " & $IRL_NAME )
	$__GH_DLL_AIRL = DllOpen ( $SDLL_PATH & "\" & $AIRL_NAME )
	If @error Or $__GH_DLL_AIRL = + 4294967295 Then Exit MsgBox ( 16 , "Fatal Error" , "Could not open " & $AIRL_NAME )
	OnAutoItExitRegister ( IR_SHUTDOWN )
	$RET = DllCall ( $__GH_DLL_AIRL , "handle" , "AIRL_InitLibrary" , "wstr" , $SDLL_PATH , "wstr" , $IRL_NAME )
	If @error Or Not $RET [ 0 ] Then Exit MsgBox ( 16 , "Fatal Error" , "Could not Initilize " & $IRL_NAME )
	$__GH_DLL_IRL = $RET [ 0 ]
	$__G_PIR_FREERESULT = __IR_FUNCTIONADDRESS ( "ImageRecognition_FreeResult" )
	$__G_PIR_OPENCLGETPLATFORM = __IR_FUNCTIONADDRESS ( "ImageRecognition_OpenCLGetPlatform" )
	$__G_PIR_OPENCLGETDEVICE = __IR_FUNCTIONADDRESS ( "ImageRecognition_OpenCLGetPlatformDevice" )
	$__G_PIR_OPENCLFREE = __IR_FUNCTIONADDRESS ( "ImageRecognition_OpenCLFree" )
	If Not @Compiled Then ConsoleWrite ( @CRLF )
EndFunc
Func IR_SHUTDOWN ( )
	DllCall ( $__GH_DLL_AIRL , "long" , "AIRL_CloseLibrary" )
	DllClose ( $__GH_DLL_AIRL )
	$__GH_DLL_AIRL = + 4294967295
	$__GH_DLL_IRL = 0
EndFunc
Func IR_IMAGE_LOAD ( $FILEPATH_OR_BINARY_OR_HHBITMAP , $RESAMPLE_MODE = False , $RESAMPLE_WIDTH = Default , $RESAMPLE_HEIGHT = Default )
	If $__GH_DLL_AIRL < 1 Then Exit MsgBox ( 16 , "Fatal Error" , """IR_StartUp"" function has not been initialized or has failed to initialize" )
	Local Static $INPUTTYPE = 0 , $DATAPOINTER = Ptr ( 0 ) , $DATASIZE = 0 , $HHBITMAP = Ptr ( 0 )
	Local $FILEPATH = ""
	# Kim tra u vo
	If IsBinary ( $FILEPATH_OR_BINARY_OR_HHBITMAP ) Then
		$INPUTTYPE = $IR_LOAD_IMAGEBINARY
		$DATASIZE = BinaryLen ( $FILEPATH_OR_BINARY_OR_HHBITMAP )
		Local $TIMAGE = DllStructCreate ( "byte[" & $DATASIZE & "]" )
		DllStructSetData ( $TIMAGE , 1 , $FILEPATH_OR_BINARY_OR_HHBITMAP )
		$DATAPOINTER = DllStructGetPtr ( $TIMAGE )
		$FILEPATH = "TBitmap:" & $DATAPOINTER & ";Size:" & $DATASIZE
	ElseIf IsPtr ( $FILEPATH_OR_BINARY_OR_HHBITMAP ) Then
		$INPUTTYPE = $IR_LOAD_IMAGEHANDE
		$HHBITMAP = $FILEPATH_OR_BINARY_OR_HHBITMAP
		$FILEPATH = "HBitmap:" & $HHBITMAP
	ElseIf FileExists ( $FILEPATH_OR_BINARY_OR_HHBITMAP ) Then
		$INPUTTYPE = $IR_LOAD_IMAGEPATH
		$FILEPATH = $FILEPATH_OR_BINARY_OR_HHBITMAP
	Else
		$INPUTTYPE = $IR_LOAD_UNKNOWN
		If Not @Compiled Then ConsoleWrite ( "!-> Input image: """ & $FILEPATH_OR_BINARY_OR_HHBITMAP & """ could not load successfully. Please check it." & @CRLF )
		Return SetError ( + 4294967295 , 0 , 0 )
	EndIf
	# Ci t tham s cho vic load nh
	Local $TIRIMAGEPARAMETERS = DllStructCreate ( $SIRCREATEOBJECTPARAMETERS )
	If Not IsNumber ( $RESAMPLE_MODE ) Or $RESAMPLE_MODE < 0 Then $RESAMPLE_MODE = $IR_RESAMPLER_NONE
	With $TIRIMAGEPARAMETERS
	.ProcessType = ( $RESAMPLE_MODE = $IR_RESAMPLER_NONE ? $IR_PROCESS_TYPE_NONE : $IR_PROCESS_TYPE_RESAMPLE )
	.Resampler = $RESAMPLE_MODE
	.W = $RESAMPLE_WIDTH
	.H = $RESAMPLE_HEIGHT
	If .W = 0 And .H = 0 Then .ProcessType = $IR_PROCESS_TYPE_NONE
	EndWith
	# To Struct nhn object nh
	Local $TIROBJECT = DllStructCreate ( $SIROBJECT )
	$TIROBJECT .IsResampler = $TIRIMAGEPARAMETERS .ProcessType
	# Khi to
	Local $RET = DllCall ( $__GH_DLL_AIRL , "long" , "AIRL_LoadImage" , "uint" , $INPUTTYPE , "wstr" , $FILEPATH , "ptr" , $DATAPOINTER , "uint64" , $DATASIZE , "handle" , $HHBITMAP , "struct*" , $TIROBJECT , $__G_T_STRUCTTYPE , $TIRIMAGEPARAMETERS )
	If @error Then Return SetError ( + 4294967294 , 0 , 0 )
	If $RET [ 0 ] = $IR_OK Then
		If Not @Compiled Then ConsoleWrite ( "-> Input image: """ & $FILEPATH & """ | Output: ImgObj=" & $TIROBJECT .pImageObject & " , W=" & $TIROBJECT .W & " , H=" & $TIROBJECT .H & @CRLF )
		If $INPUTTYPE <> $IR_LOAD_IMAGEPATH Then
			$TIROBJECT .File = _WINAPI_CREATESTRING ( $FILEPATH )
		EndIf
		Return $TIROBJECT
	Else
		If Not @Compiled Then ConsoleWrite ( "-> Input image: """ & $FILEPATH & """ could not load successfully" & @CRLF )
		Return SetError ( $RET [ 0 ] , 0 , 0 )
	EndIf
EndFunc
Func IR_IMAGE_UNLOAD ( ByRef $TIRIMAGE )
	If Not IsDllStruct ( $TIRIMAGE ) Then Return SetError ( 1 , 0 , False )
	If IsPtr ( $TIRIMAGE .File ) Then
		Local $FILEINFO = _WINAPI_GETSTRING ( $TIRIMAGE .File )
		If StringInStr ( $FILEINFO , "HBitmap:" ) Then
			_WINAPI_DELETEOBJECT ( Ptr ( StringTrimLeft ( $FILEINFO , 8 ) ) )
		ElseIf StringInStr ( $FILEINFO , "TBitmap:" ) Then
			Local $PBITMAP = StringRegExp ( $FILEINFO , "TBitmap:(0x[[:xdigit:]]+);Size:(\d+)" , 3 )
			If Not @error Then _WINAPI_ZEROMEMORY ( Ptr ( $PBITMAP [ 0 ] ) , Number ( $PBITMAP [ 1 ] ) )
			$PBITMAP = Null
		EndIf
		$TIRIMAGE .File = Null
	EndIf
	Local $RET = DllCall ( $__GH_DLL_AIRL , "int" , "AIRL_UnLoadImage" , "struct*" , $TIRIMAGE )
	If @error Or $RET [ 0 ] <> $IR_OK Then Return SetError ( 2 , 0 , False )
	$TIRIMAGE = Null
	Return True
EndFunc
Func IR_COMPARE_PARAMETERS ( $OPTIONS = Null )
	If $__GH_DLL_AIRL < 1 Then Exit MsgBox ( 16 , "Fatal Error" , """IR_StartUp"" function has not been initialized or has failed to initialize" )
	Local $TIRPROCESSPARAMETERS = DllStructCreate ( $SIRPROCESSPARAMETERS )
	If $OPTIONS == Default Then
		With $TIRPROCESSPARAMETERS
		.MaxMatches = + 4294967295
		.MultiThreadedProcessing = True
		.ColorTolerance_A = 15
		.ColorTolerance_R = 15
		.ColorTolerance_G = 15
		.ColorTolerance_B = 15
		.PixelTolerance = 1
		EndWith
	EndIf
	Return $TIRPROCESSPARAMETERS
EndFunc
Func IR_COMPARE ( $TIRIMAGE_SOURCE , $TIRIMAGE_FIND , $TIRPROCESSPARAMETERS , $USERDATA = 0 )
	#Khai bo cc bin tnh
	Local Static $TIRRESULT = DllStructCreate ( $SIRRESULT )
	Local Static $TIROPENCL_DEFAULT = DllStructCreate ( $SIROCLDEVICE )
	Local Static $ATIRRESULTERROR [ 1 ] = [ 0 ]
	Local $TIROPENCL = $TIROPENCL_DEFAULT
	#Kim tra u vo
	If Not IsDllStruct ( $TIRIMAGE_SOURCE ) Then Return SetError ( + 4294967295 , 0 , $ATIRRESULTERROR )
	If Not IsDllStruct ( $TIRIMAGE_FIND ) Then Return SetError ( + 4294967294 , 0 , $ATIRRESULTERROR )
	If Not IsDllStruct ( $TIRPROCESSPARAMETERS ) Then Return SetError ( + 4294967293 , 0 , $ATIRRESULTERROR )
	#Kim tra cc tham s chun b cho Compare
	With $TIRPROCESSPARAMETERS
	If .CompareType <> $IR_COMPARE_TYPE_EXACT And Mod ( .CompareType , 2 ) = 0 Then
		DllStructSetData ( $TIRPROCESSPARAMETERS , 6 , .ColorTolerance_A )
	EndIf
	If .CompareType = $IR_COMPARE_TYPE_EXACT And ( $TIRIMAGE_SOURCE .IsResampler + $TIRIMAGE_FIND .IsResampler > 0 ) Then
		If Not @Compiled Then ConsoleWrite ( @CRLF & "![Warning] Resample Mode is not supported with IR_COMPARE_TYPE_EXACT type" & @CRLF )
	EndIf
	If .RotateSearch = True And .CompareType <> $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA Then
		.RotateSearch = False
		If Not @Compiled Then ConsoleWrite ( @CRLF & "![Warning] RotateSearch is supported with ONLY IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA type" & @CRLF )
	EndIf
	If .EnableOpenCL = True Then
		If .ComputeCoreCount <= 1 Then .ComputeCoreCount = $IR_RTX_2060
		Local Static $TIROPENCL_SESSION = ObjCreate ( "{EE09B103-97E0-11CF-978F-00A02463E06F}" )
		If IsObj ( $TIROPENCL_SESSION ) Then
			Local $TIROPENCL_NAME = StringFormat ( "{%s-%s-%s-%s}" , .PlaformIndex , .DeviceIndex , .CompareType , .RotateSearch )
			Select
			Case $TIROPENCL_SESSION .Exists ( "Session:" & $TIROPENCL_NAME ) And IsDllStruct ( $TIROPENCL_SESSION ( "Session:" & $TIROPENCL_NAME ) )
				If $TIROPENCL_SESSION ( "ComCore:" & $TIROPENCL_NAME ) <> .ComputeCoreCount Then
					IR_OPENCL_FREE ( $TIROPENCL_SESSION ( "Session:" & $TIROPENCL_NAME ) )
					ContinueCase
				EndIf
		Case Else
				$TIROPENCL_SESSION ( "Session:" & $TIROPENCL_NAME ) = IR_OPENCL_INIT ( .PlaformIndex , .DeviceIndex , .CompareType , .RotateSearch , .ComputeCoreCount )
				If $TIROPENCL_SESSION ( "Session:" & $TIROPENCL_NAME ) == 0 Then $TIROPENCL_SESSION ( "Session:" & $TIROPENCL_NAME ) = $TIROPENCL_DEFAULT
				$TIROPENCL_SESSION ( "ComCore:" & $TIROPENCL_NAME ) = .ComputeCoreCount
			EndSelect
			$TIROPENCL = $TIROPENCL_SESSION ( "Session:" & $TIROPENCL_NAME )
		Else
			Local Static $TIROPENCL_PREV
			If IsDllStruct ( $TIROPENCL_PREV ) Then IR_OPENCL_FREE ( $TIROPENCL_PREV )
			$TIROPENCL_PREV = IR_OPENCL_INIT ( .PlaformIndex , .DeviceIndex , .CompareType , .RotateSearch , .ComputeCoreCount )
			$TIROPENCL = $TIROPENCL_PREV
		EndIf
	EndIf
	EndWith
	#Chuyn $TIRProcessParameters v nh dng chun
	Local $TIRPROCESSPARAMETERS_STANDARD = DllStructCreate ( "byte[" & $__G_SZ_STRUCTSIZE & "]" )
	DllCall ( "ntdll.dll" , "none" , "RtlMoveMemory" , "struct*" , $TIRPROCESSPARAMETERS_STANDARD , "struct*" , $TIRPROCESSPARAMETERS , "ulong_ptr" , $__G_SZ_STRUCTSIZE )
	#Compare
	Local $RET = DllCall ( $__GH_DLL_AIRL , "int" , "AIRL_Compare" , "struct*" , $TIRIMAGE_SOURCE , "struct*" , $TIRIMAGE_FIND , "struct*" , $TIRPROCESSPARAMETERS_STANDARD , "struct*" , $TIROPENCL , "struct*" , $TIRRESULT , "ptr" , $USERDATA )
	If @error Then Return SetError ( + 4294967292 , @error , $ATIRRESULTERROR )
	If $RET [ 0 ] <> $IR_OK Then Return SetError ( $RET [ 0 ] , 0 , $ATIRRESULTERROR )
	#Auto unload sau khi compare thnh cng
	Switch $TIRPROCESSPARAMETERS .AutoUnload
	Case $IR_UNLOAD_ALL
		IR_IMAGE_UNLOAD ( $TIRIMAGE_SOURCE )
		IR_IMAGE_UNLOAD ( $TIRIMAGE_FIND )
	Case $IR_UNLOAD_IMAGESOURCE
		IR_IMAGE_UNLOAD ( $TIRIMAGE_SOURCE )
	Case $IR_UNLOAD_IMAGEFIND
		IR_IMAGE_UNLOAD ( $TIRIMAGE_FIND )
	EndSwitch
	#Ghi kt qu vo mt mng
	If $TIRRESULT .MatchCount = 0 Then Return SetError ( $IR_ERROR_NO_MATCH , 0 , $ATIRRESULTERROR )
	Local $ATIRRESULT [ $TIRRESULT .MatchCount + 1 ] = [ $TIRRESULT .MatchCount ]
	For $I = 1 To $ATIRRESULT [ 0 ]
		$ATIRRESULT [ $I ] = DllStructCreate ( $SIRRESULTMATCHES , $TIRRESULT .MatchPointer + 28 * ( $I + 4294967295 ) )
	Next
	Return SetExtended ( $ATIRRESULT [ 0 ] , $ATIRRESULT )
EndFunc
Func IR_COMPARE_FREERESULT ( ByRef $ATIRRESULT )
	If $__G_PIR_FREERESULT = 0 Then Return SetError ( 1 , 0 , False )
	If Not IsArray ( $ATIRRESULT ) Then Return SetError ( 2 , 0 , False )
	Local $ERROR = 0
	For $I = 1 To $ATIRRESULT [ 0 ]
		If IsDllStruct ( $ATIRRESULT [ $I ] ) Then
			Local $RET = DllCallAddress ( "long" , $__G_PIR_FREERESULT , "struct*" , $ATIRRESULT [ $I ] )
			If @error Or $RET [ 0 ] <> $IR_OK Then $ERROR += 1
			_WINAPI_ZEROMEMORY ( $ATIRRESULT [ $I ] , DllStructGetSize ( $ATIRRESULT [ $I ] ) )
		EndIf
		$ATIRRESULT [ $I ] = Null
	Next
	$ATIRRESULT = Null
	Return SetError ( $ERROR , 0 , $ERROR = 0 )
EndFunc
Func IR_COMPARE_TEST ( $TIRIMAGE_SOURCE , $ATIRRESULT , $TITLE = "" )
	Opt ( "GUIOnEventMode" , 0 )
	If Not IsDllStruct ( $TIRIMAGE_SOURCE ) Then Return SetError ( 1 , MsgBox ( 16 , "Error/IR_Compare_Test" , "$TIRImage_Source does not exist" ) )
	If Not IsArray ( $ATIRRESULT ) Then Return SetError ( 2 , MsgBox ( 16 , "Error/IR_Compare_Test" , "$aTIRResult does not exist" ) )
	If $ATIRRESULT [ 0 ] = 0 Then Return SetError ( 3 , MsgBox ( 48 , "IR_Compare_Test" , "No match" ) )
	_GDIPLUS_STARTUP ( )
	Local $FILEINFO = _WINAPI_GETSTRING ( $TIRIMAGE_SOURCE .File )
	If StringInStr ( $FILEINFO , "HBitmap:" ) Then
		Local $HHBITMAP = Ptr ( StringTrimLeft ( $FILEINFO , 8 ) )
		Local $HIMAGE = _GDIPLUS_BITMAPCREATEFROMHBITMAP ( $HHBITMAP )
	ElseIf StringInStr ( $FILEINFO , "TBitmap:" ) Then
		Local $PBITMAP = StringRegExp ( $FILEINFO , "TBitmap:(0x[[:xdigit:]]+);Size:(\d+)" , 3 )
		If Not @error Then
			Local $TIMAGE = DllStructCreate ( "byte[" & Number ( $PBITMAP [ 1 ] ) & "]" , Ptr ( $PBITMAP [ 0 ] ) )
			Local $HIMAGE = _GDIPLUS_BITMAPCREATEFROMMEMORY ( DllStructGetData ( $TIMAGE , 1 ) )
		Else
			SetError ( 1 )
		EndIf
	Else
		Local $HIMAGE = _GDIPLUS_IMAGELOADFROMFILE ( $FILEINFO )
	EndIf
	If @error Then Return SetError ( 4 , MsgBox ( 16 , "Error/IR_Compare_Test" , "Could not create Bitmap from $TIRImage_Source" ) )
	Local $WIDTH = $TIRIMAGE_SOURCE .Resample_W
	Local $HEIGHT = $TIRIMAGE_SOURCE .Resample_H
	Local $SCALE , $COORDINATE
	If $WIDTH >= @DesktopWidth Or $HEIGHT >= @DesktopHeight + 4294967266 Then
		Local $DIV = 20
		For $I = $DIV To 1 Step + 4294967295
			If $WIDTH * ( $I / $DIV ) < @DesktopWidth And $HEIGHT * ( $I / $DIV ) < @DesktopHeight + 4294967266 Then
				$SCALE = $I / $DIV
				ExitLoop
			EndIf
		Next
	ElseIf $WIDTH <= 150 And $HEIGHT < 150 Then
		$SCALE = 4
	Else
		$SCALE = 1
	EndIf
	Local $HGUI = GUICreate ( $TITLE == "" ? "IR_Compare_Test" : $TITLE , $WIDTH * $SCALE , $HEIGHT * $SCALE , + 4294967295 , + 4294967295 , 13107200 , 8 )
	GUISetState ( @SW_SHOW )
	Local $HGRAPHICS = _GDIPLUS_GRAPHICSCREATEFROMHWND ( $HGUI )
	Local $HBRUSH = _GDIPLUS_BRUSHCREATESOLID ( 1090518784 )
	Local $HPEN = _GDIPLUS_PENCREATE ( 4294901760 )
	_GDIPLUS_GRAPHICSDRAWIMAGERECT ( $HGRAPHICS , $HIMAGE , 0 , 0 , $WIDTH * $SCALE , $HEIGHT * $SCALE )
	For $I = 1 To $ATIRRESULT [ 0 ]
		_GDIPLUS_GRAPHICSFILLRECT ( $HGRAPHICS , $ATIRRESULT [ $I ] .X * $SCALE , $ATIRRESULT [ $I ] .Y * $SCALE , $ATIRRESULT [ $I ] .W * $SCALE + 4294967295 , $ATIRRESULT [ $I ] .H * $SCALE + 4294967295 , $HBRUSH )
		_GDIPLUS_GRAPHICSDRAWRECT ( $HGRAPHICS , $ATIRRESULT [ $I ] .X * $SCALE , $ATIRRESULT [ $I ] .Y * $SCALE , $ATIRRESULT [ $I ] .W * $SCALE + 4294967295 , $ATIRRESULT [ $I ] .H * $SCALE + 4294967295 , $HPEN )
		$COORDINATE = "(" & $ATIRRESULT [ $I ] .X & ", " & $ATIRRESULT [ $I ] .Y & ( $ATIRRESULT [ $I ] .Angle ? ", " & $ATIRRESULT [ $I ] .Angle & "" : "" ) & ")"
		_GDIPLUS_GRAPHICSDRAWSTRING ( $HGRAPHICS , $COORDINATE , $ATIRRESULT [ $I ] .X * $SCALE , $ATIRRESULT [ $I ] .Y * $SCALE + 4294967281 , "Arial" , 9 )
	Next
	While GUIGetMsg ( ) <> + 4294967293
		Sleep ( 20 )
	WEnd
	Opt ( "GUIOnEventMode" , 1 )
	_GDIPLUS_GRAPHICSDISPOSE ( $HGRAPHICS )
	_GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
	_GDIPLUS_BRUSHDISPOSE ( $HBRUSH )
	_GDIPLUS_PENDISPOSE ( $HPEN )
	GUIDelete ( $HGUI )
EndFunc
Func IR_OPENCL_INFO ( )
	If $__GH_DLL_AIRL < 1 Or $__GH_DLL_IRL < 1 Then Exit MsgBox ( 16 , "Fatal Error" , """IR_StartUp"" function has not been initialized or has failed to initialize" )
	Local $PLATFORM , $DEVICE , $SRET = ""
	For $INDEXPLATFORM = 0 To 9999999
		$PLATFORM = IR_OPENCL_GETPLATFORMS ( $INDEXPLATFORM )
		If Not $PLATFORM Then ExitLoop
		$SRET &= "[" & $INDEXPLATFORM & "] " & $PLATFORM & @CRLF
		For $INDEXDEVICE = 0 To 9999999
			$DEVICE = IR_OPENCL_GETDEVICES ( $INDEXPLATFORM , $INDEXDEVICE )
			If Not $DEVICE Then ExitLoop
			$SRET &= "__ [" & $INDEXDEVICE & "] " & $DEVICE & @CRLF
		Next
		$SRET &= @CRLF
	Next
	If $SRET = "" Or Not StringInStr ( $SRET , "__ [0]" ) Then SetError ( 1 , 0 , $SRET )
	Return $SRET
EndFunc
Func IR_COMPARE_CALLBACKCREATE ( $FUNCTIONCALLBACK )
	If Not ObjName ( $__G_O_CALLBACKFUNCTION ) Then $__G_O_CALLBACKFUNCTION = ObjCreate ( "{EE09B103-97E0-11CF-978F-00A02463E06F}" )
	Local $HIRSTATUSCALLBACK = DllCallbackRegister ( $FUNCTIONCALLBACK , "none" , "double;long;ptr" )
	If @error Or $HIRSTATUSCALLBACK = 0 Then Return SetError ( 1 , 0 , 0 )
	Local $PIRSTATUSCALLBACK = DllCallbackGetPtr ( $HIRSTATUSCALLBACK )
	$__G_O_CALLBACKFUNCTION ( String ( $PIRSTATUSCALLBACK ) ) = $HIRSTATUSCALLBACK
	Return $PIRSTATUSCALLBACK
EndFunc
Func IR_COMPARE_CALLBACKFREE ( $PIRSTATUSCALLBACK )
	If Not IsPtr ( $PIRSTATUSCALLBACK ) Then Return SetError ( 1 , 0 , False )
	If Not $__G_O_CALLBACKFUNCTION .Exists ( String ( $PIRSTATUSCALLBACK ) ) Then Return SetError ( 2 , 0 , False )
	DllCallbackFree ( $__G_O_CALLBACKFUNCTION ( String ( $PIRSTATUSCALLBACK ) ) )
	Return True
EndFunc
Func IR_WINCAPTURE ( $HWND = 0 , $LEFT = 0 , $TOP = 0 , $WIDTH = 0 , $HEIGHT = 0 , $MODE = Default )
	If $__GH_DLL_AIRL < 1 Then Exit MsgBox ( 16 , "Fatal Error" , """IR_StartUp"" function has not been initialized or has failed to initialize" )
	Local $STATEWND = WinGetState ( $HWND )
	If BitAND ( $STATEWND , $WIN_STATE_MINIMIZED ) Then Return SetError ( 1 , ConsoleWrite ( "![IR_WinCapture] Could not capture a minimized $hWnd" & @CRLF ) , 0 )
	If $HWND <> 0 And Not BitAND ( $STATEWND , $WIN_STATE_VISIBLE ) Then Return SetError ( 2 , ConsoleWrite ( "![IR_WinCapture] Could not capture a hidden $hWnd" & @CRLF ) , 0 )
	_GDIPLUS_STARTUP ( )
	If Not IsNumber ( $MODE ) Or $MODE <= $IR_SNAP_NORMAL Then
		Switch @OSVersion
		Case "WIN_10" , "WIN_81" , "WIN_8" , "WIN_2016"
			$MODE = $IR_SNAP_RENDERFULLCONTENT
		EndSwitch
	EndIf
	Local $TRECT = DllStructCreate ( "long Left;long Top;long Right;long Bottom" )
	DllCall ( "dwmapi.dll" , "long" , "DwmGetWindowAttribute" , "hwnd" , $HWND , "dword" , 9 , "struct*" , $TRECT , "dword" , DllStructGetSize ( $TRECT ) )
	Local $RET = DllCall ( $__GH_DLL_AIRL , "handle" , "AIRL_WinCapture" , "handle" , $HWND , "uint" , $MODE , "int*" , $LEFT , "int*" , $TOP , "int*" , $WIDTH , "int*" , $HEIGHT , $__G_T_STRUCTTYPE , $TRECT )
	If @error Or $RET [ 0 ] = 0 Then Return SetError ( 3 , 0 , 0 )
	Return $RET [ 0 ]
EndFunc
Func IR_WINHIDE ( $HWND , $HIDE )
	#Animation API
	If $HWND == "Animation" Then
		Local Static $__SPI_GETANIMATION = 72 , $__SPI_SETANIMATION = 73
		Local $TANIMATION = DllStructCreate ( "uint cbSize;int iMinAnimate" )
		$TANIMATION .cbSize = DllStructGetSize ( $TANIMATION )
		If IsBool ( $HIDE ) Then
			$TANIMATION .iMinAnimate = $HIDE
			Local $ARETURN = DllCall ( "user32.dll" , "int" , "SystemParametersInfo" , "uint" , $__SPI_SETANIMATION , "int" , DllStructGetSize ( $TANIMATION ) , "ptr" , DllStructGetPtr ( $TANIMATION ) , "uint" , 0 )
			If IsArray ( $ARETURN ) Then Return 1
		Else
			Local $ARETURN = DllCall ( "user32.dll" , "int" , "SystemParametersInfo" , "uint" , $__SPI_GETANIMATION , "int" , DllStructGetSize ( $TANIMATION ) , "ptr" , DllStructGetPtr ( $TANIMATION ) , "uint" , 0 )
			If IsArray ( $ARETURN ) Then Return $TANIMATION .iMinAnimate
		EndIf
		Return 0
	EndIf
	If $HWND = 0 Or WinExists ( $HWND ) = 0 Then Return SetError ( 1 , 0 , False )
	Local Static $HWNDMANAGER = ObjCreate ( "{EE09B103-97E0-11CF-978F-00A02463E06F}" )
	#Kim tra HWnd c phi l control khng, nu phi th tm parent ca n
	Local $HPARENT = _WINAPI_GETANCESTOR ( $HWND , $GA_ROOT )
	If $HWND <> $HPARENT Then $HWND = $HPARENT
	#Tt ch  Chng capture ca s
	_WINAPI_SETWINDOWDISPLAYAFFINITY ( $HWND , 0 )
	If $HIDE = True Then
		#Kim tra ch  Hot nh khi Thu nh ca s c c bt hay khng, nu c th tt
		Local $HWNDEXSTYLE = _WINAPI_GETWINDOWLONG ( $HWND , $GWL_EXSTYLE )
		If BitAND ( $HWNDEXSTYLE , $WS_EX_LAYERED ) <> $WS_EX_LAYERED Or BitAND ( $HWNDEXSTYLE , $WS_EX_TOOLWINDOW ) <> $WS_EX_TOOLWINDOW Then
			_WINAPI_SETWINDOWLONG ( $HWND , $GWL_EXSTYLE , BitOR ( $HWNDEXSTYLE , $WS_EX_LAYERED , $WS_EX_TOOLWINDOW ) )
			If $HWNDEXSTYLE = _WINAPI_GETWINDOWLONG ( $HWND , $GWL_EXSTYLE ) Then
				ConsoleWrite ( @CRLF & "![Error] IR_WinHide could not change ExStyle of this hWnd. Please add #RequiredAdmin on top of script and retry." & @CRLF )
				Return SetError ( 2 , 0 , False )
			Else
				$HWNDMANAGER ( $HWND & ":ExStyle" ) = $HWNDEXSTYLE
			EndIf
		EndIf
		#Set Transparent cho ca s vi mc ti thiu l 1  hm Print vn c th in c d ca s ang trong sut
		_WINAPI_SETLAYEREDWINDOWATTRIBUTES ( $HWND , 0 , 1 , $LWA_ALPHA )
		#Hin ca s  ch  Inactive
		Local $WINSTATE = WinGetState ( $HWND )
		$HWNDMANAGER ( $HWND & ":WinState" ) = $WINSTATE
		If BitAND ( $WINSTATE , $WIN_STATE_MINIMIZED ) Then
			If IR_WINHIDE ( "Animation" , "" ) = 1 Then
				IR_WINHIDE ( "Animation" , False )
				$HWNDMANAGER ( $HWND & ":MinimizeAnimation" ) = 1
			EndIf
			_WINAPI_SHOWWINDOW ( $HWND , @SW_SHOWNOACTIVATE )
			If $HWNDMANAGER ( $HWND & ":MinimizeAnimation" ) = 1 Then
				IR_WINHIDE ( "Animation" , True )
				$HWNDMANAGER ( $HWND & ":MinimizeAnimation" ) = 0
			EndIf
		EndIf
		_WINAPI_SETWINDOWPOS ( $HWND , $HWND_BOTTOM , 0 , 0 , 0 , 0 , BitOR ( $SWP_NOMOVE , $SWP_NOSIZE ) )
	Else
		If $HWNDMANAGER ( $HWND & ":ExStyle" ) <> 0 Then
			_WINAPI_SETWINDOWLONG ( $HWND , $GWL_EXSTYLE , $HWNDMANAGER ( $HWND & ":ExStyle" ) )
			$HWNDMANAGER ( $HWND & ":ExStyle" ) = 0
		EndIf
		_WINAPI_SETLAYEREDWINDOWATTRIBUTES ( $HWND , 0 , 255 , $LWA_ALPHA )
		_WINAPI_SETWINDOWPOS ( $HWND , $HWND_TOP , 0 , 0 , 0 , 0 , BitOR ( $SWP_NOMOVE , $SWP_NOSIZE ) )
		WinSetState ( $HWND , "" , $HWNDMANAGER ( $HWND & ":WinState" ) )
	EndIf
	Return True
EndFunc
Func IR_WINMOUSE ( $HWND , $BUTTON , $ACTION , $X = + 4294967295 , $Y = + 4294967295 , $WINAPI_FUNCTION = "PostMessage" )
	If $X == Default Then $X = + 4294967295
	If $Y == Default Then $Y = + 4294967295
	Local $ABUTTON = StringRegExp ( StringLower ( $BUTTON ) , "^(?:([csa])\w+\h?\W\h?)?(l|r|mi|mo|scr|wheel)" , 3 )
	If @error Then Local $ABUTTON [ 2 ] = [ 0 , 0 ]
	Local $RET = DllCall ( $__GH_DLL_AIRL , "long" , "AIRL_WinMouse" , "handle*" , $HWND , "wstr" , StringLower ( $WINAPI_FUNCTION ) , "wstr" , $ABUTTON [ 1 ] , "wstr" , $ABUTTON [ 0 ] , "wstr" , StringLower ( $ACTION ) , "long*" , $X , "long*" , $Y )
	If @error Then Return SetError ( + 4294967295 , 0 , 0 )
	Return SetError ( $RET [ 0 ] = 0 , 0 , $RET [ 0 ] )
EndFunc
Func IR_IMAGE_SETTRANSPARENTCOLOR ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP , $OUTPUT_FILEPATH_OR_HBITMAP_OR_BITMAP = "" , $MODE = $IR_PIXTRANS_RANGE , $PARAMETER1 = 4294967295 , $PARAMETER2 = 4294967295 , $TOLERANCE_FOR_PIXTRANS_SAMPLE = Default )
	_GDIPLUS_STARTUP ( )
	Local $HIMAGE
	If IsBinary ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP ) Then
		$HIMAGE = _GDIPLUS_BITMAPCREATEFROMMEMORY ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP )
	ElseIf IsPtr ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP ) Then
		$HIMAGE = _GDIPLUS_BITMAPCREATEFROMHBITMAP ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP )
	ElseIf FileExists ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP ) Then
		$HIMAGE = _GDIPLUS_BITMAPCREATEFROMFILE ( $INPUT_FILEPATH_OR_BINARY_OR_HBITMAP )
	EndIf
	If @error Then Return SetError ( 1 )
	If Not IsNumber ( $MODE ) Then $MODE = $IR_PIXTRANS_RANGE
	If @NumParams = 4 Then
		$PARAMETER2 = $PARAMETER1
	Else
		If $MODE <> $IR_PIXTRANS_RANGE Then
			If $MODE = $IR_PIXTRANS_SAMPLE Then
				$PARAMETER1 = _GDIPLUS_BITMAPGETPIXEL ( $HIMAGE , $PARAMETER1 , $PARAMETER2 )
				If @error Then Return SetError ( 2 )
				If Not IsNumber ( $TOLERANCE_FOR_PIXTRANS_SAMPLE ) Then $TOLERANCE_FOR_PIXTRANS_SAMPLE = 10
				$PARAMETER2 = $TOLERANCE_FOR_PIXTRANS_SAMPLE
			EndIf
			Local $ARANGECOLOR = IR_COLORSRANGESIMILAR ( $PARAMETER1 , $PARAMETER2 )
			If @error Then Return SetError ( 3 )
			$PARAMETER1 = $ARANGECOLOR [ 0 ]
			$PARAMETER2 = $ARANGECOLOR [ 1 ]
		EndIf
	EndIf
	Local $ADIM = _GDIPLUS_IMAGEGETDIMENSION ( $HIMAGE )
	Local $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0 ( $ADIM [ 0 ] , $ADIM [ 1 ] )
	Local $HGFX = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $HBITMAP )
	Local $HIA = _GDIPLUS_IMAGEATTRIBUTESCREATE ( )
	_GDIPLUS_IMAGEATTRIBUTESSETCOLORKEYS ( $HIA , 0 , True , $PARAMETER1 , $PARAMETER2 )
	_GDIPLUS_GRAPHICSDRAWIMAGERECTRECT ( $HGFX , $HIMAGE , 0 , 0 , $ADIM [ 0 ] , $ADIM [ 1 ] , 0 , 0 , $ADIM [ 0 ] , $ADIM [ 1 ] , $HIA )
	_GDIPLUS_IMAGEATTRIBUTESDISPOSE ( $HIA )
	_GDIPLUS_GRAPHICSDISPOSE ( $HGFX )
	If Not $OUTPUT_FILEPATH_OR_HBITMAP_OR_BITMAP Or $OUTPUT_FILEPATH_OR_HBITMAP_OR_BITMAP = "HBitmap" Then
		Return _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $HBITMAP )
	ElseIf $OUTPUT_FILEPATH_OR_HBITMAP_OR_BITMAP = "Bitmap" Then
		Return $HBITMAP
	Else
		_GDIPLUS_IMAGESAVETOFILE ( $HBITMAP , $OUTPUT_FILEPATH_OR_HBITMAP_OR_BITMAP )
		If @error Then Return SetError ( 4 )
		_GDIPLUS_IMAGEDISPOSE ( $HBITMAP )
		_GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
	EndIf
EndFunc
#Region MT S HM RING
Func IR_OPENCL_GETPLATFORMS ( $PLAFORMINDEX )
	If $__G_PIR_OPENCLGETPLATFORM = 0 Then Return SetError ( 1 , 0 , "" )
	Local $RET = DllCallAddress ( "wstr" , $__G_PIR_OPENCLGETPLATFORM , "long" , $PLAFORMINDEX )
	If @error Or $RET [ 0 ] = "" Then Return SetError ( 2 , 0 , "" )
	Return $RET [ 0 ]
EndFunc
Func IR_OPENCL_GETDEVICES ( $PLAFORMINDEX , $DEVICEINDEX )
	If $__G_PIR_OPENCLGETDEVICE = 0 Then Return SetError ( 1 , 0 , "" )
	Local $RET = DllCallAddress ( "wstr" , $__G_PIR_OPENCLGETDEVICE , "long" , $PLAFORMINDEX , "long" , $DEVICEINDEX )
	If @error Or $RET [ 0 ] = "" Then Return SetError ( 2 , 0 , "" )
	Return $RET [ 0 ]
EndFunc
Func IR_OPENCL_INIT ( $PLAFORMINDEX , $DEVICEINDEX , $COMPARETYPE , $ROTATESEARCH , $COMPUTECORECOUNT )
	If $COMPARETYPE <> $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA And $COMPARETYPE <> $IR_COMPARE_TYPE_EXACT Then
		If Not @Compiled Then ConsoleWrite ( @CRLF & "![Warning] OpenCL is only supported with IR_COMPARE_TYPE_EXACT and IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA" & @CRLF )
		Return SetError ( 1 , 0 , 0 )
	EndIf
	Local $TIROPENCL = DllStructCreate ( $SIROCLDEVICE )
	Local $RET = DllCall ( $__GH_DLL_AIRL , "long" , "AIRL_InitOpenCL" , "uint" , $PLAFORMINDEX , "uint" , $DEVICEINDEX , "long" , $COMPARETYPE , "uint" , $COMPUTECORECOUNT , "long" , $ROTATESEARCH , "struct*" , $TIROPENCL )
	If @error Or $RET [ 0 ] <> $IR_OK Then Return SetError ( 2 , 0 , 0 )
	Return $TIROPENCL
EndFunc
Func IR_OPENCL_FREE ( $TIROPENCL )
	If $__G_PIR_OPENCLFREE = 0 Then Return SetError ( 1 , 0 , False )
	If Not IsDllStruct ( $TIROPENCL ) Then Return SetError ( 2 , 0 , False )
	Local $RET = DllCallAddress ( "long" , $__G_PIR_OPENCLFREE , "struct*" , $TIROPENCL )
	If @error Then Return SetError ( 3 , 0 , False )
	Return True
EndFunc
Func IR_COLORSCHECKSIMILAR ( $RGB_COLOR1 , $RGB_COLOR2 , $TOLERANCE )
	If $__GH_DLL_AIRL < 1 Then Exit MsgBox ( 16 , "Fatal Error" , """IR_StartUp"" function has not been initialized or has failed to initialize" )
	Local $RET = DllCall ( $__GH_DLL_AIRL , "long" , "AIRL_ColorsCheckSimilar" , "int" , $RGB_COLOR1 , "int" , $RGB_COLOR2 , "int" , $TOLERANCE , "int*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( 1 , 0 , False )
	Return ( $RET [ 0 ] = 1 )
EndFunc
Func IR_COLORSRANGESIMILAR ( $RGB_COLOR , $TOLERANCE )
	If $__GH_DLL_AIRL < 1 Then Exit MsgBox ( 16 , "Fatal Error" , """IR_StartUp"" function has not been initialized or has failed to initialize" )
	Local $RET = DllCall ( $__GH_DLL_AIRL , "long" , "AIRL_ColorsRangeSimilar" , "int" , Dec ( Hex ( $RGB_COLOR , 6 ) ) , "int" , $TOLERANCE , "int*" , 0 , "int*" , 0 )
	If @error Then Return SetError ( 1 , 0 , 0 )
	Local $ARET [ 2 ] = [ $RET [ 3 ] , $RET [ 4 ] ]
	Return $ARET
EndFunc
Func IR_DPIAWARE ( )
	Local Static $PR_DPI_UNAWARE = 0 , $PR_SYSTEM_DPI_AWARE = 1 , $PR_PER_MONITOR_DPI_AWARE = 2
	If @OSVersion = "WIN_10" Then
		DllCall ( "Shcore.dll" , "long" , "PROCESS_DPI_AWARENESS" , $PR_SYSTEM_DPI_AWARE )
	Else
		DllCall ( "User32.dll" , "bool" , "SetProcessDPIAware" )
	EndIf
EndFunc
Func __IR_FUNCTIONADDRESS ( $FUNCTIONNAME )
	If $__GH_DLL_IRL <= 0 Then Return SetError ( 1 )
	Local $RET = DllCall ( "kernel32.dll" , "ptr" , "GetProcAddress" , "handle" , $__GH_DLL_IRL , "str" , $FUNCTIONNAME )
	If @error Or Not $RET [ 0 ] Then Return SetError ( 2 )
	Return $RET [ 0 ]
EndFunc
#EndRegion
Func ARRANGEANOMALYLIST ( )
	$CURRFUNCNAME = "ArrangeAnomalyList"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $FINDED
	Local $X_FINDED , $Y_FINDED
	If ( WAITFINDPICD ( @ScriptDir & "\img\anomaly_sign.bmp" , $X_FINDED , $Y_FINDED , 0.6 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1034 , 57 , 24 , 230 ) = 1 ) Then
		LOGINFO ( "focusfire_ico" )
		SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & $Y_FINDED & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 83 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 1000 , 1590 , 1 ) )
	Else
		LOGINFO ( "focusfire_ico NOT finded" )
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func CHECKREPAIRSTATE ( )
	$CURRFUNCNAME = "CheckRepairState"
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0
	Local $AFILELIST
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Start CheckRepairState" )
	If $REPAIRTYPE = + 4294967295 Then
		$AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\repairs\" , "*.bmp" )
		ADBSCREEN ( 1 )
		For $M = 1 To $AFILELIST [ 0 ]
			LOGINFO ( "Searching for: " & $AFILELIST [ $M ] )
			$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\repairs\" & $AFILELIST [ $M ] , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 )
			If $FINDED Then
				If StringInStr ( $AFILELIST [ $M ] , "shield" ) Then
					$REPAIRTYPE = 1
					LOGDEBUG ( "Shield repair type" )
				Else
					LOGDEBUG ( "Armor repair type" )
					$REPAIRTYPE = 2
				EndIf
				$REPAIRCOORD [ 0 ] = $X1
				$REPAIRCOORD [ 1 ] = $Y1
				ExitLoop
			EndIf
		Next
		LOGINFO ( "RepairType is : " & $REPAIRTYPE )
	EndIf
	ADBSCREEN ( 1 )
	If $REPAIRTYPE = + 4294967295 Then
		LOGINFO ( "-Repair not finded " )
	Else
		For $M = 0 To 16
			$WCCOLOR = CHECKCOLOR ( $REPAIRCOORD [ 0 ] + 6 , $REPAIRCOORD [ 1 ] + 4294967278 - $M , 0 , 0 , 0 )
			$HSL_COLOR = _COLORCONVERTRGBTOHSL ( $WCCOLOR )
			If ( ( $WCCOLOR [ 0 ] ) > 220 And $WCCOLOR [ 1 ] > 250 And $WCCOLOR [ 2 ] > 240 ) Or ( $HSL_COLOR [ 0 ] > 100 And $HSL_COLOR [ 1 ] > 150 And $HSL_COLOR [ 2 ] > 200 ) Then
				$REPAIRSTATE = 1
				ExitLoop
				LOGINFO ( "+++" )
			Else
				$REPAIRSTATE = 0
			EndIf
		Next
		If $REPAIRSTATE = 1 Then
			LOGINFO ( "Repair active " )
		Else
			LOGINFO ( "Repair not active " )
		EndIf
	EndIf
	Return $REPAIRSTATE
	LOGINFO ( "Stop CheckRepairState" )
EndFunc
Func FIREREPAIR ( )
	$CURRFUNCNAME = "FireRepair"
	Local $X_FINDED , $Y_FINDED
	Local $RET = 1
	LOGINFO ( "Start FireRepair:" & $REPAIRTYPE )
	SETDOINGSTATUS ( "FireRepair" )
	If $REPAIRTYPE > 0 Then
		SENDTAP ( $REPAIRCOORD [ 0 ] , $REPAIRCOORD [ 1 ] , 5 )
	Else
		LOGINFO ( "dont have repair" )
		$RET = 0
	EndIf
	LOGINFO ( "Stop FireRepair" )
	Return $RET
EndFunc
Func GETSHIPSPARAMS ( )
	$CURRFUNCNAME = "GetShipsParams"
	LOGINFO ( "Start GetShipsParams" )
	ADBSCREEN ( 1 )
	$COUNT = 0
	$TOTALCOUNT = 0
	Global $DEGTORAD = 4 * ATan ( 1 ) / 180
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	Local $IXC = 639 , $IYC = 626 , $IMOV = 305 , $IX = 140 , $IY = 340 , $IR = 59 , $ISTEP = 3.6
	For $I = 0 To 180 Step 3.6
		$IMOV += $ISTEP
		$IX = Round ( $IXC - $IR * Cos ( $IMOV * $DEGTORAD ) + 4294967294 )
		$IY = Round ( $IYC - $IR * Sin ( $IMOV * $DEGTORAD ) + 4294967294 )
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $IX , $IY )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		$COUNT += 1
		If $ACOLOR [ 0 ] > 55 And $ACOLOR [ 1 ] > 80 And $ACOLOR [ 2 ] > 80 Then
			$TOTALCOUNT += 1
		Else
		EndIf
	Next
	$SHIPSHIELD = Round ( ( $TOTALCOUNT / $COUNT ) * 100 )
	LOGINFO ( "Total Shield Count=" & $SHIPSHIELD )
	$COUNT = 0
	$TOTALCOUNT = 0
	Local $IXC = 639 , $IYC = 626 , $IMOV = 305 , $IX = 140 , $IY = 340 , $IR = 52 , $ISTEP = 3.6
	For $I = 0 To 180 Step 3.6
		$IMOV += $ISTEP
		$IX = Round ( $IXC - $IR * Cos ( $IMOV * $DEGTORAD ) + 4294967294 )
		$IY = Round ( $IYC - $IR * Sin ( $IMOV * $DEGTORAD ) + 4294967294 )
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $IX , $IY )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		$COUNT += 1
		If $ACOLOR [ 0 ] > 55 And $ACOLOR [ 1 ] > 80 And $ACOLOR [ 2 ] > 80 Then
			$TOTALCOUNT += 1
		Else
		EndIf
	Next
	$SHIPARMOR = Round ( ( $TOTALCOUNT / $COUNT ) * 100 )
	LOGINFO ( "Total Armor Count=" & $SHIPARMOR )
	$COUNT = 0
	$TOTALCOUNT = 0
	Local $IXC = 639 , $IYC = 626 , $IMOV = 305 , $IX = 140 , $IY = 340 , $IR = 45 , $ISTEP = 3.6
	For $I = 0 To 180 Step 3.6
		$IMOV += $ISTEP
		$IX = Round ( $IXC - $IR * Cos ( $IMOV * $DEGTORAD ) + 4294967294 )
		$IY = Round ( $IYC - $IR * Sin ( $IMOV * $DEGTORAD ) + 4294967294 )
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $IX , $IY )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		$COUNT += 1
		If $ACOLOR [ 0 ] > 55 And $ACOLOR [ 1 ] > 80 And $ACOLOR [ 2 ] > 80 Then
			$TOTALCOUNT += 1
		Else
		EndIf
	Next
	$SHIPHULL = Round ( ( $TOTALCOUNT / $COUNT ) * 100 )
	LOGINFO ( "Total Hull Count=" & $SHIPHULL )
	$COUNT = 0
	$TOTALCOUNT = 0
	Local $IXC = 639 , $IYC = 626 , $IMOV = 315 , $IX = 140 , $IY = 340 , $IR = 55 , $ISTEP = 3.6
	For $I = 0 To 89 Step 3.6
		$IMOV += $ISTEP
		$IX = Round ( $IXC + $IR * Cos ( $IMOV * $DEGTORAD ) + 4294967294 )
		$IY = Round ( $IYC + $IR * Sin ( $IMOV * $DEGTORAD ) + 4294967294 )
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $IX , $IY )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		$COUNT += 1
		If $ACOLOR [ 0 ] > 30 And $ACOLOR [ 1 ] > 80 And $ACOLOR [ 2 ] > 80 Then
			$TOTALCOUNT += 1
		Else
		EndIf
	Next
	$SHIPENERGY = Round ( ( $TOTALCOUNT / $COUNT ) * 100 )
	LOGINFO ( "Total Energy Count=" & $SHIPENERGY )
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_WINAPI_DELETEOBJECT ( $BITMAP )
	LOGINFO ( "End GetShipsParams" )
EndFunc
Func SELECTANOMALY ( ByRef $ANOMALYNAME , $WARPDISTANCE = 100 , $ANOMALYMAXSIZE = 3 , $SELECTANYLEVEL = 0 )
	$CURRFUNCNAME = "SelectAnomaly"
	Local $X_FINDED , $Y_FINDED
	Local $I , $J
	Local $ANOMALYFINDED = 0
	Local $ANOMALYSIZE [ 3 ] = [ "small" , "medium" , "large" ]
	Local $TXT = ""
	Local $ANOMLIST [ 18 ] [ 3 ]
	LOGINFO ( "Start SelectAnomaly" )
	SETDOINGSTATUS ( "Selecting anomaly" )
	Local $HBRUSH = _GDIPLUS_BRUSHCREATESOLID ( 4294967295 )
	Local $COMPAREPARAMETERS = IR_COMPARE_PARAMETERS ( )
	With $COMPAREPARAMETERS
	.MultiThreadedProcessing = False
	.MaxMatches = 1
	.CompareType = $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA
	.ColorTolerance_A = 60
	.ColorTolerance_R = 60
	.ColorTolerance_G = 60
	.ColorTolerance_B = 60
	.PixelTolerance = 10
	.EnableOpenCL = False
	.PlaformIndex = Default
	.DeviceIndex = Default
	.ComputeCoreCount = Default
	EndWith
	If $WARPDISTANCE > 100 Then $WARPDISTANCE = 100
	For $J = $ANOMALYMAXSIZE + 4294967295 To 0 Step + 4294967295
		$TXT = $TXT & " " & $ANOMALYSIZE [ $J ]
	Next
	LOGINFO ( "Selected Anomaly:" & $TXT )
	SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
	Sleep ( 500 )
	SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
	Sleep ( 500 )
	ADBSCREEN ( 1 )
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	Local $BITMAPCONTEXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $BITMAP )
	Local $HTIMER = TimerInit ( )
	Local $SOCRTEXTRESULT
	Local $ISCALE = 4
	Local $SKIPLINE = 0
	Local $MAXANOMALYLEVEL = 0
	Local $TTMPBITMAP
	Local $TTMPBITMAPC
	Local $TRESULT
	Local $HBITMAP_SCALED
	For $I = 1 To 8
		$TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 1112 + 4294967219 , 53 + 69 * $I , 158 + 77 , 68 )
		$TTMPBITMAPC = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $TTMPBITMAP )
		$IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TTMPBITMAP ) )
		$TRESULT = IR_COMPARE ( $IMAGE_SRC , $OVERLAYBASEICO_1 , $COMPAREPARAMETERS )
		If Not @error Then
			LOGINFO ( "base finded:" & $TRESULT [ 0 ] )
			$SKIPLINE = 1
		Else
			$SKIPLINE = 0
		EndIf
		_GDIPLUS_GRAPHICSFILLRECT ( $TTMPBITMAPC , 26 , 5 , 56 , 61 )
		$HBITMAP_SCALED = _GDIPLUS_IMAGESCALE ( $TTMPBITMAP , $ISCALE , $ISCALE , 4 )
		Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $HBITMAP_SCALED , @ScriptDir & "\screenshot\uwpocr.bmp" )
		$SOCRTEXTRESULT = StringStripCR ( _UWPOCR_GETTEXT ( @ScriptDir & "\screenshot\uwpocr.bmp" , "EN-Us" , False ) )
		$SOCRTEXTRESULT = StringStripWS ( $SOCRTEXTRESULT , 1 )
		LOGDEBUG ( $I & " OCR:" & $SOCRTEXTRESULT )
		If $SKIPLINE = 0 Then
			$ANOMLIST [ $I ] [ 0 ] = $I
			$ANOMLIST [ $I ] [ 2 ] = $SOCRTEXTRESULT
			If $AN_IGNORELEVELS = 0 Then
				$ANOMLIST [ $I ] [ 1 ] = Number ( $SOCRTEXTRESULT )
			EndIf
		Else
			$ANOMLIST [ $I ] [ 0 ] = $I
			$ANOMLIST [ $I ] [ 2 ] = "blocked line"
			$ANOMLIST [ $I ] [ 1 ] = 0
		EndIf
		If $ANOMLIST [ $I ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "SSansha" ) Then $ANOMLIST [ $I ] [ 1 ] = 9
		If $ANOMLIST [ $I ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "IOBlood" ) Then $ANOMLIST [ $I ] [ 1 ] = 10
		If $ANOMLIST [ $I ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "IOBIood" ) Then $ANOMLIST [ $I ] [ 1 ] = 10
		If $ANOMLIST [ $I ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "IOGur" ) Then $ANOMLIST [ $I ] [ 1 ] = 10
		If $ANOMLIST [ $I ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "Wasteseeker" ) Then $ANOMLIST [ $I ] [ 1 ] = 10
		If StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "Base" ) Then $ANOMLIST [ $I ] [ 1 ] = 4
		If StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "Encampment" ) Then $ANOMLIST [ $I ] [ 1 ] = 2
		If $MAXANOMALYLEVEL < $ANOMLIST [ $I ] [ 1 ] Then $MAXANOMALYLEVEL = $ANOMLIST [ $I ] [ 1 ]
		_GDIPLUS_BITMAPDISPOSE ( $HBITMAP_SCALED )
		_GDIPLUS_BITMAPDISPOSE ( $TTMPBITMAP )
		_GDIPLUS_GRAPHICSDISPOSE ( $TTMPBITMAPC )
		IR_COMPARE_FREERESULT ( $TRESULT )
		IR_IMAGE_UNLOAD ( $IMAGE_SRC )
		_GDIPLUS_GRAPHICSFILLRECT ( $BITMAPCONTEXT , 1112 + 4294967119 , 53 + 69 * $I , 56 , 61 , $HBRUSH )
		_GDIPLUS_GRAPHICSDRAWSTRING ( $BITMAPCONTEXT , "i=" & $I , 1112 + 4294967119 , 53 + 69 * $I , "Arial" , 10 , 0 )
	Next
	$ANSW = _GDIPLUS_IMAGESAVETOFILE ( $BITMAP , @ScriptDir & "\screenshot\sw1.bmp" )
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_GDIPLUS_GRAPHICSDISPOSE ( $BITMAPCONTEXT )
	If $AN_SECONDSWIPE = 1 Then
		SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		Sleep ( 500 )
		ARRANGEANOMALYLIST ( )
		Sleep ( 500 )
		ADBSCREEN ( 1 )
		Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
		Local $BITMAPCONTEXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $BITMAP )
		For $I = 1 To 8
			$TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 1112 + 4294967219 , 53 + 69 * $I , 158 + 77 , 68 )
			$TTMPBITMAPC = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $TTMPBITMAP )
			$IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TTMPBITMAP ) )
			$TRESULT = IR_COMPARE ( $IMAGE_SRC , $OVERLAYBASEICO_1 , $COMPAREPARAMETERS )
			If Not @error Then
				LOGINFO ( "base finded:" & $TRESULT [ 0 ] )
				$SKIPLINE = 1
			Else
				$SKIPLINE = 0
			EndIf
			_GDIPLUS_GRAPHICSFILLRECT ( $TTMPBITMAPC , 26 , 5 , 56 , 61 )
			$HBITMAP_SCALED = _GDIPLUS_IMAGESCALE ( $TTMPBITMAP , $ISCALE , $ISCALE , 4 )
			Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $HBITMAP_SCALED , @ScriptDir & "\screenshot\uwpocr.bmp" )
			$SOCRTEXTRESULT = StringStripCR ( _UWPOCR_GETTEXT ( @ScriptDir & "\screenshot\uwpocr.bmp" , "EN-Us" , False ) )
			$SOCRTEXTRESULT = StringStripWS ( $SOCRTEXTRESULT , 1 )
			LOGDEBUG ( $I + 8 & " OCR:" & $SOCRTEXTRESULT )
			If $SKIPLINE = 0 Then
				$ANOMLIST [ $I + 8 ] [ 0 ] = $I + 8
				$ANOMLIST [ $I + 8 ] [ 2 ] = $SOCRTEXTRESULT
				If $AN_IGNORELEVELS = 0 Then
					$ANOMLIST [ $I + 8 ] [ 1 ] = Number ( $SOCRTEXTRESULT )
					Local $LVLREGEXP = StringRegExp ( $SOCRTEXTRESULT , "\d{1,2}" , 1 )
				EndIf
			Else
				$ANOMLIST [ $I + 8 ] [ 0 ] = $I + 8
				$ANOMLIST [ $I + 8 ] [ 2 ] = "blocked line"
				$ANOMLIST [ $I + 8 ] [ 1 ] = 0
			EndIf
			If $ANOMLIST [ $I + 8 ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "SSansha" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 9
			If $ANOMLIST [ $I + 8 ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "IOBlood" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 10
			If $ANOMLIST [ $I + 8 ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "IOBIood" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 10
			If $ANOMLIST [ $I + 8 ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "IOGur" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 10
			If $ANOMLIST [ $I + 8 ] [ 1 ] = 0 And StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "Wasteseeker" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 10
			If StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "Base" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 4
			If StringInStr ( $ANOMLIST [ $I + 8 ] [ 2 ] , "Encampment" ) Then $ANOMLIST [ $I + 8 ] [ 1 ] = 2
			If $MAXANOMALYLEVEL < $ANOMLIST [ $I + 8 ] [ 1 ] Then $MAXANOMALYLEVEL = $ANOMLIST [ $I + 8 ] [ 1 ]
			_GDIPLUS_BITMAPDISPOSE ( $HBITMAP_SCALED )
			_GDIPLUS_BITMAPDISPOSE ( $TTMPBITMAP )
			_GDIPLUS_GRAPHICSDISPOSE ( $TTMPBITMAPC )
			IR_COMPARE_FREERESULT ( $TRESULT )
			IR_IMAGE_UNLOAD ( $IMAGE_SRC )
			_GDIPLUS_GRAPHICSFILLRECT ( $BITMAPCONTEXT , 1112 + 4294967119 , 53 + 69 * $I , 56 , 61 , $HBRUSH )
			_GDIPLUS_GRAPHICSDRAWSTRING ( $BITMAPCONTEXT , "i=" & $I + 8 , 1112 + 4294967119 , 53 + 69 * $I , "Arial" , 10 , 0 )
		Next
		$ANSW = _GDIPLUS_IMAGESAVETOFILE ( $BITMAP , @ScriptDir & "\screenshot\sw2.bmp" )
		_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
		_GDIPLUS_GRAPHICSDISPOSE ( $BITMAPCONTEXT )
	EndIf
	LOGINFO ( "Total OCR Elapsed: " & TimerDiff ( $HTIMER ) & @CRLF )
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_WINAPI_DELETEOBJECT ( $BITMAP )
	LOGDEBUG ( "Max anomaly level=" & $MAXANOMALYLEVEL )
	_ARRAYSORT ( $ANOMLIST , 0 , 0 , 0 , 2 )
	LOGDEBUG ( "Finded anomalies" )
	LOGDEBUG ( "indx:pos|lvl|name" )
	For $I = 0 To 8 + 8
		LOGDEBUG ( $I & "|" & $ANOMLIST [ $I ] [ 0 ] & "|" & $ANOMLIST [ $I ] [ 1 ] & "|" & $ANOMLIST [ $I ] [ 2 ] )
	Next
	LOGDEBUG ( "Searching in arrays " )
	For $J = $ANOMALYMAXSIZE + 4294967295 To 0 Step + 4294967295
		For $I = 0 To 16
			If StringInStr ( $ANOMLIST [ $I ] [ 2 ] , $ANOMALYSIZE [ $J ] ) Then
				If StringInStr ( $ANOMLIST [ $I ] [ 2 ] , "anomaly" ) And ( $ANOMLIST [ $I ] [ 1 ] = $MAXANOMALYLEVEL Or $SELECTANYLEVEL = 1 ) Then
					LOGDEBUG ( "Go to anomaly: " & $ANOMLIST [ $I ] [ 0 ] & "|" & $ANOMLIST [ $I ] [ 1 ] & "|" & $ANOMLIST [ $I ] [ 2 ] )
					$ANOMALYNAME = $ANOMLIST [ $I ] [ 2 ]
					If $ANOMLIST [ $I ] [ 0 ] <= 8 Then
						LOGDEBUG ( "Wind it back" )
						SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 500 , 900 , 1 ) )
						SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 500 , 900 , 1 ) )
						Sleep ( 2000 )
						SENDTCPTAPSTICKY ( 1092 , 70 )
						Sleep ( 200 )
						SENDTCPTAPSTICKY ( 1092 , 100 , 2 )
						DEBUG ( 1139 , 53 + 69 * $ANOMLIST [ $I ] [ 0 ] + 35 )
						SENDTAP ( 1139 , 53 + 69 * $ANOMLIST [ $I ] [ 0 ] + 35 , 10 )
						SENDTCPTAPSTICKY ( 968 , 100 , 2 )
						SENDTCPTAPSTICKY ( 1092 , 70 , 1 )
					Else
						LOGDEBUG ( "Dont wind" )
						Sleep ( 200 )
						SENDTCPTAPSTICKY ( 1092 , 100 , 2 )
						DEBUG ( 1139 , 53 + 69 * ( $ANOMLIST [ $I ] [ 0 ] + 4294967288 ) + 35 )
						SENDTAP ( 1139 , 53 + 69 * ( $ANOMLIST [ $I ] [ 0 ] + 4294967288 ) + 35 , 10 )
						SENDTCPTAPSTICKY ( 968 , 100 , 2 )
						SENDTCPTAPSTICKY ( 1092 , 70 , 1 )
					EndIf
					$ANOMALYFINDED = 1
					Sleep ( 900 )
					ExitLoop ( 2 )
				EndIf
			EndIf
		Next
	Next
	If ( $ANOMALYFINDED = 1 ) Then
		Local $WARPCORRECTIONX = 0
		Local $WARPCORRECTIONY = 0
		If $WARPDISTANCE > 0 Then
			$WARPCORRECTION = ( 89 + 1.8 * $WARPDISTANCE )
		EndIf
		If ( WAITFINDPIC ( @ScriptDir & "\img\warp_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 , 781 , 41 , 781 + 243 , 41 + 675 ) = 1 ) Then
			If $WARPDISTANCE = 0 Then
				SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
				LOGINFO ( "Warp click FIND X=" & $X_FINDED & "Y=" & $Y_FINDED )
			Else
				If $Y_FINDED > 445 Then $WARPCORRECTIONY = 445 - $Y_FINDED
				SENDADB ( " shell input swipe " & $X_FINDED + 80 + Random ( + 4294967295 , 1 , 1 ) & " " & $Y_FINDED + Random ( + 4294967295 , 1 , 1 ) & " " & $X_FINDED + 80 + Random ( + 4294967295 , 1 , 1 ) - $WARPCORRECTION & " " & $Y_FINDED + Random ( + 4294967295 , 1 , 1 ) + $WARPCORRECTIONY & " " & Random ( 1000 , 1500 , 1 ) )
				LOGINFO ( "Warp swipe FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & " dist=" & $WARPDISTANCE )
			EndIf
		Else
			LOGINFO ( @CRLF & "ERROR - > Warp not find" )
		EndIf
	Else
		LOGINFO ( "correct anomaly not finded" )
	EndIf
	If FileExists ( @ScriptDir & "\screenshot\uwpocr.bmp" ) Then FileDelete ( @ScriptDir & "\screenshot\uwpocr.bmp" )
	LOGINFO ( "Stop SelectAnomaly" )
	Return $ANOMALYFINDED
EndFunc
Func CHECKWEAPONSTATE ( )
	$CURRFUNCNAME = "CheckWeaponState"
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0
	Local $AFILELIST
	Local $ACTCOUNT = 0
	LOGINFO ( "Start CheckWeaponState" )
	SETDOINGSTATUS ( "Checkin weapons" )
	If $WEAPONTYPE = + 4294967295 Then
		$AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\weapons\" , "*.bmp" )
		ADBSCREEN ( 1 )
		For $M = 1 To $AFILELIST [ 0 ]
			LOGINFO ( "Searching for: " & $AFILELIST [ $M ] )
			$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\weapons\" & $AFILELIST [ $M ] , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 )
			If $FINDED Then
				$WEAPONTYPE = StringTrimRight ( $AFILELIST [ $M ] , 4 )
				$WEAPONCOORD [ 0 ] = $X1
				$WEAPONCOORD [ 1 ] = $Y1
				ExitLoop
			EndIf
		Next
		LOGINFO ( "WeaponType is : " & $WEAPONTYPE )
	EndIf
	ADBSCREEN ( 1 )
	If $WEAPONTYPE = + 4294967295 Then
		LOGINFO ( "-Weapon not finded " )
	Else
		For $M = 0 To 16
			$WCCOLOR = CHECKCOLOR ( $WEAPONCOORD [ 0 ] + 6 , $WEAPONCOORD [ 1 ] + 4294967278 - $M , 0 , 0 , 0 )
			$HSL_COLOR = _COLORCONVERTRGBTOHSL ( $WCCOLOR )
			If 0 Then
				Local $TESTCOUNTER = 0
				Local $DEBUG = ""
				For $TESTCOUNTER = 0 To 2
					$DEBUG = $DEBUG & " $WCcolor[" & $TESTCOUNTER & "] =" & $WCCOLOR [ $TESTCOUNTER ]
				Next
				For $TESTCOUNTER = 0 To 2
					$DEBUG = $DEBUG & " $HSl_color[" & $TESTCOUNTER & "] =" & $HSL_COLOR [ $TESTCOUNTER ]
				Next
				LOGDEBUG ( $DEBUG )
			EndIf
			LOGINFO ( "has h=" & Round ( $HSL_COLOR [ 0 ] ) & " s=" & Round ( $HSL_COLOR [ 1 ] ) & " l=" & Round ( $HSL_COLOR [ 2 ] ) )
			If ( ( $WCCOLOR [ 0 ] ) > 180 And $WCCOLOR [ 1 ] > 220 And $WCCOLOR [ 2 ] > 215 ) Or ( $HSL_COLOR [ 0 ] > 100 And $HSL_COLOR [ 1 ] > 110 And $HSL_COLOR [ 2 ] > 180 ) Then
				$ACTCOUNT = $ACTCOUNT + 1
				LOGINFO ( "+++" )
			Else
				$WEAPONSTATE = 0
			EndIf
		Next
		LOGINFO ( "CheckWeaponState ActCount=" & $ACTCOUNT )
		If $ACTCOUNT >= 2 Then $WEAPONSTATE = 1
		If $WEAPONSTATE = 1 Then
			LOGINFO ( "Weapon active " )
		Else
			LOGINFO ( "Weapon not active " )
		EndIf
	EndIf
	LOGINFO ( "Stop CheckWeaponState" )
	Return $WEAPONSTATE
EndFunc
Func DEBUG ( $X , $Y )
	ADBSCREEN ( 1 )
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	Local $BITMAPCONTEXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $BITMAP )
	Local $HBRUSH = _GDIPLUS_BRUSHCREATESOLID ( 4294967295 )
	_GDIPLUS_GRAPHICSFILLRECT ( $BITMAPCONTEXT , $X + 4294967291 , $Y + 4294967291 , 10 , 10 , $HBRUSH )
	_GDIPLUS_GRAPHICSFILLRECT ( $BITMAPCONTEXT , 100 , 100 , 200 , 61 , $HBRUSH )
	_GDIPLUS_GRAPHICSDRAWSTRING ( $BITMAPCONTEXT , "x=" & $X & " y=" & $Y , 100 , 100 , "Arial" , 10 , 0 )
	$ANSW = _GDIPLUS_IMAGESAVETOFILE ( $BITMAP , @ScriptDir & "\screenshot\tap.bmp" )
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_GDIPLUS_GRAPHICSDISPOSE ( $BITMAPCONTEXT )
EndFunc
Func CHECKWEBSTATE ( )
	$CURRFUNCNAME = "CheckWebState"
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0
	Local $M = 0
	Local $AFILELIST
	Local $ACTCOUNT = 0
	Local $TMPRES
	LOGINFO ( "Start CheckWebState" )
	If $WEBCOORD [ 0 ] [ 0 ] = + 4294967295 Then
		ADBSCREEN ( 1 )
		LOGINFO ( "Searching for webs" )
		$FINDED = IRLFINDPIC ( @ScriptDir & "\img\web.bmp" , $TMPRES , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 , 8 )
		LOGINFO ( "Ubound: " & $TMPRES [ 0 ] )
		$WEBCOORD [ 0 ] [ 0 ] = $TMPRES [ 0 ]
		If $TMPRES [ 0 ] > 0 Then
			For $I = 1 To $TMPRES [ 0 ]
				$WEBCOORD [ $I ] [ 0 ] = $TMPRES [ $I ] .X
				$WEBCOORD [ $I ] [ 1 ] = $TMPRES [ $I ] .Y
				$WEBCOORD [ $I ] [ 2 ] = 0
			Next
		EndIf
		IR_COMPARE_FREERESULT ( $TMPRES )
	EndIf
	If Not $WEBCOORD [ 0 ] [ 0 ] > 0 Then
		ADBSCREEN ( 1 )
		For $M = 0 To 16
			$WCCOLOR = CHECKCOLOR ( $WEBCOORD [ 1 ] [ 0 ] + 6 , $WEBCOORD [ 1 ] [ 1 ] + 4294967278 - $M , 0 , 0 , 0 )
			$HSL_COLOR = _COLORCONVERTRGBTOHSL ( $WCCOLOR )
			If ( ( $WCCOLOR [ 0 ] ) > 220 And $WCCOLOR [ 1 ] > 250 And $WCCOLOR [ 2 ] > 240 ) Or ( $HSL_COLOR [ 0 ] > 100 And $HSL_COLOR [ 1 ] > 110 And $HSL_COLOR [ 2 ] > 180 ) Then
				$ACTCOUNT = $ACTCOUNT + 1
				LOGINFO ( "+++" )
			Else
				$WEAPONSTATE = 0
			EndIf
		Next
		If $ACTCOUNT >= 2 Then
			$WEBCOORD [ 1 ] [ 2 ] = 1
			LOGINFO ( "Weapon active " )
		Else
			$WEBCOORD [ 1 ] [ 2 ] = 0
			LOGINFO ( "Weapon not active " )
		EndIf
	EndIf
	LOGINFO ( "Stop CheckWebState" )
EndFunc
Func CHECKWEAPONBOOSTSTATE ( )
	$CURRFUNCNAME = "CheckWeaponBoostState"
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0
	Local $AFILELIST
	Local $ACTCOUNT = 0
	Local $TMPRES
	LOGINFO ( "Start CheckWeaponBoostState" )
	If $WEAPONBOOSTCOORD [ 0 ] [ 0 ] = + 4294967295 Then
		$AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\weaponboost\" , "*.bmp" )
		ADBSCREEN ( 1 )
		For $M = 1 To $AFILELIST [ 0 ]
			LOGINFO ( "Searching for: " & $AFILELIST [ $M ] )
			$FINDED = IRLFINDPIC ( @ScriptDir & "\img\weaponboost\" & $AFILELIST [ $M ] , $TMPRES , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 , 8 )
			LOGINFO ( "Ubound: " & $TMPRES [ 0 ] )
			$WEAPONBOOSTCOORD [ 0 ] [ 0 ] = $TMPRES [ 0 ]
			If $TMPRES [ 0 ] > 0 Then
				For $I = 1 To $TMPRES [ 0 ]
					$WEAPONBOOSTCOORD [ $I ] [ 0 ] = $TMPRES [ $I ] .X
					$WEAPONBOOSTCOORD [ $I ] [ 1 ] = $TMPRES [ $I ] .Y
					$WEAPONBOOSTCOORD [ $I ] [ 2 ] = 0
				Next
				ExitLoop
			EndIf
		Next
		IR_COMPARE_FREERESULT ( $TMPRES )
		$WEAPONBOOSTTIMER = TimerInit ( )
	EndIf
	LOGINFO ( "Stop CheckWeaponBoostState" )
EndFunc
Func CHECKALWAYSONSTATE ( )
	$CURRFUNCNAME = "CheckAlwaysOnState"
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0
	Local $AFILELIST
	Local $ACTCOUNT = 0
	Local $FINDCOUNT = 1
	Local $TMPRES
	LOGINFO ( "Start CheckAlwaysOnState" )
	If $ALWAYSON [ 0 ] [ 0 ] = + 4294967295 Then
		$AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\always_on\" , "*.png" )
		ADBSCREEN ( 1 )
		For $M = 1 To $AFILELIST [ 0 ]
			LOGINFO ( "Searching for: " & $AFILELIST [ $M ] )
			$FINDED = IRLFINDPIC ( @ScriptDir & "\img\always_on\" & $AFILELIST [ $M ] , $TMPRES , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 , 8 , 0 , 40 )
			LOGINFO ( "Ubound: " & $TMPRES [ 0 ] )
			If $TMPRES [ 0 ] > 0 Then
				For $I = 1 To $TMPRES [ 0 ]
					If $TMPRES [ $I ] .MatchPercentage > 50 Then
						$ALWAYSON [ $FINDCOUNT ] [ 0 ] = $TMPRES [ $I ] .X
						$ALWAYSON [ $FINDCOUNT ] [ 1 ] = $TMPRES [ $I ] .Y
						$FINDCOUNT = $FINDCOUNT + 1
					EndIf
					If $FINDCOUNT = 8 Then
						LOGERROR ( "Too much finded" )
						ExitLoop ( 2 )
					EndIf
				Next
			EndIf
		Next
		$ALWAYSON [ 0 ] [ 0 ] = $FINDCOUNT + 4294967295
		If $FINDCOUNT > 0 Then $ALWAYSONSTATE = 0
		IR_COMPARE_FREERESULT ( $TMPRES )
	EndIf
	LOGINFO ( "Stop CheckAlwaysOnState" )
EndFunc
Func FIREALWAYSON ( )
	$CURRFUNCNAME = "FireAlwaysOn"
	Local $I
	Local $X_FINDED , $Y_FINDED
	Local $RET = 1
	LOGINFO ( "Start FireAlwaysOn" )
	SETDOINGSTATUS ( "FireAlwaysOn" )
	If $ALWAYSON [ 0 ] [ 0 ] > 0 Then
		If $ALWAYSONSTATE = 0 Then
			$ALWAYSONSTATE = 1
		Else
			$ALWAYSONSTATE = 0
		EndIf
		For $I = 1 To $ALWAYSON [ 0 ] [ 0 ]
			SENDTAP ( $ALWAYSON [ $I ] [ 0 ] , $ALWAYSON [ $I ] [ 1 ] , 5 )
		Next
	EndIf
	LOGINFO ( "Stop FireAlwaysOn" )
	Return $RET
EndFunc
Func CHECKANDCLOSESTATUS ( )
	$CURRFUNCNAME = "CheckAndCloseStatus"
	Local $X1 , $Y1
	Local $FINDED
	Local $RET = 0
	LOGINFO ( "Start CheckAndCloseStatus" )
	ADBSCREEN ( 1 )
	$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\close_status.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 713 , 33 , 1235 , 69 + 508 )
	If $FINDED Then
		LOGINFO ( "!Closing status" )
		SENDTAP ( $X1 , $Y1 , 4 )
		$RET = 1
	EndIf
	LOGINFO ( "Stop CheckAndCloseStatus" )
	Return $RET
EndFunc
Global $TRACKERCOMPTIMER = 0
Func CHECKTRACKERCOMPSTATE ( )
	$CURRFUNCNAME = "CheckTrackerCompState"
	Local $X1 , $Y1
	Local $FINDED
	LOGINFO ( "Start CheckTrackerCompState" )
	If $TRACKERCOMPCOORD [ 0 ] = + 4294967295 Then
		ADBSCREEN ( 1 )
		LOGINFO ( "Searching for: trackingcomp.bmp" )
		$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\trackingcomp.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 )
		If $FINDED Then
			$TRACKERCOMPCOORD [ 0 ] = $X1
			$TRACKERCOMPCOORD [ 1 ] = $Y1
			LOGINFO ( "TrackingComp finded" )
			$TRACKERCOMPTIMER = TimerInit ( )
		Else
			$TRACKERCOMPCOORD [ 0 ] = 0
			LOGINFO ( "TrackingComp NOT finded" )
		EndIf
	EndIf
	LOGINFO ( "Stop CheckTrackerCompState" )
EndFunc
Func FIRETRACKERCOMP ( )
	$CURRFUNCNAME = "FireTrackerComp"
	LOGINFO ( "Start FireTrackerComp" )
	Local $FDIFF = TimerDiff ( $TRACKERCOMPTIMER )
	SETDOINGSTATUS ( "Start FireTrackerComp" )
	If $TRACKERCOMPCOORD [ 0 ] > 0 And ( $TRACKERCOMPLASTACTIVATION + SECTOMSEC ( $TRACKERCOMPACTIVATIONTIME + $TRACKERCOMPREACTIVATIONTIME , 2 ) < $FDIFF Or $TRACKERCOMPLASTACTIVATION = 0 ) Then
		$TRACKERCOMPLASTACTIVATION = $FDIFF
		SENDTAP ( $TRACKERCOMPCOORD [ 0 ] , $TRACKERCOMPCOORD [ 1 ] , 4 )
	Else
		LOGINFO ( "Too early to activate" )
	EndIf
	LOGINFO ( "Stop FireTrackerComp" )
EndFunc
Func CHECKBATTERYSTATE ( )
	$CURRFUNCNAME = "CheckBatteryState"
	Local $X1 , $Y1
	Local $FINDED
	LOGINFO ( "Start CheckBatteryState" )
	If $BATTERYCOORD [ 0 ] = + 4294967295 Then
		ADBSCREEN ( 1 )
		LOGINFO ( "Searching for: battery.bmp" )
		$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\battery.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 779 , 540 , 779 + 495 , 540 + 168 )
		If $FINDED Then
			$BATTERYCOORD [ 0 ] = $X1
			$BATTERYCOORD [ 1 ] = $Y1
			LOGINFO ( "Battery finded" )
			$BATTERYCOORDTIMER = TimerInit ( )
		Else
			$BATTERYCOORD [ 0 ] = 0
			LOGINFO ( "Battery NOT finded" )
		EndIf
	EndIf
	LOGINFO ( "Stop CheckBatteryState" )
EndFunc
Func FIREBATTERY ( )
	$CURRFUNCNAME = "FireBattery"
	LOGINFO ( "Start FireBattery" )
	If $BATTERYCOORD [ 0 ] <= 0 Then
		LOGINFO ( "Dont have battery." )
		Return
	EndIf
	Local $FDIFF = TimerDiff ( $BATTERYTIMER )
	SETDOINGSTATUS ( "FireBattery" )
	LOGDEBUG ( "$BatteryLastActivation + $BatteryReactivationTime * 1000=" & $BATTERYLASTACTIVATION + $BATTERYREACTIVATIONTIME * 1000 & "   " & $FDIFF & " delta=" & $BATTERYLASTACTIVATION + $BATTERYREACTIVATIONTIME * 1000 - $FDIFF )
	If $BATTERYCOORD [ 0 ] > 0 And ( $BATTERYLASTACTIVATION + SECTOMSEC ( $BATTERYREACTIVATIONTIME + $BATTERYACTIVATIONTIME , 2 ) < $FDIFF Or $BATTERYLASTACTIVATION = 0 ) Then
		$BATTERYLASTACTIVATION = $FDIFF
		SENDTAP ( $BATTERYCOORD [ 0 ] , $BATTERYCOORD [ 1 ] , 4 )
	Else
		LOGINFO ( "Too early to activate" )
	EndIf
	LOGINFO ( "Stop FireBattery" )
EndFunc
Func FIREWEAPONBOOST ( )
	$CURRFUNCNAME = "FireWeaponBoost"
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0
	Local $AFILELIST
	Local $ACTCOUNT = 0
	Local $TMPRES
	LOGINFO ( "Start FireWeaponBoost" )
	If $WEAPONBOOSTCOORD [ 0 ] [ 0 ] <= 0 Then
		LOGINFO ( "Dont have FireWeaponBoost." )
		Return
	EndIf
	SETDOINGSTATUS ( "FireWeaponBoost" )
	Local $FDIFF = TimerDiff ( $WEAPONBOOSTTIMER )
	LOGINFO ( "$WeaponBoostLastActivation +SecToMsec($WeaponBoostActivationTime + $WeaponBoostActivationTime)=" & $WEAPONBOOSTLASTACTIVATION + SECTOMSEC ( $WEAPONBOOSTACTIVATIONTIME + $WEAPONBOOSTACTIVATIONTIME ) & " $fDiff=" & $FDIFF & " delta=" & $WEAPONBOOSTLASTACTIVATION + SECTOMSEC ( $WEAPONBOOSTACTIVATIONTIME + $WEAPONBOOSTACTIVATIONTIME ) - $FDIFF )
	If ( ( $WEAPONBOOSTCOORD [ 0 ] [ 0 ] > 0 And ( $WEAPONBOOSTLASTACTIVATION + SECTOMSEC ( $WEAPONBOOSTACTIVATIONTIME , 2 ) < $FDIFF ) ) Or $WEAPONBOOSTLASTACTIVATION = 0 ) Then
		For $I = 1 To $WEAPONBOOSTCOORD [ 0 ] [ 0 ]
			If $WEAPONBOOSTCOORD [ $I ] [ 2 ] + SECTOMSEC ( $WEAPONBOOSTACTIVATIONTIME + $WEAPONBOOSTREACTIVATIONTIME , 2 ) < $FDIFF Or $WEAPONBOOSTCOORD [ $I ] [ 2 ] = 0 Then
				LOGDEBUG ( "Boost " & $I & " firing" )
				$WEAPONBOOSTCOORD [ $I ] [ 2 ] = $FDIFF
				$WEAPONBOOSTLASTACTIVATION = $FDIFF
				SENDTAP ( $WEAPONBOOSTCOORD [ $I ] [ 0 ] , $WEAPONBOOSTCOORD [ $I ] [ 1 ] , 4 )
				ExitLoop
			Else
				LOGDEBUG ( "Boost " & $I & " not ready" )
			EndIf
		Next
	Else
		LOGINFO ( "Too early to activate" )
	EndIf
	LOGINFO ( "Stop FireWeaponBoost" )
EndFunc
Func FIREWEB ( )
	$CURRFUNCNAME = "FireWeb"
	Local $I
	Local $X_FINDED , $Y_FINDED
	Local $RET = 1
	LOGINFO ( "Start FireWeb" )
	If $WEBCOORD [ 0 ] [ 0 ] <= 0 Then
		LOGINFO ( "Dont have Web." )
		Return
	EndIf
	SETDOINGSTATUS ( "FireWeb" )
	If $WEBCOORD [ 0 ] [ 0 ] > 0 Then
		For $I = 1 To $WEBCOORD [ 0 ] [ 0 ]
			SENDTAP ( $WEBCOORD [ $I ] [ 0 ] , $WEBCOORD [ $I ] [ 1 ] , 5 )
		Next
		If ( WAITFINDPIC ( @ScriptDir & "\img\noavailabletarget_2.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 0.5 , 366 , 188 , 366 + 527 , 188 + 40 ) = 1 ) Then
			LOGINFO ( "no target" )
			$RET = 0
		EndIf
	EndIf
	LOGINFO ( "Stop FireWeb" )
	Return $RET
EndFunc
Func FIREWEAPON ( )
	$CURRFUNCNAME = "FireWeapon"
	Local $X_FINDED , $Y_FINDED
	Local $RET = 1
	Local $TIMER = TimerInit ( )
	Local $TIMEOUT = 1500
	LOGINFO ( "Start FireWeapon" )
	SETDOINGSTATUS ( "FireWeapon" )
	If $WEAPONCOORD [ 0 ] > 0 Then
		SENDTAP ( $WEAPONCOORD [ 0 ] , $WEAPONCOORD [ 1 ] , 5 )
		Do
			ADBSCREEN ( 1 )
			If ( WAITFINDPIC ( @ScriptDir & "\img\weapon_close.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 818 , 215 , 818 + 57 , 215 + 53 , 1 ) = 1 ) Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 2 )
				ExitLoop
			EndIf
			If ( WAITFINDPIC ( @ScriptDir & "\img\noavailabletarget_2.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 366 , 188 , 366 + 527 , 188 + 40 , 1 ) = 1 ) Then
				LOGINFO ( "no target" )
				$RET = 0
				ExitLoop
			EndIf
		Until TimerDiff ( $TIMER ) > $TIMEOUT
	EndIf
	LOGINFO ( "Stop FireWeapon" )
	Return $RET
EndFunc
Func CHECKEASYLOCK ( )
	$CURRFUNCNAME = "CheckEasyLock"
	LOGINFO ( "Start CheckEasyLock" )
	Local $X_FINDED , $Y_FINDED , $FINDED = 0
	If ( WAITFINDPIC ( @ScriptDir & "\img\easy_lock.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 764 , 426 , 764 + 68 , 426 + 63 ) = 1 ) Then
		LOGINFO ( "easy_lock finded" )
		SENDTAP ( $X_FINDED , $Y_FINDED , 2 )
		$FINDED = 1
	Else
		LOGINFO ( "easy_lock NOT finded" )
		$FINDED = 0
	EndIf
	LOGINFO ( "Stop CheckEasyLock" )
	Return $FINDED
EndFunc
Func SELECTCLOSESTENEMY ( $FOCUSFIRE = 0 , $FORCEDFOCUS = 0 )
	$CURRFUNCNAME = "SelectClosestEnemy"
	Local $RET = 0
	Local $M = 0
	Local $I = 1
	Local $WCCOLOR
	Local $ENEMYCOUNT = 0
	Local $SELECTEDENEMY = 0
	Local $FINDED = 0
	Local $TMPCOLOR
	Local $PIXELCOUNT = 0
	Local $SHIPARRAY [ 9 ]
	Local $FOCUSPRESSED = 0
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Start SelectClosestEnemy" )
	SETDOINGSTATUS ( "Selecting closest enemy" )
	For $M = 0 To UBound ( $SHIPARRAY ) + 4294967295
		$SHIPARRAY [ $M ] = 0
	Next
	ADBSCREEN ( 1 )
	$WCCOLOR = CHECKCOLOR ( 1037 , 90 , 0 , 0 , 0 )
	$HSL_COLOR = _COLORCONVERTRGBTOHSL ( $WCCOLOR )
	LOGINFO ( "h=" & Round ( $HSL_COLOR [ 0 ] ) & " s=" & Round ( $HSL_COLOR [ 1 ] ) & " l=" & Round ( $HSL_COLOR [ 2 ] ) )
	For $M = 1086 To 1086 + 30
		$TMPCOLOR = _COLORCONVERTRGBTOHSL ( CHECKCOLOR ( $M , 103 , 0 , 0 , 0 ) )
		If $TMPCOLOR [ 2 ] > 100 And $TMPCOLOR [ 0 ] > 90 Then $PIXELCOUNT = $PIXELCOUNT + 1
	Next
	LOGINFO ( "PixelCount=" & $PIXELCOUNT )
	If ( $HSL_COLOR [ 0 ] > 0 And $HSL_COLOR [ 0 ] < 12 And $HSL_COLOR [ 2 ] > 46 And $HSL_COLOR [ 2 ] < 70 ) Or $PIXELCOUNT > 7 Then
		LOGINFO ( "Enemy`s finded and cloesest already selected" )
		$ENEMYCOUNT = 1
		$SELECTEDENEMY = 1
	Else
		If $ADB_CLICK Then SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		Sleep ( 300 )
		ADBSCREEN ( 1 )
		LOGINFO ( "Full cycle" )
		For $M = 66 To 527 Step 71
			$WCCOLOR = CHECKCOLOR ( 1031 , $M , 0 , 0 , 0 )
			Local $SHIPCOLOR = _COLORCONVERTRGBTOHSL ( CHECKCOLOR ( 1056 , $M + 24 , 0 , 0 , 0 ) )
			If ( INRANGE ( $SHIPCOLOR [ 0 ] , 0 , 10 ) And INRANGE ( $SHIPCOLOR [ 1 ] , 230 , 250 ) And INRANGE ( $SHIPCOLOR [ 2 ] , 70 , 90 ) ) Then
				LOGINFO ( "!enemy" )
				$SHIPARRAY [ $I ] = 1
			EndIf
			If ( INRANGE ( $SHIPCOLOR [ 0 ] , 130 , 150 ) And INRANGE ( $SHIPCOLOR [ 1 ] , 0 , 20 ) And INRANGE ( $SHIPCOLOR [ 2 ] , 110 , 131 ) ) Then
				LOGINFO ( "!neutral" )
				$SHIPARRAY [ $I ] = 2
			EndIf
			If ( INRANGE ( $SHIPCOLOR [ 0 ] , 140 , 160 ) And INRANGE ( $SHIPCOLOR [ 1 ] , 230 , 250 ) And INRANGE ( $SHIPCOLOR [ 2 ] , 70 , 90 ) ) Then
				LOGINFO ( "!ally" )
				$SHIPARRAY [ $I ] = 3
			EndIf
			LOGINFO ( "shpclr=" & $M & " has h=" & Round ( $SHIPCOLOR [ 0 ] ) & " s=" & Round ( $SHIPCOLOR [ 1 ] ) & " l=" & Round ( $SHIPCOLOR [ 2 ] ) )
			$HSL_COLOR = _COLORCONVERTRGBTOHSL ( $WCCOLOR )
			LOGINFO ( "m=" & $M & " has h=" & Round ( $HSL_COLOR [ 0 ] ) & " s=" & Round ( $HSL_COLOR [ 1 ] ) & " l=" & Round ( $HSL_COLOR [ 2 ] ) )
			If ( $HSL_COLOR [ 0 ] > 0 And $HSL_COLOR [ 0 ] < 13 ) Then
				If $SHIPARRAY [ $I ] = 0 Then $SHIPARRAY [ $I ] = 4
				$ENEMYCOUNT = $ENEMYCOUNT + 1
				LOGINFO ( "+++" )
				If ( $HSL_COLOR [ 2 ] > 46 And $HSL_COLOR [ 2 ] < 66 ) Then
					LOGINFO ( "selected i=" & $I )
					$SELECTEDENEMY = $I
				Else
					$REPAIRSTATE = 0
				EndIf
			Else
				$REPAIRSTATE = 0
			EndIf
			$I = $I + 1
		Next
		LOGINFO ( "1Enemy`s count=" & $ENEMYCOUNT & ".Selected enemy=" & $SELECTEDENEMY )
		GUICtrlSetData ( $LABEL_CARGO , "Enemy count:" & $ENEMYCOUNT & "/" & $SELECTEDENEMY )
		SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 100 , 200 , 1 ) )
	EndIf
	If ( $FOCUSFIRE And $ENEMYCOUNT > 0 And $SELECTEDENEMY <> 1 ) Or $FORCEDFOCUS = 1 Then
		Local $TMMP = 0
		For $I = 1 To UBound ( $SHIPARRAY ) + 4294967295
			If $SHIPARRAY [ $I ] = 4 Then
				SENDTAP ( 1131 , 69 * $I , 5 )
				$TMMP = 1
				ExitLoop
			EndIf
		Next
		If $TMMP = 0 Then SENDTAP ( 1131 , 69 , 5 )
		If ( WAITFINDPIC ( @ScriptDir & "\img\focusfire_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 780 , 10 , 780 + 103 , 10 + 675 ) = 1 ) Then
			LOGINFO ( "focusfire_ico" )
			SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
			$FINDED = 1
			$FOCUSPRESSED = 1
		Else
			LOGINFO ( "focusfire_ico NOT finded" )
			$FINDED = 0
		EndIf
		If $FOCUSPRESSED = 0 Then SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
	EndIf
	LOGINFO ( "2Enemy`s count=" & $ENEMYCOUNT & ".Selected enemy=" & $SELECTEDENEMY )
	LOGINFO ( "Stop SelectClosestEnemy" )
	Return $ENEMYCOUNT
EndFunc
Func SWITCHCOORDS ( $YCOORD )
	$CURRFUNCNAME = "SwitchCoords"
	Local $RET = + 4294967295
	Switch $YCOORD
	Case 1 To 68
		$RET = 0
	Case 69 To 134
		$RET = 1
	Case 138 To 203
		$RET = 2
	Case 207 To 272
		$RET = 3
	Case 276 To 341
		$RET = 4
	Case 345 To 410
		$RET = 5
	Case 414 To 479
		$RET = 6
	Case 483 To 548
		$RET = 7
	Case 552 To 617
		$RET = 8
	Case 621 To 686
		$RET = 9
	Case 690 To 755
		$RET = 10
	EndSwitch
	ConsoleWrite ( "!> $ret$ret: " & $RET & @CRLF )
	Return $RET
EndFunc
Func CHECKENEMYCOUNTER ( $MAKESCREENSHOT = 0 )
	$CURRFUNCNAME = "CheckEnemyCounter"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $X_FINDED , $Y_FINDED
	Local $RET
	If $MAKESCREENSHOT Then ADBSCREEN ( 1 )
	If ( WAITFINDPICD ( @ScriptDir & "\img\enemy_counter.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 972 , 233 , 26 , 141 , 1 ) = 1 ) Then
		$RET = 1
		LOGINFO ( "Counter finded" )
	Else
		$RET = 0
		LOGINFO ( "Counter not finded" )
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
	Return $RET
EndFunc
Global $SCANSTOP = 0
Global $SIGNATURELIST [ 300 ] [ 10 ]
Global $SIGNATURECOUNT
Global $MBUBBLECOORD [ ]
$MBUBBLECOORD .X = 961
$MBUBBLECOORD .Y = 53
Func DUMBFUNCTION ( )
	$CURRFUNCNAME = "DumbFunction"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func DUMBJUMP ( )
	$CURRFUNCNAME = "DumbJump"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	SENDTAP ( 8 , 198 , 1 )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func CHECKFORNIHIL ( )
	$CURRFUNCNAME = "CheckForNihil"
	Local $FINDED
	Local $RET = 0
	LOGINFO ( "Start " & $CURRFUNCNAME )
	$FINDED = WAITFINDPICD ( @ScriptDir & "\img\finded_nihilus.bmp" , $X_FINDED , $Y_FINDED , 0.9 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 907 , 202 , 282 , 398 )
	If $FINDED = 1 Then
		$RET = 1
	Else
		$RET = 0
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
	Return $RET
EndFunc
Func ANALYZEANDTAKELOOT ( )
	$CURRFUNCNAME = "AnalyzeAndTakeLoot"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	GUICtrlSetState ( $BUTTON_ADBINJECT , $GUI_DISABLE )
	AFTERBURNERFIND ( )
	SETDOINGSTATUS ( "Analyzing and taking loot" )
	Local $X_FINDED , $Y_FINDED
	Local $X_LOOT , $Y_LOOT
	Local $TMPRES
	Local $TMPENABLEBOT = 0
	If $BOT_ENABLED = 0 Then
		$BOT_ENABLED = 1
		$TMPENABLEBOT = 1
	EndIf
	While 1
		SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		Sleep ( 1000 )
		ADBSCREEN ( 1 )
		If ( IRLFINDPIC ( @ScriptDir & "\img\loot_closed.bmp" , $TMPRES , $X_LOOT , $Y_LOOT , 10 , @ScriptDir & "\screenshot\screenshot.bmp" , 1038 , 78 , 1038 + 41 , 78 + 578 , 1 , 0 , 60 ) = 1 ) Then
			LOGINFO ( "Closed loot finded" )
			SENDTAP ( $X_LOOT + 116 , $Y_LOOT , 5 )
			If ( WAITFINDPICD ( @ScriptDir & "\img\lock_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 , 789 , 20 , 70 , 576 ) = 1 ) Then
				Sleep ( 300 )
				SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 5 )
				Sleep ( 30 )
				SENDTAP ( $MBUBBLECOORD .X , $MBUBBLECOORD .Y , 5 )
				If ( WAITFINDPICD ( @ScriptDir & "\img\approach_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 , 709 , 20 , 270 , 576 ) = 1 ) Then
					Sleep ( 300 )
					SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
				EndIf
			EndIf
			WAITUNTILSHIPSTARTMOVING ( )
			$BOTTYPE = 5
			$NEEDCHECKLOCAL = 0
			WAITUNTILSHIPMOVING ( 1 , 0 , 0 , 0 , 1 , 0 )
			SETDOINGSTATUS ( "Analyzing and taking loot" )
			If Random ( 0 , 1 , 1 ) = 1 Then
				SENDTAP ( 937 , 661 , 5 )
				Sleep ( 300 )
				SENDTAP ( 1009 , 661 , 5 )
			Else
				SENDTAP ( 1009 , 661 , 5 )
				Sleep ( 300 )
				SENDTAP ( 937 , 661 , 5 )
			EndIf
			If ( WAITFINDPICD ( @ScriptDir & "\img\loot_all_btn.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 80 , 361 , 394 , 868 , 284 ) = 1 ) Then
				Sleep ( 3000 )
				SENDTAP ( $X_FINDED , $Y_FINDED , 5 )
				Sleep ( 3000 )
				SENDTAP ( $MBUBBLECOORD .X , $MBUBBLECOORD .Y , 5 )
				If ( WAITFINDPICD ( @ScriptDir & "\img\unlock.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 , 709 , 20 , 270 , 576 ) = 1 ) Then
					Sleep ( 300 )
					SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
				EndIf
			Else
				LOGERROR ( "not finded loot butn" )
			EndIf
		Else
			LOGINFO ( "Closed loot not finded" )
			TrayTip ( "" , "Cannon find any loot" , 30 , 1 )
			ExitLoop
		EndIf
		If $BOT_ENABLED = 0 Then ExitLoop
		Sleep ( 100 )
	WEnd
	If $TMPENABLEBOT = 1 Then
		$BOT_ENABLED = 0
	EndIf
	GUICtrlSetState ( $BUTTON_ADBINJECT , $GUI_ENABLE )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func PREPARESIGNATURELIST ( )
	$CURRFUNCNAME = "PrepareSignatureList"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	$SIGLISTFILENAME = @ScriptDir & "\SigList.txt"
	$SIGNATURECOUNT = + 4294967295
	$H = FileOpen ( $SIGLISTFILENAME , 0 )
	Local $I
	$I = 0
	Local $M
	ConsoleWrite ( "File:" & $SIGLISTFILENAME & " handle:" & $H & @CRLF )
	While 1
		$NEXTLINE = FileReadLine ( $H )
		If @error Then
			FileClose ( $H )
			ExitLoop
		Else
			$SIGNATURECOUNT = $SIGNATURECOUNT + 1
			Local $STRINGSPLIT = StringSplit ( $NEXTLINE , ";" )
			$SIGNATURELIST [ $STRINGSPLIT [ 1 ] ] [ 0 ] = $STRINGSPLIT [ 2 ]
			For $I = 3 To $STRINGSPLIT [ 0 ]
				$SIGNATURELIST [ $STRINGSPLIT [ 1 ] ] [ $I + 4294967294 ] = $STRINGSPLIT [ $I ]
			Next
		EndIf
	WEnd
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func CHECKWIDESCANRESULT ( $FIRE = 0 )
	$CURRFUNCNAME = "CheckWideScanResult"
	LOGINFO ( "Start CheckWideScanResult" )
	Local $X_FINDED , $Y_FINDED , $FINDED = 0
	If ( WAITFINDPIC ( @ScriptDir & "\img\scan_successful.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 , 7 , 75 , 7 + 86 , 75 + 218 ) = 1 ) Then
		LOGINFO ( "Scan successful" )
		If $FIRE = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 2 )
			LOGINFO ( "CheckWideScanResult fired" )
			Sleep ( 2000 )
			If ( WAITFINDPICD ( @ScriptDir & "\img\starmap_ico.bmp" , $X_FINDED , $Y_FINDED , 0.9 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 , 917 , 369 , 344 , 102 ) = 1 ) Then
				If $X_FINDED > 1000 Then
					SENDTAP ( $X_FINDED , $Y_FINDED , 2 )
					Sleep ( 1000 )
				EndIf
			EndIf
		EndIf
		$FINDED = 1
	Else
		LOGINFO ( "Scan NOT successful" )
		$FINDED = 0
	EndIf
	LOGINFO ( "Stop CheckWideScanResult" )
	Return $FINDED
EndFunc
Func CHECKFORAVAILABLESCANSITE ( $TIMEOUT = 5 , $PRESSSCANSITE = 0 )
	$CURRFUNCNAME = "CheckForAvailableScanSite"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $X_FINDED , $Y_FINDED , $FINDED = 0
	If ( WAITFINDPIC ( @ScriptDir & "\img\close_starmap.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $TIMEOUT , 1185 , 8 , 1185 + 84 , 8 + 68 ) = 1 ) Then
		If ( WAITFINDPIC ( @ScriptDir & "\img\abletoscan.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 989 , 167 , 989 + 70 , 167 + 322 ) = 1 ) Then
			LOGINFO ( "AvailableScanSite finded" )
			$FINDED = 1
		Else
			LOGINFO ( "AvailableScanSite not finded" )
			SENDTAP ( 1233 , 36 , 4 )
			Do
				Sleep ( 100 )
				$ENGINEAVAILABLE = CHECKENGINEAVAILABLE ( )
			Until $ENGINEAVAILABLE = 1
			Sleep ( 100 )
			$FINDED = 0
		EndIf
	Else
		LOGERROR ( "Not finded" )
	EndIf
	If $FINDED = 1 And $PRESSSCANSITE = 1 Then
		SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
		Sleep ( 1500 )
		SENDTAP ( 1129 , 623 , 4 )
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
	Return $FINDED
EndFunc
Func CHECKWIDESCAN ( $FIRE = 0 )
	$CURRFUNCNAME = "CheckWideScan"
	LOGINFO ( "Start CheckWideScan" )
	Local $X_FINDED , $Y_FINDED , $FINDED = 0
	If ( WAITFINDPIC ( @ScriptDir & "\img\wide_scanner.bmp" , $X_FINDED , $Y_FINDED , 0.75 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 779 , 540 , 779 + 495 , 540 + 168 ) = 1 ) Then
		LOGINFO ( "wide_scanner finded" )
		If $FIRE = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
			SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
			SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
			LOGINFO ( "wide_scanner fired" )
			Sleep ( 2000 )
			CHECKANDCLOSESTATUS ( )
		EndIf
		$FINDED = 1
	Else
		LOGINFO ( "wide_scanner not finded" )
		$FINDED = 0
	EndIf
	LOGINFO ( "Stop CheckWideScan" )
	Return $FINDED
EndFunc
Func CHECKENGINEAVAILABLE ( $FIRE = 0 )
	$CURRFUNCNAME = "CheckEngineAvailable"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $X_FINDED , $Y_FINDED , $FINDED = 0
	If ( WAITFINDPIC ( @ScriptDir & "\img\engine_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 493 , 565 , 493 + 42 , 565 + 48 ) = 1 ) Then
		LOGINFO ( "engine_ico finded" )
		If $FIRE = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 2 )
			LOGINFO ( "engine_ico fired" )
		EndIf
		$FINDED = 1
	Else
		LOGINFO ( "engine_ico not finded" )
		$FINDED = 0
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
	Return $FINDED
EndFunc
Func CHECKPLANET ( )
	$CURRFUNCNAME = "CheckPlanet"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	PREPARESIGNATURELIST ( )
	Local $I , $J = 0 , $M = 0
	Local $X_FINDED , $Y_FINDED
	Local $SIGNATUREFINDED = 0
	Local $UNKNOWNSIGNATUREFINDED = 0
	Local $FINDEDPLANETSSIGNATURE [ 5 ]
	Local $FILENAMETOHELPER = ""
	Local $RET = 0
	ADBSCREEN ( 1 )
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	While 1
		LOGDEBUG ( "CurrentUnknownSignature=" & $M )
		SETDOINGSTATUS ( "Chechkin signature:" & $M & "/" & $SIGNATURECOUNT )
		If FileExists ( @ScriptDir & "\img\scansignature\" & $M & ".bmp" ) Then
			$UNKNOWNSIGNATUREFINDED = WAITFINDPICD ( @ScriptDir & "\img\scansignature\" & $M & ".bmp" , $X_FINDED , $Y_FINDED , 0.9 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 61 , 124 , 878 , 488 , 1 )
			LOGDEBUG ( "$SignatureFinded=" & $UNKNOWNSIGNATUREFINDED )
			If $UNKNOWNSIGNATUREFINDED Then
				LOGDEBUG ( "Finded Unknownsignature=" & $M )
				ExitLoop
			Else
				LOGDEBUG ( "NOT Finded Unknownsignature" )
			EndIf
			$M = $M + 1
		Else
			Local $TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 110 , 203 , 800 , 368 )
			Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $TTMPBITMAP , @ScriptDir & "\img\scansignature\" & $M & ".bmp" )
			$FILENAMETOHELPER = @ScriptDir & "\img\scansignature\" & $M & ".bmp"
			$UNKNOWNSIGNATUREFINDED = + 4294967295
			ExitLoop
		EndIf
	WEnd
	For $I = 0 To 4
		LOGDEBUG ( "CurrentPlanet=" & $I )
		While 1
			LOGDEBUG ( "CurrentSignature=" & $J )
			If FileExists ( @ScriptDir & "\img\scansignature\planets\" & $J & ".bmp" ) Then
				$SIGNATUREFINDED = WAITFINDPICD ( @ScriptDir & "\img\scansignature\planets\" & $J & ".bmp" , $X_FINDED , $Y_FINDED , 0.75 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 960 , 206 + 79 * $I , 225 , 80 , 1 )
				LOGDEBUG ( "$SignatureFinded=" & $SIGNATUREFINDED )
				If $SIGNATUREFINDED Then
					LOGDEBUG ( "Finded signature=" & $J )
					$FINDEDPLANETSSIGNATURE [ $I ] = $J
					ExitLoop
				Else
					LOGDEBUG ( "NOT Finded signature" )
				EndIf
				$J = $J + 1
			Else
				ExitLoop
			EndIf
		WEnd
		If $SIGNATUREFINDED = 0 Then
			LOGDEBUG ( "Saving new signature i=" & $I & " j=" & $J )
			$FINDEDPLANETSSIGNATURE [ $I ] = $J
			Local $TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 967 , 206 + 79 * $I , 218 , 75 )
			Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $TTMPBITMAP , @ScriptDir & "\img\scansignature\planets\" & $J & ".bmp" )
		EndIf
		$J = 0
	Next
	LOGDEBUG ( "" )
	LOGDEBUG ( "########" )
	LOGDEBUG ( "Signature=" & $M )
	For $I = 0 To 4
		LOGDEBUG ( "Planet=" & $I + 1 & " is number of signature=" & $FINDEDPLANETSSIGNATURE [ $I ] )
	Next
	LOGDEBUG ( "########" )
	LOGDEBUG ( "" )
	LOGDEBUG ( "$UnknownSignatureFinded=" & $UNKNOWNSIGNATUREFINDED )
	LOGDEBUG ( "$m=" & $M )
	If $UNKNOWNSIGNATUREFINDED >= 0 Then
		Local $NEEDTOFIND = $SIGNATURELIST [ $M ] [ 0 ]
		LOGDEBUG ( "$NeedToFind=" & $NEEDTOFIND )
		For $I = 1 To 9
			If $NEEDTOFIND > 0 Then
				LOGDEBUG ( "$SignatureList[$m][$i]=" & $SIGNATURELIST [ $M ] [ $I ] )
				If _ARRAYSEARCH ( $FINDEDPLANETSSIGNATURE , $SIGNATURELIST [ $M ] [ $I ] ) >= 0 Then
					Local $Y_COORD = _ARRAYSEARCH ( $FINDEDPLANETSSIGNATURE , $SIGNATURELIST [ $M ] [ $I ] ) * 79 + 236
					LOGDEBUG ( "_ArraySearch=" & _ARRAYSEARCH ( $FINDEDPLANETSSIGNATURE , $SIGNATURELIST [ $M ] [ $I ] ) )
					SENDTAP ( 1065 , $Y_COORD , 5 )
					Sleep ( 1000 )
					SENDTAP ( 1165 , $Y_COORD , 5 )
					Sleep ( 1000 )
					$NEEDTOFIND = $NEEDTOFIND + 4294967295
					LOGDEBUG ( "$NeedToFind=" & $NEEDTOFIND )
				Else
					LOGDEBUG ( "Coords not finded" )
				EndIf
			Else
				LOGDEBUG ( "List completed" )
				$RET = 1
				ExitLoop
			EndIf
		Next
	Else
		TrayTip ( "" , "Unknown signature" , 30 , 1 )
		SETDOINGSTATUS ( "Unknown signature" )
	EndIf
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	If IsDeclared ( "TTmpBitmap" ) Then _GDIPLUS_BITMAPDISPOSE ( $TTMPBITMAP )
	If $RET = 0 Then MEANDRHELPER ( $FILENAMETOHELPER )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
	Return $RET
EndFunc
Func MAINSCANLOOP ( )
	$CURRFUNCNAME = "MainScanLoop"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $ENGINEAVAILABLE = 0
	Do
		If $SCANSTOP <> 2 Then CHECKWIDESCAN ( 1 )
		If $SCANSTOP = 2 Or CHECKWIDESCANRESULT ( 1 ) = 0 Then
			SETDOINGSTATUS ( "Next jump" )
			DUMBJUMP ( )
			Do
				Sleep ( 100 )
				$ENGINEAVAILABLE = CHECKENGINEAVAILABLE ( )
			Until $ENGINEAVAILABLE = 1
			LOGDEBUG ( "Wait Jump" )
			Do
				Sleep ( 100 )
				$ENGINEAVAILABLE = CHECKENGINEAVAILABLE ( )
			Until $ENGINEAVAILABLE = 0
			LOGDEBUG ( "Jumping" )
			Do
				Sleep ( 100 )
				$ENGINEAVAILABLE = CHECKENGINEAVAILABLE ( )
			Until $ENGINEAVAILABLE = 1
			LOGDEBUG ( "Jumping end" )
			ENGINESTOP ( )
			Sleep ( 500 )
			$SCANSTOP = 0
		Else
			LOGDEBUG ( "Scanned successful" )
			If CHECKFORAVAILABLESCANSITE ( 5 , 1 ) = 1 Then
				$SCANSTOP = 1
				TrayTip ( "" , "Scansite finded!" , 30 , 1 )
				If 1 Then
					Sleep ( 7000 )
					If CHECKPLANET ( ) = 1 Then
						If CHECKFORNIHIL ( ) = 0 Then
							Sleep ( 2000 )
							SENDTAP ( 1041 , 559 , 10 )
							Sleep ( 2000 )
							SENDTAP ( 887 , 523 , 10 )
							Sleep ( 2000 )
							SENDTAP ( 1163 , 131 , 10 )
							Sleep ( 2000 )
							SENDTAP ( 1231 , 40 , 10 )
							Sleep ( 5000 )
							WAITUNTILSHIPSTARTMOVING ( )
							$NEEDCHECKLOCAL = 0
							WAITUNTILSHIPMOVING ( 1 , 0 , 0 , 0 , 1 , 0 )
							ANALYZEANDTAKELOOT ( )
							$SCANSTOP = 0
						Else
							SENDTAP ( 1163 , 131 , 10 )
							Sleep ( 2000 )
							SENDTAP ( 1231 , 40 , 10 )
							Sleep ( 5000 )
							$SCANSTOP = 0
						EndIf
					EndIf
				EndIf
			Else
				$SCANSTOP = 2
			EndIf
		EndIf
	Until $SCANSTOP = 1 Or $BOT_ENABLED = 0
	$SCANSTOP = 2
	Return 1
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func CALCULATEBASESHIFT ( $X , ByRef $YSHIFT , $TYPE = 0 )
	Local $RET = 0
	Switch $X
	Case 0 To 54
		$RET = 72
		$YSHIFT = 87
	Case 55 To 137
		$RET = 247
		$YSHIFT = + 4294967209
	Case 138 To 221
		$RET = 72
		$YSHIFT = 87
	Case 222 To 306
		$RET = 247
		$YSHIFT = + 4294967209
	Case 307 To 390
		$RET = 72
		$YSHIFT = 87
	Case 391 To 474
		$RET = 247
		$YSHIFT = + 4294967209
	Case 474 To 559
		$RET = 72
		$YSHIFT = 87
	Case 560 To 643
		$RET = 247
		$YSHIFT = + 4294967209
	Case 644 To 7200
		$RET = 72
		$YSHIFT = 87
	EndSwitch
	Return $RET
EndFunc
Func MEANDRHELPER ( $FILENAME )
	Local $CURRFUNCNAME = "Test"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $PIXELS [ 300 ]
	Local $YBASE = 0
	Local $YSHIFT
	Local $X , $Y
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( $FILENAME )
	For $X = 0 To 790
		$YBASE = CALCULATEBASESHIFT ( $X , $YSHIFT )
		For $Y = $YBASE + 4294967256 To $YBASE + 40
			$PIXELS [ $Y ] = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $X , $Y )
			_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X , $Y , 1429489232 )
		Next
		$YBASE = CALCULATEBASESHIFT ( $X , $YSHIFT )
		For $Y = $YBASE + 4294967256 To $YBASE + 40
			_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X , $Y + $YSHIFT , $PIXELS [ $Y ] )
		Next
	Next
	$ANSW = _GDIPLUS_IMAGESAVETOFILE ( $BITMAP , @ScriptDir & "\testshift.bmp" )
	ConsoleWrite ( $ANSW & " " & @error & " " & @extended & @CRLF )
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Global Enum $LOG_TRACE , $LOG_DEBUG , $LOG_INFO , $LOG_WARN , $LOG_ERROR , $LOG_FATAL
Local Const $LOG_LEVELSTRING [ 6 ] = [ "TRACE" , "DEBUG" , "INFO " , "WARN " , "ERROR" , "FATAL" ]
Local $LASTLOGHANDLE = + 4294967295
Local $MINLEVEL = $LOG_TRACE
Local $LOGFORMAT = _LOGFORMATDEFAULT
Func LOGFILE ( $SFILENAME )
	Local $RETURN
	Local $PROCESS_KILLED
	GUICtrlSetData ( $LABEL_DOING , "Compressing logs" )
	$RETURN = RunWait ( "cmd /c " & @ScriptDir & "\7z\7z.exe a -mmt2 -sdel ""logs\logs.7z"" ""logs\*.log""" , "" , @SW_HIDE )
	ConsoleWrite ( "logreturn=" & $RETURN & @CRLF )
	ConsoleWrite ( "err=" & @error & @CRLF )
	$LASTLOGHANDLE = FileOpen ( $SFILENAME & "log" & @YEAR & @MON & @MDAY & @MIN & @SEC & ".log" , 1 + 8 )
	GUICtrlSetData ( $LABEL_DOING , "Wasting electricity" )
EndFunc
Func LOGLEVEL ( $IMINLEVEL )
	$MINLEVEL = $IMINLEVEL
EndFunc
Func LOGSTART ( )
	LOGMESSAGEUNFORMATTED ( "" )
	LOGINFO ( @ScriptFullPath & " started." )
	LOGMESSAGEUNFORMATTED ( "" )
EndFunc
Func LOGTRACE ( $SMESSAGE )
	LOGMESSAGE ( $LOG_TRACE , $SMESSAGE )
EndFunc
Func LOGDEBUG ( $SMESSAGE )
	LOGMESSAGE ( $LOG_DEBUG , $SMESSAGE )
EndFunc
Func LOGINFO ( $SMESSAGE )
	LOGMESSAGE ( $LOG_INFO , $SMESSAGE )
EndFunc
Func LOGWARN ( $SMESSAGE )
	LOGMESSAGE ( $LOG_WARN , $SMESSAGE )
EndFunc
Func LOGERROR ( $SMESSAGE )
	LOGMESSAGE ( $LOG_ERROR , $SMESSAGE )
EndFunc
Func LOGFATAL ( $SMESSAGE )
	LOGMESSAGE ( $LOG_FATAL , $SMESSAGE )
EndFunc
Func LOGMESSAGE ( $ILEVEL = $LOG_INFO , $SMESSAGE = "" )
	If $LASTLOGHANDLE == + 4294967295 Then
		LOGFILE ( @ScriptName & ".log" )
	EndIf
	Local $SLEVEL = LOGLEVELTOSTRING ( $ILEVEL )
	If @error Then
		ConsoleWriteError ( "Log.au3: Invalid log level given!" )
		Return SetError ( 2 , 0 , + 4294967295 )
	EndIf
	$SMESSAGE = $LOGFORMAT ( $SLEVEL , $SMESSAGE )
	If $ILEVEL >= $LOG_ERROR Then
		ConsoleWrite ( "!" & $SMESSAGE & @CRLF )
	Else
		ConsoleWrite ( $SMESSAGE & @CRLF )
	EndIf
	If $ILEVEL < $MINLEVEL Then
		Return
	EndIf
	FileWriteLine ( $LASTLOGHANDLE , $SMESSAGE )
EndFunc
Func LOGMESSAGEUNFORMATTED ( $SMESSAGE )
	If $LASTLOGHANDLE == + 4294967295 Then
		LOGFILE ( @ScriptName & ".log" )
	EndIf
	ConsoleWrite ( $SMESSAGE & @CRLF )
	FileWriteLine ( $LASTLOGHANDLE , $SMESSAGE )
EndFunc
Func LOGLEVELTOSTRING ( $ILEVEL )
	If $ILEVEL < 0 Or $ILEVEL > UBound ( $LOG_LEVELSTRING ) + 4294967295 Then
		Return SetError ( 1 , 0 , "" )
	EndIf
	Return $LOG_LEVELSTRING [ $ILEVEL ]
EndFunc
Func LOGCLOSE ( )
	FileClose ( $LASTLOGHANDLE )
	$LASTLOGHANDLE = + 4294967295
EndFunc
Func LOGFORMAT ( $FFORMATFUNC )
	$LOGFORMAT = $FFORMATFUNC
EndFunc
Func _LOGFORMATDEFAULT ( $SLEVEL , $SMESSAGE )
	If $MAXLENFUNCNAME < StringLen ( $CURRFUNCNAME ) Then $MAXLENFUNCNAME = StringLen ( $CURRFUNCNAME )
	Return "[" & @HOUR & ":" & @MIN & ":" & @SEC & "." & @MSEC & "][" & $SLEVEL & "][" & $CURRFUNCNAME & "] " & $SMESSAGE
EndFunc
HotKeySet ( "{PAUSE}" , "Test" )
HotKeySet ( "{PRINTSCREEN}" , "MakeSreenshot" )
Func GETBALANCE ( )
	$CURRFUNCNAME = "GetBalance"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $X_FINDED , $Y_FINDED
	Local $ISCALE = 4
	SENDTAP ( 63 , 33 , 10 )
	Local $RET = 0
	If ( WAITFINDPICD ( @ScriptDir & "\img\wallet_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 , 289 , 161 , 85 , 77 ) = 1 ) Then
		Sleep ( 1000 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 5 )
		If ( WAITFINDPICD ( @ScriptDir & "\img\wallet_plus.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 , 106 , 147 , 60 , 54 ) = 1 ) Then
			Sleep ( 1000 )
			ADBSCREEN ( 1 )
			Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
			Local $SOCRTEXTRESULT
			Local $TTMPBITMAP
			Local $HBITMAP_SCALED
			$TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 198 , 151 , 195 , 48 )
			$HBITMAP_SCALED = _GDIPLUS_IMAGESCALE ( $TTMPBITMAP , $ISCALE , $ISCALE , 4 )
			Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $HBITMAP_SCALED , @ScriptDir & "\screenshot\uwpocr.bmp" )
			_GDIPLUS_BITMAPDISPOSE ( $HBITMAP_SCALED )
			_GDIPLUS_BITMAPDISPOSE ( $TTMPBITMAP )
			_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
			_WINAPI_DELETEOBJECT ( $BITMAP )
			Local $PROCESS_KILLED
			$TREASURE = LAUNCHCONSOLE2 ( "cmd /c " & $TESSERACTFOLDER & "tesseract.exe screenshot\uwpocr.bmp - --psm 8 -l digitsall_layer quiet" )
			LOGINFO ( "$TreasureRAW1:" & $TREASURE )
			If $TREASURE > 0 Then
				$TREASURE = StringStripWS ( $TREASURE , $STR_STRIPALL )
				$TREASURE = StringRegExpReplace ( $TREASURE , "\r\n|\r|\n|\f" , " " )
				$TREASURE = StringReplace ( $TREASURE , "." , "" )
				$TREASURE = StringReplace ( $TREASURE , "," , "" )
				$TREASURE = StringReplace ( $TREASURE , "," , "" )
				$RET = Number ( $TREASURE )
			EndIf
			LOGINFO ( "Treasure:" & $RET )
			If FileExists ( @ScriptDir & "\screenshot\uwpocr.bmp" ) Then FileDelete ( @ScriptDir & "\screenshot\uwpocr.bmp" )
			SENDTAP ( 1137 , 83 , 10 )
			Sleep ( 4000 )
		Else
			LOGERROR ( "Not in wallet" )
		EndIf
	Else
		LOGERROR ( "Cannot find wallet" )
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
	If $RET > 0 Then Return $RET
EndFunc
Func TAKELOOT ( )
	$CURRFUNCNAME = "TakeLoot"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	AFTERBURNERFIND ( )
	Local $X_FINDED , $Y_FINDED
	Local $X_LOOT , $Y_LOOT
	Local $TMPRES
	While 1
		SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		Sleep ( 1000 )
		ADBSCREEN ( 1 )
		If ( IRLFINDPIC ( @ScriptDir & "\img\loot_closed.bmp" , $TMPRES , $X_LOOT , $Y_LOOT , 10 , @ScriptDir & "\screenshot\screenshot.bmp" , 1038 , 78 , 1038 + 41 , 78 + 578 , 1 , 0 , 60 ) = 1 Or IRLFINDPIC ( @ScriptDir & "\img\wrecks.bmp" , $TMPRES , $X_LOOT , $Y_LOOT , 12 , @ScriptDir & "\screenshot\screenshot.bmp" , 1038 , 78 , 1038 + 41 , 78 + 578 , 1 , 0 , 60 ) = 1 ) Then
			LOGINFO ( "Closed loot finded" )
			SENDTAP ( $X_LOOT + 116 , $Y_LOOT , 5 )
			If ( WAITFINDPICD ( @ScriptDir & "\img\loot_btn.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 , 789 , 20 , 70 , 576 ) = 1 ) Then
				Sleep ( 300 )
				SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 5 )
			EndIf
			$BOTTYPE = 5
			$NEEDCHECKLOCAL = 1
			Local $MOVINGTIMER = TimerInit ( )
			Local $MOVINGTIMEOUT = 5 * 60 * 1000
			While TimerDiff ( $MOVINGTIMER ) < $MOVINGTIMEOUT
				If ( WAITFINDPICD ( @ScriptDir & "\img\loot_all_btn.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 411 , 349 , 534 , 358 ) = 1 ) Then
					Sleep ( 3000 )
					SENDTAP ( $X_FINDED , $Y_FINDED , 5 )
					Sleep ( 3000 )
					ExitLoop
				Else
					Sleep ( 3000 )
				EndIf
			WEnd
			If TimerDiff ( $MOVINGTIMER ) > $MOVINGTIMEOUT Then LOGERROR ( "not finded loot butn" )
		Else
			LOGINFO ( "Closed loot not finded" )
			TrayTip ( "" , "Cannon find any loot" , 30 , 1 )
			ExitLoop
		EndIf
	WEnd
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func TEST123231 ( )
	Local $CURRFUNCNAME = "Test"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	$BOT_ENABLED = 1
	Local $BOTACTIVE = 1
	Local $ANOMCYCLETIMER = TimerInit ( )
	Local $MAXTRYSELECTANOMALY = 5
	Local $TRYCOUNTSELECTANOMALY = 0
	Local $SELECTANYLEVELANOMALY = 0
	Local $ANOMTIMERTMP = TimerDiff ( $ANOMCYCLETIMER )
	Local $TRYCOUNT = 0
	Local $SELECTCLOSESTENEMYCOUNT = 0
	Local $FORCEFOCUS = 0
	Local $MSG = ""
	SETDOINGSTATUS ( "Getting ship fit" )
	CHECKWEAPONSTATE ( )
	GETSHIPSPARAMS ( )
	CHECKWEAPONBOOSTSTATE ( )
	CHECKREPAIRSTATE ( )
	CHECKBATTERYSTATE ( )
	CHECKWEBSTATE ( )
	CHECKTRACKERCOMPSTATE ( )
	GETSHIPSPARAMS ( )
	If $USEALWAYSON = 1 Then
		CHECKALWAYSONSTATE ( )
		If $ALWAYSONSTATE = 0 Then FIREALWAYSON ( )
	EndIf
	While $TRYCOUNT < $MAXTRYANOMALY
		$ANOMTIMERTMP = TimerDiff ( $ANOMCYCLETIMER )
		LOGINFO ( "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
		GUICtrlSetData ( $LABEL_RATE , "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
		CHECKEASYLOCK ( )
		CHECKANDCLOSESTATUS ( )
		If CHECKWEAPONSTATE ( ) = 0 Then
			LOGINFO ( "Try to activate [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
			If Mod ( $TRYCOUNT , 2 ) = 0 Then
				If FIREWEAPON ( ) = 0 Then $TRYCOUNT = $TRYCOUNT + 5
			EndIf
			$TRYCOUNT = $TRYCOUNT + 1
		Else
			FIREWEAPONBOOST ( )
			FIRETRACKERCOMP ( )
			$TRYCOUNT = $TRYCOUNT + 4294967295
		EndIf
		If $WEAPONTYPE = + 4294967295 Then
			FIREWEAPONBOOST ( )
			FIRETRACKERCOMP ( )
		EndIf
		SELECTOVERLAY ( "ships" )
		LOGINFO ( "$ForceFocus=" & $FORCEFOCUS )
		If SELECTCLOSESTENEMY ( 1 , $FORCEFOCUS ) = 0 Then
			$TRYCOUNT = $TRYCOUNT + 10
		Else
			$TRYCOUNT = $TRYCOUNT + 4294967294
			$SELECTCLOSESTENEMYCOUNT = $SELECTCLOSESTENEMYCOUNT + 1
		EndIf
		If $TRYCOUNT < 0 Then $TRYCOUNT = 0
		If $SELECTCLOSESTENEMYCOUNT > 4 Then
			$SELECTCLOSESTENEMYCOUNT = 0
			$FORCEFOCUS = 1
			FIREWEB ( )
		Else
			$FORCEFOCUS = 0
		EndIf
		GETSHIPSPARAMS ( )
		CHECKREPAIRSTATE ( )
		Local $MSG = ""
		If $SHIPENERGY < 90 Then FIREBATTERY ( )
		If $REPAIRTYPE = 1 Then
			If $SHIPSHIELD < 80 And $REPAIRSTATE = 0 Then FIREREPAIR ( )
			If $SHIPSHIELD > 90 And $REPAIRSTATE = 1 Then FIREREPAIR ( )
			If $SHIPSHIELD < 20 Or $SHIPARMOR < 50 Or $SHIPENERGY < 30 Then
				$NEED_DOCKING = 1
				$MSG = "low state"
				ExitLoop ( 2 )
			EndIf
		Else
			If $SHIPARMOR < 93 And $REPAIRSTATE = 0 Then FIREREPAIR ( )
			If $SHIPARMOR > 98 And $REPAIRSTATE = 1 Then FIREREPAIR ( )
			If $SHIPARMOR < 40 Or $SHIPENERGY < 30 Then
				$NEED_DOCKING = 1
				$MSG = "low state"
				ExitLoop ( 2 )
			EndIf
		EndIf
		If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
			$NEED_DOCKING = 1
			ExitLoop ( 2 )
		EndIf
		If $BOT_ENABLED = 0 Then
			$NEED_DOCKING = 1
			$MSG = "bot prepairing to stop. time is out"
			ExitLoop
		EndIf
		LOGINFO ( "AnomTime. Time for 1 check round :" & Round ( ( TimerDiff ( $ANOMCYCLETIMER ) - $ANOMTIMERTMP ) , 0 ) & " ms" )
	WEnd
	TAKELOOT ( )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func TEST ( )
	Local $CURRFUNCNAME = "Test"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $TMP
	SELECTANOMALY ( $TMP )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func TE123ST ( )
	FILECONSOLEWRITE ( "test stop" & @CRLF )
EndFunc
Func TESTSAVETEST ( )
	FILECONSOLEWRITE ( "Start perfomance test" & @CRLF )
	Local $I
	Local $AWINLIST = WinList ( "[REGEXPTITLE:(?i)(.*Ldplayer.*|.*bluestacks.*|.*memu.*)]" )
	FILECONSOLEWRITE ( $AWINLIST [ 1 ] [ 0 ] & @CRLF )
	Local $ITERARION = 50
	FILECONSOLEWRITE ( "OldScreenShot. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0 , $CURTIME
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		SENDADB ( " exec-out /data/local/tmp/ascreencap -f /data/local/tmp/screenshot.bmp &&  pull /data/local/tmp/screenshot.bmp " & "screenshot\screenshot.bmp" , 1 )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "NewcreenShot. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		SENDADB ( " exec-out /data/local/tmp/ascreencap --stdout> screenshot\screenshot.bmp" , 1 )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "NewcreenMemShot. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		Local $PID = Run ( "cmd /c adb\adb.exe exec-out /data/local/tmp/ascreencap --stdout" , "" , @SW_HIDE , $STDERR_MERGED )
		ProcessWaitClose ( $PID )
		Local $SOUTPUT = StdoutRead ( $PID , 0 , 1 )
		$MEM = _GDIPLUS_BITMAPCREATEFROMMEMORY ( $SOUTPUT )
		_GDIPLUS_IMAGESAVETOFILE ( $MEM , "lalala4.bmp" )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "NewcreenMemShotNotWrite. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		Local $PID = Run ( "cmd /c adb\adb.exe exec-out /data/local/tmp/ascreencap --stdout" , "" , @SW_HIDE , $STDERR_MERGED )
		While 1
			$SOUTPUT &= StdoutRead ( $PID , False , True )
			If @error Then ExitLoop
		WEnd
		$MEM = _GDIPLUS_BITMAPCREATEFROMMEMORY ( $SOUTPUT )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "ScreenshotSock. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		SCREENSHOTSOCK ( "screenshot\screenshot.bmp" , 1 )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "Old+copy. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		SCREENSHOTCOPY ( "screenshot\screenshot.bmp" , 1 )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "sock+copy. Iterations=" & $ITERARION & @CRLF )
	Local $MIN = 10000 , $MAX = 0 , $AVG = 0 , $TOTALTIME = 0
	For $I = 0 To $ITERARION
		Local $START = TimerInit ( )
		SCREENSHOTCOPYSOCK ( "screenshot\screenshot.bmp" , 1 )
		$CURTIME = Round ( TimerDiff ( $START ) , 0 )
		If $MIN > $CURTIME Then $MIN = $CURTIME
		If $MAX < $CURTIME Then $MAX = $CURTIME
		$TOTALTIME = $TOTALTIME + $CURTIME
	Next
	FILECONSOLEWRITE ( "$totaltime=" & $TOTALTIME & " $min=" & $MIN & " $max=" & $MAX & " avg=" & Round ( $TOTALTIME / $ITERARION , 0 ) & @CRLF )
	FILECONSOLEWRITE ( "end perfomance test" & @CRLF )
EndFunc
Func NEWSCREENSHOT ( $SILENT = 0 , $SAVETO = "screenshot\screenshot.bmp" )
	Local $ISOCKET = _ANDROID_CONNECT ( )
	_ANDROID_SEND ( $ISOCKET , "host:transport-any" )
	Local $M = _ANDROID_SEND ( $ISOCKET , "shell:sh /data/local/tmp/ascreencap.sh" )
	Do
		$M = $M & TCPRecv ( $ISOCKET , 4 )
	Until StringInStr ( $M , "ready" )
	SENDADB ( " pull /data/local/tmp/screenshot.bmp " & $SAVETO , 1 )
EndFunc
Func IRLTEST ( )
	Local $X1 = 1045 , $Y1 = 0 , $I = 0
	Local $ENEMY_DETECTED = 0 , $FOCUS_DETECTED = 0
	ADBSCREEN ( 1 )
	$PROCESSINGTIME = TimerInit ( )
	Local $AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\fleet\" , "*.bmp" )
	For $M = 1 To $AFILELIST [ 0 ]
		FILECONSOLEWRITE ( "Searching for: " & $AFILELIST [ $M ] & @CRLF )
		$Y1 = 58
		Do
			If $Y1 > 58 + 364 + 4294967266 Then ExitLoop
			If $I > 12 Then ExitLoop
			$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\fleet\" & $AFILELIST [ $M ] , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1027 , $Y1 , 1027 + 83 , 58 + 364 )
			If $FINDED Then
				$I += 1
				$SHIP_LIST [ $I ] [ 0 ] = $X1
				$SHIP_LIST [ $I ] [ 1 ] = $Y1
				$SHIP_LIST [ $I ] [ 2 ] = StringTrimRight ( $AFILELIST [ $M ] , 4 )
				If $SHIP_LIST [ $I ] [ 2 ] = "cargo" Or $SHIP_LIST [ $I ] [ 2 ] = "industry" Then
					$SHIP_LIST [ 0 ] [ 0 ] += 1
				Else
					$SHIP_LIST [ 0 ] [ 1 ] += 1
				EndIf
			EndIf
		Until $FINDED = 0
	Next
	ConsoleWrite ( "Time: " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms" & @CRLF )
	$PROCESSINGTOTALTIME = TimerInit ( )
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	Local $TMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 1027 , 58 , 83 , 364 )
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	$IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TMPBITMAP ) )
	_GDIPLUS_BITMAPDISPOSE ( $TMPBITMAP )
	Local $IMAGE_FIND [ 12 ]
	$IMAGE_FIND [ 0 ] = IR_IMAGE_LOAD ( "img\fleet\enemy.png" )
	$IMAGE_FIND [ 1 ] = IR_IMAGE_LOAD ( "img\fleet\targeted.png" )
	$IMAGE_FIND [ 2 ] = IR_IMAGE_LOAD ( "img\fleet\destroyer.png" )
	$IMAGE_FIND [ 3 ] = IR_IMAGE_LOAD ( "img\fleet\bcruiser.png" )
	$IMAGE_FIND [ 4 ] = IR_IMAGE_LOAD ( "img\fleet\bship.png" )
	$IMAGE_FIND [ 5 ] = IR_IMAGE_LOAD ( "img\fleet\cruiser.png" )
	$IMAGE_FIND [ 6 ] = IR_IMAGE_LOAD ( "img\fleet\frigate.png" )
	$IMAGE_FIND [ 7 ] = IR_IMAGE_LOAD ( "img\fleet\destroyer.png" )
	$IMAGE_FIND [ 8 ] = IR_IMAGE_LOAD ( "img\fleet\cargo.png" )
	$IMAGE_FIND [ 9 ] = IR_IMAGE_LOAD ( "img\fleet\industry.png" )
	$IMAGE_FIND [ 10 ] = IR_IMAGE_LOAD ( "img\fleet\industry1.png" )
	Local $IMAGE_FILENAME [ 12 ]
	$IMAGE_FILENAME [ 0 ] = "enemy"
	$IMAGE_FILENAME [ 1 ] = "targeted"
	$IMAGE_FILENAME [ 2 ] = "destroyer"
	$IMAGE_FILENAME [ 3 ] = "bcruiser"
	$IMAGE_FILENAME [ 4 ] = "bship"
	$IMAGE_FILENAME [ 5 ] = "cruiser"
	$IMAGE_FILENAME [ 6 ] = "frigate"
	$IMAGE_FILENAME [ 7 ] = "destroyer"
	$IMAGE_FILENAME [ 8 ] = "cargo"
	$IMAGE_FILENAME [ 9 ] = "industry"
	$IMAGE_FILENAME [ 10 ] = "industry1"
	Local $COMPAREPARAMETERS = IR_COMPARE_PARAMETERS ( )
	With $COMPAREPARAMETERS
	.MultiThreadedProcessing = False
	.CompareType = $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA
	.ColorTolerance_A = 49
	.ColorTolerance_R = 49
	.ColorTolerance_G = 49
	.ColorTolerance_B = 49
	.PixelTolerance = 4
	.FilterTresholdX = 20
	.FilterTresholdY = 20
	.EnableOpenCL = False
	.PlaformIndex = Default
	.DeviceIndex = Default
	.ComputeCoreCount = Default
	EndWith
	Local $NUMBER [ 0 ] [ 2 ] , $COUNT = 0 , $PROCESSINGTIME , $M = 0
	For $I = 0 To 10
		$PROCESSINGTIME = TimerInit ( )
		$TRESULT = IR_COMPARE ( $IMAGE_SRC , $IMAGE_FIND [ $I ] , $COMPAREPARAMETERS )
		If Not @error Then
			ConsoleWrite ( "!>" & $IMAGE_FILENAME [ $I ] & " Successful search (In " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms), match count: " & $TRESULT [ 0 ] & @CRLF )
			For $M = 1 To $TRESULT [ 0 ]
				FILECONSOLEWRITE ( "> Found " & $IMAGE_FILENAME [ $I ] & " at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
				FILECONSOLEWRITE ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage & @CRLF )
			Next
			ConsoleWrite ( "Number: " & $I & " - Search: " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms" & @CRLF )
			Switch $I
			Case 0
				FILECONSOLEWRITE ( "Enemy detected!" & @CRLF )
				$ENEMY_DETECTED = 1
			Case 1
				FILECONSOLEWRITE ( "Lock detected!" & @CRLF )
				$FOCUS_DETECTED = 1
				$ENEMY_DETECTED = 1
			Case 2 To 7
				FILECONSOLEWRITE ( "Armed neautral detected!" & @CRLF )
				$ENEMY_DETECTED = 1
			Case 8 To 10
				FILECONSOLEWRITE ( "Unarmed Neautral detected!" & @CRLF )
			EndSwitch
			If $ENEMY_DETECTED = 1 Then ExitLoop
		EndIf
	Next
	For $I = 0 To 10
		IR_IMAGE_UNLOAD ( $IMAGE_FIND [ $I ] )
	Next
	IR_COMPARE_FREERESULT ( $TRESULT )
	IR_IMAGE_UNLOAD ( $IMAGE_SRC )
	ConsoleWrite ( "Total Time " & Round ( TimerDiff ( $PROCESSINGTOTALTIME ) , 2 ) & "ms" & @CRLF )
EndFunc
Func IRLFINDPIC ( $MATCH_PIC , ByRef $TRESULT , ByRef $X1 , ByRef $Y1 , $THRESHOLD = 4 , $LOAD_PIC = 0 , $XS = 0 , $YS = 0 , $XE = 0 , $YE = 0 , $MAXMATCHES = 1 , $SHOW = 0 , $COLORTOLERANCE = 0 )
	Local $PROCESSINGTIME = TimerInit ( )
	Local $M , $DX , $DY
	Local $SCOORDS [ 4 ] = [ $XS , $YS , $XE , $YE ]
	Local $IMAGE_FIND = IR_IMAGE_LOAD ( $MATCH_PIC )
	Local $FINDED = 0
	ConsoleWrite ( "Load_Pic =" & $LOAD_PIC & @CRLF )
	If $THRESHOLD < 1 Then $THRESHOLD = 4
	If ( $XS = 0 And $YS = 0 And $XE = 0 And $YE = 0 ) Then
		$IMAGE_SRC = IR_IMAGE_LOAD ( $LOAD_PIC )
	Else
		$DX = $XS
		$DY = $YS
		Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( $LOAD_PIC )
		Local $TMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , $XS , $YS , $XE - $XS , $YE - $YS )
		_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
		$IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TMPBITMAP ) )
		_GDIPLUS_BITMAPDISPOSE ( $TMPBITMAP )
	EndIf
	Local $COMPAREPARAMETERS = IR_COMPARE_PARAMETERS ( )
	With $COMPAREPARAMETERS
	.MultiThreadedProcessing = True
	.CompareType = $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA
	.ColorTolerance_A = 69
	.ColorTolerance_R = 69
	.ColorTolerance_G = 69
	.ColorTolerance_B = 69
	.PixelTolerance = $THRESHOLD
	.FilterTresholdX = $IMAGE_FIND .W
	.FilterTresholdY = $IMAGE_FIND .H
	.MaxMatches = $MAXMATCHES
	.RotateSearch = False
	.StretchCompare = False
	.EnableOpenCL = False
	.PlaformIndex = Default
	.DeviceIndex = Default
	.ComputeCoreCount = Default
	EndWith
	If $COLORTOLERANCE > 0 Then
		$COMPAREPARAMETERS .ColorTolerance_A = $COLORTOLERANCE
		$COMPAREPARAMETERS .ColorTolerance_R = $COLORTOLERANCE
		$COMPAREPARAMETERS .ColorTolerance_G = $COLORTOLERANCE
		$COMPAREPARAMETERS .ColorTolerance_B = $COLORTOLERANCE
	EndIf
	$TRESULT = IR_COMPARE ( $IMAGE_SRC , $IMAGE_FIND , $COMPAREPARAMETERS )
	If Not @error Then
		$FINDED = 1
		Local $FINDEDMAXMATCHPERCENTAGE , $FINDEDMAXMATCHPERCENTAGECOUNTER
		ConsoleWrite ( @CRLF & "!>" & $MATCH_PIC & " Successful search (In " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms), match count: " & $TRESULT [ 0 ] & @CRLF )
		For $M = 1 To $TRESULT [ 0 ]
			ConsoleWrite ( "> Found at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
			ConsoleWrite ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage & @CRLF )
			If $FINDEDMAXMATCHPERCENTAGE < $TRESULT [ $M ] .MatchPercentage Then
				$FINDEDMAXMATCHPERCENTAGE = $TRESULT [ $M ] .MatchPercentage
				$FINDEDMAXMATCHPERCENTAGECOUNTER = $M
			EndIf
			$X1 = $TRESULT [ $M ] .X + $TRESULT [ $M ] .W / 2 + $DX
			$Y1 = $TRESULT [ $M ] .Y + $TRESULT [ $M ] .H / 2 + $DY
			ConsoleWrite ( "> Return position: X=" & $X1 & ", Y=" & $Y1 & @CRLF )
		Next
		If $SHOW = 1 Then IR_COMPARE_TEST ( $IMAGE_SRC , $TRESULT , $MATCH_PIC )
		If $MAXMATCHES = 1 Then
			ConsoleWrite ( "> MaxMatches = 1, best result:" & @CRLF )
			$X1 = $TRESULT [ $FINDEDMAXMATCHPERCENTAGECOUNTER ] .X + $TRESULT [ $FINDEDMAXMATCHPERCENTAGECOUNTER ] .W / 2 + $DX
			$Y1 = $TRESULT [ $FINDEDMAXMATCHPERCENTAGECOUNTER ] .Y + $TRESULT [ $FINDEDMAXMATCHPERCENTAGECOUNTER ] .H / 2 + $DY
			ConsoleWrite ( "> Return position: X=" & $X1 & ", Y=" & $Y1 & ", MatchPercentage=" & $TRESULT [ $FINDEDMAXMATCHPERCENTAGECOUNTER ] .MatchPercentage & @CRLF )
		EndIf
	EndIf
	IR_IMAGE_UNLOAD ( $IMAGE_SRC )
	IR_IMAGE_UNLOAD ( $IMAGE_FIND )
	For $M = 1 To $TRESULT [ 0 ]
		$TRESULT [ $M ] .X = $TRESULT [ $M ] .X + $TRESULT [ $M ] .W / 2 + $DX
		$TRESULT [ $M ] .Y = $TRESULT [ $M ] .Y + $TRESULT [ $M ] .H / 2 + $DY
	Next
	If $FINDED Then
		Return 1
	Else
		ConsoleWrite ( "!>" & $MATCH_PIC & " Not finded (In " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms)" & @CRLF )
		Return 0
	EndIf
EndFunc
Func FINDERTEST ( )
	Local $X_FINDED , $Y_FINDED
	Local $COUNT = 0
	Local $I
	$LESSSCREENSHOTSAVE = 0
	For $I = 1 To 0.1 Step - 0.01
		ConsoleWrite ( "i=" & $I )
		If WAITFINDPIC ( @ScriptDir & "\img\localchat_zeroneutral.bmp" , $X_FINDED , $Y_FINDED , $I , @ScriptDir & "\screenshot\screenshot3-crop.bmpp" , 0 , 0 , 0 , 240 , 40 , 1 ) Then
			FILECONSOLEWRITE ( "Finded. Accuracy:" & $I & @CRLF )
			ExitLoop
		EndIf
	Next
EndFunc
Func T23 ( )
	FILECONSOLEWRITE ( "test start32" & @CRLF )
	Local $BITMAP1 , $BITMAP , $HPEN
	Local $ICOLOR = 0 , $ACOLOR = 0
	Local $ICOLOR1 = 0 , $ACOLOR1 = 0
	Local $X = 1045 , $Y = 0
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot_2022.08.12_13-31-37.bmp" )
	Local $HPEN = _GDIPLUS_PENCREATE ( 4294902015 , 2 )
	_GDIPLUS_PENSETWIDTH ( $HPEN , 1 )
	For $Y = 77 To 545 Step 4
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $X , $Y )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		Local $HSL_COLOR = _COLORCONVERTRGBTOHSL ( $ACOLOR )
		FILECONSOLEWRITE ( "Pixel at x=" & $X & " y=" & $Y & " has h=" & StringFormat ( "%.3f" , $HSL_COLOR [ 0 ] ) & " s=" & StringFormat ( "%.3f" , $HSL_COLOR [ 1 ] ) & " l=" & StringFormat ( "%.3f" , $HSL_COLOR [ 2 ] ) )
		_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X , $Y , 4294902015 )
		If $HSL_COLOR [ 0 ] > 25 And $HSL_COLOR [ 0 ] < 45 And $HSL_COLOR [ 1 ] > 45 And $HSL_COLOR [ 1 ] < 110 Then
			$YELLOW_DETECTED = 1
			_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X , $Y , 4278255360 )
			_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X + 4294967286 , $Y , 4278255360 )
			If @error Then MsgBox ( 0 , "failed" , @error )
			ConsoleWrite ( " YellowDetected detected" )
		EndIf
		FILECONSOLEWRITE ( @CRLF )
	Next
	_GDIPLUS_IMAGESAVETOFILE ( $BITMAP , @ScriptDir & "\screenshot\screenshot_yellowdetected-" & @MDAY & "." & @HOUR & "." & @MIN & "." & @MSEC & ".bmp" )
EndFunc
Func FAILEXP ( )
	Local $COMPAREPARAMETERS = IR_COMPARE_PARAMETERS ( )
	With $COMPAREPARAMETERS
	.MultiThreadedProcessing = False
	.MaxMatches = + 4294967295
	.CompareType = $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA
	.ColorTolerance_A = 99
	.ColorTolerance_R = 99
	.ColorTolerance_G = 99
	.ColorTolerance_B = 99
	.PixelTolerance = 20
	.FilterTresholdX = 20
	.FilterTresholdY = 30
	.EnableOpenCL = False
	.PlaformIndex = Default
	.DeviceIndex = Default
	.ComputeCoreCount = Default
	EndWith
	Local $M = 0 , $N = 0
	For $N = 1 To $ANOMALYANOMALY [ 0 ]
		ConsoleWrite ( "!> $n: " & $N & @CRLF )
		ConsoleWrite ( "!> $AnomalyAnomaly[$n]: " & $ANOMALYANOMALY [ $N ] & @CRLF )
		Local $TPLATE = $ANOMALYANOMALY [ $N ]
		$TRESULT = IR_COMPARE ( $IMAGE_SRC , $TPLATE , $COMPAREPARAMETERS )
		If Not @error Then
			ConsoleWrite ( "!> match count: " & $TRESULT [ 0 ] & @CRLF )
			For $M = 1 To $TRESULT [ 0 ]
				FILECONSOLEWRITE ( "> Found small_anomaly.bmp at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
				FILECONSOLEWRITE ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage & @CRLF , 1 )
				If $TRESULT [ $M ] .MatchPercentage > 50 Then
					$HPEN = _GDIPLUS_PENCREATE ( 4294967295 , 1 )
					$ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "anom"
				EndIf
			Next
		Else
			ConsoleWrite ( "-ERROR:" & @error & @CRLF )
		EndIf
		IR_COMPARE_FREERESULT ( $TRESULT )
	Next
	For $N = 1 To $ANOMALYMEDIUM [ 0 ]
		Local $TPLATE = $ANOMALYMEDIUM [ $N ]
		$TRESULT = IR_COMPARE ( $IMAGE_SRC , $TPLATE , $COMPAREPARAMETERS )
		If Not @error Then
			ConsoleWrite ( "!> match count: " & $TRESULT [ 0 ] & @CRLF )
			For $M = 1 To $TRESULT [ 0 ]
				FILECONSOLEWRITE ( "> Found $AnomalyMedium.bmp at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
				FILECONSOLEWRITE ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage & @CRLF , 1 )
				If $TRESULT [ $M ] .MatchPercentage > 50 Then
					$HPEN = _GDIPLUS_PENCREATE ( 4278255615 , 1 )
					If $ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "anom" Then $ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "medium"
				EndIf
			Next
		Else
			ConsoleWrite ( "-ERROR:" & @error & @CRLF )
		EndIf
		IR_COMPARE_FREERESULT ( $TRESULT )
	Next
	For $N = 1 To $ANOMALYSMALL [ 0 ]
		Local $TPLATE = $ANOMALYSMALL [ $N ]
		$TRESULT = IR_COMPARE ( $IMAGE_SRC , $TPLATE , $COMPAREPARAMETERS )
		If Not @error Then
			ConsoleWrite ( "!> match count: " & $TRESULT [ 0 ] & @CRLF )
			For $M = 1 To $TRESULT [ 0 ]
				FILECONSOLEWRITE ( "> Found $AnomalySmall.bmp at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
				FILECONSOLEWRITE ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage & @CRLF , 1 )
				If $TRESULT [ $M ] .MatchPercentage > 50 Then
					$HPEN = _GDIPLUS_PENCREATE ( 4294902015 , 1 )
					If $ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "anom" Then $ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "small"
				EndIf
			Next
		Else
			ConsoleWrite ( "-ERROR:" & @error & @CRLF )
		EndIf
		IR_COMPARE_FREERESULT ( $TRESULT )
	Next
	For $N = 1 To $ANOMALYLARGE [ 0 ]
		Local $TPLATE = $ANOMALYLARGE [ $N ]
		$TRESULT = IR_COMPARE ( $IMAGE_SRC , $TPLATE , $COMPAREPARAMETERS )
		If Not @error Then
			ConsoleWrite ( "!> match count: " & $TRESULT [ 0 ] & @CRLF )
			For $M = 1 To $TRESULT [ 0 ]
				FILECONSOLEWRITE ( "> Found $AnomalyLarge at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
				FILECONSOLEWRITE ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage & @CRLF , 1 )
				If $TRESULT [ $M ] .MatchPercentage > 50 Then
					$HPEN = _GDIPLUS_PENCREATE ( 4294967040 , 1 )
					If $ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "anom" Then $ANOMCOORDS [ SWITCHCOORDS ( $TRESULT [ $M ] .Y ) ] = "large"
				EndIf
			Next
		Else
			ConsoleWrite ( "-ERROR:" & @error & @CRLF )
		EndIf
		IR_COMPARE_FREERESULT ( $TRESULT )
	Next
	Local $TTMPBITMAP
	Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $TTMPBITMAP , @ScriptDir & "\screenshot\OpenCVcrop2-" & Random ( 0 , 9999 , 1 ) & ".bmp" )
	ConsoleWrite ( "!> $answ: " & $ANSW & " :" & @error & @CRLF )
	IR_IMAGE_UNLOAD ( $IMAGE_SRC )
	_ARRAYDISPLAY ( $ANOMCOORDS , "$AnomCoords" )
EndFunc
Func TAPSPEEDTEST ( )
	Local $X_FINDED , $Y_FINDED
	Local $ANOMLIST [ 9 ]
	Local $I = 0
	$EMULATORTYPE = 1
	$SDKVER = 28
	Local $TTIMER = TimerInit ( )
	SENDTAP ( 15 , 15 , 2 )
	SENDTAP ( 15 , 15 , 2 )
	Local $START
	Local $ANSW = @CRLF
	$START = TimerDiff ( $TTIMER )
	$CLICKTYPE = 0
	For $I = 1 To 10
		SENDTAP ( 15 , 15 , 2 )
		SENDTAP ( 15 , 15 , 2 )
	Next
	$ANSW = $ANSW & "time for tap $ClickType = " & $CLICKTYPE & ": " & ( TimerDiff ( $TTIMER ) - $START ) / 10 / 2 & " ms" & @CRLF
	$START = TimerDiff ( $TTIMER )
	$CLICKTYPE = 1
	For $I = 1 To 10
		SENDTAP ( 15 , 15 , 2 )
		SENDTAP ( 15 , 15 , 2 )
	Next
	$ANSW = $ANSW & "time for tap $ClickType = " & $CLICKTYPE & ": " & ( TimerDiff ( $TTIMER ) - $START ) / 10 / 2 & " ms" & @CRLF
	$START = TimerDiff ( $TTIMER )
	$CLICKTYPE = 2
	For $I = 1 To 10
		SENDTAP ( 15 , 15 , 2 )
		SENDTAP ( 15 , 15 , 2 )
	Next
	$ANSW = $ANSW & "time for tap $ClickType = " & $CLICKTYPE & ": " & ( TimerDiff ( $TTIMER ) - $START ) / 10 / 2 & " ms" & @CRLF
	$START = TimerDiff ( $TTIMER )
	$CLICKTYPE = 3
	For $I = 1 To 10
		SENDTAP ( 15 , 15 , 2 )
		SENDTAP ( 15 , 15 , 2 )
	Next
	$ANSW = $ANSW & "time for tap $ClickType = " & $CLICKTYPE & ": " & ( TimerDiff ( $TTIMER ) - $START ) / 10 / 2 & " ms" & @CRLF
	FILECONSOLEWRITE ( $ANSW )
EndFunc
Func PREPAREMINTOUCH ( )
	Local $TRY
	Local $IERROR = ""
	$CURRFUNCNAME = "PrepareMintouch"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	TCPStartup ( )
	Global $IPORT = Random ( 11000 , 15000 , 1 )
	If Not $ADBTRANSPORTSERIAL = 0 Then $TRANSPORTSTRING = " -s " & $ADBTRANSPORTSERIAL
	ShellExecute ( @ScriptDir & "\" & $ADBFOLDER , $TRANSPORTSTRING & " shell /data/local/tmp/minitouch -n minitouch" & $IPORT , @ScriptDir , Default , @SW_HIDE )
	Local $ANSW = LAUNCHCONSOLE2 ( $ADBFOLDER & $TRANSPORTSTRING & " forward tcp:" & $IPORT & " localabstract:minitouch" & $IPORT )
	LOGDEBUG ( $ANSW )
	OnAutoItExitRegister ( "OnAutoItExit" )
	Local $SIPADDRESS = "127.0.0.1"
	Sleep ( 1000 )
	Do
		Global $ISOCKET = TCPConnect ( $SIPADDRESS , $IPORT )
		If @error Then
			$IERROR = @error
		Else
			LOGINFO ( "Connection successful" )
			LOGDEBUG ( TCPRecv ( $ISOCKET , 2048 , 1 ) )
			ExitLoop
		EndIf
	Until $TRY < 100
	If StringLen ( $IERROR ) > 1 Then
		LOGERROR ( "Could not connect, Error code: " & $IERROR & @CRLF & _WINAPI_GETERRORMESSAGE ( $IERROR ) )
	EndIf
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func SENDTCPTAP ( $X , $Y )
	$CURRFUNCNAME = "SendTCPTap"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $HTIMER = TimerInit ( )
	Local $BYTESENDED = 0
	$X = Round ( $X * 255 / 10 , 0 )
	$Y = Round ( $Y * 455 / 10 , 0 )
	$BYTESENDED = TCPSend ( $ISOCKET , "d 0 " & $X & " " & $Y & " 50" & @LF )
	If $BYTESENDED = 0 Then $ADBERROR = 1
	$BYTESENDED = TCPSend ( $ISOCKET , "c/n" & @LF )
	If $BYTESENDED = 0 Then $ADBERROR = 1
	$BYTESENDED = TCPSend ( $ISOCKET , "u 0/n" & @LF )
	If $BYTESENDED = 0 Then $ADBERROR = 1
	$BYTESENDED = TCPSend ( $ISOCKET , "c/n" & @LF )
	If $BYTESENDED = 0 Then $ADBERROR = 1
	If $ADBERROR = 1 Then LOGFATAL ( " connect error " )
	ConsoleWrite ( TimerDiff ( $HTIMER ) )
EndFunc
Func SENDTCPTAPSTICKY ( $X , $Y , $REGIME = 0 )
	$CURRFUNCNAME = "SendTCPTapSticky"
	LOGINFO ( "Start " & $CURRFUNCNAME )
	Local $HTIMER = TimerInit ( )
	Local $BYTESENDED = 0
	$X = Round ( $X * 255 / 10 , 0 )
	$Y = Round ( $Y * 455 / 10 , 0 )
	If $REGIME = 0 Then
		$BYTESENDED = TCPSend ( $ISOCKET , "d 1 " & $X & " " & $Y & " 50" & @LF )
		If $BYTESENDED = 0 Then $ADBERROR = 1
		$BYTESENDED = TCPSend ( $ISOCKET , "c" & @LF )
		If $BYTESENDED = 0 Then $ADBERROR = 1
	ElseIf $REGIME = 1 Then
		$BYTESENDED = TCPSend ( $ISOCKET , "u 1" & @LF )
		If $BYTESENDED = 0 Then $ADBERROR = 1
		$BYTESENDED = TCPSend ( $ISOCKET , "c" & @LF )
		If $BYTESENDED = 0 Then $ADBERROR = 1
	ElseIf $REGIME = 2 Then
		$BYTESENDED = TCPSend ( $ISOCKET , "m 1 " & $X & " " & $Y & " 50" & @LF )
		If $BYTESENDED = 0 Then $ADBERROR = 1
		$BYTESENDED = TCPSend ( $ISOCKET , "c" & @LF )
		If $BYTESENDED = 0 Then $ADBERROR = 1
	EndIf
	ConsoleWrite ( TimerDiff ( $HTIMER ) )
	LOGINFO ( "Stop " & $CURRFUNCNAME )
EndFunc
Func ONAUTOITEXIT ( )
	TCPShutdown ( )
EndFunc
_OPENCV_STARTUP ( )
_OPENCV_ENABLELOGGING ( False , False , True )
IR_STARTUP ( )
IRLIMAGEPRELOAD ( )
Global $OVERALLTIMERCORRECTION = 0
Global $OVERALLTIMER = 0
Global $OVERALLTIMERMAX = HOURSTOMSEC ( 2 )
Global $MAINLOOPTIMER = 0
If @Compiled Then
	$REV = FileGetVersion ( @ScriptFullPath )
Else
	$REV = "0.0.0.0"
	$OVERALLTIMERMAX = HOURSTOMSEC ( 8 )
EndIf
_GDIPLUS_STARTUP ( )
Local $DIFF = _DATEDIFF ( "D" , "2025/6/20" , _NOWCALCDATE ( ) )
If $DIFF > 1 Then
	GUICtrlSetState ( $BUTTON_START , $GUI_DISABLE )
	$OVERALLTIMERMAX = 0
	GUICtrlSetData ( $LABEL_DOING , "This version is expired. Download new one." )
	LOGINFO ( "This version is expired" )
	MsgBox ( 262144 , "ERROR" , "This version is expired. Download new one." )
	TERMINATE ( )
Else
	GUICtrlSetData ( $LABEL_DOING , "Wasting electricity" )
EndIf
Local $X_FINDED , $Y_FINDED
If StringInStr ( @ScriptDir , " " ) Then
	LOGINFO ( "Scriptdir:" & @ScriptDir & ". Contains spaces!" )
	MsgBox ( 262144 , "ERROR" , "Launch folder:" & @CRLF & @ScriptDir & @CRLF & "Please, remove spaces in path." )
	$BOT_ENABLED = 0
	TERMINATE ( )
EndIf
LOGFILE ( $LOGFILE )
LOGSTART ( )
Local $X_15M , $Y_15M
Local $X_TEMP , $Y_TEMP
Local $NEEDRESET = 0
Local $ASTEROIDFINDED = 0
$BOT_ENABLED = 0
Func CHECKOVERALLTIME ( )
	$CURRFUNCNAME = "CheckOverallTime"
	Local $TIMELEFT
	Local $IHOURS = 0 , $IMINS = 0 , $ISECS = 0
	$TIMELEFT = $OVERALLTIMERMAX - TimerDiff ( $OVERALLTIMER )
	_TICKSTOTIME ( $TIMELEFT , $IHOURS , $IMINS , $ISECS )
	GUICtrlSetData ( $LABEL_TIMELEFT , StringFormat ( "Time left: %02d:%02d:%02d" , $IHOURS , $IMINS , $ISECS ) )
	If $TIMELEFT < 0 Then
		$BOT_ENABLED = 0
		LOGINFO ( "!Botstop: OverallTime" )
	EndIf
EndFunc
LOADMINERALPRIORITY ( )
SETUPINI ( "read" )
LOGINFO ( "Telegram init start" )
_INITBOT ( $TELEGRAMTOKEN )
LOGINFO ( "Telegram init stop" )
If $LOGDONTSAVEINFO = 1 Then
	LOGINFO ( "Disabling [INFO] in logfile" )
	LOGLEVEL ( $LOG_WARN )
EndIf
If $BOTTYPE = 5 Then
	HotKeySet ( "{scrolllock}" , "CheckPlanet" )
EndIf
$ADBCHECKTIMER = TimerInit ( )
Local $SERVERVERSION = CHECKFORNEWVERSION ( )
LOGINFO ( "Current version: " & $REV )
LOGINFO ( "Server version: " & $SERVERVERSION )
Local $AWINLIST = WinList ( "[REGEXPTITLE:(?i)(.*Ldplayer.*|.*bluestacks.*|.*memu.*)]" )
LOGINFO ( "Winlist: " & $AWINLIST )
If Not IsArray ( $AWINLIST ) Or $AWINLIST [ 0 ] [ 0 ] = 0 Then
	$ALIST = WinList ( )
	For $I = 0 To UBound ( $ALIST ) + 4294967295
		If StringInStr ( $ALIST [ $I ] [ 0 ] , "dnplayer.exe" ) Then
			LOGINFO ( "Finded dnplayer.exe" )
			Local $AWINLIST [ 2 ] [ 2 ]
			$AWINLIST [ 0 ] [ 0 ] = 1
			$AWINLIST [ 1 ] [ 0 ] = "LD"
		EndIf
	Next
EndIf
If IsArray ( $AWINLIST ) And Not $AWINLIST [ 0 ] [ 0 ] = 0 Then
	LOGINFO ( "Emulator:" & $AWINLIST [ 1 ] [ 0 ] )
	If StringInStr ( $AWINLIST [ 1 ] [ 0 ] , "Blue" ) Then
		$EMULATORTYPE = 1
		If @OSArch = "X64" Then
			Global $EMULATORSHAREDFOLDER = RegRead ( "HKEY_LOCAL_MACHINE64\SOFTWARE\BlueStacks_nxt" , "DataDir" ) & "UserData\SharedFolder\"
		Else
			Global $EMULATORSHAREDFOLDER = RegRead ( "HKEY_LOCAL_MACHINE\SOFTWARE\BlueStacks_nxt" , "DataDir" ) & "UserData\SharedFolder\"
		EndIf
		LOGINFO ( "BlustacksSharedFolder:" & $EMULATORSHAREDFOLDER & " Error:" & @error )
	EndIf
	If StringInStr ( $AWINLIST [ 1 ] [ 0 ] , "LD" ) Then
		$EMULATORTYPE = 2
		$EMULATORSHAREDFOLDER = @MyDocumentsDir & "\XuanZhi\Pictures\"
		LOGINFO ( "LdSharedFolder:" & $EMULATORSHAREDFOLDER & " Error:" & @error )
	EndIf
Else
	If $EMULATORTYPE = 0 Then
		LOGINFO ( "Emulator not find." )
	EndIf
EndIf
GETOSINFO ( )
If _STRINGCOMPAREVERSIONS ( $REV , $SERVERVERSION ) >= 0 Then
	LOGINFO ( "Same version" )
Else
	LOGINFO ( "Have newer version" )
	If @Compiled Then MsgBox ( 48 , " " , "  . Download new version." )
EndIf
If $CMDLINE [ 0 ] > 0 Then
	LOGINFO ( "Commands found!" )
	For $I = 1 To $CMDLINE [ 0 ] Step 2
		If $CMDLINE [ $I ] = "/serial" Then
			LOGINFO ( $CMDLINE [ $I ] & " " & $CMDLINE [ $I + 1 ] )
			$ADBTRANSPORTSERIAL = $CMDLINE [ $I + 1 ]
		EndIf
		If $CMDLINE [ $I ] = "/start" Then
			BUTTON_STARTCLICK ( )
		EndIf
	Next
EndIf
If 1 And StringLen ( $ADBTRANSPORTSERIAL ) > 1 Then
	LOGDEBUG ( "Getting EmulatorPID " )
	Local $EMULATORLIST = WinList ( "[REGEXPTITLE:(?i)(.*" & $ADBTRANSPORTSERIAL & ".*)]" )
	If Not IsArray ( $EMULATORLIST ) Or $EMULATORLIST [ 0 ] [ 0 ] <> 0 Then
		$EMULATORPID = WinGetProcess ( $EMULATORLIST [ 1 ] [ 1 ] )
		LOGDEBUG ( "EmulatorPID =" & $EMULATORPID )
		If $BOTWINDOWMOVE = 1 Then
			LOGDEBUG ( "MovingWindow" )
			Local $EMULATORWINDOWSPOS = WinGetPos ( $EMULATORLIST [ 1 ] [ 1 ] )
			LOGDEBUG ( "EmulatorWindowsPos[0]=" & $EMULATORWINDOWSPOS [ 0 ] & " EmulatorWindowsPos[1] =" & $EMULATORWINDOWSPOS [ 1 ] )
			If $EMULATORWINDOWSPOS [ 0 ] + 4294967016 > 0 And $EMULATORWINDOWSPOS [ 1 ] > 0 Then
				WinMove ( $FORM1 , "" , $EMULATORWINDOWSPOS [ 0 ] + 4294967016 , $EMULATORWINDOWSPOS [ 1 ] )
			Else
				LOGDEBUG ( "Cannot move window" )
			EndIf
		EndIf
	Else
		LOGDEBUG ( "EmulatorPID NOT FOUND" )
	EndIf
EndIf
Func RATECALCULATE ( )
	$CURRFUNCNAME = "RateCalculate"
	LOGINFO ( "RateCalculate:" )
	LOGINFO ( "Time in min:" & TimerDiff ( $OVERALLTIMER ) / 1000 / 60 )
	LOGINFO ( "UnloadCount:" & $UNLOADCOUNT )
	$ASTEROIDRATE = Round ( TimerDiff ( $OVERALLTIMER ) / 1000 / 60 / $UNLOADCOUNT , 0 )
	LOGINFO ( "Minutes for cycle: " & $ASTEROIDRATE )
	GUICtrlSetData ( $LABEL_RATE , "Minutes for cycle: " & $ASTEROIDRATE )
EndFunc
Func WAITUNTILSHIPSTARTMOVING ( )
	$CURRFUNCNAME = "WaitUntilShipStartMoving"
	Local $MOVINGTIMER = TimerInit ( )
	Local $MOVINGTIMEOUT = 15 * 1000
	Local $X_FINDED , $Y_FINDED
	GUICtrlSetData ( $LABEL_DOING , "Wait for ship start" )
	LOGINFO ( ">Wait until ship start moving " & $MOVINGTIMEOUT / 1000 & " seconds." )
	Sleep ( 2000 )
	While Not SHIPMOVING ( 1 ) And TimerDiff ( $MOVINGTIMER ) < $MOVINGTIMEOUT
		Sleep ( 100 )
	WEnd
	LOGINFO ( ">Wait until ship start moving complete. It takes " & Round ( TimerDiff ( $MOVINGTIMER ) / 1000 ) & "/" & $MOVINGTIMEOUT / 1000 & " seconds." )
EndFunc
TESTADB ( )
$BOT_STATUS = "Paid"
$OVERALLTIMERMAX = 2147483647
; If Not $USERID = 0 Then AUTH ( )
If $CLICKTYPE = 4 Then
	GUICtrlSetData ( $LABEL_DOING , "Preparing" )
	PREPAREMINTOUCH ( )
EndIf
$MAINLOOPTIMER = TimerInit ( )
GUICtrlSetData ( $LABEL_DOING , "Wasting electricity" )
GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
While 1
	$VRET = _GUILISTVIEWEX_EVENTMONITOR ( )
	If @error Then
		MsgBox ( $MB_SYSTEMMODAL , "Error" , "Event error: " & @error )
	EndIf
	Switch @extended
	Case 0
	Case 4
	EndSwitch
	#Region BOT LOOP
	While $BOT_ENABLED
		If $TIMERFOR1CYCLE = 0 Then
			TrayTip ( "" , "Bot starting" , 30 , 1 )
			$TIMERFOR1CYCLE = 1
		EndIf
		GUICtrlSetState ( $BUTTON_START , $GUI_DISABLE )
		If ( $ADB_SCREENSHOT Or $ADB_CLICK ) And $ADB_TESTPASSED = 0 Then
			TESTADB ( )
			If TESTADBRESOLUTION ( ) = 0 Then
				$BOT_ENABLED = 0
				LOGINFO ( "!Botstop: testADBResolution FAIL" )
				TERMINATE ( )
			Else
				$ADB_TESTPASSED = 1
			EndIf
			LOGINFO ( "Fill Label_adbStatus" )
			LOGDEBUG ( "$AdbTransportSerial=" & $ADBTRANSPORTSERIAL )
			LOGDEBUG ( "$EmulatorPID=" & $EMULATORPID )
			If Not StringIsDigit ( $ADBTRANSPORTSERIAL ) Then
				If $EMULATORPID > 0 Then
					GUICtrlSetData ( $LABEL_ADBSTATUS , "ADB:" & $ADBTRANSPORTSERIAL & " PID:" & $EMULATORPID )
				Else
					GUICtrlSetData ( $LABEL_ADBSTATUS , "ADB:" & $ADBTRANSPORTSERIAL )
				EndIf
			EndIf
		EndIf
		If $OVERALLTIMER = 0 Then $OVERALLTIMER = TimerInit ( )
		CHECKOVERALLTIME ( )
		If $BOTTYPE = 3 Then $USERID = 777
		If $USERID = 0 Then $USERID = IDREAD ( )
		; If $BOT_STATUS = 0 Then AUTH ( )
			$BOT_STATUS = "Paid"
		If $OVERALLTIMERCORRECTION = 0 Then
			$OVERALLTIMERMAX = 2147483647
			$OVERALLTIMERCORRECTION = 1
		EndIf
		CHECKOVERALLTIME ( )
		_SLEEP ( 1200 )
		If $BOTTYPE = 0 Then
			#Region Mining MODE
			Local $REWARPCOUNT = 0
			Local $REWARPMAXCOUNT = 3
			If ( CHECKCARGOVALUE ( ) > 10 And INDOCK ( ) ) Then INDOCKUNLOAD ( )
			If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
				GUICtrlSetData ( $LABEL_DOING , "Wait for for empty local" )
				TrayTip ( "" , "Waiting for empty local" , 30 , 1 )
				TELEGRAMBOTSEND ( "Waiting for empty local" )
				While CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL
					LOGINFO ( "Enemy in local detected. Wait 15 seconds before next check." )
					_SLEEP ( 15000 )
				WEnd
				GUICtrlSetData ( $LABEL_DOING , "Wait for for empty local complete" )
				TrayTip ( "" , "Waiting for empty local complete" , 30 , 1 )
				TELEGRAMBOTSEND ( "Waiting for empty local complete" )
			EndIf
			If $GOHOMEPREPAREFIRSTRUN = 1 And INDOCK ( ) Then GOHOMESORT ( )
			If INDOCK ( 1 ) Then
				$JUSTUNDOCKED = 1
			EndIf
			If $STOPAFTERUNDOCK = 1 Then
				ENGINESTOP ( )
			EndIf
			$ISHOMEDPREPAIRED = GOHOMEPREPARE ( )
			If $ISHOMEDPREPAIRED = 0 Then
				TELEGRAMBOTSEND ( "Cannot set BookMark" , "\screenshot\screenshot.bmp" )
			EndIf
			CHECKINSQUAD ( )
			ZOOMOUT ( )
			Sleep ( 2000 )
			If $NEEDCHECKOTHERSHIPS = 1 And $NEEDCHECKLOCAL = 1 Then
				If CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
					$NEED_DOCKING = 1
					$HIDING = 1
				EndIf
				If $HIDING = 0 Then
					CHECKNAV ( )
					If CHECKOTHERSHIPS ( ) Then
						$NEED_DOCKING = 1
						$HIDING = 1
					Else
						SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
						Sleep ( 2000 )
					EndIf
				EndIf
			EndIf
			If $NEEDCHECKOTHERSHIPS = 1 And $NEEDCHECKLOCAL = 0 Then
				CHECKNAV ( )
				If CHECKOTHERSHIPS ( ) Then
					$NEED_DOCKING = 1
					$HIDING = 1
				Else
					SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
					Sleep ( 2500 )
				EndIf
			EndIf
			If $NEED_DOCKING = 0 Then
				$TIMERFOR1CYCLE = TimerInit ( )
				Do
					If $USEMININGIMPLANT = 1 Then USEMININGIMPLANT ( )
					If $HIDING = 1 Then ExitLoop
					$MINERS_STATUS [ 0 ] = + 4294967295
					Local $GETMINERSCOORDTRY = 0
					Do
						If GETMINERSCOORD ( 0 ) = 0 Then
							$GETMINERSCOORDTRY = $GETMINERSCOORDTRY + 1
						Else
							$GETMINERSCOORDTRY = 10
						EndIf
					Until $GETMINERSCOORDTRY >= 3
					If $GETMINERSCOORDTRY = 3 Then $BOT_ENABLED = 0
					If $BOT_ENABLED = 0 Then ExitLoop
					OPENASTEROIDSLIST ( )
					Do
						Local $ASTEROIDCLUSTERFOUND = 0
						$ASTEROIDCLUSTERFOUND = WARPTOASTEROIDCLUSTERV2 ( )
						If $ASTEROIDCLUSTERFOUND = 0 Then
							LOGINFO ( "Secon try" )
							If $BELTWARPFROMBELT = 1 Then
								LOGINFO ( "Warp from belt to belt enabled" )
								$ASTEROIDCLUSTERFOUND = WARPTOASTEROIDCLUSTERV2 ( 1 )
							Else
								LOGINFO ( "Warp from belt to belt disabled" )
								$ASTEROIDCLUSTERFOUND = WARPTOASTEROIDCLUSTERV2 ( )
							EndIf
						EndIf
						LOGDEBUG ( "Asteroid cluster found= " & $ASTEROIDCLUSTERFOUND )
						If $ASTEROIDCLUSTERFOUND = 0 Then
							$NEED_DOCKING = 1
							TELEGRAMBOTSEND ( "Cannot find belt to warp" , "\screenshot\screenshot.bmp" )
							ExitLoop
						EndIf
						SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
						Sleep ( 200 )
						CHECKDETECTED ( )
						If $WARPSTABS [ 0 ] [ 0 ] = 0 Then GETWARPSTABCOORD ( )
						If $GYROSTABS [ 0 ] [ 0 ] = 0 Then GETGYROSTABCOORD ( )
						CHECKMINERS ( )
						AFTERBURNERFIND ( )
						WAITUNTILSHIPSTARTMOVING ( )
						WAITUNTILSHIPMOVING ( )
						If $NEEDCHECKOTHERSHIPS = 1 Then
							If CHECKOTHERSHIPS ( ) = 1 Or ( $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL ) Then
								$NEED_DOCKING = 1
								$HIDING = 1
								ExitLoop ( 2 )
							EndIf
						EndIf
						$JUSTUNDOCKED = 0
						If $MINERS_SIZE = 2 Then
							LOGINFO ( "Activation stripe miners" )
							For $I = 0 To 2 Step 1
								If ( $MINERS_STATUS [ $I ] > 1 ) Then SENDTAP ( $MINERS_COORD [ $I ] [ 0 ] , 666 , 19 )
							Next
						EndIf
						If $MINERS_SIZE = 3 Then
							LOGINFO ( "Activation droid miners" )
							For $I = 0 To 2 Step 1
								If ( $MINERS_STATUS [ $I ] >= 1 ) Then
									SENDTAP ( $MINERS_COORD [ $I ] [ 0 ] , $MINERS_COORD [ $I ] [ 1 ] , 19 )
									Sleep ( 3500 )
									SENDTAP ( $MINERS_COORD [ $I ] [ 0 ] , $MINERS_COORD [ $I ] [ 1 ] , 19 )
								EndIf
							Next
						EndIf
						OPENASTEROIDSLIST ( )
						_SLEEP ( 1300 )
						Local $MININGTIMER = TimerInit ( )
						Local $MININGTIMEOUT = 45 * 60 * 1000
						While CHECKCARGOVALUE ( ) < $SETMAXCARGO And TimerDiff ( $MININGTIMER ) < $MININGTIMEOUT And $BOT_ENABLED
							_SLEEP ( 1000 )
							$ASTEROIDFINDED = SELECTASTEROID ( )
							If Not $ASTEROIDFINDED Then $ASTEROIDFINDED = SELECTASTEROID ( 1 )
							If Not $ASTEROIDFINDED Then
								If $BELTWARPFROMBELT = 1 Then
									If $REWARPCOUNT < $REWARPMAXCOUNT Then
										$REWARPCOUNT = $REWARPCOUNT + 1
										$ASTEROIDFINDED = 1
									EndIf
								EndIf
								ExitLoop
							Else
								SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
								CHECKMINERS ( )
								WAITUNTILSHIPSTARTMOVING ( )
								WAITUNTILSHIPMOVING ( 1 , 1 , 0 , $FASTMINING )
								If $HIDING = 1 Then ExitLoop ( 3 )
								If $MINERS_SIZE = 2 And $NEEDCHECKOTHERSHIPS = 1 Then GETDOCKDIRECTION ( )
								If $MINERS_SIZE = 3 Then GETDOCKDIRECTION ( )
								MININGASTEROID ( )
								If $HIDING = 1 Then
									ExitLoop ( 3 )
								Else
									If $MINERS_SIZE = 2 And $NEEDCHECKOTHERSHIPS = 1 Then ENGINEMAX ( )
									If $MINERS_SIZE = 3 And $NEEDCHECKOTHERSHIPS = 1 Then ENGINEMAX ( )
								EndIf
								$ASTEROID_WIPED = $ASTEROID_WIPED + 1
								GUICtrlSetData ( $LABEL_ASTEROIDWIPED , "Asteroid wiped: " & $ASTEROID_WIPED )
								If $NEEDCHECKOTHERSHIPS = 1 And CHECKCARGOVALUE ( ) < $SETMAXCARGO Then OPENASTEROIDSLIST ( )
							EndIf
						WEnd
						If Not ( CHECKCARGOVALUE ( ) < $SETMAXCARGO And TimerDiff ( $MININGTIMER ) < $MININGTIMEOUT And $BOT_ENABLED ) Then
							LOGINFO ( "Need Docking" )
							$NEED_DOCKING = 1
							$REWARPCOUNT = 0
							ExitLoop
						EndIf
					Until Not $ASTEROIDFINDED
					If $NEED_DOCKING = 0 Then
						GOHOME ( 1 )
						$REWARPCOUNT = 0
						WAITUNTILSHIPMOVING ( )
					EndIf
				Until $NEED_DOCKING = 1
			EndIf
			$NEED_DOCKING = 0
			Local $TIMETOSENDHOME = GOHOME ( )
			If $JUSTUNDOCKED = 0 Then FIREGYROSTABS ( )
			If $HIDING = 1 Then
				If $MINERS_SIZE = 2 Then
					_SLEEP ( $TIMETOWARPCURRENT * 0.8 - ENGINEMAX ( ) - $TIMETOSENDHOME )
				Else
					_SLEEP ( $TIMETOWARPCURRENT * 0.6 )
				EndIf
				If $JUSTUNDOCKED = 0 Then FIREWARPSTABS ( )
				_SLEEP ( $TIMETOWARPCURRENT * 0.5 )
				ADBSCREEN ( 1 )
				TELEGRAMBOTSEND ( "Warping" , "\screenshot\screenshot.bmp" )
			EndIf
			LOGINFO ( "Slipping 15 sec before inhome check" )
			_SLEEP ( 15000 )
			Local $TRY = 0
			Local $ERRTRY = 0
			Local $INDOCKSTATUS = 0
			While $INDOCKSTATUS = INDOCK ( )
				If $INDOCKSTATUS = 1 Then ExitLoop
				$TRY = $TRY + 1
				_SLEEP ( 1300 )
				CHECKDAILY ( )
				GOHOME ( 0 , 1 )
				If $TRY > 160 Then
					LOGINFO ( "Going Home TimeOut " )
				EndIf
				If $INDOCKSTATUS = 2 Or $TRY > 160 Then $ERRTRY = $ERRTRY + 1
				If $ERRTRY > 3 Then
					TELEGRAMBOTSEND ( "Docking error! Killing Eve" , "\screenshot\screenshot.bmp" )
					KILLEVE ( )
					ExitLoop ( 2 )
				EndIf
			WEnd
			_SLEEP ( 13000 )
			If ( CHECKCARGOVALUE ( ) > 2 And INDOCK ( ) = 1 ) Then INDOCKUNLOAD ( )
			If $HIDING = 1 Then
				If Not @Compiled Then Run ( "OBSCommand.exe  /stoprecording" , "" , @SW_HIDE )
				CHECKINDOCKREPAIR ( )
				If $HIDINGNOWAIT = 0 Or $CHECKLOCALRETREAT = 1 Then
					Local $SLEEPMINUTES
					$SLEEPMINUTES = Random ( 5 , 12 , 1 )
					LOGINFO ( "Hiding for " & $SLEEPMINUTES & " min" )
					TELEGRAMBOTSEND ( "Hiding for " & $SLEEPMINUTES & " min" )
					For $HIDE_COUNTER = 1 To $SLEEPMINUTES * 60
						GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
						GUICtrlSetData ( $LABEL_DOING , "Hiding " & $HIDE_COUNTER & "/" & $SLEEPMINUTES * 60 & " sec" )
						_SLEEP ( 1000 )
					Next
					$HIDE_COUNTER = 0
					LOGINFO ( "Hiding complete" )
					TELEGRAMBOTSEND ( "Hiding complete" )
				Else
					LOGINFO ( "Hiding timer turned OFF" )
				EndIf
				$CHECKLOCALRETREAT = 0
				$HIDING = 0
				$NEED_DOCKING = 0
				If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
					GUICtrlSetData ( $LABEL_DOING , "Wait for for empty local" )
					TrayTip ( "" , "Waiting for empty local" , 30 , 1 )
					TELEGRAMBOTSEND ( "Waiting for empty local" )
					While CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL
						LOGINFO ( "Enemy in local detected. Wait 15 seconds before next check." )
						_SLEEP ( 15000 )
					WEnd
					Local $SLEEPMINUTES
					If $ADDITIONALHIDINGMAX > 0 Then
						$SLEEPMINUTES = Random ( $ADDITIONALHIDINGMIN , $ADDITIONALHIDINGMAX , 1 )
						LOGINFO ( "Hiding for " & $SLEEPMINUTES & " min" )
						TELEGRAMBOTSEND ( "Additional Hiding for " & $SLEEPMINUTES & " min" )
						For $HIDE_COUNTER = 1 To $SLEEPMINUTES * 60
							GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
							GUICtrlSetData ( $LABEL_DOING , "Hiding " & $HIDE_COUNTER & "/" & $SLEEPMINUTES * 60 & " sec" )
							_SLEEP ( 1000 )
						Next
						$HIDE_COUNTER = 0
					EndIf
					GUICtrlSetData ( $LABEL_DOING , "Wait for for empty local complete" )
					TrayTip ( "" , "Waiting for empty local complete" , 30 , 1 )
					TELEGRAMBOTSEND ( "Waiting for empty local complete" )
				EndIf
			EndIf
			Local $IHOURS = 0 , $IMINS = 0 , $ISECS = 0
			_TICKSTOTIME ( TimerDiff ( $TIMERFOR1CYCLE ) , $IHOURS , $IMINS , $ISECS )
			$STATTEXT &= $UNLOADCOUNT & @TAB & StringFormat ( "%02d:%02d:%02d" , $IHOURS , $IMINS , $ISECS ) & @TAB & $CURRENTTREASURE & @CRLF
			If $BOT_ENABLED Then
			Else
				$TIMERFOR1CYCLE = 0
				GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
				GUICtrlSetData ( $LABEL_DOING , "BOT STOP" )
				LOGINFO ( "> BOT STOP" )
				TrayTip ( "" , "Bot stop" , 30 , 1 )
				TELEGRAMBOTSEND ( "Bot Stop" , "\screenshot\screenshot.bmp" )
				Local $KEYBOARD [ 1 ] = [ "start" ]
				Local $MARKUP = _CREATEKEYBOARD ( $KEYBOARD , True )
				_SENDMSG ( $TELEGRAMCHATID , "Bot ready to restart" , Default , $MARKUP )
			EndIf
			#EndRegion Mining MODE
		ElseIf $BOTTYPE = 1 Then
			#Region EYE MODE
			DISCORDSENDMESSAGE ( "<t:" & GETUNIXTIME ( ) & ":R>: every " & $EYECYCLETIME & " minutes ping" )
			$EYETIMER = TimerInit ( )
			$EYETIMER_TIMEOUT = TimerInit ( )
			While TimerDiff ( $EYETIMER ) < MINUTESTOMS ( $EYECYCLETIME )
				If $BOT_ENABLED Then
					If TimerDiff ( $EYETIMER_TIMEOUT ) > $EYECYCLETIMEOUT * 1000 + Random ( 0 , 5 , 1 ) * 1000 Then
						$EYETIMER_TIMEOUT = TimerInit ( )
						If EYELOCALCHAT ( ) Or CHECKOTHERSHIPS ( ) Then
							COMBINEIMAGE ( $CHECKLOCALPANELCOORD [ 0 ] , $CHECKLOCALPANELCOORD [ 1 ] + 4294966925 , 232 , 425 , "\screenshot\localchat.png" )
							DISCORDSENDFILE ( "\u003Ct:" & GETUNIXTIME ( ) & ":R\u003E" , @ScriptDir & "\screenshot\localchat.png" )
						EndIf
						LOGDEBUG ( "Panel coords x=" & $CHECKLOCALPANELCOORD [ 0 ] & " y=" & $CHECKLOCALPANELCOORD [ 1 ] )
					Else
						Sleep ( 2000 )
						LOGDEBUG ( "Wait before next check" )
					EndIf
				EndIf
			WEnd
			#EndRegion EYE MODE
		ElseIf $BOTTYPE = 2 Then
			#Region Anomaly MODE
			Local $ANOMCYCLETIMER = TimerInit ( )
			If $GOHOMEPREPAREFIRSTRUN = 1 And INDOCK ( ) Then GOHOMESORT ( )
			CHECKOVERALLTIME ( )
			If INDOCK ( 1 ) Then
				$JUSTUNDOCKED = 1
				TELEGRAMBOTSEND ( "Undocked" )
				$ALWAYSONSTATE = 0
			EndIf
			If $STOPAFTERUNDOCK = 1 Then
				ENGINESTOP ( )
			EndIf
			CHECKINSQUAD ( )
			ZOOMOUT ( )
			$ISHOMEDPREPAIRED = GOHOMEPREPARE ( )
			If $ISHOMEDPREPAIRED = 0 Then
				TELEGRAMBOTSEND ( "Cannot set BookMark" , "\screenshot\screenshot.bmp" )
			EndIf
			If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
				$NEED_DOCKING = 1
			EndIf
			LOGINFO ( "Need_docking1 =" & $NEED_DOCKING )
			Local $BOTACTIVE = 1
			Local $MAXTRYSELECTANOMALY = 5
			Local $TRYCOUNTSELECTANOMALY = 0
			Local $SELECTANYLEVELANOMALY = 0
			Local $TRYCOUNT = 0
			Local $SELECTCLOSESTENEMYCOUNT = 0
			Local $FORCEFOCUS = 0
			Local $MSG = ""
			Local $ANOMTIMERTMP = TimerDiff ( $ANOMCYCLETIMER )
			CHECKOVERALLTIME ( )
			If $USEALWAYSON = 1 Then
				CHECKALWAYSONSTATE ( )
				If $ALWAYSONSTATE = 0 Then FIREALWAYSON ( )
			EndIf
			SETDOINGSTATUS ( "Getting ship fit" )
			CHECKWEAPONSTATE ( )
			GETSHIPSPARAMS ( )
			CHECKWEAPONBOOSTSTATE ( )
			CHECKREPAIRSTATE ( )
			CHECKBATTERYSTATE ( )
			CHECKWEBSTATE ( )
			CHECKTRACKERCOMPSTATE ( )
			LOGINFO ( "AnomTime. For get ship stats :" & TimerDiff ( $ANOMCYCLETIMER ) - $ANOMTIMERTMP & " ms" )
			Do
				If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
					$NEED_DOCKING = 1
				EndIf
				CHECKOVERALLTIME ( )
				GETSHIPSPARAMS ( )
				LOGINFO ( "Need_docking2 =" & $NEED_DOCKING )
				If $NEED_DOCKING = 1 Then ExitLoop
				If $REPAIRTYPE = 1 Then
					If $SHIPSHIELD < 20 Or $SHIPARMOR < 50 Or $SHIPENERGY < 30 Then
						$NEED_DOCKING = 1
						$MSG = "low state"
						ExitLoop
					EndIf
				Else
					If $SHIPARMOR < 40 Or $SHIPENERGY < 30 Then
						$NEED_DOCKING = 1
						$MSG = "low state"
						ExitLoop
					EndIf
				EndIf
				CHECKNAV ( )
				SELECTOVERLAY ( "Anomaly" )
				Local $ANOMALYNAME = ""
				If ( SELECTANOMALY ( $ANOMALYNAME , $WARPDISTANCE , $SELECTANOMALYSIZE , $SELECTANYLEVELANOMALY ) = 1 ) Then
					$TRYCOUNTSELECTANOMALY = 0
					$SELECTANYLEVELANOMALY = 0
					ADBSCREEN ( 1 )
					TELEGRAMBOTSEND ( "Jumping next anomaly: " & $ANOMALYNAME , "\screenshot\screenshot.bmp" )
					If @Compiled Then
						If FileExists ( @ScriptDir & "\screenshot\tap.bmp" ) Then FileDelete ( @ScriptDir & "\screenshot\tap.bmp" )
					Else
						TELEGRAMBOTSEND ( "Debug:" , "\screenshot\tap.bmp" )
					EndIf
					Sleep ( 1000 )
					$TRYCOUNT = 0
					WAITUNTILSHIPSTARTMOVING ( )
					SELECTOVERLAY ( "ships" )
					WAITUNTILSHIPMOVING ( 0 , 0 , 0 , 0 , 1 , 1 )
					While $TRYCOUNT < $MAXTRYANOMALY
						CHECKOVERALLTIME ( )
						$ANOMTIMERTMP = TimerDiff ( $ANOMCYCLETIMER )
						LOGINFO ( "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
						GUICtrlSetData ( $LABEL_RATE , "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
						If CHECKEASYLOCK ( ) = 1 Then $TRYCOUNT = + 4294967291
						CHECKANDCLOSESTATUS ( )
						If CHECKWEAPONSTATE ( ) = 0 Then
							LOGINFO ( "Try to activate [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
							If Mod ( $TRYCOUNT , 2 ) = 0 Then
								If FIREWEAPON ( ) = 0 Then $TRYCOUNT = $TRYCOUNT + 5
							EndIf
							$TRYCOUNT = $TRYCOUNT + 1
						Else
							FIREWEAPONBOOST ( )
							FIRETRACKERCOMP ( )
							$TRYCOUNT = $TRYCOUNT + 4294967295
						EndIf
						GUICtrlSetData ( $LABEL_RATE , "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
						If $WEAPONTYPE = + 4294967295 Then
							FIREWEAPONBOOST ( )
							FIRETRACKERCOMP ( )
						EndIf
						CHECKOVERALLTIME ( )
						SELECTOVERLAY ( "ships" )
						LOGINFO ( "$ForceFocus=" & $FORCEFOCUS )
						If SELECTCLOSESTENEMY ( 1 , $FORCEFOCUS ) = 0 Then
							$TRYCOUNT = $TRYCOUNT + 10
						Else
							$TRYCOUNT = $TRYCOUNT + 4294967294
							$SELECTCLOSESTENEMYCOUNT = $SELECTCLOSESTENEMYCOUNT + 1
						EndIf
						GUICtrlSetData ( $LABEL_RATE , "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
						If $SELECTCLOSESTENEMYCOUNT > 4 Then
							$SELECTCLOSESTENEMYCOUNT = 0
							$FORCEFOCUS = 1
							FIREWEB ( )
						Else
							$FORCEFOCUS = 0
						EndIf
						CHECKOVERALLTIME ( )
						GETSHIPSPARAMS ( )
						If CHECKENEMYCOUNTER ( ) = 0 Then
							$TRYCOUNT = $TRYCOUNT + 1
						Else
							$TRYCOUNT = $TRYCOUNT + 4294967290
						EndIf
						If $TRYCOUNT < 0 Then $TRYCOUNT = 0
						GUICtrlSetData ( $LABEL_RATE , "Try count [" & $TRYCOUNT & "/" & $MAXTRYANOMALY & "]" )
						CHECKREPAIRSTATE ( )
						Local $MSG = ""
						If $SHIPENERGY < 90 Then FIREBATTERY ( )
						If $REPAIRTYPE = 1 Then
							If $SHIPSHIELD < 80 And $REPAIRSTATE = 0 Then FIREREPAIR ( )
							If $SHIPSHIELD > 90 And $REPAIRSTATE = 1 Then FIREREPAIR ( )
							If $SHIPSHIELD < 20 Or $SHIPARMOR < 50 Or $SHIPENERGY < 30 Then
								$NEED_DOCKING = 1
								$MSG = "low state"
								ExitLoop ( 2 )
							EndIf
						Else
							If $SHIPARMOR < 93 And $REPAIRSTATE = 0 Then FIREREPAIR ( )
							If $SHIPARMOR > 98 And $REPAIRSTATE = 1 Then FIREREPAIR ( )
							If $SHIPARMOR < 40 Or $SHIPENERGY < 30 Then
								$NEED_DOCKING = 1
								$MSG = "low state"
								ExitLoop ( 2 )
							EndIf
						EndIf
						If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
							$NEED_DOCKING = 1
							ExitLoop ( 2 )
						EndIf
						If $BOT_ENABLED = 0 Then
							$NEED_DOCKING = 1
							$MSG = "bot prepairing to stop. time is out"
							ExitLoop
						EndIf
						LOGINFO ( "AnomTime. Time for 1 check round :" & Round ( ( TimerDiff ( $ANOMCYCLETIMER ) - $ANOMTIMERTMP ) , 0 ) & " ms" )
						CHECKOVERALLTIME ( )
					WEnd
					GUICtrlSetData ( $LABEL_CARGO , "" )
				Else
					CHECKANDCLOSESTATUS ( )
					$TRYCOUNTSELECTANOMALY = $TRYCOUNTSELECTANOMALY + 1
				EndIf
				If $TRYCOUNTSELECTANOMALY > $MAXTRYSELECTANOMALY Then
					$NEED_DOCKING = 1
					$MSG = "cannot find selected anomaly"
				EndIf
				If $TRYCOUNTSELECTANOMALY = $MAXTRYSELECTANOMALY + 4294967295 Then
					$SELECTANYLEVELANOMALY = 1
					LOGINFO ( "Selecting Anomaly of any level" )
				EndIf
			Until $NEED_DOCKING = 1
			If Not $MSG = "" Then TELEGRAMBOTSEND ( "Go home:" & $MSG , "\screenshot\screenshot.bmp" )
			CHECKANDCLOSESTATUS ( )
			If $REPAIRSTATE = 0 And $REPAIRTYPE = 2 Then FIREREPAIR ( )
			GOHOME ( )
			Local $TRY = 0
			Local $ERRTRY = 0
			Local $INDOCKSTATUS = 0
			While 1
				$INDOCKSTATUS = INDOCK ( )
				If $INDOCKSTATUS = 1 Then ExitLoop
				$TRY = $TRY + 1
				_SLEEP ( 1300 )
				CHECKDAILY ( )
				GOHOME ( 0 , 1 )
				If $TRY > 160 Then
					LOGINFO ( "Going Home TimeOut " )
				EndIf
				If $INDOCKSTATUS = 2 Or $TRY > 160 Then $ERRTRY = $ERRTRY + 1
				If $ERRTRY > 3 Then
					TELEGRAMBOTSEND ( "Docking error! Killing Eve" , "\screenshot\screenshot.bmp" )
					KILLEVE ( )
					ExitLoop ( 2 )
				EndIf
			WEnd
			$NEED_DOCKING = 0
			If $ALWAYSONSTATE = 1 Then $ALWAYSONSTATE = 0
			_SLEEP ( 13000 )
			$REPAIRSTATE = 0
			CHECKINDOCKREPAIR ( )
			If $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL Then
				GUICtrlSetData ( $LABEL_DOING , "Wait for for empty local" )
				TrayTip ( "" , "Waiting for empty local" , 30 , 1 )
				TELEGRAMBOTSEND ( "Waiting for empty local" )
				While CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL
					LOGINFO ( "Enemy in local detected. Wait 15 seconds before next check." )
					_SLEEP ( 15000 )
				WEnd
				If $ADDITIONALHIDINGMAX > 0 Then
					Local $SLEEPMINUTES
					$SLEEPMINUTES = Random ( $ADDITIONALHIDINGMIN , $ADDITIONALHIDINGMAX , 1 )
					LOGINFO ( "Hiding for " & $SLEEPMINUTES & " min" )
					TELEGRAMBOTSEND ( "Additional Hiding for " & $SLEEPMINUTES & " min" )
					For $HIDE_COUNTER = 1 To $SLEEPMINUTES * 60
						GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
						GUICtrlSetData ( $LABEL_DOING , "Hiding " & $HIDE_COUNTER & "/" & $SLEEPMINUTES * 60 & " sec" )
						_SLEEP ( 1000 )
					Next
					$HIDE_COUNTER = 0
				EndIf
				LOGINFO ( "Hiding complete" )
				TELEGRAMBOTSEND ( "Hiding complete" )
				GUICtrlSetData ( $LABEL_DOING , "Wait for for empty local complete" )
				TrayTip ( "" , "Waiting for empty local complete" , 30 , 1 )
				TELEGRAMBOTSEND ( "Waiting for empty local complete" )
			EndIf
			If $BOT_ENABLED Then
			Else
				$TIMERFOR1CYCLE = 0
				GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
				GUICtrlSetData ( $LABEL_DOING , "BOT STOP" )
				LOGINFO ( "> BOT STOP" )
				TrayTip ( "" , "Bot stop" , 30 , 1 )
				ADBSCREEN ( 1 )
				TELEGRAMBOTSEND ( "Bot Stop: time is out" , "\screenshot\screenshot.bmp" )
			EndIf
			#EndRegion Anomaly MODE
		ElseIf $BOTTYPE = 3 Then
			#Region Event MODE
			Local $EVENTUNLOADTIMER = TimerInit ( )
			Local $EVENTLASTUNLOAD = TimerDiff ( $EVENTUNLOADTIMER )
			$BOT_ENABLED = 1
			$NEEDCHECKOTHERSHIPS = 0
			GETMINERSCOORD ( )
			CHECKNAV ( )
			OPENASTEROIDSLIST ( )
			While 1
				If WARPTOASTEROIDCLUSTERV2 ( ) == 0 Then
					LOGINFO ( "Secon try" )
					WARPTOASTEROIDCLUSTERV2 ( )
				EndIf
				CHECKMINERS ( )
				AFTERBURNERFIND ( )
				WAITUNTILSHIPSTARTMOVING ( )
				WAITUNTILSHIPMOVING ( 0 , 0 , 0 , 0 , 1 , 1 )
				If $MINERS_SIZE = 2 Then
					LOGINFO ( "Activation stripe miners" )
					For $I = 0 To 2 Step 1
						If ( $MINERS_STATUS [ $I ] > 1 ) Then SENDTAP ( $MINERS_COORD [ $I ] [ 0 ] , 666 , 19 )
					Next
				EndIf
				If $MINERS_SIZE = 3 Then
					LOGINFO ( "Activation drones miners" )
					SENDTAP ( $MINERS_COORD [ 0 ] [ 0 ] , 666 , 19 )
					Sleep ( 4000 )
					SENDTAP ( $MINERS_COORD [ 0 ] [ 0 ] , 666 , 19 )
				EndIf
				If MININGASTEROID ( ) = 5 Then ExitLoop
				If TimerDiff ( $EVENTUNLOADTIMER ) - $EVENTLASTUNLOAD > 30 * 60 * 1000 Then ExitLoop
				CHECKOVERALLTIME ( )
			WEnd
			SETDOINGSTATUS ( "Unloading" )
			Do
				If ( WAITFINDPIC ( @ScriptDir & "\img\station_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 1000 , 1 , 1100 , 60 ) = 1 ) Then
					LOGINFO ( "Station ico finded" )
					Sleep ( 1000 )
					LOGINFO ( "go 1" )
				Else
					SENDTAP ( 1107 , 27 , 4 )
					If ( WAITFINDPIC ( @ScriptDir & "\img\station_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 1000 , 1 , 1100 , 600 ) = 1 ) Then
						SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
					EndIf
					Sleep ( 2000 )
					LOGINFO ( "go 2" )
				EndIf
				Sleep ( 2000 )
				SENDTAP ( 1124 , 92 , 8 )
				If ( WAITFINDPIC ( @ScriptDir & "\img\warp_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 , 781 , 41 , 781 + 243 , 41 + 675 ) = 1 ) Then
					SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
					LOGINFO ( "Warp click FIND X=" & $X_FINDED & "Y=" & $Y_FINDED )
					Local $WARPING = 1
				Else
					$WARPING = 0
				EndIf
			Until $WARPING = 1
			Sleep ( 9000 )
			WAITUNTILSHIPSTARTMOVING ( )
			WAITUNTILSHIPMOVING ( 0 , 0 , 0 , 0 , 1 , 1 )
			SENDTAP ( 1124 , 92 , 8 )
			Sleep ( 3000 )
			SENDTAP ( 891 , 101 , 8 )
			Sleep ( 300 )
			ADBSCREEN ( 1 )
			TELEGRAMBOTSEND ( "Unloading" , "\screenshot\screenshot.bmp" )
			$NEEDCHECKOTHERSHIPS = 1
			#EndRegion Event MODE
		ElseIf $BOTTYPE = 5 Then
			#Region Scan MODE
			If MAINSCANLOOP ( ) = 1 Then
				$BOT_ENABLED = 0
				GUICtrlSetState ( $BUTTON_START , $GUI_ENABLE )
			EndIf
			#EndRegion Scan MODE
		EndIf
	WEnd
	If TimerDiff ( $MAINLOOPTIMER ) > 8000 Then
		$MAINLOOPTIMER = TimerInit ( )
		TELEGRAMPOLLING ( )
	EndIf
	Sleep ( 500 )
WEnd
#EndRegion BOT LOOP
_OPENCV_SHUTDOWN ( )
Func INDOCKUNLOAD ( )
	$CURRFUNCNAME = "InDockUnload"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Start InDOckUnload" )
	GUICtrlSetData ( $LABEL_DOING , "In dock unload" )
	CHECKDETECTED ( )
	SENDTAP ( 649 , 366 , 10 )
	If WAITFINDPIC ( @ScriptDir & "\img\open_cargo_hold.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 ) = 0 Then
		SENDTAP ( 649 , 366 , 10 )
		Sleep ( 1000 )
		WAITFINDPIC ( @ScriptDir & "\img\open_cargo_hold.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 )
	EndIf
	SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
	If Not WAITFINDPIC ( @ScriptDir & "\img\ore_hold.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 ) Then
		WAITFINDPIC ( @ScriptDir & "\img\cargoarrow.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		Sleep ( 1000 )
		WAITFINDPIC ( @ScriptDir & "\img\ore_hold.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 )
		Sleep ( 2000 )
	EndIf
	SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
	Sleep ( 1000 )
	$CURRENTTREASURE = TREASUREREAD ( )
	$TOTALTREASURE = $TOTALTREASURE + $CURRENTTREASURE
	Local $TREASUREPERHOUR
	If TimerDiff ( $TIMERFOR1CYCLE ) > 0 Then $TREASUREPERHOUR = NUMFORMAT ( Round ( $CURRENTTREASURE / ( TimerDiff ( $TIMERFOR1CYCLE ) / 1000 / 60 / 60 ) , 0 ) )
	TELEGRAMBOTSEND ( "Unload: " & $UNLOADCOUNT + 1 & " .Current: " & NUMFORMAT ( $CURRENTTREASURE ) & " Total Treasure: " & NUMFORMAT ( $TOTALTREASURE ) & " Per hour:~" & $TREASUREPERHOUR & " ISK" , "\screenshot\screenshot.bmp" )
	WAITFINDPIC ( @ScriptDir & "\img\select_all.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 )
	SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
	WAITFINDPIC ( @ScriptDir & "\img\move_to.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 )
	SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
	WAITFINDPIC ( @ScriptDir & "\img\save_hangar.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 )
	SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
	$UNLOADCOUNT = $UNLOADCOUNT + 1
	GUICtrlSetData ( $LABEL_UNLOADINGCOUNT , "Unloading count: " & $UNLOADCOUNT )
	RATECALCULATE ( )
	_SLEEP ( 5000 )
	WAITFINDPIC ( @ScriptDir & "\img\close_inventory.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 )
	SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
	LOGINFO ( "Finish InDOckUnload" )
EndFunc
Func INDOCK ( $UNDOCK = False )
	$CURRFUNCNAME = "InDock"
	Local $X_FINDED , $Y_FINDED
	Local $X_UNDOCK , $Y_UNDOCK
	Local $DELAYAFTERUNDOCK = 2
	LOGINFO ( "Check InDock" )
	GUICtrlSetData ( $LABEL_DOING , "In dock check" )
	If ADB_ARRIVALCHECK ( ) = 1 Then
	EndIf
	ADBSCREEN ( 1 )
	If ( WAITFINDPIC ( @ScriptDir & "\img\eye.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 942 , 368 , 1272 , 452 , 1 ) ) Then
		If ( Not WAITFINDPIC ( @ScriptDir & "\img\undock_btn1.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1016 , 192 , 1277 , 278 , 1 ) And Not WAITFINDPIC ( @ScriptDir & "\img\undock_btn.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1016 , 192 , 1277 , 278 , 1 ) ) Then
			LOGINFO ( "Check InDock complete: NOT InDock" )
			Return 0
		Else
			LOGINFO ( "Check InDock complete: NOT InDock an NOT in SPACE!" )
			Return 2
		EndIf
	Else
		If ( WAITFINDPIC ( @ScriptDir & "\img\close_inventory_2.bmp" , $X_FINDED , $Y_FINDED , 0.5 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1032 , 3 , 1032 + 246 , 3 + 112 , 1 ) Or WAITFINDPIC ( @ScriptDir & "\img\close_inventory.bmp" , $X_FINDED , $Y_FINDED , 0.5 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1032 , 3 , 1032 + 246 , 3 + 112 , 1 ) ) Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
			Sleep ( 10000 )
			ADBSCREEN ( 1 )
		EndIf
		If ( WAITFINDPIC ( @ScriptDir & "\img\undock_btn1.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1016 , 192 , 1277 , 278 , 1 ) Or WAITFINDPIC ( @ScriptDir & "\img\undock_btn.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1016 , 192 , 1277 , 278 , 1 ) ) Then
			$X_UNDOCK = $X_FINDED
			$Y_UNDOCK = $Y_FINDED
			LOGINFO ( "InDock" )
			$ANSW = SENDADB ( " shell ""logcat com.netease.eve.en:I -e autopilot -b main -t " & GETUNIXTIME ( ) + 4294967236 & ".000""" )
			LOGINFO ( "Indock ADB1:" & @CRLF & $ANSW )
			Do
				CHECKDETECTED ( )
				If WAITFINDPIC ( @ScriptDir & "\img\bookmarks_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 3 , 162 , 3 + 284 , 162 + 67 ) = 1 Then
					SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
					Sleep ( 2000 )
				EndIf
				CHECKANDCLOSESTATUS ( )
			Until WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 , 220 , 200 , 220 + 94 , 200 + 74 ) = 1
			Sleep ( 1500 )
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
			If $UNDOCK Then
				LOGINFO ( "Undocking" )
				SENDTAP ( $X_UNDOCK , $Y_UNDOCK , 10 )
				Sleep ( 2000 )
				If ( WAITFINDPIC ( @ScriptDir & "\img\confirm.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 ) = 1 ) Then
					SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
					Sleep ( 4000 )
				EndIf
				If ( WAITFINDPIC ( @ScriptDir & "\img\confirm.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 ) = 1 ) Then
					SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
					Sleep ( 4000 )
				EndIf
				_SLEEP ( 4000 )
				If ( WAITFINDPICD ( @ScriptDir & "\img\engine_ico.bmp" , $X_FINDED , $Y_FINDED , 0.9 , @ScriptDir & "\screenshot\screenshot.bmp" , 30 , 479 , 558 , 67 , 61 ) = 1 ) Then
					LOGINFO ( "engine Finded" )
				EndIf
				LOGINFO ( "Delay after undocking: " & $DELAYAFTERUNDOCK & " second" )
				_SLEEP ( $DELAYAFTERUNDOCK * 1000 )
			EndIf
			LOGINFO ( "Check InDock complete" )
			Return 1
		Else
			LOGINFO ( "Check InDock complete: NOT InDock an NOT in SPACE!" )
			Return 2
		EndIf
	EndIf
EndFunc
Func CHECKDAILY ( )
	$CURRFUNCNAME = "CheckDaily"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "CheckDaily" )
	If ( WAITFINDPIC ( @ScriptDir & "\img\menu_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 2 , 2 , 150 , 150 ) ) Then
		SENDTAP ( 1241 , 41 , 10 )
		LOGINFO ( "CheckDaily: closed" )
		_SLEEP ( 5000 )
	Else
		LOGINFO ( "CheckDaily: not find" )
	EndIf
EndFunc
Func CHECKINSQUAD ( )
	$CURRFUNCNAME = "CheckInSquad"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "CheckInSquad" )
	If ( WAITFINDPIC ( @ScriptDir & "\img\squad_sign.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 5 , 98 , 5 + 19 , 98 + 18 ) ) Then
		SENDTAP ( 63 , 33 , 10 )
		If WAITFINDPIC ( @ScriptDir & "\img\settings.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 ) = 1 Then
			SENDTAP ( 63 , 33 , 10 )
		EndIf
		LOGINFO ( "CheckInSquad: closed" )
		_SLEEP ( 2500 )
	Else
		LOGINFO ( "CheckInSquad: not find" )
	EndIf
EndFunc
Func GOHOME ( $NOTDOCKING = 0 , $SECONDCHECK = 0 )
	$CURRFUNCNAME = "GoHome"
	Local $X_FINDED , $Y_FINDED
	Local $X_ARR , $Y_ARR
	Local $TRY = 0
	Local $MAXTRY = 20
	Local $ATRY = 0
	Local $MAXATRY = 3
	Local $WARPPRESSED = 0
	Local $ERRORTHRESHOLD = 1
	Local $XCOLOR [ 3 ]
	If $NOTDOCKING = 0 Then
		LOGINFO ( "Start Going Home" )
		GUICtrlSetData ( $LABEL_DOING , "Going home" )
	Else
		LOGINFO ( "Start Going near Home" )
		GUICtrlSetData ( $LABEL_DOING , "Going near home" )
	EndIf
	CHECKDETECTED ( )
	$XCOLOR [ 0 ] = 163
	$XCOLOR [ 1 ] = 180
	$XCOLOR [ 2 ] = 174
	Local $TMPTIMER = TimerInit ( )
	While $WARPPRESSED = 0 And $ATRY < $MAXATRY
		If $SECONDCHECK = 0 Then SENDTAP ( 8 , 198 , 1 )
		LOGINFO ( "Check jump is pressed" )
		$TRY = 0
		While $WARPPRESSED < 3 And $TRY < $MAXTRY
			$COLOR = CHECKCOLOR ( 22 , 203 , 1 , 0 , 1 )
			If ( $COLOR [ 0 ] > $XCOLOR [ 0 ] - $ERRORTHRESHOLD And $COLOR [ 0 ] < $XCOLOR [ 0 ] + $ERRORTHRESHOLD And $COLOR [ 1 ] > $XCOLOR [ 1 ] - $ERRORTHRESHOLD And $COLOR [ 1 ] < $XCOLOR [ 1 ] + $ERRORTHRESHOLD And $COLOR [ 2 ] > $XCOLOR [ 2 ] - $ERRORTHRESHOLD And $COLOR [ 2 ] < $XCOLOR [ 2 ] + $ERRORTHRESHOLD ) Then
				$WARPPRESSED = $WARPPRESSED + 1
				LOGINFO ( "Jump is pressed. Check number=" & $WARPPRESSED )
			Else
				Sleep ( 20 )
				$TRY = $TRY + 1
				LOGINFO ( "Check jump try " & $TRY & " of " & $MAXTRY )
			EndIf
		WEnd
		$ATRY = $ATRY + 1
		$SECONDCHECK = 0
	WEnd
	Local $TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) )
	If $NOTDOCKING = 0 Then
		LOGINFO ( "Sending Home complete.Time for command: " & $TMPDIFF & "ms" )
		Return $TMPDIFF
	Else
		LOGINFO ( "Sending Home delay:" & $TIMETOWARPCURRENT * 0.5 )
		_SLEEP ( $TIMETOWARPCURRENT * 0.5 )
		SENDTAP ( 8 , 198 , 1 )
		LOGINFO ( "Sending near Home complete" )
		Return $TMPDIFF
	EndIf
EndFunc
Func GOHOMESORT ( )
	$CURRFUNCNAME = "GoHomeSort"
	Local $X_FINDED , $Y_FINDED
	Local $X_ARR , $Y_ARR
	Local $TRY = 0
	Local $ALREADYTOP = 0
	Local $TIMECORRECTION = 1.4
	LOGINFO ( "Going Home Sort" )
	GUICtrlSetData ( $LABEL_DOING , "Going home Prepare" )
	Do
		CHECKDETECTED ( )
		If WAITFINDPIC ( @ScriptDir & "\img\bookmarks_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 3 , 162 , 3 + 284 , 162 + 67 ) = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		EndIf
	Until WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 , 220 , 200 , 220 + 94 , 200 + 74 ) = 1 Or WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks2.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 8 , 166 , 8 + 288 , 166 + 113 ) = 1
	_SLEEP ( 2000 )
	If $GOHOMEPREPAREFIRSTRUN = 1 Then
		WAITFINDPIC ( @ScriptDir & "\img\location_filter.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 , 233 , 657 , 233 + 32 , 657 + 32 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		WAITFINDPIC ( @ScriptDir & "\img\location_displaycurrentsystem.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 , 240 , 246 , 240 + 359 , 246 + 194 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		Sleep ( 1000 * $TIMECORRECTION )
		$GOHOMEPREPAREFIRSTRUN = 0
		If WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 , 220 , 200 , 220 + 94 , 200 + 74 ) Then SENDTAP ( $X_FINDED , $Y_FINDED , 5 )
	EndIf
EndFunc
Func GOHOMEPREPARE ( $TIMECORRECTION = 1 )
	$CURRFUNCNAME = "GoHomePrepare"
	Local $X_FINDED , $Y_FINDED
	Local $X_ARR , $Y_ARR
	Local $TRY = 0
	Local $ALREADYTOP = 0
	LOGINFO ( "Going Home Prepare" )
	GUICtrlSetData ( $LABEL_DOING , "Going home Prepare" )
	Do
		CHECKDETECTED ( )
		If WAITFINDPIC ( @ScriptDir & "\img\bookmarks_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 3 , 162 , 3 + 284 , 162 + 67 ) = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		EndIf
	Until WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 , 220 , 200 , 220 + 94 , 200 + 74 ) = 1
	_SLEEP ( 2000 )
	If $GOHOMEPREPAREFIRSTRUN = 1 Then
		WAITFINDPIC ( @ScriptDir & "\img\location_filter.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 , 233 , 657 , 233 + 32 , 657 + 32 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		WAITFINDPIC ( @ScriptDir & "\img\location_displaycurrentsystem.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 , 240 , 246 , 240 + 359 , 246 + 194 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		Sleep ( 1000 * $TIMECORRECTION )
		SENDTAP ( 112 , 304 , 10 )
		If WAITFINDPIC ( @ScriptDir & "\img\location_removefromtop.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 * $TIMECORRECTION , 294 , 204 , 547 , 710 ) = 0 Then
			If WAITFINDPIC ( @ScriptDir & "\img\location_movetotop.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 * $TIMECORRECTION , 294 , 204 , 547 , 710 ) = 1 Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
			Else
				If WAITFINDPIC ( @ScriptDir & "\img\set_as_destination.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 25 ) = 1 Then
					SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
					$ALREADYTOP = 1
				EndIf
			EndIf
		Else
			If WAITFINDPIC ( @ScriptDir & "\img\set_as_destination.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 25 ) = 1 Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
				$ALREADYTOP = 1
			EndIf
		EndIf
		$GOHOMEPREPAREFIRSTRUN = 0
	EndIf
	If Not $ALREADYTOP Then
		SENDTAP ( 112 , 304 , 10 )
		WAITFINDPIC ( @ScriptDir & "\img\set_as_destination.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 25 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
	EndIf
	Sleep ( 100 )
	If WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 , 220 , 200 , 220 + 94 , 200 + 74 ) Then SENDTAP ( $X_FINDED , $Y_FINDED , 5 )
	Sleep ( 1500 )
	LOGINFO ( "Color Checkin" )
	Local $M = CHECKCOLOR ( 65 , 214 , 1 , 0 , 1 )
	Local $HSL_COLOR = _COLORCONVERTRGBTOHSL ( $M )
	Local $N = CHECKCOLOR ( 67 , 214 , 1 , 0 , 0 )
	Local $HSL_COLOR1 = _COLORCONVERTRGBTOHSL ( $N )
	LOGINFO ( "1 has h=" & Round ( $HSL_COLOR [ 0 ] ) & " s=" & Round ( $HSL_COLOR [ 1 ] ) & " l=" & Round ( $HSL_COLOR [ 2 ] ) )
	LOGINFO ( "2 has h=" & Round ( $HSL_COLOR1 [ 0 ] ) & " s=" & Round ( $HSL_COLOR1 [ 1 ] ) & " l=" & Round ( $HSL_COLOR1 [ 2 ] ) )
	LOGINFO ( "delta h=" & Abs ( Round ( $HSL_COLOR1 [ 0 ] ) - Round ( $HSL_COLOR [ 0 ] ) ) & " s=" & Abs ( Round ( $HSL_COLOR1 [ 1 ] ) - Round ( $HSL_COLOR [ 1 ] ) ) & " l=" & Abs ( Round ( $HSL_COLOR1 [ 2 ] ) - Round ( $HSL_COLOR [ 2 ] ) ) )
	Local $DELTA = Abs ( Round ( $HSL_COLOR1 [ 2 ] ) - Round ( $HSL_COLOR [ 2 ] ) )
	If $DELTA > 4 Then
		LOGINFO ( "Going Home Prepare complete" )
		Return 1
	Else
		If $TIMECORRECTION = 1 Then
			LOGINFO ( "Going Home Prepare first run FAIL. Try again." )
			If GOHOMEPREPARE ( 1.8 ) = 1 Then
				LOGINFO ( "Going Home Prepare Second run complete." )
				Return 1
			Else
				Return 0
			EndIf
		Else
			LOGINFO ( "Going Home Prepare Second run FAIL!!!" )
			Return 0
		EndIf
	EndIf
EndFunc
Func WAITUNTILSHIPMOVING ( $USEAFTERBURNER = 0 , $DONTWAITFORPIC_SHIPSTOPPING = 0 , $WAITFORPIC_APPROACHING = 0 , $FASTMINE = 0 , $DONTCHECKLOCAL = 0 , $WAITEASYLOCK = 0 )
	$CURRFUNCNAME = "WaitUntilShipMoving"
	Local $MOVINGTIMER = TimerInit ( )
	Local $MOVINGTIMEOUT = 5 * 60 * 1000
	Local $X_FINDED , $Y_FINDED
	Local $CHECKMINERSDELAY = 5 * 1000
	Local $CHECKMINERSTIMER = TimerInit ( )
	Local $CHECKMINERSFIRSTTIME = 1
	Local $CHECKMINERS = 5 * 1000
	LOGINFO ( ">Wait for ship stops " & $MOVINGTIMEOUT / 1000 & " seconds." )
	GUICtrlSetData ( $LABEL_DOING , "Wait for ship stops" )
	FILECONSOLEWRITE ( "[" )
	While SHIPMOVING ( 0 ) And TimerDiff ( $MOVINGTIMER ) < $MOVINGTIMEOUT
		_SLEEP ( 100 )
		If $USEAFTERBURNER = 1 And $AFTERBURNER [ 2 ] = 0 Then
			SENDTAP ( $AFTERBURNER [ 0 ] , $AFTERBURNER [ 1 ] , 5 )
			$AFTERBURNER [ 2 ] = 1
		EndIf
		ConsoleWrite ( "|" )
		If Not $DONTWAITFORPIC_SHIPSTOPPING And WAITFINDPIC ( @ScriptDir & "\img\shipstopping.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 534 , 506 , 717 , 550 ) Then ExitLoop
		If $WAITFORPIC_APPROACHING And Not WAITFINDPIC ( @ScriptDir & "\img\approaching.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 326 , 514 , 717 , 540 ) Then ExitLoop
		If $WAITEASYLOCK And WAITFINDPIC ( @ScriptDir & "\img\easy_lock.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 764 , 426 , 764 + 68 , 426 + 63 ) Then ExitLoop
		If $FASTMINE = 1 And ( $MINERS_SIZE = 0 Or $MINERS_SIZE = 1 ) And ( TimerDiff ( $CHECKMINERSTIMER ) > $CHECKMINERSDELAY Or $CHECKMINERSFIRSTTIME = 1 ) Then
			LOGINFO ( "Try to FastMine" )
			$CHECKMINERSTIMER = TimerInit ( )
			$CHECKMINERSFIRSTTIME = 0
			For $I = 0 To 2 Step 1
				If ( $MINERS_STATUS [ $I ] > 1 ) Then SENDTAP ( $MINERS_COORD [ $I ] [ 0 ] , 666 , 19 )
			Next
			Sleep ( 700 )
			CHECKMINERS ( )
			If ( $MINERS_STATUS [ 0 ] = 1 ) And $DONTCHECKLOCAL = 0 Then
				LOGINFO ( "Try to FastMine DONE" )
				ExitLoop
			EndIf
		EndIf
		If $NEEDCHECKOTHERSHIPS = 1 Then
			If ( $BOTTYPE = 0 And CHECKOTHERSHIPS ( ) = 1 ) Or ( $NEEDCHECKLOCAL = 1 And CHECKLOCAL ( ) >= $CHECKLOCALPANICLEVEL ) Then
				$NEED_DOCKING = 1
				$HIDING = 1
				ExitLoop
			EndIf
		EndIf
	WEnd
	ConsoleWrite ( "]" & @CRLF )
	If $USEAFTERBURNER = 1 And $AFTERBURNER [ 2 ] >= 0 Then
		SENDTAP ( $AFTERBURNER [ 0 ] , $AFTERBURNER [ 1 ] , 5 )
		$AFTERBURNER [ 2 ] = 0
	EndIf
	$ANSW = SENDADB ( " shell ""pid=$(ps | grep com.netease.eve.en | tr -s ' ' | cut -d ' ' -f2);logcat --pid=$pid -b main -t " & GETUNIXTIME ( ) + 4294967236 & ".000""" )
	LOGINFO ( "stop ADB1:" & @CRLF & $ANSW )
	LOGINFO ( ">Wait for ship stops complete.It takes " & Round ( TimerDiff ( $MOVINGTIMER ) / 1000 ) & "/" & $MOVINGTIMEOUT / 1000 & " seconds." )
EndFunc
Func ENGINESTOP ( )
	$CURRFUNCNAME = "EngineSTOP"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Stop engine" )
	SENDTAP ( 511 , 586 , 10 )
	LOGINFO ( "stop engine STOP" )
EndFunc
Func ZOOMOUT ( )
	$CURRFUNCNAME = "ZoomOut"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Start ZoomOut" )
	SENDTAP ( 639 , 627 , 10 )
	LOGINFO ( "STOP ZoomOut " )
EndFunc
Func ENGINEMAX ( )
	$CURRFUNCNAME = "EngineMax"
	LOGINFO ( "Start engine at max speed" )
	Local $TMPTIMER = TimerInit ( )
	SENDADB ( " shell input swipe " & 511 + Random ( + 4294967295 , 1 , 1 ) & " " & 586 + Random ( + 4294967295 , 1 , 1 ) & " " & 503 + Random ( + 4294967291 , 5 , 1 ) & " " & 162 + Random ( + 4294967291 , 5 , 1 ) & " " & Random ( 400 , 600 , 1 ) )
	Local $TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) )
	LOGINFO ( "Time for command: " & $TMPDIFF & "ms" )
	LOGINFO ( "Start engine at max speed STOP" )
	Return $TMPDIFF
EndFunc
Func MININGASTEROID ( )
	$CURRFUNCNAME = "MiningAsteroid"
	Local $FIRSTSHIPCHECKING = 1
	Local $X_FINDED , $Y_FINDED
	Local $MINING = True
	Local $I
	Local $TRY_TRESHOLD = 12
	Local $CHECKMINERSDELAY = 5 * 1000
	Local $CHECKMINERSTIMER = TimerInit ( )
	Local $CHECKMINERSFIRSTTIME = 1
	Local $NO_TARGET = 0
	Local $WORKTIMER = TimerInit ( )
	Local $WORKTIMEOUT = 20 * 60 * 1000
	Local $NOORESFOUND = 0
	Local $POLLINGCOUNTER = 0
	Local $CHESKLOCALRET = 0
	Local $WAITDELAY = 7
	Local $ADBWIPECHECK = 0
	LOGINFO ( "Start MiningAsteroid" )
	GUICtrlSetData ( $LABEL_DOING , "Mining" )
	While $MINING
		If $NEEDCHECKOTHERSHIPS = 1 Then
			If $NEEDCHECKLOCAL = 1 Then $CHESKLOCALRET = CHECKLOCAL ( )
			If $DONTNEEDCHECKOTHERSHIPS = 0 Then
				If CHECKOTHERSHIPS ( ) = 1 Or ( $NEEDCHECKLOCAL = 1 And $CHESKLOCALRET >= $CHECKLOCALPANICLEVEL ) Then
					$NEED_DOCKING = 1
					$HIDING = 1
					Return 0
				EndIf
			Else
				If $FIRSTSHIPCHECKING = 1 Then
					CHECKOTHERSHIPS ( )
					$FIRSTSHIPCHECKING = 0
				EndIf
				If ( $NEEDCHECKLOCAL = 1 And $CHESKLOCALRET > 0 ) Then
					If $CHESKLOCALRET >= $CHECKLOCALPANICLEVEL Or CHECKOTHERSHIPS ( ) = 1 Then
						$NEED_DOCKING = 1
						$HIDING = 1
						Return 0
					EndIf
				Else
					LOGINFO ( "No neutrals. Just waiting for:" & $WAITDELAY & " seconds." )
					_SLEEP ( $WAITDELAY * 1000 )
				EndIf
			EndIf
		EndIf
		If TimerDiff ( $CHECKMINERSTIMER ) > $CHECKMINERSDELAY Or $CHECKMINERSFIRSTTIME = 1 Or $DONTNEEDCHECKOTHERSHIPS = 1 Then
			$CHECKMINERSTIMER = TimerInit ( )
			$CHECKMINERSFIRSTTIME = 0
			CHECKMINERS ( )
			For $I = 0 To 2 Step 1
				If ( $MINERS_STATUS [ $I ] > 1 ) And ( $MINERS_STATUS [ $I ] <= $TRY_TRESHOLD ) Then
					If $MINERS_STATUS [ $I ] > 3 Then
						SENDTAP ( $MINERS_COORD [ $I ] [ 0 ] , 666 , 19 )
						$NO_TARGET = WAITFINDPIC ( @ScriptDir & "\img\noavailabletarget.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 301 , 156 , 1023 , 299 )
						$NOORESFOUND = WAITFINDPIC ( @ScriptDir & "\img\no_ores_found.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0.5 , 466 , 183 , 778 , 274 )
						If $BOTTYPE = 3 And WAITFINDPIC ( @ScriptDir & "\img\event_isfull.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 0.5 , 366 , 140 , 366 + 607 , 140 + 96 ) = 1 Then
							Return 5
						EndIf
						If $NO_TARGET = 1 Or $NOORESFOUND = 1 Then ExitLoop
						CHECKMINERS ( )
					EndIf
					If $MINERS_STATUS [ $I ] > 1 Then $MINERS_STATUS [ $I ] = $MINERS_STATUS [ $I ] + 1
				EndIf
			Next
		EndIf
		If Not $BOT_ENABLED Then
			LOGINFO ( "+Time is over" )
			ExitLoop
		EndIf
		If $MINERS_SIZE = 0 Or $MINERS_SIZE = 1 Then $ADBWIPECHECK = ADB_ASTERWIPECHECK ( )
		If $MINERS_SIZE = 2 Or $MINERS_SIZE = 3 Then $NOORESFOUND = WAITFINDPIC ( @ScriptDir & "\img\no_ores_found.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0.5 , 466 , 183 , 778 , 274 )
		If ( ( $MINERS_STATUS [ 0 ] > $TRY_TRESHOLD ) Or ( $MINERS_STATUS [ 1 ] > $TRY_TRESHOLD ) Or ( $MINERS_STATUS [ 2 ] > $TRY_TRESHOLD ) ) Or ( CHECKCARGOVALUE ( ) > $SETMAXCARGO ) Or TimerDiff ( $WORKTIMER ) > $WORKTIMEOUT Or $NO_TARGET Or $NOORESFOUND Or $ADBWIPECHECK Then
			If ( $MINERS_STATUS [ 0 ] > $TRY_TRESHOLD ) Then ConsoleWrite ( "!$Miners_status[0] > $Try_treshold" & @CRLF )
			If ( $MINERS_STATUS [ 1 ] > $TRY_TRESHOLD ) Then ConsoleWrite ( "!$Miners_status[1] > $Try_treshold" & @CRLF )
			If ( $MINERS_STATUS [ 2 ] > $TRY_TRESHOLD ) Then ConsoleWrite ( "!$Miners_status[2] > $Try_treshold" & @CRLF )
			If ( CHECKCARGOVALUE ( ) > $SETMAXCARGO ) Then ConsoleWrite ( "!CheckCargoValue() > $SetMaxCargo" & @CRLF )
			If ( TimerDiff ( $WORKTIMER ) > $WORKTIMEOUT ) Then ConsoleWrite ( "!TimerDiff($WorkTimer) > $WorkTimeout" & @CRLF )
			If ( $NO_TARGET ) Then ConsoleWrite ( "!$No_target" & @CRLF )
			If ( $NOORESFOUND ) Then ConsoleWrite ( "!$NoOresFound" & @CRLF )
			CHECKMINERS ( )
			If $MINERS_SIZE < 2 Then
				FILECONSOLEWRITE ( "Turning off miners " )
				PRINTLIST ( $MINERS_STATUS )
				LOGINFO ( " ." )
				If $MINERS_STATUS [ 0 ] >= 1 Then
					LOGINFO ( "Turning off miner #1" )
					$MINERS_STATUS [ 0 ] = 2
					SENDTAP ( $MINERS_COORD [ 0 ] [ 0 ] , 666 , 19 )
				EndIf
				If $MINERS_STATUS [ 1 ] >= 1 Then
					LOGINFO ( "Turning off miner #2" )
					$MINERS_STATUS [ 1 ] = 2
					SENDTAP ( $MINERS_COORD [ 1 ] [ 0 ] , 666 , 19 )
				EndIf
				If $MINERS_STATUS [ 2 ] >= 1 Then
					LOGINFO ( "Turning off miner #3" )
					$MINERS_STATUS [ 2 ] = 2
					SENDTAP ( $MINERS_COORD [ 2 ] [ 0 ] , 666 , 19 )
				EndIf
			EndIf
			ConsoleWrite ( "+MINIG COMPLETE" & @CRLF )
			If Not $MINERS_SIZE = 2 Then
				ENGINESTOP ( )
				WAITUNTILSHIPMOVING ( 1 , 0 , 1 )
			EndIf
			ExitLoop
		EndIf
		ConsoleWrite ( "Timeleft:" & Round ( ( $WORKTIMEOUT - TimerDiff ( $WORKTIMER ) ) / 1000 ) & "/" & Round ( $WORKTIMEOUT / 1000 ) & " sec. Asteroid wiped:" & $ASTEROID_WIPED & ". Unload count:" & $UNLOADCOUNT & @CRLF )
		If $POLLINGCOUNTER > 30 Then
			TELEGRAMPOLLING ( )
			$POLLINGCOUNTER = 0
		EndIf
		$POLLINGCOUNTER = $POLLINGCOUNTER + 1
	WEnd
	LOGINFO ( "Stop MiningAsteroid" )
EndFunc
Func SELECTASTEROID ( $TRY = 0 )
	$CURRFUNCNAME = "SelectAsteroid"
	Local $X_FINDED , $Y_FINDED
	Local $RETURN = 0
	Local $I , $M
	LOGINFO ( "Start SelectAsteroid" )
	GUICtrlSetData ( $LABEL_DOING , "Selecting asteroid" )
	If $TRY = 0 Then
		If $NEEDCHECKOTHERSHIPS = 0 Then
			For $I = 1 To $FIRSTSWIPEASTER
				SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
			Next
		Else
			SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		EndIf
	Else
		If $ADB_CLICK Then SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		If $ADB_CLICK Then SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
		If $ADB_CLICK Then SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
	EndIf
	Sleep ( 500 )
	GETASTEROIDSLIST ( )
	LOGINFO ( "_GUICtrlListView_GetItemCount($cLV):" & _GUICTRLLISTVIEW_GETITEMCOUNT ( $CLV ) )
	For $I = 0 To _GUICTRLLISTVIEW_GETITEMCOUNT ( $CLV )
		If StringCompare ( _GUICTRLLISTVIEW_GETITEMTEXT ( $CLV , $I ) , "vvNOT SEARCHvv" ) = 0 And $CONDENSEDBELT = 0 Then
			LOGINFO ( "Finded: vvNOT SEARCHvv!" )
			$FINDED = 0
			ExitLoop
		EndIf
		LOGINFO ( "_GUICtrlListView_GetItemText($cLV, $i):" & _GUICTRLLISTVIEW_GETITEMTEXT ( $CLV , $I ) )
		$FINDED = _ARRAYSEARCH ( $ASTEROIDS_LIST , _GUICTRLLISTVIEW_GETITEMTEXT ( $CLV , $I ) )
		If @error Then LOGINFO ( _GUICTRLLISTVIEW_GETITEMTEXT ( $CLV , $I ) & " not finded" )
		If $FINDED > 0 Then
			LOGINFO ( "$Finded:" & $FINDED )
			ExitLoop
		EndIf
	Next
	ConsoleWrite ( @CRLF & _ARRAYTOSTRING ( $ASTEROIDS_LIST , " :: " ) & @CRLF )
	LOGINFO ( "$Asteroids_list[$Finded][0]" & $ASTEROIDS_LIST [ $FINDED ] [ 0 ] )
	LOGINFO ( "$Asteroids_list[$Finded][1]" & $ASTEROIDS_LIST [ $FINDED ] [ 1 ] )
	LOGINFO ( "$Asteroids_list[$Finded][2]" & $ASTEROIDS_LIST [ $FINDED ] [ 2 ] )
	If ( $FINDED > 0 ) Then
		SENDTAP ( $ASTEROIDS_LIST [ $FINDED ] [ 0 ] , $ASTEROIDS_LIST [ $FINDED ] [ 1 ] + 4294967290 , 5 )
		If ( WAITFINDPIC ( @ScriptDir & "\img\lock_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 ) = 1 ) Then
			SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
			ConsoleWrite ( @CRLF & "Lock click FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
			_SLEEP ( 1000 )
			SENDTAP ( 958 , 52 , 14 )
			Local $XX , $YY
			If ( WAITFINDPIC ( @ScriptDir & "\img\approach_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 , 742 , 86 , 742 + 111 , 86 + 350 ) = 1 ) Then
				If ( WAITFINDPIC ( @ScriptDir & "\img\focusfire_ico.bmp" , $XX , $YY , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 742 , 86 , 742 + 111 , 86 + 350 , 1 ) = 1 ) Then
					ConsoleWrite ( @CRLF & "!Clicked on ship!" & @CRLF )
					If ( WAITFINDPIC ( @ScriptDir & "\img\unlock_ico.bmp.bmp" , $XX , $YY , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 742 , 86 , 742 + 111 , 86 + 350 , 1 ) ) Then SENDTAP ( $XX + 80 , $YY , 14 )
					$RETURN = 0
				Else
					_SLEEP ( 1000 )
					SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
					ConsoleWrite ( @CRLF & "Approaching" & @CRLF )
					$RETURN = 1
				EndIf
			EndIf
		Else
			ConsoleWrite ( @CRLF & "ERROR - > Lock not find" & @CRLF )
		EndIf
	Else
		ConsoleWrite ( @CRLF & "ERROR - > not asteroid 1" & @CRLF )
	EndIf
	LOGINFO ( "Stop SelectAsteroid" )
	Return $RETURN
EndFunc
Func WARPTOASTEROIDCLUSTER ( )
	$CURRFUNCNAME = "WarpToAsteroidCluster"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Start WarpToAsteroidCluster" )
	GUICtrlSetData ( $LABEL_DOING , "Warp to asteroid" )
	If ( WAITFINDPIC ( @ScriptDir & "\img\asteroid_cluster.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 ) = 1 Or WAITFINDPIC ( @ScriptDir & "\img\asteroid_group.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 ) = 1 Or WAITFINDPIC ( @ScriptDir & "\img\asteroid_belt.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 ) = 1 ) Then
		SENDTAP ( $X_FINDED , $Y_FINDED + 4294967286 , 8 )
		ConsoleWrite ( @CRLF & "Asteroid click FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
		If ( WAITFINDPIC ( @ScriptDir & "\img\warp_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 5 ) = 1 ) Then
			SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
			ConsoleWrite ( @CRLF & "Warp click FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
		Else
			ConsoleWrite ( @CRLF & "ERROR - > Warp not find" & @CRLF )
		EndIf
	Else
		ConsoleWrite ( @CRLF & "ERROR - > not asteroid" & @CRLF )
	EndIf
	LOGINFO ( "Stop WarpToAsteroidCluster" )
EndFunc
Func WARPTOASTEROIDCLUSTERV2 ( $REWARP = 0 )
	$CURRFUNCNAME = "WarpToAsteroidClusterV2"
	Local $X1 , $Y1
	Local $I = 0 , $RND_NUMBER
	Local $STOPCOUNTER = 0
	Local $CONDENSEDBELT = 0
	Local $BELTNUMBER = 0
	Local $ASTERFINDTRYCOUNT = 0
	Local $ASTERFINDTRYMAX = 7
	LOGINFO ( "Start WarpToAsteroidCluster V2" )
	GUICtrlSetData ( $LABEL_DOING , "Warp to asteroid V2" )
	_ARRAYCLEAR ( $ASTEROIDS_BELT_LIST )
	Sleep ( 1000 )
	If $REWARP = 0 Then
		$FINDED = WAITFINDPIC ( @ScriptDir & "\img\asteroid_au.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 15 , 1059 , $Y1 , 1273 , 714 )
		If Not $FINDED Then
			LOGINFO ( @CRLF & "ERROR - > Ateroid belts not find" )
			Return 0
		EndIf
		ADBSCREEN ( 1 )
		If OPENCVFINDPIC ( @ScriptDir & "\img\condensed_belt.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1059 , 58 , 1273 , 714 ) Then
			$I += 1
			$ASTEROIDS_BELT_LIST [ $I ] [ 0 ] = $X1
			$ASTEROIDS_BELT_LIST [ $I ] [ 1 ] = $Y1
			$CONDENSEDBELT = 1
		EndIf
	Else
		Do
			LOGINFO ( "Try to find aster [" & $ASTERFINDTRYCOUNT & "/" & $ASTERFINDTRYMAX & "]" )
			If $ADB_CLICK Then SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 103 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
			If $ADB_CLICK Then SENDADB ( " shell input swipe " & 1155 + Random ( + 4294967271 , 25 , 1 ) & " " & 614 + Random ( + 4294967286 , 15 , 1 ) & " " & 1055 + Random ( + 4294967271 , 25 , 1 ) & " " & 93 + Random ( + 4294967281 , 15 , 1 ) & " " & Random ( 100 , 190 , 1 ) )
			Sleep ( 500 )
			$FINDED = WAITFINDPIC ( @ScriptDir & "\img\asteroid_au.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 1059 , $Y1 , 1273 , 714 )
			If Not $FINDED Then
				LOGINFO ( @CRLF & "ERROR - > Ateroid belts not find" )
			EndIf
			$ASTERFINDTRYCOUNT = $ASTERFINDTRYCOUNT + 1
		Until $ASTERFINDTRYCOUNT > $ASTERFINDTRYMAX Or $FINDED = 1
	EndIf
	$Y1 = 58
	Do
		If $CONDENSEDBELT Then ExitLoop
		If $Y1 > 665 Then ExitLoop
		If $I > 12 Then ExitLoop
		$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\asteroid_au.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1059 , $Y1 , 1273 , 714 )
		If $FINDED Then
			$I += 1
			$ASTEROIDS_BELT_LIST [ $I ] [ 0 ] = $X1
			$ASTEROIDS_BELT_LIST [ $I ] [ 1 ] = $Y1
		EndIf
	Until $FINDED = 0
	If $I = 0 Then
		LOGINFO ( "Cannot find asteroids" )
		Return 0
	Else
		LOGINFO ( "Finded asteroids:" & $I )
	EndIf
	LOGINFO ( "$LastAsteroidClusterNumber=" & $LASTASTEROIDCLUSTERNUMBER )
	If $I > 5 Then $I = 5
	If 1 Then
		Do
			$STOPCOUNTER = $STOPCOUNTER + 1
			$RND_NUMBER = Random ( 1 , $I , 1 )
			If $STOPCOUNTER > 100 Then ExitLoop
		Until $RND_NUMBER <> $LASTASTEROIDCLUSTERNUMBER
		$LASTASTEROIDCLUSTERNUMBER = $RND_NUMBER
	Else
		$RND_NUMBER = Random ( 1 , $I , 1 )
	EndIf
	LOGINFO ( "new $LastAsteroidClusterNumber=" & $LASTASTEROIDCLUSTERNUMBER )
	If ( $PREFERBELTNUMBER ) > 0 And $CONDENSEDBELT = 0 Then
		LOGINFO ( "Belt selection override. Prefered belt=" & $PREFERBELTNUMBER )
		If $PREFERBELTNUMBER > $I Then
			$BELTNUMBER = $I
			LOGINFO ( "Not enough belts. selected belt=" & $PREFERBELTNUMBER )
		Else
			$BELTNUMBER = $PREFERBELTNUMBER
		EndIf
		SENDTAP ( $ASTEROIDS_BELT_LIST [ $BELTNUMBER ] [ 0 ] , $ASTEROIDS_BELT_LIST [ $BELTNUMBER ] [ 1 ] + 4294967286 , 8 )
	Else
		SENDTAP ( $ASTEROIDS_BELT_LIST [ $RND_NUMBER ] [ 0 ] , $ASTEROIDS_BELT_LIST [ $RND_NUMBER ] [ 1 ] + 4294967286 , 8 )
	EndIf
	If ( WAITFINDPIC ( @ScriptDir & "\img\warp_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 ) = 1 ) Then
		SENDTAP ( $X_FINDED + 80 , $Y_FINDED , 14 )
		LOGINFO ( "Warp click FIND X=" & $X_FINDED & "Y=" & $Y_FINDED )
		If $CONDENSEDBELT Then
			LOGINFO ( "Finded CONDENSED asteroids" )
			If $USEMININGIMPLANTCONDENSED = 1 Then
				USEMININGIMPLANT ( )
				TELEGRAMBOTSEND ( "Finded CONDENSED asteroids. Activating mining implant" )
			Else
				TELEGRAMBOTSEND ( "Finded CONDENSED asteroids" )
			EndIf
		EndIf
		Return 1
	Else
		LOGINFO ( @CRLF & "ERROR - > Warp not find" )
		Return 0
	EndIf
EndFunc
Func CHECKNAV ( )
	$CURRFUNCNAME = "CheckNav"
	If ( WAITFINDPIC ( @ScriptDir & "\img\eye.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 ) = 1 ) Then
		ConsoleWrite ( @CRLF & "FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
		If ( $X_FINDED < 930 ) Then
			MsgBox ( 262144 , "ERROR" , "Uncheck 'Display filter tag' in filter setting of overlay" )
			TERMINATE ( )
		EndIf
		If ( $X_FINDED < 1100 ) Then
			ConsoleWrite ( "Nav Opened" & @CRLF )
		Else
			SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
			Sleep ( 1000 )
			WAITFINDPIC ( @ScriptDir & "\img\eye.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 )
			If ( $X_FINDED < 930 ) Then
				MsgBox ( 262144 , "ERROR" , "Uncheck 'Display filter tag' in filter setting of overlay" )
				TERMINATE ( )
			EndIf
		EndIf
	EndIf
EndFunc
Func OPENASTEROIDSLIST ( )
	$CURRFUNCNAME = "OpenAsteroidsList"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Start OpenAsteroidsList" )
	GUICtrlSetData ( $LABEL_DOING , "Opening asteroid list" )
	If ( WAITFINDPIC ( @ScriptDir & "\img\eye.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 ) = 1 ) Then
		ConsoleWrite ( @CRLF & "FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
		If ( $X_FINDED < 930 ) Then
			MsgBox ( 262144 , "ERROR" , "Uncheck 'Display filter tag' in filter setting of overlay" )
			TERMINATE ( )
		EndIf
		If ( $X_FINDED < 1100 ) Then
			ConsoleWrite ( "Nav Opened" & @CRLF )
		Else
			SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
			Sleep ( 1000 )
			WAITFINDPIC ( @ScriptDir & "\img\eye.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 )
			If ( $X_FINDED < 930 ) Then
				MsgBox ( 262144 , "ERROR" , "Uncheck 'Display filter tag' in filter setting of overlay" )
				TERMINATE ( )
			EndIf
		EndIf
		If ( Not WAITFINDPIC ( @ScriptDir & "\img\ship_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1000 , 1 , 1100 , 60 ) = 1 And WAITFINDPIC ( @ScriptDir & "\img\label_mining.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 ) = 1 ) Then
			If ( $Y_FINDED < 100 ) Then
				ConsoleWrite ( "Nav Opened, Mining Active" & @CRLF )
			Else
				SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
				ConsoleWrite ( "Mining activated" & @CRLF )
			EndIf
			ConsoleWrite ( @CRLF & "FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
		Else
			ConsoleWrite ( @CRLF & "Not mining" & @CRLF )
			SENDTAP ( 1107 , 27 , 8 )
			If ( WAITFINDPIC ( @ScriptDir & "\img\mining_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 ) = 1 ) Then
				If ( $Y_FINDED < 100 ) Then
					ConsoleWrite ( "Nav Opened, Mining Active" & @CRLF )
				Else
					SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
					ConsoleWrite ( "Mining activated" & @CRLF )
				EndIf
				ConsoleWrite ( @CRLF & "FIND X=" & $X_FINDED & "Y=" & $Y_FINDED & @CRLF )
			Else
				ConsoleWrite ( @CRLF & "ERROR - > Not mining" & @CRLF )
			EndIf
		EndIf
	Else
		ConsoleWrite ( @CRLF & "NOTFIND" & @CRLF )
	EndIf
	Return 1
EndFunc
Func SENDADB ( $CMD , $SILENT = 0 , $RAW = 0 )
	$CURRFUNCNAME = "SendAdb"
	Local $PROCESS_KILLED
	Local $TRANSPORTSTRING = ""
	If Not $ADBTRANSPORTSERIAL = 0 Then $TRANSPORTSTRING = " -s " & $ADBTRANSPORTSERIAL
	If Not $RAW Then $CMD = StringReplace ( $CMD , "&& " , "&& " & $ADBFOLDER & $TRANSPORTSTRING )
	If Not $RAW Then $CMD = StringReplace ( $CMD , "+++ " , "&& " )
	If $SILENT = 0 Then
		Local $TMPTIMER = TimerInit ( )
		LOGINFO ( "CMD::" & $ADBFOLDER & $TRANSPORTSTRING & $CMD )
		If $CONSOLETYPE = 0 Then $RETURN = LAUNCHCONSOLE ( "cmd /c " & $ADBFOLDER & $TRANSPORTSTRING & $CMD , "" , $PROCESS_KILLED , 25000 )
		If $CONSOLETYPE = 1 Then $RETURN = LAUNCHCONSOLE2 ( $ADBFOLDER & $TRANSPORTSTRING & $CMD )
		Local $TMPDIFF = TimerDiff ( $TMPTIMER )
		LOGINFO ( "Time for ADB: " & $TMPDIFF )
	Else
		If $CONSOLETYPE = 0 Then $RETURN = LAUNCHCONSOLE ( "cmd /c " & $ADBFOLDER & $TRANSPORTSTRING & $CMD , "" , $PROCESS_KILLED , 25000 )
		If $CONSOLETYPE = 1 Then $RETURN = LAUNCHCONSOLE2 ( $ADBFOLDER & $TRANSPORTSTRING & $CMD )
	EndIf
	Return $RETURN
EndFunc
Func ADBSCREENTRY ( $SILENT = 0 , $SAVETO = "screenshot\screenshot.bmp" )
	$CURRFUNCNAME = "AdbScreenTry"
	If Not $SILENT Then FILECONSOLEWRITE ( "AdbScreenTry start. " )
	Local $TRY = 0 , $MAXTRY = 3 , $DONE = 0
	Local $TMPTIMER = TimerInit ( )
	Local $RETRY = 0
	Do
		$T1 = SENDADB ( " shell if ! timeout 9s /data/local/tmp/ascreencap -f /data/local/tmp/screenshot.bmp; then echo fail; fi &&  pull /data/local/tmp/screenshot.bmp " & $SAVETO & " +++ echo screendone" , $SILENT )
		If FileGetSize ( @ScriptDir & "\" & $SAVETO ) = 2764854 Or FileGetSize ( @ScriptDir & "\" & $SAVETO ) <> 2764870 Or $SCREENSHOTSIZECHECKDISABLE = 1 Then
			$DONE = 1
		EndIf
		$TRY = $TRY + 1
	Until $DONE Or $TRY > $MAXTRY
	Local $TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) , 0 )
	If Not $SILENT Then LOGINFO ( "Time for AdbScreenTry: " & $TMPDIFF & " ms. TryCount= " & $TRY )
	If $TMPDIFF > $SSTATMAX Then $SSTATMAX = $TMPDIFF
	If $SSTATMIN > $TMPDIFF Then $SSTATMIN = $TMPDIFF
	If $TRY > $SSTATMAXTRYCOUNT Then $SSTATMAXTRYCOUNT = $TRY
	$SSTATTOTALTIME = $SSTATTOTALTIME + $TMPDIFF
	$SSTATCOUNT = $SSTATCOUNT + 1
EndFunc
Func ADBSCREEN ( $SILENT = 0 , $SAVETO = "screenshot\screenshot.bmp" )
	$CURRFUNCNAME = "AdbScreen"
	LOGINFO ( "Making screenshot" )
	If $CURRENTSCREENSHOTBITMAP Then
		_GDIPLUS_BITMAPDISPOSE ( $CURRENTSCREENSHOTBITMAP )
		_WINAPI_DELETEOBJECT ( $CURRENTSCREENSHOTBITMAP )
	EndIf
	If $SCREENSHOTINGTYPE = 0 Then
		ADBSCREENTRY ( $SILENT , $SAVETO )
	ElseIf $SCREENSHOTINGTYPE = 2 Then
		SCREENSHOTCOPY ( $SAVETO )
	ElseIf $SCREENSHOTINGTYPE = 3 Then
		SCREENSHOTCOPYSOCK ( $SAVETO )
	Else
		SCREENSHOTSOCK ( $SAVETO , 0 )
	EndIf
	If $ADBERROR = 1 Then
		SETDOINGSTATUS ( "!Fatal error! ADB Timeout" , 1 , 1 )
		SENDTAP ( 3 , 169 , 1 )
		Sleep ( 5000 )
		KILLEMULATOR ( )
		TERMINATE ( )
	EndIf
	If FileGetSize ( @ScriptDir & "\" & $SAVETO ) <> 2764854 And FileGetSize ( @ScriptDir & "\" & $SAVETO ) <> 2764870 And $SCREENSHOTSIZECHECKDISABLE = 0 Then
		SETDOINGSTATUS ( "!Fatal error! Size of screenshot is wrong!" , 1 , 1 )
		SENDTAP ( 3 , 169 , 1 )
		Sleep ( 5000 )
		KILLEMULATOR ( )
		TERMINATE ( )
	Else
		If $LESSSCREENSHOTSAVE = 1 Then
			$CURRENTSCREENSHOTBITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\" & $SAVETO )
			If @error Then LOGFATAL ( "Error:" & @error & @CRLF )
			If 0 Then ConsoleWrite ( "W1:" & _GDIPLUS_IMAGEGETWIDTH ( $CURRENTSCREENSHOTBITMAP ) & " H1:" & _GDIPLUS_IMAGEGETHEIGHT ( $CURRENTSCREENSHOTBITMAP ) & @CRLF )
		EndIf
	EndIf
	If TimerDiff ( $ADBCHECKTIMER ) > 5 * 1000 * 60 Then
		LOGINFO ( "Check emulator presence" )
		$ADBCHECKTIMER = TimerInit ( )
		Local $ANSW = SENDADB ( " shell ""ps | grep netease | tr -s " & "' '" & " | cut -d" & " ' '" & " -f2""" )
		If StringLen ( $ANSW ) = 0 Or StringInStr ( $ANSW , "no device" ) Or StringInStr ( $ANSW , "not found" ) Then
			Local $ANSW = SENDADB ( " shell ""ps | grep netease | tr -s " & "' '" & " | cut -d" & " ' '" & " -f2""" )
			If StringLen ( $ANSW ) = 0 Or StringInStr ( $ANSW , "no device" ) Or StringInStr ( $ANSW , "not found" ) Then
				SETDOINGSTATUS ( "!Fatal error! EVE Echo not find!!" , 1 , 1 )
				$BOT_ENABLED = 0
				KILLEMULATOR ( )
				TERMINATE ( )
			EndIf
		Else
			$NETEASEPID = $ANSW
			LOGINFO ( "EVE Echoes PID=[" & $NETEASEPID & "]" )
		EndIf
	EndIf
EndFunc
Func SENDTAP ( $X , $Y , $DEVIATION = 0 , $RETRY = 0 )
	$CURRFUNCNAME = "SendTap"
	Local $MAXRETRY = 5
	Local $LOCALERROR
	If ( $DEVIATION > 0 ) Then
		$X = $X + Random ( - $DEVIATION , $DEVIATION , 1 )
		$Y = $Y + Random ( - $DEVIATION , $DEVIATION , 1 )
	EndIf
	Local $TMPTIMER = TimerInit ( )
	If $CLICKTYPE = 0 Then
		SENDADB ( " shell input tap " & $X & " " & $Y & " +++ echo tapdone" )
	ElseIf $CLICKTYPE = 1 Then
		Local $ISOCKET = _ANDROID_CONNECT ( )
		If Not $ADBTRANSPORTSERIAL = 0 Then
			_ANDROID_SEND ( $ISOCKET , "host:transport:" & $ADBTRANSPORTSERIAL )
		Else
			_ANDROID_SEND ( $ISOCKET , "host:transport-any" )
		EndIf
		Local $M = _ANDROID_SEND ( $ISOCKET , "shell:input tap " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) & " && echo done" )
		Local $SBUFFER = "" , $SRECEIVED = ""
		Do
			$SRECEIVED &= $SBUFFER
			$SBUFFER = TCPRecv ( $ISOCKET , 6000 )
			$LOCALERROR = @error
		Until StringInStr ( $SRECEIVED , "done" ) Or $LOCALERROR
		TCPCloseSocket ( $ISOCKET )
		If @error Then
			If $RETRY = 0 Then
				$RETRY = 1
			Else
				$RETRY = $RETRY + 1
			EndIf
		EndIf
	ElseIf $CLICKTYPE = 2 Then
		LOGINFO ( "ExpSendTap" )
		Switch $EMULATORTYPE
		Case 1
			SENDADB ( " shell sh /data/local/tmp/clickbl" & $SDKVER & ".sh " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) )
		Case 2
			SENDADB ( " shell sh /data/local/tmp/clickld.sh " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) )
	Case Else
			LOGINFO ( "!ERRROR!" )
		EndSwitch
	ElseIf $CLICKTYPE = 3 Then
		LOGINFO ( "SendTapSocksAndFile" )
		Local $ISOCKET = _ANDROID_CONNECT ( )
		If Not $ADBTRANSPORTSERIAL = 0 Then
			_ANDROID_SEND ( $ISOCKET , "host:transport:" & $ADBTRANSPORTSERIAL )
		Else
			_ANDROID_SEND ( $ISOCKET , "host:transport-any" )
		EndIf
		Switch $EMULATORTYPE
		Case 1
			LOGDEBUG ( "shell:sh /data/local/tmp/clickbl" & $SDKVER & ".sh " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) )
			Local $M = _ANDROID_SEND ( $ISOCKET , "shell:sh /data/local/tmp/clickbl64.sh " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) )
		Case 2
			LOGDEBUG ( "shell:sh /data/local/tmp/clickld.sh " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) )
			Local $M = _ANDROID_SEND ( $ISOCKET , "shell:sh /data/local/tmp/clickld.sh " & Round ( $X , 0 ) & " " & Round ( $Y , 0 ) )
	Case Else
			LOGINFO ( "!ERRROR!" )
		EndSwitch
		Local $SBUFFER = "" , $SRECEIVED = ""
		Do
			$SRECEIVED &= $SBUFFER
			$SBUFFER = TCPRecv ( $ISOCKET , 6000 )
			$LOCALERROR = @error
		Until StringInStr ( $SRECEIVED , "done" ) Or $LOCALERROR
	ElseIf $CLICKTYPE = 4 Then
		LOGINFO ( "SendTCPTap" )
		SENDTCPTAP ( $X , $Y )
	EndIf
	If $LOCALERROR Then
		If $RETRY < $MAXRETRY Then
			$RETRY = $RETRY + 1
			SENDTAP ( $X , $Y , $DEVIATION , $RETRY )
		EndIf
	EndIf
	Local $TMPDIFF = TimerDiff ( $TMPTIMER )
	LOGINFO ( "Time for TAP: " & $TMPDIFF )
EndFunc
Func SENDDOUBLETAP ( $X , $Y , $DEVIATION = 0 )
	$CURRFUNCNAME = "SendDoubleTap"
	Local $X1 , $Y1 , $X2 , $Y2
	If ( $DEVIATION > 0 ) Then
		$X1 = $X + Random ( - $DEVIATION , $DEVIATION , 1 )
		$Y1 = $Y + Random ( - $DEVIATION , $DEVIATION , 1 )
		$X2 = $X + Random ( - $DEVIATION , $DEVIATION , 1 )
		$Y2 = $Y + Random ( - $DEVIATION , $DEVIATION , 1 )
	EndIf
	If $ADB_CLICK Then
		SENDADB ( " shell ""input tap " & $X1 & " " & $Y1 & "&input tap " & $X2 & " " & $Y2 & """" )
	Else
	EndIf
EndFunc
Func WAITFINDPICD ( $MATCH_PIC , ByRef $X1 , ByRef $Y1 , $THRESHOLD , $LOAD_PIC , $TIME , $XS = 0 , $YS = 0 , $XD = 0 , $YD = 0 , $DONTSREENSHOT = 0 )
	Return WAITFINDPIC ( $MATCH_PIC , $X1 , $Y1 , $THRESHOLD , $LOAD_PIC , $TIME , $XS , $YS , $XS + $XD , $YS + $YD , $DONTSREENSHOT )
EndFunc
Func WAITFINDPIC ( $MATCH_PIC , ByRef $X1 , ByRef $Y1 , $THRESHOLD , $LOAD_PIC , $TIME , $XS = 0 , $YS = 0 , $XE = 0 , $YE = 0 , $DONTSREENSHOT = 0 )
	$CURRFUNCNAME = "WaitFindPic"
	Local $CURRTIME = TimerInit ( )
	Local $FORMATTED_TIME
	Local $FINDED = 0
	Local $COORDSLIST
	If $TIME > 0 Then
		LOGINFO ( ">Wait for img " & $TIME & " seconds:" & $MATCH_PIC )
	Else
		LOGINFO ( ">Search for img " & $MATCH_PIC )
	EndIf
	Do
		If $DONTSREENSHOT = 0 Then
			ADBSCREEN ( 1 )
		Else
			$TIME = 0
		EndIf
		$FINDED = OPENCVFINDPIC ( $MATCH_PIC , $X1 , $Y1 , $THRESHOLD , $LOAD_PIC , $XS , $YS , $XE , $YE )
	Until Not ( ( $FINDED = 0 ) And ( TimerDiff ( $CURRTIME ) < $TIME * 1000 ) )
	If $FINDED Then
		$FORMATTED_TIME = StringFormat ( "%.3f" , TimerDiff ( $CURRTIME ) )
		LOGINFO ( "+Finded! Waittime " & $FORMATTED_TIME & " ms" )
		Return 1
	Else
		$FORMATTED_TIME = StringFormat ( "%.3f" , TimerDiff ( $CURRTIME ) )
		LOGINFO ( "-NOT Finded! Waittime " & $FORMATTED_TIME & " ms" )
		Return 0
	EndIf
EndFunc
Func SHIPMOVING ( $SILENT = 0 )
	$CURRFUNCNAME = "ShipMoving"
	Local $COLOR = CHECKCOLOR ( 616 , 664 )
	ConsoleWrite ( "color[0]=" & $COLOR [ 0 ] & " color[1]=" & $COLOR [ 1 ] & " color[2]=" & $COLOR [ 2 ] & @CRLF )
	If $COLOR [ 2 ] < 80 Then
		If Not $SILENT Then LOGINFO ( "Ship is NOT moving" )
		Return False
	Else
		If Not $SILENT Then LOGINFO ( "Ship is moving" )
		Return True
	EndIf
EndFunc
Func CHECKCARGOVALUE ( )
	$CURRFUNCNAME = "CheckCargoValue"
	$COUNT = 0
	$TOTALCOUNT = 0
	Global $DEGTORAD = 4 * ATan ( 1 ) / 180
	Local $IXC = 29 , $IYC = 120 , $IMOV = 270 , $IX = 140 , $IY = 340 , $IR = 22.5 , $ISTEP = 3.6
	ADBSCREEN ( 1 )
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	For $I = 0 To 360 Step 3.6
		$IMOV += $ISTEP
		$IX = Round ( $IXC - $IR * Cos ( $IMOV * $DEGTORAD ) + 4294967294 )
		$IY = Round ( $IYC - $IR * Sin ( $IMOV * $DEGTORAD ) + 4294967294 )
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $IX , $IY )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		$COUNT += 1
		If $ACOLOR [ 0 ] > 55 And $ACOLOR [ 1 ] > 80 And $ACOLOR [ 2 ] > 80 Then
			$TOTALCOUNT += 1
		Else
		EndIf
	Next
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_WINAPI_DELETEOBJECT ( $BITMAP )
	LOGINFO ( "Cargo Load:" & $TOTALCOUNT )
	GUICtrlSetData ( $LABEL_CARGO , "Cargo: " & $TOTALCOUNT & "%" )
	Return $TOTALCOUNT
EndFunc
Func AFTERBURNERFIND ( )
	$CURRFUNCNAME = "AfterburnerFind"
	Local $X1 , $Y1
	ADBSCREEN ( 1 )
	LOGINFO ( "Check afterburner" )
	If ( WAITFINDPIC ( @ScriptDir & "\img\afterburner.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 739 , 536 , 739 + 533 , 536 + 172 , 1 ) = 1 ) Or ( WAITFINDPIC ( @ScriptDir & "\img\afterburner1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 739 , 536 , 739 + 533 , 536 + 172 , 1 ) = 1 ) Or ( WAITFINDPIC ( @ScriptDir & "\img\mvd.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 739 , 536 , 739 + 533 , 536 + 172 , 1 ) = 1 ) Then
		$AFTERBURNER [ 0 ] = $X1
		$AFTERBURNER [ 1 ] = $Y1
		$AFTERBURNER [ 2 ] = 0
		LOGINFO ( "afterburner found" )
	Else
		LOGINFO ( "afterburner NOT found" )
	EndIf
EndFunc
Func AFTERBURNERSTART ( )
	$CURRFUNCNAME = "AfterburnerSTART"
	Local $X1 , $Y1
	FILECONSOLEWRITE ( "AfterburnerSTART" )
	If ( $AFTERBURNER [ 2 ] = 0 ) Then
		$AFTERBURNER [ 0 ] = $X1
		$AFTERBURNER [ 1 ] = $Y1
		$AFTERBURNER [ 2 ] = 0
		LOGINFO ( "afterburner found" )
	Else
		LOGINFO ( "afterburner NOT found" )
	EndIf
	LOGINFO ( "AfterburnerSTART END" )
EndFunc
Func ADB_ASTERWIPECHECK ( )
	$CURRFUNCNAME = "ADB_AsterWipeCheck"
	LOGINFO ( "ADB_AsterWipeCheck START" )
	Local $ANSW
	Local $RET
	$ANSW = SENDADB ( " shell ""pid=$(ps | grep com.netease.eve.en | tr -s ' ' | cut -d ' ' -f2);logcat --pid=$pid -b main -t " & GETUNIXTIME ( ) + 4294967284 & ".000""" )
	If StringInStr ( $ANSW , "[on_drone_target_change]" ) Then
		LOGINFO ( "Aster is wiped" )
		$RET = 1
	Else
		$RET = 0
	EndIf
	LOGINFO ( "ADB_AsterWipeCheck END" )
	Return $RET
EndFunc
Func ADB_ARRIVALCHECK ( )
	$CURRFUNCNAME = "ADB_ArrivalCheck"
	LOGINFO ( "ADB_ArrivalCheck START" )
	Local $ANSW
	Local $RET
	$ANSW = SENDADB ( " shell ""pid=$(ps | grep com.netease.eve.en | tr -s ' ' | cut -d ' ' -f2);logcat --pid=$pid -b main -t " & GETUNIXTIME ( ) + 4294967286 & ".000""" )
	If StringInStr ( $ANSW , "[on_autopilot2_finished]" ) Then
		LOGINFO ( "has arrived" )
		$RET = 1
	Else
		$RET = 0
	EndIf
	LOGINFO ( "ADB_ArrivalCheck END" )
	Return $RET
EndFunc
Func CHECKMINERS ( $NUM = 0 )
	$CURRFUNCNAME = "CheckMiners"
	LOGINFO ( "CheckMiners start" )
	Local $X1 , $Y1
	Local $DEBUGCHECKPOINT = 0
	GUICtrlSetData ( $LABEL_DOING , "Checking miners" )
	If $MINERS_STATUS [ 0 ] = + 4294967295 Then GETMINERSCOORD ( )
	FILECONSOLEWRITE ( "Miner status: " )
	ADBSCREEN ( 1 )
	If $MINERS_SIZE = 3 Then
		LOGINFO ( "Not need to check drones status. Yet." )
		Return 1
	EndIf
	If $MINERS_STATUS [ 0 ] > 0 Then
		If $MINERS_SIZE = 0 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 0 ] [ 0 ] , 626 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINERS_SIZE = 1 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 0 ] [ 0 ] , 633 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINERS_SIZE = 2 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 0 ] [ 0 ] + 1 , 632 + 1 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINER2COLOR [ 0 ] > 205 And $MINER2COLOR [ 1 ] > 240 And $MINER2COLOR [ 2 ] > 230 Then
			FILECONSOLEWRITE ( "*#1 active " )
			$MINERS_STATUS [ 0 ] = 1
		Else
			FILECONSOLEWRITE ( "*#1 not active " )
			If $MINERS_STATUS [ 0 ] < 2 Then $MINERS_STATUS [ 0 ] = 2
		EndIf
	EndIf
	If $MINERS_STATUS [ 1 ] > 0 Then
		If $MINERS_SIZE = 0 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 1 ] [ 0 ] , 626 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINERS_SIZE = 1 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 1 ] [ 0 ] , 633 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINERS_SIZE = 2 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 1 ] [ 0 ] + 1 , 632 + $DEBUGCHECKPOINT , 0 , 0 , 0 )
		If $MINER2COLOR [ 0 ] > 205 And $MINER2COLOR [ 1 ] > 240 And $MINER2COLOR [ 2 ] > 230 Then
			FILECONSOLEWRITE ( "*#2 active " )
			$MINERS_STATUS [ 1 ] = 1
		Else
			FILECONSOLEWRITE ( "*#2 not active " )
			If $MINERS_STATUS [ 1 ] < 2 Then $MINERS_STATUS [ 1 ] = 2
		EndIf
	EndIf
	If $MINERS_STATUS [ 2 ] > 0 Then
		If $MINERS_SIZE = 0 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 2 ] [ 0 ] , 626 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINERS_SIZE = 1 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 2 ] [ 0 ] , 633 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINERS_SIZE = 2 Then $MINER2COLOR = CHECKCOLOR ( $MINERS_COORD [ 2 ] [ 0 ] + 1 , 632 + 1 , 0 , $DEBUGCHECKPOINT , 0 )
		If $MINER2COLOR [ 0 ] > 205 And $MINER2COLOR [ 1 ] > 240 And $MINER2COLOR [ 2 ] > 230 Then
			FILECONSOLEWRITE ( "*#3 active " )
			$MINERS_STATUS [ 2 ] = 1
		Else
			FILECONSOLEWRITE ( "*#3 not active " )
			If $MINERS_STATUS [ 2 ] < 2 Then $MINERS_STATUS [ 2 ] = 2
		EndIf
	EndIf
	PRINTLIST ( $MINERS_STATUS )
	LOGINFO ( "*" )
	CHECKOVERALLTIME ( )
	LOGINFO ( "CheckMiners stop" )
	Return $MINERS_STATUS [ $NUM ]
EndFunc
Func TERMINATE ( )
	$CURRFUNCNAME = "Terminate"
	Local $I
	Local Const $IITEMCOUNT = _GUICTRLLISTVIEW_GETITEMCOUNT ( $CLV ) + 4294967295
	LOGINFO ( "!Terminating" )
	If $BOT_ENABLED = 1 Then
		$BOT_ENABLED = 0
	Else
		For $I = 0 To $IITEMCOUNT
			IniWrite ( $INIFILE , "MineralPriority" , $I , _GUICTRLLISTVIEW_GETITEMTEXT ( $CLV , $I , 0 ) )
		Next
		LOGINFO ( "Exit. Asteroid wiped:" & $ASTEROID_WIPED & ". Unload count:" & $UNLOADCOUNT & ". Asteroid per minute : " & $ASTEROIDRATE )
		LOGINFO ( "Total treasure:" & $TOTALTREASURE & " ISK" )
		LOGINFO ( "More statistics:" )
		FILECONSOLEWRITE ( $STATTEXT )
		Local $ISK_TOTAL = IniRead ( $INIFILE , "Statistic" , "ISK Earned" , "0" )
		$ISK_TOTAL = $ISK_TOTAL + $TOTALTREASURE
		IniWrite ( $INIFILE , "Statistic" , "ISK Earned" , $ISK_TOTAL )
		Local $WIPED_TOTAL = IniRead ( $INIFILE , "Statistic" , "Asteroids wiped" , "0" )
		$WIPED_TOTAL = $WIPED_TOTAL + $ASTEROID_WIPED
		IniWrite ( $INIFILE , "Statistic" , "Asteroids wiped" , $WIPED_TOTAL )
		LOGINFO ( "MaxLenFuncName=" & $MAXLENFUNCNAME )
		LOGINFO ( "ScreenshotStat. Screenshots: " & $SSTATCOUNT & ". MinTime=" & $SSTATMIN & "ms. MaxTime=" & $SSTATMAX & " ms. AvgTime=" & Round ( $SSTATTOTALTIME / $SSTATCOUNT , 0 ) & " ms. MaxTryCount=" & $SSTATMAXTRYCOUNT )
		SETUPINI ( "save" )
		TELEGRAMBOTSEND ( "Bot terminated" )
		LOGCLOSE ( )
		IRLIMAGEPRELOAD ( 1 )
		IR_SHUTDOWN ( )
		Exit
	EndIf
EndFunc
Func TREASUREREAD ( )
	$CURRFUNCNAME = "TreasureRead"
	Local $X_FINDED , $Y_FINDED
	$TREASURE = 0
	LOGINFO ( "Start TreasureRead." )
	If ( WAITFINDPIC ( @ScriptDir & "\img\cargo_isk.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 ) ) = 1 Then
		ADBSCREEN ( 1 )
		$X_FINDED = $X_FINDED + 4294966859
		CROPIMAGE ( 438 , 662 , $X_FINDED + 4294967281 , 23 , "\screenshot\treasure.png" )
		Local $PROCESS_KILLED
		$TREASURE = LAUNCHCONSOLE ( "cmd /c " & $TESSERACTFOLDER & "tesseract.exe screenshot\treasure.png - --psm 8 -l digitsall_layer quiet" , "" , $PROCESS_KILLED , 10000 )
		LOGINFO ( "$TreasureRAW1:" & $TREASURE )
		ConsoleWrite ( "lines count=" & UBound ( StringRegExp ( $TREASURE , "([^\v]+)" , 3 ) ) + 1 & @CRLF )
		If StringInStr ( $TREASURE , "-" ) Then
			LOGINFO ( "Reading error 1" )
			$TREASURE = 0
		EndIf
		If $TREASURE = 0 Then
			$TREASURE = LAUNCHCONSOLE ( "cmd /c " & $TESSERACTFOLDER & "tesseract.exe screenshot\treasure.png - -l digitsall_layer quiet" , "" , $PROCESS_KILLED , 10000 )
			If Not UBound ( StringRegExp ( $TREASURE , "([^\v]+)" , 3 ) ) + 1 = 2 Or StringInStr ( $TREASURE , "-" ) Then
				LOGINFO ( "$TreasureRAW2:" & $TREASURE )
				LOGINFO ( "Reading error 2" )
				$TREASURE = 0
				FileCopy ( @ScriptDir & "\screenshot\treasure.png" , @ScriptDir & "\failscreenshot\treasure-fail-" & @MDAY & "." & @HOUR & "." & @MIN & "." & @MSEC & ".png" )
			EndIf
		EndIf
		If $TREASURE > 0 Then
			$TREASURE = StringStripWS ( $TREASURE , $STR_STRIPALL )
			$TREASURE = StringRegExpReplace ( $TREASURE , "\r\n|\r|\n|\f" , " " )
			$TREASURE = StringReplace ( $TREASURE , "." , "" )
			$TREASURE = StringReplace ( $TREASURE , "," , "" )
		EndIf
		If $TREASURE > 15000000 Then $TREASURE = 0
		If $TREASURE = 0 Then FileCopy ( @ScriptDir & "\screenshot\treasure.png" , @ScriptDir & "\failscreenshot\treasure-fail-" & @MDAY & "." & @HOUR & "." & @MIN & "." & @MSEC & ".png" )
		If FileExists ( @ScriptDir & "\screenshot\treasure.png" ) Then FileDelete ( @ScriptDir & "\screenshot\treasure.png" )
		LOGINFO ( "$Treasure:" & $TREASURE )
		LOGINFO ( "Finish TreasureRead." )
		Return $TREASURE
	EndIf
EndFunc
Func IDREAD ( )
	$CURRFUNCNAME = "IdRead"
	Local $X_FINDED , $Y_FINDED , $GOFURTHER = 0
	LOGINFO ( "Start IdRead." )
	GUICtrlSetData ( $LABEL_DOING , "Getting ID" )
	SENDTAP ( 63 , 33 , 10 )
	If WAITFINDPIC ( @ScriptDir & "\img\settings.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 ) = 0 Then
		LOGINFO ( "1" )
		SENDTAP ( 63 , 33 , 10 )
		Sleep ( 1500 )
	Else
		LOGINFO ( "1+" )
		$GOFURTHER = 1
	EndIf
	If ( ( $GOFURTHER = 1 ) Or ( WAITFINDPIC ( @ScriptDir & "\img\settings.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 ) ) ) = 0 Then
		LOGINFO ( "2" )
		SENDTAP ( 63 , 33 , 5 )
		Sleep ( 1500 )
	Else
		$GOFURTHER = 1
		LOGINFO ( "2+" )
	EndIf
	If ( WAITFINDPIC ( @ScriptDir & "\img\settings.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 ) ) = 1 Then
		SENDTAP ( $X_FINDED , $Y_FINDED + 4294967274 , 5 )
		WAITFINDPIC ( @ScriptDir & "\img\settings_title.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 )
		If ( $ADB_SCREENSHOT = 1 ) Then
			ADBSCREEN ( 1 )
			CROPIMAGE ( 216 , 677 , 182 , 22 , "\screenshot\id.png" )
			CROPIMAGE ( 153 , 638 , 258 , 36 , "\screenshot\nick.png" )
		Else
		EndIf
		Local $PROCESS_KILLED
		$USERID = LAUNCHCONSOLE ( "cmd /c " & $TESSERACTFOLDER & "tesseract.exe screenshot\id.png - --psm 7 quiet -l eng" , "" , $PROCESS_KILLED , 10000 )
		$USERID = StringStripWS ( $USERID , $STR_STRIPALL )
		$USERID = StringRegExpReplace ( $USERID , "\r\n|\r|\n|\f" , " " )
		If Not IsNumber ( $USERID ) Then
			$USERID = LAUNCHCONSOLE ( "cmd /c " & $TESSERACTFOLDER & "tesseract.exe screenshot\id.png - -l digitsall_layer quiet" , "" , $PROCESS_KILLED , 10000 )
			$USERID = StringStripWS ( $USERID , $STR_STRIPALL )
			$USERID = StringRegExpReplace ( $USERID , "\r\n|\r|\n|\f" , " " )
		EndIf
		WAITFINDPIC ( @ScriptDir & "\img\close_inventory.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 8 )
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		LOGINFO ( "UserID:" & $USERID )
		If FileExists ( @ScriptDir & "\screenshot\id.png" ) Then FileDelete ( @ScriptDir & "\screenshot\id.png" )
		If FileExists ( @ScriptDir & "\screenshot\nick.png" ) Then FileDelete ( @ScriptDir & "\screenshot\nick.png" )
		$ANSW = SENDADB ( " shell ""echo " & $USERID & " > /data/local/tmp/pid""" )
		LOGINFO ( "Finish IdRead." )
		Return $USERID
	EndIf
	Return + 4294967295
EndFunc
Func CROPIMAGE ( $X1 , $Y1 , $X2 , $Y2 , $CROPFILENAME )
	$CURRFUNCNAME = "CropImage"
	Local $HBITMAP , $HCLONE , $HIMAGE , $IX , $IY
	$HIMAGE = _GDIPLUS_IMAGELOADFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	If $Y1 > _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE ) Then $Y1 = _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE ) + 4294967295
	If $X1 > _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE ) Then $X1 = _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE ) + 4294967295
	$HCLONE = _GDIPLUS_BITMAPCLONEAREA ( $HIMAGE , $X1 , $Y1 , $X2 , $Y2 , $GDIP_PXF24RGB )
	_GDIPLUS_IMAGESAVETOFILE ( $HCLONE , @ScriptDir & $CROPFILENAME )
	_GDIPLUS_IMAGEDISPOSE ( $HCLONE )
	_GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
EndFunc
Func COMBINEIMAGE ( $X1 , $Y1 , $X2 , $Y2 , $COMBINEIMAGE )
	$CURRFUNCNAME = "CombineImage"
	LOGINFO ( "Start CombineImage" )
	LOGINFO ( "Crop coords x1=" & $X1 & " y1=" & $Y1 & " x2=" & $X2 & " y2=" & $Y2 )
	LOGINFO ( "Combine to:" & $COMBINEIMAGE )
	Local $HBITMAP , $HCLONE , $HIMAGE , $IX , $IY , $SHIPLISTBITMAP , $LOCATIONBITMAP
	If $X1 = 0 Then
		LOGINFO ( "Default coords" )
		$X1 = 97
		$Y1 = 560
	EndIf
	$HIMAGE = _GDIPLUS_IMAGELOADFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	$HGRAPHIC = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT ( $HIMAGE )
	$SHIPLISTBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $HIMAGE , 1027 , 58 , 250 , $Y2 )
	$LOCATIONBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $HIMAGE , 110 , 17 , $X2 , 48 )
	If $Y1 > _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE ) Then $Y1 = _GDIPLUS_IMAGEGETHEIGHT ( $HIMAGE ) + 4294967295
	If $X1 > _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE ) Then $X1 = _GDIPLUS_IMAGEGETWIDTH ( $HIMAGE ) + 4294967295
	_GDIPLUS_GRAPHICSDRAWIMAGE ( $HGRAPHIC , $SHIPLISTBITMAP , $X1 + $X2 , $Y1 )
	_GDIPLUS_GRAPHICSDRAWIMAGE ( $HGRAPHIC , $LOCATIONBITMAP , $X1 , $Y1 )
	$HCLONE = _GDIPLUS_BITMAPCLONEAREA ( $HIMAGE , $X1 , $Y1 , $X2 + 250 , $Y2 , $GDIP_PXF24RGB )
	_GDIPLUS_IMAGESAVETOFILE ( $HCLONE , @ScriptDir & $COMBINEIMAGE )
	_GDIPLUS_IMAGEDISPOSE ( $HCLONE )
	_GDIPLUS_IMAGEDISPOSE ( $HIMAGE )
	_GDIPLUS_IMAGEDISPOSE ( $LOCATIONBITMAP )
	_GDIPLUS_GRAPHICSDISPOSE ( $HGRAPHIC )
	_GDIPLUS_IMAGEDISPOSE ( $SHIPLISTBITMAP )
	LOGINFO ( "Stop CombineImage" )
EndFunc
Func AUTH ( )
	$BOT_STATUS = "Paid"
	$OVERALLTIMERMAX = 2147483647
	ConsoleWrite ( "Authentication bypassed: Unlimited Local Mode active." & @CRLF )
	Return
EndFunc
Func GETMINERSCOORD ( $STOPONFAIL = 1 )
	$CURRFUNCNAME = "GetMinerscoord"
	LOGINFO ( "Start GetMinerscoord" )
	Local $X1 , $Y1
	Local $FINDED
	SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
	Sleep ( 1000 )
	ADBSCREEN ( 1 )
	If OPENCVFINDPIC ( @ScriptDir & "\img\miner-n1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 742 , 610 , 1270 , 711 ) Then
		LOGINFO ( "Small miner 1 found $x1,$y1:" & $X1 & "," & $Y1 )
		$MINERS_COORD [ 0 ] [ 0 ] = $X1
		$MINERS_COORD [ 0 ] [ 1 ] = $Y1
		$MINERS_STATUS [ 0 ] = 2
		$MINERS_SIZE = 1
		If OPENCVFINDPIC ( @ScriptDir & "\img\miner-n1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $X1 , 610 , 1270 , 711 ) Then
			LOGINFO ( "Small miner 2 found $x1,$y1:" & $X1 & "," & $Y1 )
			$MINERS_COORD [ 1 ] [ 0 ] = $X1
			$MINERS_COORD [ 1 ] [ 1 ] = $Y1
			$MINERS_STATUS [ 1 ] = 2
			If OPENCVFINDPIC ( @ScriptDir & "\img\miner-n1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $X1 , 610 , 1270 , 711 ) Then
				LOGINFO ( "Small miner 3 found $x1,$y1:" & $X1 & "," & $Y1 )
				$MINERS_COORD [ 2 ] [ 0 ] = $X1
				$MINERS_COORD [ 2 ] [ 1 ] = $Y1
				$MINERS_STATUS [ 2 ] = 2
			EndIf
		EndIf
	ElseIf OPENCVFINDPIC ( @ScriptDir & "\img\miner1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 742 , 610 , 1270 , 711 ) Then
		LOGINFO ( "Big miner 1 found $x1,$y1:" & $X1 & "," & $Y1 )
		$MINERS_COORD [ 0 ] [ 0 ] = $X1
		$MINERS_COORD [ 0 ] [ 1 ] = $Y1
		$MINERS_STATUS [ 0 ] = 2
		$MINERS_SIZE = 0
		If OPENCVFINDPIC ( @ScriptDir & "\img\miner1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $X1 , 610 , 1270 , 711 ) Then
			LOGINFO ( "Big miner 2 found $x1,$y1:" & $X1 & "," & $Y1 )
			$MINERS_COORD [ 1 ] [ 0 ] = $X1
			$MINERS_COORD [ 1 ] [ 1 ] = $Y1
			$MINERS_STATUS [ 1 ] = 2
			If OPENCVFINDPIC ( @ScriptDir & "\img\miner1.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $X1 , 610 , 1270 , 711 ) Then
				LOGINFO ( "Big miner 3 found $x1,$y1:" & $X1 & "," & $Y1 )
				$MINERS_COORD [ 2 ] [ 0 ] = $X1
				$MINERS_COORD [ 2 ] [ 1 ] = $Y1
				$MINERS_STATUS [ 2 ] = 2
			EndIf
		EndIf
	ElseIf OPENCVFINDPIC ( @ScriptDir & "\img\strip_miner-n.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 742 , 610 , 1270 , 711 ) Then
		LOGINFO ( "Strip miner 1 found $x1,$y1:" & $X1 & "," & $Y1 )
		$MINERS_COORD [ 0 ] [ 0 ] = $X1
		$MINERS_COORD [ 0 ] [ 1 ] = $Y1
		$MINERS_STATUS [ 0 ] = 2
		$MINERS_SIZE = 2
		If OPENCVFINDPIC ( @ScriptDir & "\img\strip_miner-n.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $X1 , 610 , 1270 , 711 ) Then
			LOGINFO ( "Strip miner 2 found $x1,$y1:" & $X1 & "," & $Y1 )
			$MINERS_COORD [ 1 ] [ 0 ] = $X1
			$MINERS_COORD [ 1 ] [ 1 ] = $Y1
			$MINERS_STATUS [ 1 ] = 2
			If OPENCVFINDPIC ( @ScriptDir & "\img\strip_miner-n.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , $X1 , 610 , 1270 , 711 ) Then
				LOGINFO ( "Strip miner 3 found $x1,$y1:" & $X1 & "," & $Y1 )
				$MINERS_COORD [ 2 ] [ 0 ] = $X1
				$MINERS_COORD [ 2 ] [ 1 ] = $Y1
				$MINERS_STATUS [ 2 ] = 2
			EndIf
		EndIf
	ElseIf OPENCVFINDPIC ( @ScriptDir & "\img\miningdrone_heavy.bmp" , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 742 , 610 , 1270 , 711 ) Then
		LOGINFO ( "Heavy minig drones found $x1,$y1:" & $X1 & "," & $Y1 )
		$MINERS_COORD [ 0 ] [ 0 ] = $X1
		$MINERS_COORD [ 0 ] [ 1 ] = $Y1
		$MINERS_STATUS [ 0 ] = 1
		$MINERS_SIZE = 3
	Else
		FileCopy ( @ScriptDir & "\screenshot\screenshot.bmp" , @ScriptDir & "\failscreenshot\CheckMiners-" & @MDAY & "." & @HOUR & "." & @MIN & "." & @MSEC & ".bmp" )
		LOGINFO ( "!Miners not found" )
		LOGINFO ( "!Botstop: miners not found" )
		LOGINFO ( "GetMinerscoord STOP" )
		TELEGRAMBOTSEND ( "Botstop: miners not found" , "\screenshot\screenshot.bmp" )
		If $STOPONFAIL = 1 Then $BOT_ENABLED = 0
		Return 0
	EndIf
	LOGINFO ( "$Miners_size = " & $MINERS_SIZE )
	LOGINFO ( "GetMinerscoord STOP" )
	Return 1
EndFunc
Func LOADMINERALPRIORITY ( )
	$CURRFUNCNAME = "LoadMineralPriority"
	Local $I = 0
	Local $READSTRING
	LOGINFO ( "Read MineralPriority from ini" )
	Do
		$READSTRING = IniRead ( $INIFILE , "MineralPriority" , $I , "STOP" )
		If Not StringInStr ( $READSTRING , "STOP" ) Then GUICtrlCreateListViewItem ( $READSTRING , $CLV )
		$I += 1
	Until StringInStr ( $READSTRING , "STOP" )
	LOGINFO ( "Stop MineralPriority from ini" )
	LOGINFO ( "Start cheking new minerals" )
	Local $AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\minerals\" , "*.bmp" )
	Local $M = 0
	For $M = 1 To $AFILELIST [ 0 ]
		If _GUICTRLLISTVIEW_FINDINTEXT ( $CLV , StringTrimRight ( $AFILELIST [ $M ] , 4 ) ) = + 4294967295 Then GUICtrlCreateListViewItem ( StringTrimRight ( $AFILELIST [ $M ] , 4 ) , $CLV )
	Next
	If _GUICTRLLISTVIEW_FINDINTEXT ( $CLV , "vvNOT SEARCHvv" , 4 ) = + 4294967295 Then GUICtrlCreateListViewItem ( "vvNOT SEARCHvv" , $CLV )
	$ILV_TOM = _GUILISTVIEWEX_INIT ( $CLV )
	LOGINFO ( "Stop cheking new minerals" )
EndFunc
Func GETASTEROIDSLIST ( )
	$CURRFUNCNAME = "GetAsteroidsList"
	LOGINFO ( "Start GetAsteroidsList()" )
	_ARRAYCLEAR ( $ASTEROIDS_LIST )
	Local $AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\minerals\" , "*.bmp" )
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0 , $M = 0
	ADBSCREEN ( 1 )
	For $M = 1 To $AFILELIST [ 0 ]
		LOGINFO ( "Searching for: " & $AFILELIST [ $M ] )
		$Y1 = 58
		Do
			If $Y1 > 665 Then ExitLoop
			If $I > 12 Then ExitLoop
			$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\minerals\" & $AFILELIST [ $M ] , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1059 , $Y1 , 1273 , 714 )
			If $FINDED Then
				$I += 1
				$ASTEROIDS_LIST [ $I ] [ 0 ] = $X1
				$ASTEROIDS_LIST [ $I ] [ 1 ] = $Y1
				$ASTEROIDS_LIST [ $I ] [ 2 ] = StringTrimRight ( $AFILELIST [ $M ] , 4 )
			EndIf
		Until $FINDED = 0
	Next
	$ASTEROIDS_LIST [ 0 ] [ 2 ] = $I
	LOGINFO ( "End GetAsteroidsList()" )
EndFunc
Func GETOSINFO ( )
	$CURRFUNCNAME = "GetOSInfo"
	Local $INFO = StringFormat ( "CPU: %s OS: %s %s %s" , @CPUArch , @OSArch , @OSVersion , @OSType )
	Local $OS_ARCH_TYPE = @OSArch
	LOGINFO ( "Info:" & $INFO )
	If $OS_ARCH_TYPE = "X86" Then MsgBox ( "" , "Warning" , "Your windows is 32-bit, bot may not work" )
EndFunc
Func SENDSTAT ( )
	Return
EndFunc
Func CHECKDETECTED ( $DONTSREENSHOT = 0 )
	$CURRFUNCNAME = "CheckDetected"
	Local $X_FINDED = 0 , $Y_FINDED = 0
	Local $DETECTED = 0
	Local $TIMEOUT = 0
	LOGINFO ( "CheckDetected start" )
	While WAITFINDPIC ( @ScriptDir & "\img\hasbeendetected.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 22 , 150 , 464 , 194 , $DONTSREENSHOT ) = 1
		LOGINFO ( "CheckDetected TRUE" )
		$DETECTED = 1
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		Sleep ( 1500 )
		If $TIMEOUT > 3 Then ExitLoop
		If $DONTSREENSHOT Then ExitLoop
		$TIMEOUT += 1
	WEnd
	If $DETECTED = 1 Then
		TrayTip ( "" , "Scanned" , 30 , 1 )
		TELEGRAMBOTSEND ( "Scanned" )
		Return 1
	Else
		LOGINFO ( "CheckDetected FALSE" )
		Return 0
	EndIf
	LOGINFO ( "CheckDetected" )
EndFunc
Func CHECKOTHERSHIPS ( )
	$CURRFUNCNAME = "CheckOtherShips"
	LOGINFO ( "Start CheckOtherShips" )
	Local $X_FINDED , $Y_FINDED
	Local $ENEMY_DETECTED = 0 , $FOCUS_DETECTED = 0
	Local $X1 , $Y1
	Local $FINDED
	Local $I = 0 , $M = 0
	Local $UNIQ = 0
	$PROCESSINGTIME = TimerInit ( )
	_ARRAYCLEAR ( $SHIP_LIST )
	If SELECTOVERLAY ( "ships" ) = 1 Then
		Sleep ( 500 )
	EndIf
	ADBSCREEN ( 1 )
	CHECKDETECTED ( 1 )
	Local $BITMAP1 , $BITMAP , $HPEN
	Local $ICOLOR = 0 , $ACOLOR = 0
	Local $ICOLOR1 = 0 , $ACOLOR1 = 0
	Local $X = 1045 , $Y = 0
	Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
	For $Y = 77 To 345 Step 2
		$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $X , $Y )
		$ACOLOR = __COLORGETRGB ( $ICOLOR )
		If $ACOLOR [ 0 ] > 150 And $ACOLOR [ 1 ] < 35 And $ACOLOR [ 2 ] < 35 Then
			$ENEMY_DETECTED = 1
			LOGINFO ( "CheckOtherShips: red ship detected" )
			ExitLoop
		EndIf
	Next
	_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
	_WINAPI_DELETEOBJECT ( $BITMAP )
	If $FAKE = 1 Then
		LOGINFO ( "FAKE Enemy DETECTED!" )
		LOGINFO ( "End CheckOtherShips" )
		$ENEMY_DETECTED = 1
	EndIf
	If CHECKDAMAGE ( 0 ) = 1 Then $ENEMY_DETECTED = 1
	If $ENEMY_DETECTED And $BOTTYPE <> 1 Then
		Run ( "OBSCommand.exe  /startrecording" , "" , @SW_HIDE )
		LOGINFO ( "Enemy DETECTED!" )
		LOGINFO ( "End CheckOtherShips" )
		FileCopy ( @ScriptDir & "\screenshot\screenshot.bmp" , @ScriptDir & "\screenshot\screenshot-enemydetected-" & @MDAY & "." & @HOUR & "." & @MIN & "." & @MSEC & ".bmp" )
		TrayTip ( "" , "Enemy detected!!" , 300 , 2 )
		TELEGRAMBOTSEND ( "Enemy detected" , "\screenshot\screenshot.bmp" )
		$CHECKLOCALRETREAT = 1
		Return 1
	EndIf
	LOGINFO ( "Time starting optical recognition: " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms" )
	If $CHECKOTHERSHIPSTYPE = 0 Then
		Local $AFILELIST = _FILELISTTOARRAY ( @ScriptDir & "\img\fleet\" , "*.bmp" )
		For $M = 1 To $AFILELIST [ 0 ]
			LOGINFO ( "Searching for: " & $AFILELIST [ $M ] )
			$Y1 = 58
			Do
				If $Y1 > 665 Then ExitLoop
				If $I > 12 Then ExitLoop
				$FINDED = OPENCVFINDPIC ( @ScriptDir & "\img\fleet\" & $AFILELIST [ $M ] , $X1 , $Y1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 950 , $Y1 , 1100 , 670 )
				If $FINDED Then
					$I += 1
					$SHIP_LIST [ $I ] [ 0 ] = $X1
					$SHIP_LIST [ $I ] [ 1 ] = $Y1
					$SHIP_LIST [ $I ] [ 2 ] = StringTrimRight ( $AFILELIST [ $M ] , 4 )
					If $SHIP_LIST [ $I ] [ 2 ] = "cargo" Or $SHIP_LIST [ $I ] [ 2 ] = "industry" Then
						$SHIP_LIST [ 0 ] [ 0 ] += 1
					Else
						$SHIP_LIST [ 0 ] [ 1 ] += 1
					EndIf
				EndIf
			Until $FINDED = 0
		Next
		$SHIP_LIST [ 0 ] [ 2 ] = $I
	Else
		LOGINFO ( "CheckOtherShips IRL" )
		Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
		Local $TMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 1027 , 58 , 83 , 364 )
		_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
		_WINAPI_DELETEOBJECT ( $BITMAP )
		$IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TMPBITMAP ) )
		_GDIPLUS_BITMAPDISPOSE ( $TMPBITMAP )
		_WINAPI_DELETEOBJECT ( $TMPBITMAP )
		Local $COMPAREPARAMETERS = IR_COMPARE_PARAMETERS ( )
		With $COMPAREPARAMETERS
		.MultiThreadedProcessing = False
		.CompareType = $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA
		.ColorTolerance_A = 49
		.ColorTolerance_R = 49
		.ColorTolerance_G = 49
		.ColorTolerance_B = 49
		.PixelTolerance = 4
		.FilterTresholdX = 20
		.FilterTresholdY = 20
		.EnableOpenCL = False
		.PlaformIndex = Default
		.DeviceIndex = Default
		.ComputeCoreCount = Default
		EndWith
		Local $NUMBER [ 0 ] [ 2 ] , $COUNT = 0 , $M = 0
		For $I = 0 To 10
			ConsoleWrite ( "> Serching for " & $SHIP_ICO_FILENAME [ $I ] & @CRLF )
			$TRESULT = IR_COMPARE ( $IMAGE_SRC , $SHIP_ICO [ $I ] , $COMPAREPARAMETERS )
			If Not @error Then
				ConsoleWrite ( "!>" & $SHIP_ICO_FILENAME [ $I ] & " Successful search (In " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms), match count: " & $TRESULT [ 0 ] & @CRLF )
				For $M = 1 To $TRESULT [ 0 ]
					LOGINFO ( "> Found " & $SHIP_ICO_FILENAME [ $I ] & " at position: X=" & $TRESULT [ $M ] .X & ", Y=" & $TRESULT [ $M ] .Y & ", W=" & $TRESULT [ $M ] .W & ", H=" & $TRESULT [ $M ] .H )
					LOGINFO ( ", Angle=" & $TRESULT [ $M ] .Angle & ", Difference=" & $TRESULT [ $M ] .Difference & ", MatchPercentage=" & $TRESULT [ $M ] .MatchPercentage )
					$UNIQ = $UNIQ + $I * $M
				Next
				ConsoleWrite ( "Number: " & $I & " - Search: " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms" & @CRLF )
				Switch $I
				Case 0
					LOGINFO ( "Enemy detected!" )
					$ENEMY_DETECTED = 1
				Case 1
					LOGINFO ( "Lock detected!" )
					$FOCUS_DETECTED = 1
					$ENEMY_DETECTED = 1
				Case 2 To 7
					LOGINFO ( "Armed neautral " & $SHIP_ICO_FILENAME [ $I ] & " detected!" )
					$ENEMY_DETECTED = 1
				Case 8 To 10
					LOGINFO ( "Unarmed Neautral detected!" )
				EndSwitch
				If $ENEMY_DETECTED = 1 And $BOTTYPE <> 1 Then ExitLoop
			EndIf
		Next
		IR_COMPARE_FREERESULT ( $TRESULT )
		IR_IMAGE_UNLOAD ( $IMAGE_SRC )
	EndIf
	LOGINFO ( "Time for CheckOtherShips: " & Round ( TimerDiff ( $PROCESSINGTIME ) , 2 ) & "ms" )
	If ( $SHIP_LIST [ 0 ] [ 1 ] > 0 Or $ENEMY_DETECTED = 1 ) And $BOTTYPE = 1 Then
		LOGDEBUG ( "$Uniq=" & $UNIQ )
		Return $UNIQ
	EndIf
	If $SHIP_LIST [ 0 ] [ 1 ] > 0 Or $ENEMY_DETECTED = 1 Then
		Run ( "OBSCommand.exe  /startrecording" , "" , @SW_HIDE )
		LOGINFO ( "Neutral ship present" )
		LOGINFO ( "End CheckOtherShips" )
		TrayTip ( "" , "Neutral ship detected!!" , 300 , 2 )
		TELEGRAMBOTSEND ( "Neutral ship " & $SHIP_ICO_FILENAME [ $I ] & " detected" , "\screenshot\screenshot.bmp" )
		$CHECKLOCALRETREAT = 1
		Return 1
	Else
		LOGINFO ( "Ship NOT present" )
		LOGINFO ( "End CheckOtherShips" )
		Return 0
	EndIf
EndFunc
Func SETUPINI ( $ACTION = "read" )
	$CURRFUNCNAME = "SetupIni"
	If $ACTION = "read" Then
		LOGINFO ( "Start conf.ini reading" )
		$OBSTYPE = IniRead ( $INIFILE , "Settings" , "OBSType" , "0" )
		LOGINFO ( "$OBSType=" & $OBSTYPE )
		$CHECKOTHERSHIPSTYPE = IniRead ( $INIFILE , "Settings" , "CheckOtherShipsType" , "1" )
		LOGINFO ( "$CheckOtherShipsType=" & $CHECKOTHERSHIPSTYPE )
		$SCREENSHOTINGTYPE = IniRead ( $INIFILE , "Settings" , "ScreenshotingType" , "0" )
		LOGINFO ( "$ScreenshotingType=" & $SCREENSHOTINGTYPE )
		$CLICKTYPE = IniRead ( $INIFILE , "Settings" , "ClickType" , "0" )
		LOGINFO ( "$ClickType=" & $CLICKTYPE )
		$SCREENSHOTSIZECHECKDISABLE = IniRead ( $INIFILE , "Settings" , "ScreenShotSizeCheckDisable" , "0" )
		LOGINFO ( "$ScreenShotSizeCheckDisable=" & $SCREENSHOTSIZECHECKDISABLE )
		$GETDOCKDIRECTIONTYPE = IniRead ( $INIFILE , "Settings" , "GetDockDirectionType" , "1" )
		LOGINFO ( "$GetDockDirectionType=" & $GETDOCKDIRECTIONTYPE )
		$USEMININGIMPLANT = IniRead ( $INIFILE , "Settings" , "UseMiningImplant" , "0" )
		LOGINFO ( "$UseMiningImplant=" & $USEMININGIMPLANT )
		$USEMININGIMPLANTCONDENSED = IniRead ( $INIFILE , "Settings" , "UseMiningImplantCondensed" , "0" )
		LOGINFO ( "$UseMiningImplantCondensed=" & $USEMININGIMPLANTCONDENSED )
		$DONTNEEDCHECKOTHERSHIPS = IniRead ( $INIFILE , "Settings" , "DontNeedCheckOtherShips" , "0" )
		LOGINFO ( "$DontNeedCheckOtherShips=" & $DONTNEEDCHECKOTHERSHIPS )
		$BOTTYPE = IniRead ( $INIFILE , "Settings" , "BotType" , "0" )
		LOGINFO ( "$BotType=" & $BOTTYPE )
		$CONSOLETYPE = IniRead ( $INIFILE , "Settings" , "ConsoleType" , "0" )
		LOGINFO ( "$ConsoleType=" & $CONSOLETYPE )
		$BOTWINDOWMOVE = IniRead ( $INIFILE , "Settings" , "BotWindowMove" , "0" )
		LOGINFO ( "$BotWindowMove=" & $BOTWINDOWMOVE )
		$NEEDCHECKOTHERSHIPS = IniRead ( $INIFILE , "Waxtep`s parameters" , "CheckOtherShips" , "0" )
		LOGINFO ( "$NeedCheckOtherShips=" & $NEEDCHECKOTHERSHIPS )
		If $NEEDCHECKOTHERSHIPS = 1 Then GUICtrlSetState ( $CHECKBOX_NEEDCHECKOTHERSHIPS , $GUI_CHECKED )
		$FIRSTSWIPEASTER = IniRead ( $INIFILE , "Waxtep`s parameters" , "FirstSwipeAster" , "4" )
		LOGINFO ( "$FirstSwipeAster=" & $FIRSTSWIPEASTER )
		$FASTMINING = IniRead ( $INIFILE , "Waxtep`s parameters" , "FastMining" , "0" )
		LOGINFO ( "$FastMining=" & $FASTMINING )
		$ADDITIONALHIDINGMAX = IniRead ( $INIFILE , "Settings" , "AdditionalHidingMax" , "5" )
		LOGINFO ( "$AdditionalHidingMax = " & $ADDITIONALHIDINGMAX )
		$ADDITIONALHIDINGMIN = IniRead ( $INIFILE , "Settings" , "AdditionalHidingMin" , "2" )
		LOGINFO ( "$AdditionalHidingMin = " & $ADDITIONALHIDINGMIN )
		$BELTWARPFROMBELT = IniRead ( $INIFILE , "Settings" , "BeltWarpFromBelt" , "0" )
		LOGINFO ( "$BeltWarpFromBelt=" & $BELTWARPFROMBELT )
		$HIDINGNOWAIT = IniRead ( $INIFILE , "Waxtep`s parameters" , "HidingNoWait" , "0" )
		LOGINFO ( "$HidingNoWait=" & $HIDINGNOWAIT )
		If $HIDINGNOWAIT = 1 Then GUICtrlSetState ( $CHECKBOX_HIDINGNOWAIT , $GUI_CHECKED )
		$NEEDCHECKLOCAL = IniRead ( $INIFILE , "Waxtep`s parameters" , "NeedCheckLocal" , "0" )
		LOGINFO ( "$NeedCheckLocal=" & $NEEDCHECKLOCAL )
		If $NEEDCHECKLOCAL = 1 Then GUICtrlSetState ( $CHECKBOX_NEEDCHECKLOCAL , $GUI_CHECKED )
		$TIMETOWARPCURRENT = IniRead ( $INIFILE , "Waxtep`s parameters" , "TimeToWarpCurrent" , "12000" )
		LOGINFO ( "$TimeToWarpCurrent=" & $TIMETOWARPCURRENT )
		Local $TMPDOING = GUICtrlRead ( $LABEL_THINGSONSHIP )
		$TMPDOING = $TMPDOING & "TTW=" & $TIMETOWARPCURRENT & " ms."
		GUICtrlSetData ( $LABEL_THINGSONSHIP , $TMPDOING )
		$CHECKLOCALPANICLEVEL = IniRead ( $INIFILE , "Waxtep`s parameters" , "CheckLocalPanicLevel" , "0" )
		LOGINFO ( "$CheckLocalPanicLevel=" & $CHECKLOCALPANICLEVEL )
		$DISCORDHOOK = IniRead ( $INIFILE , "Settings" , "DiscordHook" , "" )
		LOGINFO ( "$DiscordHook=" & $DISCORDHOOK )
		$LOGDONTSAVEINFO = IniRead ( $INIFILE , "Settings" , "LogDontSaveInfo" , "0" )
		Switch $BOTTYPE
		Case 0
			GUICtrlSetData ( $BUTTON_START , "START MINING" )
		Case 1
			GUICtrlSetData ( $BUTTON_START , "START EYE" )
		Case 2
			GUICtrlSetData ( $BUTTON_START , "START ANOMALY" )
		Case 3
			GUICtrlSetData ( $BUTTON_START , "START EVENT" )
		Case 5
			GUICtrlSetData ( $BUTTON_START , "START SCANBOT" )
			GUICtrlSetData ( $BUTTON_ADBINJECT , "Analyze+take" )
			GUICtrlSetOnEvent ( $BUTTON_ADBINJECT , "AnalyzeAndTakeLoot" )
	Case Else
			GUICtrlSetData ( $BUTTON_START , "START UNKNOWN" )
		EndSwitch
		Global $WEAPONBOOSTREACTIVATIONTIME = IniRead ( $INIFILE , "Anomaly" , "WeaponBoostReactivationTime" , "135" )
		LOGINFO ( "$WeaponBoostReactivationTime=" & $WEAPONBOOSTREACTIVATIONTIME )
		Global $WEAPONBOOSTACTIVATIONTIME = IniRead ( $INIFILE , "Anomaly" , "WeaponBoostActivationTime" , "22" )
		LOGINFO ( "$WeaponBoostActivationTime=" & $WEAPONBOOSTACTIVATIONTIME )
		Global $BATTERYREACTIVATIONTIME = IniRead ( $INIFILE , "Anomaly" , "BatteryReactivationTime" , "90" )
		LOGINFO ( "$BatteryReactivationTime=" & $BATTERYREACTIVATIONTIME )
		Global $BATTERYACTIVATIONTIME = IniRead ( $INIFILE , "Anomaly" , "BatteryActivationTime" , "25" )
		LOGINFO ( "$BatteryActivationTime=" & $BATTERYACTIVATIONTIME )
		Global $WARPDISTANCE = IniRead ( $INIFILE , "Anomaly" , "WarpDistance" , "100" )
		LOGINFO ( "$WarpDistance=" & $WARPDISTANCE )
		Global $SELECTANOMALYSIZE = IniRead ( $INIFILE , "Anomaly" , "SelectAnomalySize" , "3" )
		LOGINFO ( "$SelectAnomalySize=" & $SELECTANOMALYSIZE )
		$AN_IGNORELEVELS = IniRead ( $INIFILE , "Anomaly" , "AN_IgnoreLevels" , "1" )
		LOGINFO ( "$AN_IgnoreLevels=" & $AN_IGNORELEVELS )
		$AN_SECONDSWIPE = IniRead ( $INIFILE , "Anomaly" , "AN_SecondSwipe" , "0" )
		LOGINFO ( "$AN_SecondSwipe=" & $AN_SECONDSWIPE )
		Global $USEALWAYSON = IniRead ( $INIFILE , "Anomaly" , "UseAlwaysOn" , "0" )
		LOGINFO ( "$UseAlwaysOn=" & $USEALWAYSON )
		Global $MAXTRYANOMALY = IniRead ( $INIFILE , "Anomaly" , "MaxTryAnomaly" , "22" )
		LOGINFO ( "$MaxTryAnomaly=" & $MAXTRYANOMALY )
		Switch $CHECKLOCALPANICLEVEL
		Case 0
			_GUICTRLCOMBOBOX_SETCURSEL ( $COMBO1 , 0 )
		Case 1
			_GUICTRLCOMBOBOX_SETCURSEL ( $COMBO1 , 1 )
		Case 2
			_GUICTRLCOMBOBOX_SETCURSEL ( $COMBO1 , 2 )
		EndSwitch
		$TELEGRAMTOKEN = IniRead ( $INIFILE , "TelegramBot" , "TelegramToken" , "" )
		$TELEGRAMCHATID = IniRead ( $INIFILE , "TelegramBot" , "TelegramChatId" , "" )
		$PREFERBELTNUMBER = IniRead ( $INIFILE , "Settings" , "PreferBeltNumber" , "0" )
		LOGINFO ( "$PreferBeltNumber=" & $PREFERBELTNUMBER )
		LOGINFO ( "Stop conf.ini reading" )
	EndIf
	If $ACTION = "save" Then
		IniWrite ( $INIFILE , "Settings" , "CheckOtherShipsType" , $CHECKOTHERSHIPSTYPE )
		IniWrite ( $INIFILE , "Settings" , "ClickType" , $CLICKTYPE )
		IniWrite ( $INIFILE , "Settings" , "ScreenshotingType" , $SCREENSHOTINGTYPE )
		IniWrite ( $INIFILE , "Settings" , "BotWindowMove" , $BOTWINDOWMOVE )
		IniWrite ( $INIFILE , "Settings" , "ConsoleType" , $CONSOLETYPE )
		IniWrite ( $INIFILE , "Settings" , "GetDockDirectionType" , $GETDOCKDIRECTIONTYPE )
		IniWrite ( $INIFILE , "Settings" , "UseMiningImplant" , $USEMININGIMPLANT )
		IniWrite ( $INIFILE , "Settings" , "UseMiningImplantCondensed" , $USEMININGIMPLANTCONDENSED )
		IniWrite ( $INIFILE , "Settings" , "DiscordHook" , $DISCORDHOOK )
		IniWrite ( $INIFILE , "Settings" , "BotType" , $BOTTYPE )
		IniWrite ( $INIFILE , "Settings" , "BeltWarpFromBelt" , $BELTWARPFROMBELT )
		IniWrite ( $INIFILE , "Settings" , "DontNeedCheckOtherShips" , $DONTNEEDCHECKOTHERSHIPS )
		IniWrite ( $INIFILE , "Settings" , "AdditionalHidingMax" , $ADDITIONALHIDINGMAX )
		IniWrite ( $INIFILE , "Settings" , "AdditionalHidingMin" , $ADDITIONALHIDINGMIN )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "CheckOtherShips" , $NEEDCHECKOTHERSHIPS )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "FirstSwipeAster" , $FIRSTSWIPEASTER )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "FastMining" , $FASTMINING )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "HidingNoWait" , $HIDINGNOWAIT )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "NeedCheckLocal" , $NEEDCHECKLOCAL )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "TimeToWarpCurrent" , $TIMETOWARPCURRENT )
		If _GUICTRLCOMBOBOX_GETCURSEL ( $COMBO1 ) >= 0 Then $CHECKLOCALPANICLEVEL = _GUICTRLCOMBOBOX_GETCURSEL ( $COMBO1 )
		IniWrite ( $INIFILE , "Waxtep`s parameters" , "CheckLocalPanicLevel" , $CHECKLOCALPANICLEVEL )
		IniWrite ( $INIFILE , "TelegramBot" , "TelegramToken" , $TELEGRAMTOKEN )
		IniWrite ( $INIFILE , "TelegramBot" , "TelegramChatId" , $TELEGRAMCHATID )
		IniWrite ( $INIFILE , "Settings" , "PreferBeltNumber" , $PREFERBELTNUMBER )
		IniWrite ( $INIFILE , "Anomaly" , "WeaponBoostReactivationTime" , $WEAPONBOOSTREACTIVATIONTIME )
		IniWrite ( $INIFILE , "Anomaly" , "WeaponBoostActivationTime" , $WEAPONBOOSTACTIVATIONTIME )
		IniWrite ( $INIFILE , "Anomaly" , "BatteryReactivationTime" , $BATTERYREACTIVATIONTIME )
		IniWrite ( $INIFILE , "Anomaly" , "BatteryActivationTime" , $BATTERYACTIVATIONTIME )
		IniWrite ( $INIFILE , "Anomaly" , "WarpDistance" , $WARPDISTANCE )
		IniWrite ( $INIFILE , "Anomaly" , "SelectAnomalySize" , $SELECTANOMALYSIZE )
		IniWrite ( $INIFILE , "Anomaly" , "UseAlwaysOn" , $USEALWAYSON )
		IniWrite ( $INIFILE , "Anomaly" , "MaxTryAnomaly" , $MAXTRYANOMALY )
		IniWrite ( $INIFILE , "Anomaly" , "AN_IgnoreLevels" , $AN_IGNORELEVELS )
		IniWrite ( $INIFILE , "Anomaly" , "AN_SecondSwipe" , $AN_SECONDSWIPE )
	EndIf
EndFunc
Func GETWARPSTABCOORD ( )
	$CURRFUNCNAME = "GetWarpStabCoord"
	LOGINFO ( "GetWarpStabCoord start" )
	Local $X_FINDED , $Y_FINDED
	Local $X_FINDED = 763
	Local $I = 1
	ADBSCREEN ( 1 )
	While WAITFINDPIC ( @ScriptDir & "\img\warpstab.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED , 529 , 1266 , 706 , 1 ) = 1
		$WARPSTABS [ $I ] [ 0 ] = $X_FINDED
		$WARPSTABS [ $I ] [ 1 ] = $Y_FINDED
		$I += 1
	WEnd
	$WARPSTABS [ 0 ] [ 0 ] = $I + 4294967295
	If $WARPSTABS [ 0 ] [ 0 ] = 0 Then
		While WAITFINDPIC ( @ScriptDir & "\img\warpstab1.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED , 529 , 1266 , 706 , 1 ) = 1
			$WARPSTABS [ $I ] [ 0 ] = $X_FINDED
			$WARPSTABS [ $I ] [ 1 ] = $Y_FINDED
			$I += 1
		WEnd
	EndIf
	$WARPSTABS [ 0 ] [ 0 ] = $I + 4294967295
	If $WARPSTABS [ 0 ] [ 0 ] = 0 Then
		While WAITFINDPIC ( @ScriptDir & "\img\warpstab-n.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED , 529 , 1266 , 706 , 1 ) = 1
			$WARPSTABS [ $I ] [ 0 ] = $X_FINDED
			$WARPSTABS [ $I ] [ 1 ] = $Y_FINDED
			$I += 1
		WEnd
	EndIf
	$WARPSTABS [ 0 ] [ 0 ] = $I + 4294967295
	If $WARPSTABS [ 0 ] [ 0 ] > 0 Then
		LOGINFO ( "WarpStabcount= " & $WARPSTABS [ 0 ] [ 0 ] )
		GUICtrlSetData ( $LABEL_THINGSONSHIP , GUICtrlRead ( $LABEL_THINGSONSHIP ) & "Warpstabs:" & $WARPSTABS [ 0 ] [ 0 ] & ". " )
	Else
		LOGINFO ( "WarpStabCoord not found" )
		$WARPSTABS [ 0 ] [ 0 ] = + 4294967295
	EndIf
	LOGINFO ( "GetWarpStabCoord start" )
EndFunc
Func GETGYROSTABCOORD ( )
	$CURRFUNCNAME = "GetGyroStabCoord"
	LOGINFO ( "GetGyroStabCoord start" )
	Local $X_FINDED , $Y_FINDED
	Local $X_FINDED = 763
	Local $I = 1
	ADBSCREEN ( 1 )
	While WAITFINDPIC ( @ScriptDir & "\img\Gyrostab.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED , 529 , 1266 , 706 , 1 ) = 1
		$GYROSTABS [ $I ] [ 0 ] = $X_FINDED
		$GYROSTABS [ $I ] [ 1 ] = $Y_FINDED
		$I += 1
	WEnd
	$GYROSTABS [ 0 ] [ 0 ] = $I + 4294967295
	If $GYROSTABS [ 0 ] [ 0 ] = 0 Then
		While WAITFINDPIC ( @ScriptDir & "\img\Gyrostab1.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED , 529 , 1266 , 706 , 1 ) = 1
			$GYROSTABS [ $I ] [ 0 ] = $X_FINDED
			$GYROSTABS [ $I ] [ 1 ] = $Y_FINDED
			$I += 1
		WEnd
	EndIf
	$GYROSTABS [ 0 ] [ 0 ] = $I + 4294967295
	If $GYROSTABS [ 0 ] [ 0 ] > 0 Then
		LOGINFO ( "GyroStabcount= " & $GYROSTABS [ 0 ] [ 0 ] )
		GUICtrlSetData ( $LABEL_THINGSONSHIP , GUICtrlRead ( $LABEL_THINGSONSHIP ) & "Gyrostabs:" & $GYROSTABS [ 0 ] [ 0 ] & ". " )
	Else
		LOGINFO ( "GyroStabCoord not found" )
		$GYROSTABS [ 0 ] [ 0 ] = + 4294967295
	EndIf
	LOGINFO ( "GetGyroStabCoord start" )
EndFunc
Func WAITUNTILSHIPRICHHALFSPEED ( )
	$CURRFUNCNAME = "WaitUntilShipRichHalfSpeed"
	Local $MOVINGTIMER = TimerInit ( )
	Local $MOVINGTIMEOUT = 10000
	Local $X_FINDED , $Y_FINDED
	Local $DONE = 0
	Local $COLOR
	LOGINFO ( ">Wait until ship get half of speed for " & $MOVINGTIMEOUT / 1000 & " seconds." )
	While Not $DONE And TimerDiff ( $MOVINGTIMER ) < $MOVINGTIMEOUT
		$COLOR = CHECKCOLOR ( 640 , 663 )
		If $COLOR [ 0 ] < 120 And $COLOR [ 1 ] < 170 And $COLOR [ 0 ] < 160 Then
			$DONE = 1
			FILECONSOLEWRITE ( "Done!" )
		Else
			$DONE = 0
		EndIf
	WEnd
	If $DONE = 0 Then FILECONSOLEWRITE ( "Timeout!" )
	LOGINFO ( ">Wait until ship get half of speed complete. It takes " & Round ( TimerDiff ( $MOVINGTIMER ) / 1000 ) & "/" & $MOVINGTIMEOUT / 1000 & " seconds." )
EndFunc
Func FIREWARPSTABS ( )
	$CURRFUNCNAME = "FireWarpStabs"
	Local $I = 1
	LOGINFO ( "FireWarpStabs start" )
	If $WARPSTABS [ 0 ] [ 0 ] > 0 Then
		For $I = 1 To $WARPSTABS [ 0 ] [ 0 ]
			SENDTAP ( $WARPSTABS [ $I ] [ 0 ] , $WARPSTABS [ $I ] [ 1 ] , 10 )
		Next
	Else
		LOGINFO ( "WarpStabCoord not found" )
	EndIf
	LOGINFO ( "FireWarpStabs end" )
EndFunc
Func FIREGYROSTABS ( )
	$CURRFUNCNAME = "FireGyroStabs"
	Local $I = 1
	LOGINFO ( "FireGyroStabs start" )
	If $GYROSTABS [ 0 ] [ 0 ] > 0 Then
		For $I = 1 To $GYROSTABS [ 0 ] [ 0 ]
			SENDTAP ( $GYROSTABS [ $I ] [ 0 ] , $GYROSTABS [ $I ] [ 1 ] , 10 )
		Next
	Else
		LOGINFO ( "WarpGyroCoord not found" )
	EndIf
	LOGINFO ( "FireWarpStabs end" )
EndFunc
Func CHECKDAMAGE ( $NOSCREENSHOT = 0 )
	$CURRFUNCNAME = "CheckDamage"
	LOGINFO ( "Start CheckDamage" )
	Local $COLOR = CHECKCOLOR ( 675 , 577 , 0 , 0 , $NOSCREENSHOT )
	If $COLOR [ 1 ] > 100 And $COLOR [ 2 ] > 100 Then
		LOGINFO ( "Ship NOT damaged" )
		Return False
	Else
		LOGINFO ( "Ship damaged. Colors RGB" & $COLOR [ 0 ] & "|" & $COLOR [ 1 ] & "|" & $COLOR [ 2 ] )
		Return True
	EndIf
EndFunc
Func CHECKINDOCKREPAIR ( )
	$CURRFUNCNAME = "CheckIndockRepair"
	LOGINFO ( "CheckIndockRepair start" )
	Local $X_FINDED , $Y_FINDED
	Local $I = 1
	If WAITFINDPIC ( @ScriptDir & "\img\repair.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1043 , 313 , 1267 , 646 ) Then
		SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
		If Not WAITFINDPIC ( @ScriptDir & "\img\noshiprepair.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 4 ) Then
			If ( WAITFINDPIC ( @ScriptDir & "\img\confirm.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 12 ) = 1 ) Then
				TELEGRAMBOTSEND ( "Ship repairing" , "\screenshot\screenshot.bmp" )
				SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
				Sleep ( 4000 )
			EndIf
			If ( WAITFINDPIC ( @ScriptDir & "\img\confirm.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 12 ) = 1 ) Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
				Sleep ( 4000 )
			EndIf
			LOGINFO ( "Ship repaired?" )
		Else
			LOGINFO ( "Nothing to repair" )
		EndIf
	Else
		SENDADB ( " shell input swipe " & 1165 + Random ( + 4294967295 , 1 , 1 ) & " " & 634 + Random ( + 4294967295 , 1 , 1 ) & " " & 1655 + Random ( + 4294967291 , 5 , 1 ) & " " & 123 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 1000 , 1 ) )
		Sleep ( 1000 )
		If WAITFINDPIC ( @ScriptDir & "\img\repair.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1043 , 313 , 1267 , 646 ) Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
			If Not WAITFINDPIC ( @ScriptDir & "\img\noshiprepair.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 4 ) Then
				If ( WAITFINDPIC ( @ScriptDir & "\img\confirm.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 12 ) = 1 ) Then
					TELEGRAMBOTSEND ( "Ship repairing" , "\screenshot\screenshot.bmp" )
					SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
					Sleep ( 4000 )
				EndIf
				If ( WAITFINDPIC ( @ScriptDir & "\img\confirm.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 12 ) = 1 ) Then
					SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
					Sleep ( 4000 )
				EndIf
				LOGINFO ( "Ship repaired?" )
			Else
				LOGINFO ( "Nothing to repair" )
			EndIf
		EndIf
	EndIf
	LOGINFO ( "CheckIndockRepair stop" )
EndFunc
Func TELEGRAMBOTSEND ( $MESSAGE , $PIC = 0 )
	Return
EndFunc
Func TELEGRAMPOLLING ( )
	Return
EndFunc
Func _SLEEP ( $TIMETOSLEEP )
	$CURRFUNCNAME = "_Sleep"
	If $TIMETOSLEEP < 0 Then
		LOGINFO ( "_Sleep time NEGATIVE" )
	EndIf
	$START = TimerInit ( )
	If $TIMETOSLEEP < 1200 Then
		While 1
			If TimerDiff ( $START ) >= $TIMETOSLEEP Then ExitLoop
			Sleep ( 100 )
		WEnd
	Else
		TELEGRAMPOLLING ( )
		ConsoleWrite ( "Time for tele=" & TimerDiff ( $START ) & @CRLF )
		While 1
			If TimerDiff ( $START ) > $TIMETOSLEEP Then ExitLoop
			Sleep ( 100 )
		WEnd
	EndIf
EndFunc
Func CHECKLOCAL ( )
	$CURRFUNCNAME = "CheckLocal"
	Local $X_FINDED , $Y_FINDED
	Local $X_TEMP1 , $Y_TEMP1
	Local $X_LOCALCHATLABLE = 0 , $Y_LOCALCHATLABLE = 0
	Local $DONE = 0 , $TRY = 0
	Local $RET = 5
	Local $DETECT_PRECISSION = 0.8
	Local $MSG = ""
	LOGINFO ( "CheckLocal start. Counters:" & $CHECKLOCALCOUNTER & "/" & $CHECKLOCALCOUNTER_RND )
	Local $TEMPDOING = GUICtrlRead ( $LABEL_DOING )
	Local $NEUTRALSFINDED = True
	Local $CRIMEFINDED = True
	Local $ENEMYFINDED = True
	GUICtrlSetData ( $LABEL_DOING , "CheckLocal" )
	Local $COMPAREPARAMETERS = IR_COMPARE_PARAMETERS ( )
	With $COMPAREPARAMETERS
	.MultiThreadedProcessing = True
	.MaxMatches = + 4294967295
	.CompareType = $IR_COMPARE_TYPE_RELATIVE_ARGB_ALPHA
	.ColorTolerance_A = 85
	.ColorTolerance_R = 85
	.ColorTolerance_G = 85
	.ColorTolerance_B = 85
	.PixelTolerance = 15
	.FilterTresholdX = 50
	.FilterTresholdY = 20
	.EnableOpenCL = False
	.PlaformIndex = Default
	.DeviceIndex = Default
	.ComputeCoreCount = Default
	EndWith
	If $FAKE1 = 1 Then
		LOGINFO ( "CheckLocal FAKE " )
		Return 3
	EndIf
	Do
		$DONE = 1
		If WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 242 , 215 , 242 + 43 , 215 + 44 ) = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
			Sleep ( 2500 )
		EndIf
		If WAITFINDPIC ( @ScriptDir & "\img\close_bookmarks2.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 8 , 166 , 8 + 288 , 166 + 113 ) = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
			Sleep ( 2500 )
		EndIf
		If CHECKANDCLOSESTATUS ( ) = 1 Then
			Sleep ( 1000 )
			ADBSCREEN ( 1 )
		EndIf
		If WAITFINDPIC ( @ScriptDir & "\img\localchat_title.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 8 , 126 , 607 , 439 , 1 ) = 0 Then
			If ( WAITFINDPIC ( @ScriptDir & "\img\close_inventory.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1158 , 13 , 1276 , 79 , 1 ) = 1 ) Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
				Sleep ( 500 )
			EndIf
			$CHECKLOCALCOUNTER = $CHECKLOCALCOUNTER + 1
			If $CHECKLOCALCOUNTER > $CHECKLOCALCOUNTER_RND Then
				If WAITFINDPIC ( @ScriptDir & "\img\localchat_ico.bmp" , $X_TEMP1 , $Y_TEMP1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 0 , 200 , 600 , 720 , 1 ) = 1 Then
					SENDTAP ( $X_TEMP1 , $Y_TEMP1 , 10 )
					Sleep ( 500 )
					SENDTAP ( $X_TEMP1 , $Y_TEMP1 , 10 )
					Sleep ( 500 )
					$CHECKLOCALCOUNTER = 0
					$CHECKLOCALCOUNTER_RND = Random ( 10 , 15 , 1 )
				EndIf
			EndIf
			If ( 1 ) Then
				LOGDEBUG ( "stage 1" )
				Local $M
				Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
				Local $BIG_IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $BITMAP ) )
				$COMPAREPARAMETERS .PixelTolerance = 1
				$COMPAREPARAMETERS .MaxMatches = 1
				Local $MRESULT = IR_COMPARE ( $BIG_IMAGE_SRC , $LOCALCHATPANEL , $COMPAREPARAMETERS )
				$COMPAREPARAMETERS .PixelTolerance = 15
				$COMPAREPARAMETERS .MaxMatches = + 4294967295
				If Not @error And $MRESULT [ 0 ] > 0 Then
					LOGINFO ( "Panel finded:" & $MRESULT [ 0 ] & " X=" & $MRESULT [ 1 ] .X & " Y=" & $MRESULT [ 1 ] .Y )
					Local $TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , $MRESULT [ 1 ] .X + 4294967286 , $MRESULT [ 1 ] .Y + 4294967276 , 250 , 51 )
					$CHECKLOCALPANELCOORD [ 0 ] = $MRESULT [ 1 ] .X + 4294967286
					$CHECKLOCALPANELCOORD [ 1 ] = $MRESULT [ 1 ] .Y + 4294967276
				Else
					LOGERROR ( "Panel not finded" )
					Local $TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 90 , 557 , 260 , 61 )
				EndIf
				IR_COMPARE_FREERESULT ( $MRESULT )
				IR_IMAGE_UNLOAD ( $BIG_IMAGE_SRC )
				Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $TTMPBITMAP , @ScriptDir & "\screenshot\localchat-crop.bmp" )
				Local $IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TTMPBITMAP ) )
				Local $TRESULT = IR_COMPARE ( $IMAGE_SRC , $ZEROIMG , $COMPAREPARAMETERS )
				LOGINFO ( "ZeroImg" )
				If Not @error And $TRESULT [ 0 ] > 0 Then
					LOGINFO ( "IR finded:" & $TRESULT [ 0 ] )
					For $M = 1 To $TRESULT [ 0 ]
						LOGINFO ( "Match:" & $TRESULT [ $M ] .MatchPercentage & "% m=" & $M & " x=" & $TRESULT [ $M ] .X )
						If $TRESULT [ $M ] .MatchPercentage > 50 Then
							If INRANGE ( $TRESULT [ $M ] .X , 0 , 80 ) Then
								LOGINFO ( "zero crime" )
								$CRIMEFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 81 , 151 ) Then
								LOGINFO ( "zero enemy" )
								$ENEMYFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 152 , 250 ) Then
								LOGINFO ( "zero neutral" )
								$NEUTRALSFINDED = False
							EndIf
						EndIf
					Next
				Else
					LOGERROR ( "error=" & @error )
				EndIf
				LOGINFO ( "ZeroImg_1" )
				Local $TRESULT = IR_COMPARE ( $IMAGE_SRC , $ZEROIMG_1 , $COMPAREPARAMETERS )
				If Not @error And $TRESULT [ 0 ] > 0 Then
					LOGINFO ( "IR finded:" & $TRESULT [ 0 ] )
					For $M = 1 To $TRESULT [ 0 ]
						LOGINFO ( "Match:" & $TRESULT [ $M ] .MatchPercentage & "% m=" & $M & " x=" & $TRESULT [ $M ] .X )
						If $TRESULT [ $M ] .MatchPercentage > 50 Then
							If INRANGE ( $TRESULT [ $M ] .X , 0 , 80 ) Then
								LOGINFO ( "zero crime" )
								$CRIMEFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 81 , 151 ) Then
								LOGINFO ( "zero enemy" )
								$ENEMYFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 152 , 250 ) Then
								LOGINFO ( "zero neutral" )
								$NEUTRALSFINDED = False
							EndIf
						EndIf
					Next
				Else
					LOGERROR ( "error=" & @error )
				EndIf
				IR_COMPARE_FREERESULT ( $TRESULT )
				IR_IMAGE_UNLOAD ( $IMAGE_SRC )
				_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
				_GDIPLUS_BITMAPDISPOSE ( $TTMPBITMAP )
				If $ENEMYFINDED Then
					$MSG = "CheckLocal: ENEMY detected"
					LOGINFO ( $MSG )
					$RET = 3
					ExitLoop
				EndIf
				If $CRIMEFINDED Then
					$MSG = "CheckLocal: CRIME detected"
					LOGINFO ( $MSG )
					$RET = 2
					ExitLoop
				EndIf
				If $NEUTRALSFINDED Then
					$MSG = "CheckLocal: NEUTRAL detected"
					LOGINFO ( $MSG )
					$RET = 1
					ExitLoop
				EndIf
			EndIf
			If ( WAITFINDPIC ( @ScriptDir & "\img\localchat_criminal.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 46 , 269 , 46 + 362 , 269 + 384 , 1 ) = 1 ) Then
				If WAITFINDPIC ( @ScriptDir & "\img\localchat_zeroenemy.bmp" , $X_TEMP1 , $Y_TEMP1 , $DETECT_PRECISSION , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 46 , 269 , 46 + 362 , 269 + 384 , 1 ) = 0 Then
					$MSG = "CheckLocal: ENEMY detected"
					LOGINFO ( $MSG )
					$RET = 3
					ExitLoop
				EndIf
				If WAITFINDPIC ( @ScriptDir & "\img\localchat_zerocrime.bmp" , $X_TEMP1 , $Y_TEMP1 , $DETECT_PRECISSION , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 46 , 269 , 46 + 362 , 269 + 384 , 1 ) = 0 Then
					$MSG = "CheckLocal: CRIME detected"
					LOGINFO ( $MSG )
					$RET = 2
					ExitLoop
				EndIf
				If WAITFINDPIC ( @ScriptDir & "\img\localchat_zeroneutral.bmp" , $X_TEMP1 , $Y_TEMP1 , $DETECT_PRECISSION , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 46 , 269 , 46 + 362 , 269 + 384 , 1 ) = 0 Then
					$MSG = "CheckLocal: NEUTRAL detected"
					LOGINFO ( $MSG )
					$RET = 1
					ExitLoop
				EndIf
				$CHECKNEEDSEND = 1
				$RET = 0
				$DONE = 1
			Else
				$DONE = 0
			EndIf
			If ( $DONE == 0 And WAITFINDPIC ( @ScriptDir & "\img\localchat_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 0 , 200 , 600 , 720 , 1 ) = 1 ) Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 10 )
				$DONE = 0
				Sleep ( 1500 )
			EndIf
		Else
			$X_LOCALCHATLABLE = $X_FINDED
			$Y_LOCALCHATLABLE = $Y_FINDED
			$CHECKLOCALCOUNTER = $CHECKLOCALCOUNTER + 1
			If $CHECKLOCALCOUNTER > $CHECKLOCALCOUNTER_RND Then
				If WAITFINDPIC ( @ScriptDir & "\img\localchat_ico.bmp" , $X_TEMP1 , $Y_TEMP1 , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 0 , 200 , 600 , 720 , 1 ) = 1 Then
					SENDTAP ( $X_TEMP1 , $Y_TEMP1 , 10 )
					Sleep ( 500 )
					SENDTAP ( $X_TEMP1 , $Y_TEMP1 , 10 )
					Sleep ( 500 )
					$CHECKLOCALCOUNTER = 0
					$CHECKLOCALCOUNTER_RND = Random ( 10 , 15 , 1 )
				EndIf
			EndIf
			If $X_FINDED < 100 Or $X_FINDED > 170 Or $Y_FINDED < 210 Or $Y_FINDED > 225 Then
				SENDADB ( " shell input swipe " & $X_FINDED + Random ( + 4294967294 , 2 , 1 ) & " " & $Y_FINDED + Random ( + 4294967294 , 2 , 1 ) & " " & 135 + Random ( + 4294967295 , 1 , 1 ) & " " & 215 + Random ( + 4294967295 , 1 , 1 ) & " " & 200 )
				WAITFINDPIC ( @ScriptDir & "\img\localchat_title.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 8 , 126 , 607 , 439 )
				LOGINFO ( "Current LocalChatCoords:" & $X_FINDED & "," & $Y_FINDED )
			EndIf
			If ( 1 ) Then
				ADBSCREEN ( 1 )
				LOGDEBUG ( "stage 2" )
				Local $M
				Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
				Local $BIG_IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $BITMAP ) )
				$COMPAREPARAMETERS .PixelTolerance = 1
				Local $MRESULT = IR_COMPARE ( $BIG_IMAGE_SRC , $LOCALCHATPANEL , $COMPAREPARAMETERS )
				$COMPAREPARAMETERS .PixelTolerance = 15
				$COMPAREPARAMETERS .MaxMatches = + 4294967295
				If Not @error And $MRESULT [ 0 ] > 0 Then
					LOGINFO ( "Panel finded:" & $MRESULT [ 0 ] & " X=" & $MRESULT [ 1 ] .X & " Y=" & $MRESULT [ 1 ] .Y )
					Local $TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , $MRESULT [ 1 ] .X + 4294967283 , $MRESULT [ 1 ] .Y + 4294967273 , 260 , 61 )
					$CHECKLOCALPANELCOORD [ 0 ] = $MRESULT [ 1 ] .X + 4294967286
					$CHECKLOCALPANELCOORD [ 1 ] = $MRESULT [ 1 ] .Y + 4294967276
				Else
					LOGERROR ( "Panel not finded" )
					Local $TTMPBITMAP = _GDIPLUS_BITMAPCLONEAREA ( $BITMAP , 90 , 557 , 260 , 61 )
				EndIf
				IR_COMPARE_FREERESULT ( $MRESULT )
				IR_IMAGE_UNLOAD ( $BIG_IMAGE_SRC )
				Local $ANSW = _GDIPLUS_IMAGESAVETOFILE ( $TTMPBITMAP , @ScriptDir & "\screenshot\localchat-crop.bmp" )
				Local $IMAGE_SRC = IR_IMAGE_LOAD ( _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP ( $TTMPBITMAP ) )
				Local $TRESULT = IR_COMPARE ( $IMAGE_SRC , $ZEROIMG , $COMPAREPARAMETERS )
				LOGINFO ( "ZeroImg" )
				If Not @error And $TRESULT [ 0 ] > 0 Then
					LOGINFO ( "IR finded:" & $TRESULT [ 0 ] )
					For $M = 1 To $TRESULT [ 0 ]
						LOGINFO ( "Match:" & $TRESULT [ $M ] .MatchPercentage & "% m=" & $M & " x=" & $TRESULT [ $M ] .X )
						If $TRESULT [ $M ] .MatchPercentage > 50 Then
							If INRANGE ( $TRESULT [ $M ] .X , 0 , 80 ) Then
								LOGINFO ( "zero crime" )
								$CRIMEFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 81 , 151 ) Then
								LOGINFO ( "zero enemy" )
								$ENEMYFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 152 , 250 ) Then
								LOGINFO ( "zero neutral" )
								$NEUTRALSFINDED = False
							EndIf
						EndIf
					Next
				Else
					LOGERROR ( "error=" & @error )
				EndIf
				LOGINFO ( "ZeroImg_1" )
				Local $TRESULT = IR_COMPARE ( $IMAGE_SRC , $ZEROIMG_1 , $COMPAREPARAMETERS )
				If Not @error And $TRESULT [ 0 ] > 0 Then
					LOGINFO ( "IR finded:" & $TRESULT [ 0 ] )
					For $M = 1 To $TRESULT [ 0 ]
						LOGINFO ( "Match:" & $TRESULT [ $M ] .MatchPercentage & "% m=" & $M & " x=" & $TRESULT [ $M ] .X )
						If $TRESULT [ $M ] .MatchPercentage > 50 Then
							If INRANGE ( $TRESULT [ $M ] .X , 0 , 80 ) Then
								LOGINFO ( "zero crime" )
								$CRIMEFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 81 , 151 ) Then
								LOGINFO ( "zero enemy" )
								$ENEMYFINDED = False
							EndIf
							If INRANGE ( $TRESULT [ $M ] .X , 152 , 250 ) Then
								LOGINFO ( "zero neutral" )
								$NEUTRALSFINDED = False
							EndIf
						EndIf
					Next
				Else
					LOGERROR ( "error=" & @error )
				EndIf
				IR_COMPARE_FREERESULT ( $TRESULT )
				IR_IMAGE_UNLOAD ( $IMAGE_SRC )
				_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
				_GDIPLUS_BITMAPDISPOSE ( $TTMPBITMAP )
				If $ENEMYFINDED Then
					$MSG = "CheckLocal: ENEMY detected"
					LOGINFO ( $MSG )
					$RET = 3
					ExitLoop
				EndIf
				If $CRIMEFINDED Then
					$MSG = "CheckLocal: CRIME detected"
					LOGINFO ( $MSG )
					$RET = 2
					ExitLoop
				EndIf
				If $NEUTRALSFINDED Then
					$MSG = "CheckLocal: NEUTRAL detected"
					LOGINFO ( $MSG )
					$RET = 1
					ExitLoop
				EndIf
			EndIf
			If WAITFINDPIC ( @ScriptDir & "\img\localchat_zeroenemy.bmp" , $X_TEMP1 , $Y_TEMP1 , $DETECT_PRECISSION , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED + 4294967206 , $Y_FINDED , $X_FINDED + 230 , $Y_FINDED + 450 , 1 ) = 0 Then
				$MSG = "CheckLocal: ENEMY detected"
				LOGINFO ( $MSG )
				$RET = 3
				ExitLoop
			EndIf
			If WAITFINDPIC ( @ScriptDir & "\img\localchat_zerocrime.bmp" , $X_TEMP1 , $Y_TEMP1 , $DETECT_PRECISSION , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED + 4294967206 , $Y_FINDED , $X_FINDED + 230 , $Y_FINDED + 450 , 1 ) = 0 Then
				$MSG = "CheckLocal: CRIME detected"
				LOGINFO ( $MSG )
				$RET = 2
				ExitLoop
			EndIf
			If WAITFINDPIC ( @ScriptDir & "\img\localchat_zeroneutral.bmp" , $X_TEMP1 , $Y_TEMP1 , $DETECT_PRECISSION , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , $X_FINDED + 4294967206 , $Y_FINDED , $X_FINDED + 230 , $Y_FINDED + 450 , 1 ) = 0 Then
				$MSG = "CheckLocal: NEUTRAL detected"
				LOGINFO ( $MSG )
				$RET = 1
				ExitLoop
			EndIf
			$CHECKNEEDSEND = 1
			$RET = 0
			$DONE = 1
		EndIf
		$TRY += 1
	Until $DONE = 1 Or $TRY = 4
	If $RET >= $CHECKLOCALPANICLEVEL And $CHECKNEEDSEND = 1 Then
		If $RET = 5 Then $MSG = "Cannot find LocalChat window"
		If ( $OBSTYPE = 1 ) Then Run ( "OBSCommand.exe  /startrecording" , "" , @SW_HIDE )
		SETDOINGSTATUS ( $MSG , 1 , 1 , 1 )
		$CHECKNEEDSEND = 0
	EndIf
	If $BOTTYPE = 1 Then
		ConsoleWrite ( @CRLF & "crop and save" & @CRLF )
		COMBINEIMAGE ( $CHECKLOCALPANELCOORD [ 0 ] , $CHECKLOCALPANELCOORD [ 1 ] + 4294966925 , 232 , 425 , "\screenshot\localchat.png" )
	EndIf
	GUICtrlSetData ( $LABEL_DOING , $TEMPDOING )
	LOGINFO ( "CheckLocal stop. Return=" & $RET )
	Return $RET
EndFunc
Func SETDOINGSTATUS ( $MSG , $TOTRAYTIP = 0 , $SENDTOTELEGRAM = 0 , $SENDSCREENSHOT = 0 )
	$CURRFUNCNAME = "SetDoingStatus"
	Local $PREVSTATUS = ""
	$PREVSTATUS = GUICtrlRead ( $LABEL_DOING )
	LOGINFO ( "Set Status ='" & $MSG & "', " & $TOTRAYTIP & ", " & $SENDTOTELEGRAM & ", " & $SENDSCREENSHOT )
	GUICtrlSetData ( $LABEL_DOING , $MSG )
	If $TOTRAYTIP = 1 Then TrayTip ( "" , $MSG , 30 , 1 )
	If $SENDSCREENSHOT = 1 Then $SENDSCREENSHOT = "\screenshot\screenshot.bmp"
	If $SENDTOTELEGRAM = 1 Then TELEGRAMBOTSEND ( $MSG , $SENDSCREENSHOT )
	Return $PREVSTATUS
EndFunc
Func GETDOCKDIRECTION ( $RETRY = 0 )
	$CURRFUNCNAME = "GetDockDirection"
	LOGINFO ( "GetDockDirection start" )
	Local $X_FINDED , $Y_FINDED
	$YELLOW_DETECTED = 0
	If $GETDOCKDIRECTIONTYPE = 0 Or $RETRY = 1 Then
		LOGINFO ( "$TimeToWarpCurrent*0.5=" & $TIMETOWARPCURRENT * 0.5 )
		SENDADB ( " shell ""input tap 3 195 && sleep " & $TIMETOWARPCURRENT * 0.5 / 1000 & " && input tap " & 511 + Random ( + 4294967294 , 2 , 1 ) & " " & 586 + Random ( + 4294967294 , 2 , 1 ) & """" , 0 , 1 )
		Sleep ( 1000 )
		SENDADB ( " shell input swipe " & 511 + Random ( + 4294967295 , 1 , 1 ) & " " & 586 + Random ( + 4294967295 , 1 , 1 ) & " " & 511 + Random ( + 4294967291 , 5 , 1 ) & " " & 545 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 1000 , 1 ) )
		Sleep ( 1000 )
	Else
		If ( WAITFINDPIC ( @ScriptDir & "\img\station_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 1000 , 1 , 1100 , 60 ) = 1 ) Then
			LOGINFO ( "Station ico finded" )
			Sleep ( 1000 )
			LOGINFO ( "go 1" )
		Else
			SENDTAP ( 1107 , 27 , 4 )
			If ( WAITFINDPIC ( @ScriptDir & "\img\station_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 1000 , 1 , 1100 , 600 ) = 1 ) Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
			EndIf
			Sleep ( 2000 )
			LOGINFO ( "go 2" )
		EndIf
		ADBSCREEN ( 1 )
		LOGINFO ( "finding yellow" )
		Local $BITMAP1 , $BITMAP , $HPEN
		Local $ICOLOR = 0 , $ACOLOR = 0
		Local $ICOLOR1 = 0 , $ACOLOR1 = 0
		Local $X = 1045 , $Y = 0
		Local $BITMAP = _GDIPLUS_BITMAPCREATEFROMFILE ( @ScriptDir & "\screenshot\screenshot.bmp" )
		For $Y = 77 To 445 Step 4
			$ICOLOR = _GDIPLUS_BITMAPGETPIXEL ( $BITMAP , $X , $Y )
			$ACOLOR = __COLORGETRGB ( $ICOLOR )
			Local $HSL_COLOR = _COLORCONVERTRGBTOHSL ( $ACOLOR )
			If $HSL_COLOR [ 0 ] > 25 And $HSL_COLOR [ 0 ] < 45 And $HSL_COLOR [ 1 ] > 45 And $HSL_COLOR [ 1 ] < 110 Then
				$YELLOW_DETECTED = 1
				_GDIPLUS_BITMAPSETPIXEL ( $BITMAP , $X , $Y , BitXOR ( 16777215 , $ICOLOR ) )
				LOGINFO ( "YellowDetected detected" )
				ExitLoop
			EndIf
		Next
		_GDIPLUS_BITMAPDISPOSE ( $BITMAP )
		_WINAPI_DELETEOBJECT ( $BITMAP )
		If $YELLOW_DETECTED = 1 Then
			SENDTAP ( $X + 25 , $Y , 14 )
			If ( WAITFINDPIC ( @ScriptDir & "\img\approach_ico.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 6 , 742 , 86 , 909 , 625 ) = 1 ) Then
				SENDTAP ( $X_FINDED , $Y_FINDED , 4 )
				_SLEEP ( $TIMETOWARPCURRENT * 0.5 )
				SENDADB ( " shell input swipe " & 511 + Random ( + 4294967295 , 1 , 1 ) & " " & 586 + Random ( + 4294967295 , 1 , 1 ) & " " & 511 + Random ( + 4294967291 , 5 , 1 ) & " " & 542 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 1000 , 1 ) )
				Sleep ( 1000 )
			EndIf
		Else
			LOGINFO ( "yellow NOT finded" )
			GETDOCKDIRECTION ( 1 )
		EndIf
	EndIf
	LOGINFO ( "GetDockDirection stop" )
EndFunc
Func GETSHIPINFO ( )
	$CURRFUNCNAME = "GetShipInfo"
	LOGINFO ( "GetShipInfo" )
	Local $X_FINDED , $Y_FINDED
	If INDOCK ( ) Then
		SENDTAP ( 649 , 366 , 10 )
		If WAITFINDPIC ( @ScriptDir & "\img\shipinfo_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 , 446 , 158 , 446 + 365 , 158 + 451 ) = 1 Then
			SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
			Sleep ( 1000 )
			If WAITFINDPIC ( @ScriptDir & "\img\shipinfo_ico_close.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 10 , 456 , 21 , 456 + 325 , 21 + 450 ) = 1 Then
				TELEGRAMBOTSEND ( "Ship info" , "\screenshot\screenshot.bmp" )
				SENDTAP ( $X_FINDED , $Y_FINDED , 8 )
			EndIf
		EndIf
	EndIf
	LOGINFO ( "GetShipInfo stop" )
EndFunc
Func SCREENSHOTSOCK ( $SAVETO = "screenshot\screenshot.bmp" , $SILENT = 0 )
	$CURRFUNCNAME = "ScreenshotSock"
	If Not $SILENT Then FILECONSOLEWRITE ( "ScreenshotSock start. " )
	Local $TRY = 0 , $MAXTRY = 15 , $DONE = 0
	Local $TMPTIMER = TimerInit ( )
	Local $RETRY = 0 , $M = 0
	Local $I = 1
	Do
		Local $ISOCKET = _ANDROID_CONNECT ( )
		If Not $ADBTRANSPORTSERIAL = 0 Then
			$M = _ANDROID_SEND_COMMAND ( $ISOCKET , "host:transport:" & $ADBTRANSPORTSERIAL )
		Else
			$M = _ANDROID_SEND_COMMAND ( $ISOCKET , "host:transport-any" )
		EndIf
		ConsoleWrite ( "$Command=" & $M & @CRLF )
		If Not $RETRY Then
			Local $M = _ANDROID_SEND_COMMAND ( $ISOCKET , "exec:/data/local/tmp/ascreencap -stdout" )
		Else
			Local $M = _ANDROID_SEND_COMMAND ( $ISOCKET , "exec:/data/local/tmp/ascreencap -stdout" )
		EndIf
		If Not $SILENT Then LOGINFO ( "$m=" & $M )
		ConsoleWrite ( "$m=" & $M & @CRLF )
		Local $SBUFFER = Binary ( "" ) , $SRECEIVED = Binary ( "" )
		Do
			$SRECEIVED &= $SBUFFER
			$SBUFFER = TCPRecv ( $ISOCKET , 6300000 , 1 )
		Until $SBUFFER = "" Or @error
		ConsoleWrite ( "recv @error:" & @error & @CRLF )
		If StringLen ( $SRECEIVED ) = 5529710 Then
			$DONE = 1
			FileDelete ( $SAVETO )
			FileWrite ( $SAVETO , $SRECEIVED )
			$RETRY = 0
		Else
			LOGINFO ( "Wrong data size: " & StringLen ( $SRECEIVED ) & "/5529710" )
			$RETRY = 1
		EndIf
		TCPCloseSocket ( $ISOCKET )
		$TRY = $TRY + 1
		_ANDROID_SHUTDOWN ( $ISOCKET )
	Until $DONE Or $TRY > $MAXTRY
	If Not $DONE Then SENDADB ( " exec-out /data/local/tmp/ascreencap -f /data/local/tmp/screenshot.bmp &&  pull /data/local/tmp/screenshot.bmp " & $SAVETO )
	Local $TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) , 0 )
	If Not $SILENT Then LOGINFO ( "Time for ScreenshotSock: " & $TMPDIFF & " ms. TryCount= " & $TRY )
	If $TMPDIFF > $SSTATMAX Then $SSTATMAX = $TMPDIFF
	If $SSTATMIN > $TMPDIFF Then $SSTATMIN = $TMPDIFF
	If $TRY > $SSTATMAXTRYCOUNT Then $SSTATMAXTRYCOUNT = $TRY
	$SSTATTOTALTIME = $SSTATTOTALTIME + $TMPDIFF
	$SSTATCOUNT = $SSTATCOUNT + 1
EndFunc
Func SCREENSHOTCOPY ( $SAVETO , $SILENT = 0 )
	$CURRFUNCNAME = "ScreenShotCopy"
	Local $TMPTIMER = TimerInit ( )
	FILECONSOLEWRITE ( "ScreenShotCopy " )
	Switch $EMULATORTYPE
	Case 1
		SENDADB ( " exec-out /data/local/tmp/ascreencap -f /mnt/windows/BstSharedFolder/screenshot" & $ADBTRANSPORTSERIAL & ".bmp" , 1 )
	Case 2
		SENDADB ( " exec-out /data/local/tmp/ascreencap -f /mnt/shared/Pictures/screenshot" & $ADBTRANSPORTSERIAL & ".bmp" , 1 )
Case Else
		LOGINFO ( "!ERRROR! EmulatorType" )
	EndSwitch
	Local $TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) , 0 )
	If Not $SILENT Then FILECONSOLEWRITE ( "Time adb: " & $TMPDIFF & " ms. " , 1 )
	FileDelete ( @ScriptDir & "\" & $SAVETO )
	If Not FileCopy ( $EMULATORSHAREDFOLDER & "screenshot" & $ADBTRANSPORTSERIAL & ".bmp" , @ScriptDir & "\" & $SAVETO , 8 ) Then
		Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
		Local $SLASTERRORMESSAGE = _WINAPI_GETLASTERRORMESSAGE ( )
		ConsoleWrite ( $ILASTERROR & " - " & $SLASTERRORMESSAGE & @CRLF )
	EndIf
	$TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) , 0 )
	If Not $SILENT Then LOGINFO ( "Time total: " & $TMPDIFF & " ms." )
	If $TMPDIFF > $SSTATMAX Then $SSTATMAX = $TMPDIFF
	If $SSTATMIN > $TMPDIFF Then $SSTATMIN = $TMPDIFF
	$SSTATTOTALTIME = $SSTATTOTALTIME + $TMPDIFF
	$SSTATCOUNT = $SSTATCOUNT + 1
EndFunc
Func SCREENSHOTCOPYSOCK ( $SAVETO , $SILENT = 0 )
	$CURRFUNCNAME = "ScreenShotCopySock"
	Local $TMPTIMER = TimerInit ( )
	FILECONSOLEWRITE ( "ScreenShotCopySock " )
	Do
		Local $TIMEOUTTIMER = TimerInit ( )
		Local $ISOCKET = _ANDROID_CONNECT ( )
		If Not $ADBTRANSPORTSERIAL = 0 Then
			_ANDROID_SEND ( $ISOCKET , "host:transport:" & $ADBTRANSPORTSERIAL )
		Else
			_ANDROID_SEND ( $ISOCKET , "host:transport-any" )
		EndIf
		Switch $EMULATORTYPE
		Case 1
			Local $M = _ANDROID_SEND ( $ISOCKET , "shell:/data/local/tmp/ascreencap -f /mnt/windows/BstSharedFolder/screenshot" & $ADBTRANSPORTSERIAL & ".bmp && echo done" )
		Case 2
			Local $M = _ANDROID_SEND ( $ISOCKET , "shell:/data/local/tmp/ascreencap -f /mnt/shared/Pictures/screenshot" & $ADBTRANSPORTSERIAL & ".bmp && echo done" )
	Case Else
			LOGINFO ( "!ERRROR!" )
		EndSwitch
		ConsoleWrite ( "donedone" )
		Local $SBUFFER = $M , $SRECEIVED = ""
		Do
			$SRECEIVED &= $SBUFFER
			$SBUFFER = TCPRecv ( $ISOCKET , 6000 )
		Until StringInStr ( $SRECEIVED , "done" ) Or @error Or TimerDiff ( $TIMEOUTTIMER ) > 3000
		If Not StringInStr ( $SRECEIVED , "done" ) Then FILECONSOLEWRITE ( " try " )
		TCPCloseSocket ( $ISOCKET )
	Until StringInStr ( $SRECEIVED , "done" )
	LOGINFO ( "sock complete. Copy" )
	Local $TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) , 0 )
	If Not $SILENT Then FILECONSOLEWRITE ( "Time adb: " & $TMPDIFF & " ms. " , 1 )
	FileDelete ( @ScriptDir & "\" & $SAVETO )
	ConsoleWrite ( "file:" & $EMULATORSHAREDFOLDER & "screenshot" & $ADBTRANSPORTSERIAL & ".bmp" & @CRLF )
	ConsoleWrite ( "to:" & @ScriptDir & "\" & $SAVETO & @CRLF )
	If Not FileCopy ( $EMULATORSHAREDFOLDER & "screenshot" & $ADBTRANSPORTSERIAL & ".bmp" , @ScriptDir & "\" & $SAVETO , 8 ) Then
		Local $ILASTERROR = _WINAPI_GETLASTERROR ( )
		Local $SLASTERRORMESSAGE = _WINAPI_GETLASTERRORMESSAGE ( )
		ConsoleWrite ( $ILASTERROR & " - " & $SLASTERRORMESSAGE & @CRLF )
	EndIf
	$TMPDIFF = Round ( TimerDiff ( $TMPTIMER ) , 0 )
	If Not $SILENT Then LOGINFO ( "Time total: " & $TMPDIFF & " ms." )
	If $TMPDIFF > $SSTATMAX Then $SSTATMAX = $TMPDIFF
	If $SSTATMIN > $TMPDIFF Then $SSTATMIN = $TMPDIFF
	$SSTATTOTALTIME = $SSTATTOTALTIME + $TMPDIFF
	$SSTATCOUNT = $SSTATCOUNT + 1
EndFunc
Func IRLIMAGEPRELOAD ( $UNLOAD = 0 )
	$CURRFUNCNAME = "IRLImagePreload"
	If Not $UNLOAD Then
		Global $OVERLAYBASEICO_1 = IR_IMAGE_LOAD ( "img\base_ico.bmp" )
		Global $OVERLAYBASEICO_2 = IR_IMAGE_LOAD ( "img\base_ico_2.png" )
		Global $ZEROIMG = IR_IMAGE_LOAD ( @ScriptDir & "\img\localchat_zero.png" )
		Global $ZEROIMG_1 = IR_IMAGE_LOAD ( @ScriptDir & "\img\localchat_zero_1.png" )
		Global $LOCALCHATPANEL = IR_IMAGE_LOAD ( @ScriptDir & "\img\localchat_panel.png" )
		$SHIP_ICO [ 0 ] = IR_IMAGE_LOAD ( "img\fleet\enemy.png" )
		$SHIP_ICO [ 1 ] = IR_IMAGE_LOAD ( "img\fleet\targeted.png" )
		$SHIP_ICO [ 2 ] = IR_IMAGE_LOAD ( "img\fleet\destroyer.png" )
		$SHIP_ICO [ 3 ] = IR_IMAGE_LOAD ( "img\fleet\bcruiser.png" )
		$SHIP_ICO [ 4 ] = IR_IMAGE_LOAD ( "img\fleet\bship.png" )
		$SHIP_ICO [ 5 ] = IR_IMAGE_LOAD ( "img\fleet\cruiser.png" )
		$SHIP_ICO [ 6 ] = IR_IMAGE_LOAD ( "img\fleet\frigate.png" )
		$SHIP_ICO [ 7 ] = IR_IMAGE_LOAD ( "img\fleet\destroyer.png" )
		$SHIP_ICO [ 8 ] = IR_IMAGE_LOAD ( "img\fleet\cargo.png" )
		$SHIP_ICO [ 9 ] = IR_IMAGE_LOAD ( "img\fleet\industry.png" )
		$SHIP_ICO [ 10 ] = IR_IMAGE_LOAD ( "img\fleet\industry1.png" )
		$SHIP_ICO_FILENAME [ 0 ] = "enemy"
		$SHIP_ICO_FILENAME [ 1 ] = "targeted"
		$SHIP_ICO_FILENAME [ 2 ] = "destroyer"
		$SHIP_ICO_FILENAME [ 3 ] = "bcruiser"
		$SHIP_ICO_FILENAME [ 4 ] = "bship"
		$SHIP_ICO_FILENAME [ 5 ] = "cruiser"
		$SHIP_ICO_FILENAME [ 6 ] = "frigate"
		$SHIP_ICO_FILENAME [ 7 ] = "destroyer"
		$SHIP_ICO_FILENAME [ 8 ] = "cargo"
		$SHIP_ICO_FILENAME [ 9 ] = "industry"
		$SHIP_ICO_FILENAME [ 10 ] = "industry1"
		$ANOMALYANOMALY [ 0 ] = 3
		$ANOMALYANOMALY [ 1 ] = IR_IMAGE_LOAD ( "img\anomaly1.bmp" )
		$ANOMALYANOMALY [ 2 ] = IR_IMAGE_LOAD ( "img\anomaly2.bmp" )
		$ANOMALYANOMALY [ 3 ] = IR_IMAGE_LOAD ( "img\anomaly.bmp" )
		$ANOMALYSMALL [ 0 ] = 2
		$ANOMALYSMALL [ 1 ] = IR_IMAGE_LOAD ( "img\small_anomaly.bmp" )
		$ANOMALYSMALL [ 2 ] = IR_IMAGE_LOAD ( "img\small_anomaly1.bmp" )
		$ANOMALYMEDIUM [ 0 ] = 4
		$ANOMALYMEDIUM [ 1 ] = IR_IMAGE_LOAD ( "img\medium_anomaly.bmp" )
		$ANOMALYMEDIUM [ 2 ] = IR_IMAGE_LOAD ( "img\medium_anomaly1.bmp" )
		$ANOMALYMEDIUM [ 3 ] = IR_IMAGE_LOAD ( "img\medium_anomaly2.bmp" )
		$ANOMALYMEDIUM [ 4 ] = IR_IMAGE_LOAD ( "img\medium_anomaly3.bmp" )
		$ANOMALYLARGE [ 0 ] = 3
		$ANOMALYLARGE [ 1 ] = IR_IMAGE_LOAD ( "img\large_anomaly.bmp" )
		$ANOMALYLARGE [ 2 ] = IR_IMAGE_LOAD ( "img\large_anomaly1.bmp" )
		$ANOMALYLARGE [ 3 ] = IR_IMAGE_LOAD ( "img\large_anomaly2.bmp" )
	Else
		For $I = 0 To 10
			IR_IMAGE_UNLOAD ( $SHIP_ICO [ $I ] )
		Next
	EndIf
EndFunc
Func USEMININGIMPLANT ( )
	$CURRFUNCNAME = "UseMiningImplant"
	Local $X_FINDED , $Y_FINDED
	LOGINFO ( "Try Activate mining implant" )
	$IMPLANTFINDED = WAITFINDPIC ( @ScriptDir & "\img\implant_mining_ico.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 1 , 733 , 554 , 733 + 56 , 554 + 64 , 1 )
	If $IMPLANTFINDED Then
		SENDTAP ( $X_FINDED , $Y_FINDED , 5 )
	EndIf
	LOGINFO ( "stop Try Activate mining implant" )
EndFunc
Func EYELOCALCHAT ( )
	$CURRFUNCNAME = "EYELocalChat"
	$CHECKLOCALCOUNTER = 200
	Local $LOCAL_IDS_DIFFER [ 0 ]
	Local $I = 0
	Local $CHECKRESULT = 0
	$CHECKRESULT = CHECKLOCAL ( )
	ConsoleWrite ( "$CheckResult =" & $CHECKRESULT & @CRLF )
	ConsoleWrite ( "$EYEPrevChecklocal=" & $EYEPREVCHECKLOCAL & @CRLF )
	ConsoleWrite ( "$EYECheckNeedSend=" & $EYECHECKNEEDSEND & @CRLF )
	If $CHECKRESULT >= $CHECKLOCALPANICLEVEL Then
		If $EYEPREVCHECKLOCAL = $CHECKRESULT Then
			ConsoleWrite ( "pop" )
		Else
			DISCORDSENDFILE ( "Detected:" , @ScriptDir & "\screenshot\localchat.png" )
			$EYECHECKNEEDSEND = 1
		EndIf
	Else
		If $EYEPREVCHECKLOCAL = $CHECKRESULT Then
			ConsoleWrite ( "pop" )
		Else
			If $EYECHECKNEEDSEND = 1 Then
				DISCORDSENDFILE ( "Clear:" , @ScriptDir & "\screenshot\localchat.png" )
				$EYECHECKNEEDSEND = 0
			EndIf
		EndIf
	EndIf
	$EYEPREVCHECKLOCAL = $CHECKRESULT
	$ANSW = SENDADB ( " shell ""logcat com.netease.eve.en:I -e channel_args -b main -d |tail -n 1""" )
	$LOCAL_IDS_NEW = StringRegExp ( $ANSW , "([0-9]{8,12})" , 3 )
	ConsoleWrite ( "readed Ubound($Local_ids_new):" & UBound ( $LOCAL_IDS_NEW ) & @CRLF )
	_ARRAYSORT ( $LOCAL_IDS_NEW )
	If $LOCAL_IDS = 0 Then
		$LOCAL_IDS = $LOCAL_IDS_NEW
	Else
		For $I = 0 To UBound ( $LOCAL_IDS_NEW ) + 4294967295
			If _ARRAYSEARCH ( $LOCAL_IDS , $LOCAL_IDS_NEW [ $I ] ) < 0 Then
				_ARRAYADD ( $LOCAL_IDS_DIFFER , $LOCAL_IDS_NEW [ $I ] )
			Else
			EndIf
		Next
		$LOCAL_IDS = $LOCAL_IDS_NEW
	EndIf
	If UBound ( $LOCAL_IDS_DIFFER ) > 0 Then
		$ID_LIST = "New ID in sector:"
		For $I = 0 To UBound ( $LOCAL_IDS_DIFFER ) + 4294967295
			$ID_LIST = $ID_LIST & " " & $LOCAL_IDS_DIFFER [ $I ]
		Next
		Return 1
	Else
		Return 0
	EndIf
EndFunc
Func SELECTOVERLAY ( $OVERLAYNAME )
	$CURRFUNCNAME = "SelectOverlay"
	Local $X_FINDED , $Y_FINDED
	Local $RET = 0
	LOGINFO ( "Start SelectOverlay" )
	If ( WAITFINDPIC ( @ScriptDir & "\img\overlay_filter.bmp" , $X_FINDED , $Y_FINDED , 0.7 , @ScriptDir & "\screenshot\screenshot.bmp" , 3 , 1220 , 6 , 1220 + 51 , 6 + 43 ) = 1 ) Then
		LOGINFO ( "OverlayPanel Finded. Trying to select: " & $OVERLAYNAME )
		Switch $OVERLAYNAME
		Case "ships"
			If ( WAITFINDPIC ( @ScriptDir & "\img\label_ships_ru.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1052 , 6 , 1052 + 163 , 6 + 58 , 1 ) = 1 Or WAITFINDPIC ( @ScriptDir & "\img\label_ships_eng.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1052 , 6 , 1052 + 163 , 6 + 58 , 1 ) = 1 ) Then
				LOGINFO ( "Ship selected alredy" )
				If ( WAITFINDPIC ( @ScriptDir & "\img\overlay_defaultfitting.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1029 , 55 , 1029 + 157 , 55 + 36 ) = 1 ) Then
					SENDTAP ( 1106 , 203 , 10 )
					SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
					Sleep ( 500 )
				EndIf
				$RET = 1
			Else
				SENDTAP ( 1107 , 27 , 8 )
				If ( WAITFINDPIC ( @ScriptDir & "\img\overlay_defaultfitting.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 1029 , 55 , 1029 + 157 , 55 + 36 ) = 1 ) Then
					SENDTAP ( 1106 , 203 , 10 )
				EndIf
				Sleep ( 1000 )
				SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
				Sleep ( 500 )
				$RET = 1
			EndIf
		Case "anomaly"
			If ( WAITFINDPIC ( @ScriptDir & "\img\label_anomaly_ru.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1052 , 6 , 1052 + 163 , 6 + 58 , 1 ) = 1 Or WAITFINDPIC ( @ScriptDir & "\img\cosmic_anomaly.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1052 , 6 , 1052 + 163 , 6 + 58 , 1 ) = 1 ) Then
				LOGINFO ( "Anomaly label alredy" )
				If ( WAITFINDPIC ( @ScriptDir & "\img\overlay_defaultfitting.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 0 , 1029 , 55 , 1029 + 157 , 55 + 36 ) = 1 ) Then
					SENDTAP ( 1106 , 411 , 10 )
					SENDADB ( " shell input swipe " & 641 + Random ( + 4294967286 , 10 , 1 ) & " " & 365 + Random ( + 4294967286 , 10 , 1 ) & " " & 571 + Random ( + 4294967291 , 5 , 1 ) & " " & 390 + Random ( + 4294967295 , 1 , 1 ) & " " & Random ( 800 , 900 , 1 ) )
					Sleep ( 500 )
				EndIf
			Else
				SENDTAP ( 1107 , 27 , 8 )
				If ( WAITFINDPIC ( @ScriptDir & "\img\overlay_defaultfitting.bmp" , $X_FINDED , $Y_FINDED , 0.8 , @ScriptDir & "\screenshot\screenshot.bmp" , 2 , 1029 , 55 , 1029 + 157 , 55 + 36 ) = 1 ) Then
					SENDTAP ( 1106 , 411 , 10 )
				EndIf
				Sleep ( 1000 )
			EndIf
			Sleep ( 2000 )
	Case Else
			MsgBox ( 4096 , "" , "       " )
		EndSwitch
	Else
		LOGINFO ( "OverlayPanel NOT Finded" )
		$RET = 0
	EndIf
	LOGINFO ( "Stop SelectOverlay" )
	Return $RET
EndFunc
Func MYERRFUNC ( )
	LOGFATAL ( "We intercepted a COM Error !" & @CRLF & @CRLF & "err.description is: " & @TAB & $OMYERROR .description & @CRLF & "err.windescription:" & @TAB & $OMYERROR .windescription & @CRLF & "err.number is: " & @TAB & Hex ( $OMYERROR .number , 8 ) & @CRLF & "err.lastdllerror is: " & @TAB & $OMYERROR .lastdllerror & @CRLF & "err.scriptline is: " & @TAB & $OMYERROR .scriptline & @CRLF & "err.source is: " & @TAB & $OMYERROR .source & @CRLF & "err.helpfile is: " & @TAB & $OMYERROR .helpfile & @CRLF & "err.helpcontext is: " & @TAB & $OMYERROR .helpcontext )
EndFunc
Func BUTTON_ADBINJECTCLICK ( )
	$CURRFUNCNAME = "Button_ADBInjectClick"
	INJECTADB ( )
EndFunc
Func BUTTON_STARTCLICK ( )
	$CURRFUNCNAME = "Button_STARTClick"
	GUICtrlSetState ( $CHECKBOX_NEEDCHECKOTHERSHIPS , $GUI_DISABLE )
	GUICtrlSetState ( $CHECKBOX_NEEDCHECKLOCAL , $GUI_DISABLE )
	GUICtrlSetState ( $CHECKBOX_JUSTEYE , $GUI_DISABLE )
	GUICtrlSetState ( $CHECKBOX_HIDINGNOWAIT , $GUI_DISABLE )
	GUICtrlSetState ( $COMBO1 , $GUI_DISABLE )
	If $BOTTYPE <> 5 Then GUICtrlSetState ( $BUTTON_ADBINJECT , $GUI_DISABLE )
	If $HIDE_COUNTER > 0 Then
		$HIDE_COUNTER = 50000
		GUICtrlSetState ( $BUTTON_START , $GUI_DISABLE )
	EndIf
	$BOT_ENABLED = 1
EndFunc
Func BUTTON_STOPCLICK ( )
	$CURRFUNCNAME = "Button_STOPClick"
	TERMINATE ( )
EndFunc
Func FORM1CLOSE ( )
	$CURRFUNCNAME = "Form1Close"
	TERMINATE ( )
EndFunc
Func FORM1MAXIMIZE ( )
	$CURRFUNCNAME = "Form1Maximize"
EndFunc
Func FORM1MINIMIZE ( )
	$CURRFUNCNAME = "Form1Minimize"
EndFunc
Func FORM1RESTORE ( )
	$CURRFUNCNAME = "Form1Restore"
EndFunc
Func LABEL_ASTEROIDWIPEDCLICK ( )
	$CURRFUNCNAME = "Label_AsteroidWipedClick"
EndFunc
Func LABEL_ADBSTATUSCLICK ( )
	$CURRFUNCNAME = "Label_adbStatusClick"
EndFunc
Func LABEL_DOINGCLICK ( )
	$CURRFUNCNAME = "Label_doingClick"
EndFunc
Func LABEL_LINKCLICK ( )
	$CURRFUNCNAME = "Label_linkClick"
	ShellExecute ( "http://eve.dru4.ru/" )
EndFunc
Func LABEL_LINKDISCORDCLICK ( )
	$CURRFUNCNAME = "Label_linkDiscordClick"
	ShellExecute ( "https://discord.gg/PHbsW6FFFA" )
EndFunc
Func LABEL_TIMELEFTCLICK ( )
	$CURRFUNCNAME = "Label_TimeLeftClick"
EndFunc
Func LABEL_UNLOADINGCOUNTCLICK ( )
	$CURRFUNCNAME = "Label_UnloadingCountClick"
EndFunc
Func LABEL1CLICK ( )
	$CURRFUNCNAME = "Label1Click"
EndFunc
Func LABEL_CARGOCLICK ( )
	$CURRFUNCNAME = "Label_CargoClick"
EndFunc
Func RADIO_ADBCLICK ( )
	$CURRFUNCNAME = "Radio_ADBClick"
	$ADB_SCREENSHOT = 1
	LOGINFO ( "@@ Debug(" & @ScriptLineNumber & ") : $ADB_Screenshot = " & $ADB_SCREENSHOT )
	$ADB_CLICK = 1
	LOGINFO ( "@@ Debug(" & @ScriptLineNumber & ") : $ADB_Click = " & $ADB_CLICK )
EndFunc
Func RADIO_MOUSECLICK ( )
	$CURRFUNCNAME = "Radio_MouseClick"
EndFunc
Func CHECKBOX_NEEDCHECKLOCALCLICK ( )
	$CURRFUNCNAME = "Checkbox_NeedCheckLocalClick"
	If GUICtrlRead ( $CHECKBOX_NEEDCHECKLOCAL ) = $GUI_CHECKED Then
		$NEEDCHECKLOCAL = 1
	Else
		$NEEDCHECKLOCAL = 0
	EndIf
EndFunc
Func CHECKBOX_NEEDCHECKOTHERSHIPSCLICK ( )
	$CURRFUNCNAME = "Checkbox_NeedCheckOtherShipsClick"
	If GUICtrlRead ( $CHECKBOX_NEEDCHECKOTHERSHIPS ) = $GUI_CHECKED Then
		$NEEDCHECKOTHERSHIPS = 1
		GUICtrlSetState ( $CHECKBOX_NEEDCHECKLOCAL , $GUI_ENABLE )
		GUICtrlSetState ( $COMBO1 , $GUI_ENABLE )
	Else
		$NEEDCHECKOTHERSHIPS = 0
		GUICtrlSetState ( $CHECKBOX_NEEDCHECKLOCAL , $GUI_DISABLE )
		GUICtrlSetState ( $COMBO1 , $GUI_DISABLE )
	EndIf
EndFunc
$CURRFUNCNAME = "Checkbox_FastMiningClick"
Func CHECKBOX_HIDINGNOWAITCLICK ( )
	$CURRFUNCNAME = "Checkbox_HidingNoWaitClick"
	If GUICtrlRead ( $CHECKBOX_HIDINGNOWAIT ) = $GUI_CHECKED Then
		$HIDINGNOWAIT = 1
	Else
		$HIDINGNOWAIT = 0
	EndIf
EndFunc
Func COMBO1CHANGE ( )
	$CURRFUNCNAME = "Combo1Change"
	ConsoleWrite ( "comb1o=" & $CHECKLOCALPANICLEVEL & @CRLF )
	If _GUICTRLCOMBOBOX_GETCURSEL ( $COMBO1 ) >= 0 Then $CHECKLOCALPANICLEVEL = _GUICTRLCOMBOBOX_GETCURSEL ( $COMBO1 )
	ConsoleWrite ( "combo=" & $CHECKLOCALPANICLEVEL & @CRLF )
EndFunc
